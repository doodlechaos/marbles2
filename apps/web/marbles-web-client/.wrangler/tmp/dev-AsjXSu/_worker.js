var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key2 of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key2) && key2 !== except)
        __defProp(to2, key2, { get: () => from2[key2], enumerable: !(desc = __getOwnPropDesc(from2, key2)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options2) {
        this.name = name;
        this.startTime = options2?.startTime || _performanceNow();
        this.detail = options2?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e5) => e5.name !== markName) : this._entries.filter((e5) => e5.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e5) => e5.name !== measureName) : this._entries.filter((e5) => e5.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e5) => e5.entryType !== "resource" || e5.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type) {
        return this._entries.filter((e5) => e5.name === name && (!type || e5.entryType === type));
      }
      getEntriesByType(type) {
        return this._entries.filter((e5) => e5.entryType === type);
      }
      mark(name, options2) {
        const entry = new PerformanceMark(name, options2);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type, listener, options2) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type, listener, options2) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options2) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x2, y2, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env3) {
        return 1;
      }
      hasColors(count3, env3) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type ? `${type}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js
var init_remote_functions = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/remote-functions.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/index.js
var HttpError, Redirect, SvelteKitError, ActionFailure;
var init_internal = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_remote_functions();
    HttpError = class {
      static {
        __name(this, "HttpError");
      }
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body2) {
        this.status = status;
        if (typeof body2 === "string") {
          this.body = { message: body2 };
        } else if (body2) {
          this.body = body2;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      static {
        __name(this, "Redirect");
      }
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    SvelteKitError = class extends Error {
      static {
        __name(this, "SvelteKitError");
      }
      /**
       * @param {number} status
       * @param {string} text
       * @param {string} message
       */
      constructor(status, text2, message) {
        super(message);
        this.status = status;
        this.text = text2;
      }
    };
    ActionFailure = class {
      static {
        __name(this, "ActionFailure");
      }
      /**
       * @param {number} status
       * @param {T} data
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
  }
});

// node_modules/esm-env/true.js
var true_default;
var init_true = __esm({
  "node_modules/esm-env/true.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    true_default = true;
  }
});

// node_modules/esm-env/dev-fallback.js
var node_env, dev_fallback_default;
var init_dev_fallback = __esm({
  "node_modules/esm-env/dev-fallback.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    node_env = "development";
    dev_fallback_default = node_env && !node_env.toLowerCase().startsWith("prod");
  }
});

// node_modules/esm-env/false.js
var init_false = __esm({
  "node_modules/esm-env/false.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/esm-env/index.js
var init_esm_env = __esm({
  "node_modules/esm-env/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_true();
    init_dev_fallback();
    init_false();
  }
});

// node_modules/@sveltejs/kit/src/runtime/pathname.js
var init_pathname = __esm({
  "node_modules/@sveltejs/kit/src/runtime/pathname.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/@sveltejs/kit/src/runtime/utils.js
var text_encoder, text_decoder;
var init_utils2 = __esm({
  "node_modules/@sveltejs/kit/src/runtime/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_esm_env();
    text_encoder = new TextEncoder();
    text_decoder = new TextDecoder();
  }
});

// node_modules/@sveltejs/kit/src/version.js
var init_version = __esm({
  "node_modules/@sveltejs/kit/src/version.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/@sveltejs/kit/src/exports/index.js
function error3(status, body2) {
  if ((!true_default || dev_fallback_default) && (isNaN(status) || status < 400 || status > 599)) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  throw new HttpError(status, body2);
}
function json(data, init3) {
  const body2 = JSON.stringify(data);
  const headers2 = new Headers(init3?.headers);
  if (!headers2.has("content-length")) {
    headers2.set("content-length", text_encoder.encode(body2).byteLength.toString());
  }
  if (!headers2.has("content-type")) {
    headers2.set("content-type", "application/json");
  }
  return new Response(body2, {
    ...init3,
    headers: headers2
  });
}
function text(body2, init3) {
  const headers2 = new Headers(init3?.headers);
  if (!headers2.has("content-length")) {
    const encoded = text_encoder.encode(body2);
    headers2.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init3,
      headers: headers2
    });
  }
  return new Response(body2, {
    ...init3,
    headers: headers2
  });
}
var init_exports = __esm({
  "node_modules/@sveltejs/kit/src/exports/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_internal();
    init_esm_env();
    init_pathname();
    init_utils2();
    init_version();
    __name(error3, "error");
    __name(json, "json");
    __name(text, "text");
  }
});

// node_modules/@sveltejs/kit/src/runtime/server/constants.js
var IN_WEBCONTAINER;
var init_constants = __esm({
  "node_modules/@sveltejs/kit/src/runtime/server/constants.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    IN_WEBCONTAINER = !!globalThis.process?.versions?.webcontainer;
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/event.js
function with_request_store(store, fn) {
  try {
    sync_store = store;
    return als ? als.run(store, fn) : fn();
  } finally {
    if (!IN_WEBCONTAINER) {
      sync_store = null;
    }
  }
}
var sync_store, als;
var init_event = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/event.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constants();
    sync_store = null;
    import("node:async_hooks").then((hooks) => als = new hooks.AsyncLocalStorage()).catch(() => {
    });
    __name(with_request_store, "with_request_store");
  }
});

// node_modules/@sveltejs/kit/src/exports/internal/server.js
function merge_tracing(event_like, current2) {
  return {
    ...event_like,
    tracing: {
      ...event_like.tracing,
      current: current2
    }
  };
}
var init_server = __esm({
  "node_modules/@sveltejs/kit/src/exports/internal/server.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_event();
    __name(merge_tracing, "merge_tracing");
  }
});

// .svelte-kit/output/server/chunks/equality.js
function run_all(arr) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    arr[i2]();
  }
}
function deferred() {
  var resolve4;
  var reject2;
  var promise = new Promise((res, rej) => {
    resolve4 = res;
    reject2 = rej;
  });
  return { promise, resolve: resolve4, reject: reject2 };
}
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}
var is_array, index_of, array_from, define_property, get_descriptor, object_prototype, array_prototype, get_prototype_of, is_extensible, noop;
var init_equality = __esm({
  ".svelte-kit/output/server/chunks/equality.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    is_array = Array.isArray;
    index_of = Array.prototype.indexOf;
    array_from = Array.from;
    define_property = Object.defineProperty;
    get_descriptor = Object.getOwnPropertyDescriptor;
    object_prototype = Object.prototype;
    array_prototype = Array.prototype;
    get_prototype_of = Object.getPrototypeOf;
    is_extensible = Object.isExtensible;
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    __name(run_all, "run_all");
    __name(deferred, "deferred");
    __name(equals, "equals");
    __name(safe_not_equal, "safe_not_equal");
    __name(safe_equals, "safe_equals");
  }
});

// node_modules/clsx/dist/clsx.mjs
function r(e5) {
  var t3, f2, n3 = "";
  if ("string" == typeof e5 || "number" == typeof e5) n3 += e5;
  else if ("object" == typeof e5) if (Array.isArray(e5)) {
    var o3 = e5.length;
    for (t3 = 0; t3 < o3; t3++) e5[t3] && (f2 = r(e5[t3])) && (n3 && (n3 += " "), n3 += f2);
  } else for (f2 in e5) e5[f2] && (n3 && (n3 += " "), n3 += f2);
  return n3;
}
function clsx() {
  for (var e5, t3, f2 = 0, n3 = "", o3 = arguments.length; f2 < o3; f2++) (e5 = arguments[f2]) && (t3 = r(e5)) && (n3 && (n3 += " "), n3 += t3);
  return n3;
}
var init_clsx = __esm({
  "node_modules/clsx/dist/clsx.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(r, "r");
    __name(clsx, "clsx");
  }
});

// .svelte-kit/output/server/chunks/exports.js
function resolve2(base2, path2) {
  if (path2[0] === "/" && path2[1] === "/") return path2;
  let url = new URL(base2, internal);
  url = new URL(path2, url);
  return url.protocol === internal.protocol ? url.pathname + url.search + url.hash : url.href;
}
function normalize_path(path2, trailing_slash) {
  if (path2 === "/" || trailing_slash === "ignore") return path2;
  if (trailing_slash === "never") {
    return path2.endsWith("/") ? path2.slice(0, -1) : path2;
  } else if (trailing_slash === "always" && !path2.endsWith("/")) {
    return path2 + "/";
  }
  return path2;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
function make_trackable(url, callback, search_params_callback, allow_hash = false) {
  const tracked = new URL(url);
  Object.defineProperty(tracked, "searchParams", {
    value: new Proxy(tracked.searchParams, {
      get(obj, key2) {
        if (key2 === "get" || key2 === "getAll" || key2 === "has") {
          return (param) => {
            search_params_callback(param);
            return obj[key2](param);
          };
        }
        callback();
        const value = Reflect.get(obj, key2);
        return typeof value === "function" ? value.bind(obj) : value;
      }
    }),
    enumerable: true,
    configurable: true
  });
  const tracked_url_properties = ["href", "pathname", "search", "toString", "toJSON"];
  if (allow_hash) tracked_url_properties.push("hash");
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url, opts);
    };
    tracked.searchParams[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url.searchParams, opts);
    };
  }
  if (!allow_hash) {
    disable_hash(tracked);
  }
  return tracked;
}
function disable_hash(url) {
  allow_nodejs_console_log(url);
  Object.defineProperty(url, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url) {
  allow_nodejs_console_log(url);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url) {
  {
    url[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url), opts);
    };
  }
}
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  __name(set2, "set");
  function update(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  __name(update, "update");
  function subscribe(run, invalidate = noop) {
    const subscriber = [run, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update) || noop;
    }
    run(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  __name(subscribe, "subscribe");
  return { set: set2, update, subscribe };
}
function validator(expected) {
  function validate(module2, file) {
    if (!module2) return;
    for (const key2 in module2) {
      if (key2[0] === "_" || expected.has(key2)) continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file?.slice(file.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file ? ` in ${file}` : ""} (${hint})`);
    }
  }
  __name(validate, "validate");
  return validate;
}
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var internal, subscriber_queue, valid_layout_exports, valid_page_exports, valid_layout_server_exports, valid_page_server_exports, valid_server_exports, validate_layout_exports, validate_page_exports, validate_layout_server_exports, validate_page_server_exports, validate_server_exports;
var init_exports2 = __esm({
  ".svelte-kit/output/server/chunks/exports.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_equality();
    init_clsx();
    internal = new URL("sveltekit-internal://");
    __name(resolve2, "resolve");
    __name(normalize_path, "normalize_path");
    __name(decode_pathname, "decode_pathname");
    __name(decode_params, "decode_params");
    __name(make_trackable, "make_trackable");
    __name(disable_hash, "disable_hash");
    __name(disable_search, "disable_search");
    __name(allow_nodejs_console_log, "allow_nodejs_console_log");
    subscriber_queue = [];
    __name(readable, "readable");
    __name(writable, "writable");
    __name(validator, "validator");
    __name(hint_for_supported_files, "hint_for_supported_files");
    valid_layout_exports = /* @__PURE__ */ new Set([
      "load",
      "prerender",
      "csr",
      "ssr",
      "trailingSlash",
      "config"
    ]);
    valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
    valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
    valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
    valid_server_exports = /* @__PURE__ */ new Set([
      "GET",
      "POST",
      "PATCH",
      "PUT",
      "DELETE",
      "OPTIONS",
      "HEAD",
      "fallback",
      "prerender",
      "trailingSlash",
      "config",
      "entries"
    ]);
    validate_layout_exports = validator(valid_layout_exports);
    validate_page_exports = validator(valid_page_exports);
    validate_layout_server_exports = validator(valid_layout_server_exports);
    validate_page_server_exports = validator(valid_page_server_exports);
    validate_server_exports = validator(valid_server_exports);
  }
});

// .svelte-kit/output/server/chunks/utils.js
function get_relative_path(from2, to2) {
  const from_parts = from2.split(/[/\\]/);
  const to_parts = to2.split(/[/\\]/);
  from_parts.pop();
  while (from_parts[0] === to_parts[0]) {
    from_parts.shift();
    to_parts.shift();
  }
  let i2 = from_parts.length;
  while (i2--) from_parts[i2] = "..";
  return from_parts.concat(to_parts).join("/");
}
function base64_encode(bytes) {
  if (globalThis.Buffer) {
    return globalThis.Buffer.from(bytes).toString("base64");
  }
  let binary = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return btoa(binary);
}
function base64_decode(encoded) {
  if (globalThis.Buffer) {
    const buffer = globalThis.Buffer.from(encoded, "base64");
    return new Uint8Array(buffer);
  }
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0; i2 < binary.length; i2++) {
    bytes[i2] = binary.charCodeAt(i2);
  }
  return bytes;
}
var text_encoder2, text_decoder2;
var init_utils3 = __esm({
  ".svelte-kit/output/server/chunks/utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    text_encoder2 = new TextEncoder();
    text_decoder2 = new TextDecoder();
    __name(get_relative_path, "get_relative_path");
    __name(base64_encode, "base64_encode");
    __name(base64_decode, "base64_decode");
  }
});

// .svelte-kit/output/server/chunks/escaping.js
function escape_html(value, is_attr) {
  const str = String(value ?? "");
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern2.test(str)) {
    const i2 = pattern2.lastIndex - 1;
    const ch = str[i2];
    escaped2 += str.substring(last, i2) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i2 + 1;
  }
  return escaped2 + str.substring(last);
}
var ATTR_REGEX, CONTENT_REGEX;
var init_escaping = __esm({
  ".svelte-kit/output/server/chunks/escaping.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    __name(escape_html, "escape_html");
  }
});

// .svelte-kit/output/server/chunks/context.js
function lifecycle_outside_component(name) {
  {
    throw new Error(`https://svelte.dev/e/lifecycle_outside_component`);
  }
}
function set_ssr_context(v2) {
  ssr_context = v2;
}
function getContext(key2) {
  const context_map = get_or_init_context_map();
  const result = (
    /** @type {T} */
    context_map.get(key2)
  );
  return result;
}
function setContext(key2, context3) {
  get_or_init_context_map().set(key2, context3);
  return context3;
}
function get_or_init_context_map(name) {
  if (ssr_context === null) {
    lifecycle_outside_component();
  }
  return ssr_context.c ??= new Map(get_parent_context(ssr_context) || void 0);
}
function push(fn) {
  ssr_context = { p: ssr_context, c: null, r: null };
}
function pop() {
  ssr_context = /** @type {SSRContext} */
  ssr_context.p;
}
function get_parent_context(ssr_context2) {
  let parent = ssr_context2.p;
  while (parent !== null) {
    const context_map = parent.c;
    if (context_map !== null) {
      return context_map;
    }
    parent = parent.p;
  }
  return null;
}
var ssr_context;
var init_context = __esm({
  ".svelte-kit/output/server/chunks/context.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(lifecycle_outside_component, "lifecycle_outside_component");
    ssr_context = null;
    __name(set_ssr_context, "set_ssr_context");
    __name(getContext, "getContext");
    __name(setContext, "setContext");
    __name(get_or_init_context_map, "get_or_init_context_map");
    __name(push, "push");
    __name(pop, "pop");
    __name(get_parent_context, "get_parent_context");
  }
});

// .svelte-kit/output/server/chunks/index.js
function is_boolean_attribute(name) {
  return DOM_BOOLEAN_ATTRIBUTES.includes(name);
}
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}
function attr(name, value, is_boolean = false) {
  if (name === "hidden" && value !== "until-found") {
    is_boolean = true;
  }
  if (value == null || !value && is_boolean) return "";
  const normalized = name in replacements && replacements[name].get(value) || value;
  const assignment = is_boolean ? "" : `="${escape_html(normalized, true)}"`;
  return ` ${name}${assignment}`;
}
function clsx2(value) {
  if (typeof value === "object") {
    return clsx(value);
  } else {
    return value ?? "";
  }
}
function to_class(value, hash2, directives) {
  var classname = value == null ? "" : "" + value;
  if (hash2) {
    classname = classname ? classname + " " + hash2 : hash2;
  }
  if (directives) {
    for (var key2 in directives) {
      if (directives[key2]) {
        classname = classname ? classname + " " + key2 : key2;
      } else if (classname.length) {
        var len = key2.length;
        var a2 = 0;
        while ((a2 = classname.indexOf(key2, a2)) >= 0) {
          var b2 = a2 + len;
          if ((a2 === 0 || whitespace.includes(classname[a2 - 1])) && (b2 === classname.length || whitespace.includes(classname[b2]))) {
            classname = (a2 === 0 ? "" : classname.substring(0, a2)) + classname.substring(b2 + 1);
          } else {
            a2 = b2;
          }
        }
      }
    }
  }
  return classname === "" ? null : classname;
}
function append_styles(styles, important = false) {
  var separator = important ? " !important;" : ";";
  var css = "";
  for (var key2 in styles) {
    var value = styles[key2];
    if (value != null && value !== "") {
      css += " " + key2 + ": " + value + separator;
    }
  }
  return css;
}
function to_css_name(name) {
  if (name[0] !== "-" || name[1] !== "-") {
    return name.toLowerCase();
  }
  return name;
}
function to_style(value, styles) {
  if (styles) {
    var new_style = "";
    var normal_styles;
    var important_styles;
    if (Array.isArray(styles)) {
      normal_styles = styles[0];
      important_styles = styles[1];
    } else {
      normal_styles = styles;
    }
    if (value) {
      value = String(value).replaceAll(/\s*\/\*.*?\*\/\s*/g, "").trim();
      var in_str = false;
      var in_apo = 0;
      var in_comment = false;
      var reserved_names = [];
      if (normal_styles) {
        reserved_names.push(...Object.keys(normal_styles).map(to_css_name));
      }
      if (important_styles) {
        reserved_names.push(...Object.keys(important_styles).map(to_css_name));
      }
      var start_index = 0;
      var name_index = -1;
      const len = value.length;
      for (var i2 = 0; i2 < len; i2++) {
        var c3 = value[i2];
        if (in_comment) {
          if (c3 === "/" && value[i2 - 1] === "*") {
            in_comment = false;
          }
        } else if (in_str) {
          if (in_str === c3) {
            in_str = false;
          }
        } else if (c3 === "/" && value[i2 + 1] === "*") {
          in_comment = true;
        } else if (c3 === '"' || c3 === "'") {
          in_str = c3;
        } else if (c3 === "(") {
          in_apo++;
        } else if (c3 === ")") {
          in_apo--;
        }
        if (!in_comment && in_str === false && in_apo === 0) {
          if (c3 === ":" && name_index === -1) {
            name_index = i2;
          } else if (c3 === ";" || i2 === len - 1) {
            if (name_index !== -1) {
              var name = to_css_name(value.substring(start_index, name_index).trim());
              if (!reserved_names.includes(name)) {
                if (c3 !== ";") {
                  i2++;
                }
                var property = value.substring(start_index, i2).trim();
                new_style += " " + property + ";";
              }
            }
            start_index = i2 + 1;
            name_index = -1;
          }
        }
      }
    }
    if (normal_styles) {
      new_style += append_styles(normal_styles);
    }
    if (important_styles) {
      new_style += append_styles(important_styles, true);
    }
    new_style = new_style.trim();
    return new_style === "" ? null : new_style;
  }
  return value == null ? null : String(value);
}
function abort2() {
  controller?.abort(STALE_REACTION);
  controller = null;
}
function await_invalid() {
  const error4 = new Error(`await_invalid
Encountered asynchronous work while rendering synchronously.
https://svelte.dev/e/await_invalid`);
  error4.name = "Svelte error";
  throw error4;
}
function render(component5, options2 = {}) {
  return Renderer.render(
    /** @type {Component<Props>} */
    component5,
    options2
  );
}
function head(hash2, renderer, fn) {
  renderer.head((renderer2) => {
    renderer2.push(`<!--${hash2}-->`);
    renderer2.child(fn);
    renderer2.push(EMPTY_COMMENT);
  });
}
function attributes(attrs, css_hash, classes, styles, flags2 = 0) {
  if (styles) {
    attrs.style = to_style(attrs.style, styles);
  }
  if (attrs.class) {
    attrs.class = clsx2(attrs.class);
  }
  if (css_hash || classes) {
    attrs.class = to_class(attrs.class, css_hash, classes);
  }
  let attr_str = "";
  let name;
  const is_html = (flags2 & ELEMENT_IS_NAMESPACED) === 0;
  const lowercase = (flags2 & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;
  const is_input = (flags2 & ELEMENT_IS_INPUT) !== 0;
  for (name in attrs) {
    if (typeof attrs[name] === "function") continue;
    if (name[0] === "$" && name[1] === "$") continue;
    if (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;
    var value = attrs[name];
    if (lowercase) {
      name = name.toLowerCase();
    }
    if (is_input) {
      if (name === "defaultvalue" || name === "defaultchecked") {
        name = name === "defaultvalue" ? "value" : "checked";
        if (attrs[name]) continue;
      }
    }
    attr_str += attr(name, value, is_html && is_boolean_attribute(name));
  }
  return attr_str;
}
function slot(renderer, $$props, name, slot_props, fallback_fn) {
  var slot_fn = $$props.$$slots?.[name];
  if (slot_fn === true) {
    slot_fn = $$props["children"];
  }
  if (slot_fn !== void 0) {
    slot_fn(renderer, slot_props);
  }
}
var DERIVED, EFFECT, RENDER_EFFECT, BLOCK_EFFECT, BRANCH_EFFECT, ROOT_EFFECT, BOUNDARY_EFFECT, CONNECTED, CLEAN, DIRTY, MAYBE_DIRTY, INERT, DESTROYED, EFFECT_RAN, EFFECT_TRANSPARENT, EAGER_EFFECT, HEAD_EFFECT, EFFECT_PRESERVED, USER_EFFECT, WAS_MARKED, REACTION_IS_UPDATING, ASYNC, ERROR_VALUE, STATE_SYMBOL, LEGACY_PROPS, STALE_REACTION, COMMENT_NODE, HYDRATION_START, HYDRATION_START_ELSE, HYDRATION_END, HYDRATION_ERROR, ELEMENT_IS_NAMESPACED, ELEMENT_PRESERVE_ATTRIBUTE_CASE, ELEMENT_IS_INPUT, UNINITIALIZED, DOM_BOOLEAN_ATTRIBUTES, PASSIVE_EVENTS, replacements, whitespace, BLOCK_OPEN, BLOCK_CLOSE, EMPTY_COMMENT, controller, Renderer, SSRState, INVALID_ATTR_NAME_CHAR_REGEX;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_escaping();
    init_clsx();
    init_context();
    DERIVED = 1 << 1;
    EFFECT = 1 << 2;
    RENDER_EFFECT = 1 << 3;
    BLOCK_EFFECT = 1 << 4;
    BRANCH_EFFECT = 1 << 5;
    ROOT_EFFECT = 1 << 6;
    BOUNDARY_EFFECT = 1 << 7;
    CONNECTED = 1 << 9;
    CLEAN = 1 << 10;
    DIRTY = 1 << 11;
    MAYBE_DIRTY = 1 << 12;
    INERT = 1 << 13;
    DESTROYED = 1 << 14;
    EFFECT_RAN = 1 << 15;
    EFFECT_TRANSPARENT = 1 << 16;
    EAGER_EFFECT = 1 << 17;
    HEAD_EFFECT = 1 << 18;
    EFFECT_PRESERVED = 1 << 19;
    USER_EFFECT = 1 << 20;
    WAS_MARKED = 1 << 15;
    REACTION_IS_UPDATING = 1 << 21;
    ASYNC = 1 << 22;
    ERROR_VALUE = 1 << 23;
    STATE_SYMBOL = Symbol("$state");
    LEGACY_PROPS = Symbol("legacy props");
    STALE_REACTION = new class StaleReactionError extends Error {
      static {
        __name(this, "StaleReactionError");
      }
      name = "StaleReactionError";
      message = "The reaction that called `getAbortSignal()` was re-run or destroyed";
    }();
    COMMENT_NODE = 8;
    HYDRATION_START = "[";
    HYDRATION_START_ELSE = "[!";
    HYDRATION_END = "]";
    HYDRATION_ERROR = {};
    ELEMENT_IS_NAMESPACED = 1;
    ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
    ELEMENT_IS_INPUT = 1 << 2;
    UNINITIALIZED = Symbol();
    DOM_BOOLEAN_ATTRIBUTES = [
      "allowfullscreen",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "disabled",
      "formnovalidate",
      "indeterminate",
      "inert",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "seamless",
      "selected",
      "webkitdirectory",
      "defer",
      "disablepictureinpicture",
      "disableremoteplayback"
    ];
    __name(is_boolean_attribute, "is_boolean_attribute");
    PASSIVE_EVENTS = ["touchstart", "touchmove"];
    __name(is_passive_event, "is_passive_event");
    replacements = {
      translate: /* @__PURE__ */ new Map([
        [true, "yes"],
        [false, "no"]
      ])
    };
    __name(attr, "attr");
    __name(clsx2, "clsx");
    whitespace = [..." 	\n\r\f\xA0\v\uFEFF"];
    __name(to_class, "to_class");
    __name(append_styles, "append_styles");
    __name(to_css_name, "to_css_name");
    __name(to_style, "to_style");
    BLOCK_OPEN = `<!--${HYDRATION_START}-->`;
    BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;
    EMPTY_COMMENT = `<!---->`;
    controller = null;
    __name(abort2, "abort");
    __name(await_invalid, "await_invalid");
    Renderer = class _Renderer {
      static {
        __name(this, "Renderer");
      }
      /**
       * The contents of the renderer.
       * @type {RendererItem[]}
       */
      #out = [];
      /**
       * Any `onDestroy` callbacks registered during execution of this renderer.
       * @type {(() => void)[] | undefined}
       */
      #on_destroy = void 0;
      /**
       * Whether this renderer is a component body.
       * @type {boolean}
       */
      #is_component_body = false;
      /**
       * The type of string content that this renderer is accumulating.
       * @type {RendererType}
       */
      type;
      /** @type {Renderer | undefined} */
      #parent;
      /**
       * Asynchronous work associated with this renderer
       * @type {Promise<void> | undefined}
       */
      promise = void 0;
      /**
       * State which is associated with the content tree as a whole.
       * It will be re-exposed, uncopied, on all children.
       * @type {SSRState}
       * @readonly
       */
      global;
      /**
       * State that is local to the branch it is declared in.
       * It will be shallow-copied to all children.
       *
       * @type {{ select_value: string | undefined }}
       */
      local;
      /**
       * @param {SSRState} global
       * @param {Renderer | undefined} [parent]
       */
      constructor(global2, parent) {
        this.#parent = parent;
        this.global = global2;
        this.local = parent ? { ...parent.local } : { select_value: void 0 };
        this.type = parent ? parent.type : "body";
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      head(fn) {
        const head2 = new _Renderer(this.global, this);
        head2.type = "head";
        this.#out.push(head2);
        head2.child(fn);
      }
      /**
       * @param {Array<Promise<void>>} blockers
       * @param {(renderer: Renderer) => void} fn
       */
      async_block(blockers, fn) {
        this.#out.push(BLOCK_OPEN);
        this.async(blockers, fn);
        this.#out.push(BLOCK_CLOSE);
      }
      /**
       * @param {Array<Promise<void>>} blockers
       * @param {(renderer: Renderer) => void} fn
       */
      async(blockers, fn) {
        let callback = fn;
        if (blockers.length > 0) {
          const context3 = ssr_context;
          callback = /* @__PURE__ */ __name((renderer) => {
            return Promise.all(blockers).then(() => {
              const previous_context = ssr_context;
              try {
                set_ssr_context(context3);
                return fn(renderer);
              } finally {
                set_ssr_context(previous_context);
              }
            });
          }, "callback");
        }
        this.child(callback);
      }
      /**
       * @param {Array<() => void>} thunks
       */
      run(thunks) {
        const context3 = ssr_context;
        let promise = Promise.resolve(thunks[0]());
        const promises = [promise];
        for (const fn of thunks.slice(1)) {
          promise = promise.then(() => {
            const previous_context = ssr_context;
            set_ssr_context(context3);
            try {
              return fn();
            } finally {
              set_ssr_context(previous_context);
            }
          });
          promises.push(promise);
        }
        return promises;
      }
      /**
       * Create a child renderer. The child renderer inherits the state from the parent,
       * but has its own content.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       */
      child(fn) {
        const child = new _Renderer(this.global, this);
        this.#out.push(child);
        const parent = ssr_context;
        set_ssr_context({
          ...ssr_context,
          p: parent,
          c: null,
          r: child
        });
        const result = fn(child);
        set_ssr_context(parent);
        if (result instanceof Promise) {
          if (child.global.mode === "sync") {
            await_invalid();
          }
          result.catch(() => {
          });
          child.promise = result;
        }
        return child;
      }
      /**
       * Create a component renderer. The component renderer inherits the state from the parent,
       * but has its own content. It is treated as an ordering boundary for ondestroy callbacks.
       * @param {(renderer: Renderer) => MaybePromise<void>} fn
       * @param {Function} [component_fn]
       * @returns {void}
       */
      component(fn, component_fn) {
        push();
        const child = this.child(fn);
        child.#is_component_body = true;
        pop();
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {(renderer: Renderer) => void} fn
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       * @returns {void}
       */
      select(attrs, fn, css_hash, classes, styles, flags2) {
        const { value, ...select_attrs } = attrs;
        this.push(`<select${attributes(select_attrs, css_hash, classes, styles, flags2)}>`);
        this.child((renderer) => {
          renderer.local.select_value = value;
          fn(renderer);
        });
        this.push("</select>");
      }
      /**
       * @param {Record<string, any>} attrs
       * @param {string | number | boolean | ((renderer: Renderer) => void)} body
       * @param {string | undefined} [css_hash]
       * @param {Record<string, boolean> | undefined} [classes]
       * @param {Record<string, string> | undefined} [styles]
       * @param {number | undefined} [flags]
       */
      option(attrs, body2, css_hash, classes, styles, flags2) {
        this.#out.push(`<option${attributes(attrs, css_hash, classes, styles, flags2)}`);
        const close = /* @__PURE__ */ __name((renderer, value, { head: head2, body: body22 }) => {
          if ("value" in attrs) {
            value = attrs.value;
          }
          if (value === this.local.select_value) {
            renderer.#out.push(" selected");
          }
          renderer.#out.push(`>${body22}</option>`);
          if (head2) {
            renderer.head((child) => child.push(head2));
          }
        }, "close");
        if (typeof body2 === "function") {
          this.child((renderer) => {
            const r4 = new _Renderer(this.global, this);
            body2(r4);
            if (this.global.mode === "async") {
              return r4.#collect_content_async().then((content) => {
                close(renderer, content.body.replaceAll("<!---->", ""), content);
              });
            } else {
              const content = r4.#collect_content();
              close(renderer, content.body.replaceAll("<!---->", ""), content);
            }
          });
        } else {
          close(this, body2, { body: body2 });
        }
      }
      /**
       * @param {(renderer: Renderer) => void} fn
       */
      title(fn) {
        const path2 = this.get_path();
        const close = /* @__PURE__ */ __name((head2) => {
          this.global.set_title(head2, path2);
        }, "close");
        this.child((renderer) => {
          const r4 = new _Renderer(renderer.global, renderer);
          fn(r4);
          if (renderer.global.mode === "async") {
            return r4.#collect_content_async().then((content) => {
              close(content.head);
            });
          } else {
            const content = r4.#collect_content();
            close(content.head);
          }
        });
      }
      /**
       * @param {string | (() => Promise<string>)} content
       */
      push(content) {
        if (typeof content === "function") {
          this.child(async (renderer) => renderer.push(await content()));
        } else {
          this.#out.push(content);
        }
      }
      /**
       * @param {() => void} fn
       */
      on_destroy(fn) {
        (this.#on_destroy ??= []).push(fn);
      }
      /**
       * @returns {number[]}
       */
      get_path() {
        return this.#parent ? [...this.#parent.get_path(), this.#parent.#out.indexOf(this)] : [];
      }
      /**
       * @deprecated this is needed for legacy component bindings
       */
      copy() {
        const copy = new _Renderer(this.global, this.#parent);
        copy.#out = this.#out.map((item) => item instanceof _Renderer ? item.copy() : item);
        copy.promise = this.promise;
        return copy;
      }
      /**
       * @param {Renderer} other
       * @deprecated this is needed for legacy component bindings
       */
      subsume(other) {
        if (this.global.mode !== other.global.mode) {
          throw new Error(
            "invariant: A renderer cannot switch modes. If you're seeing this, there's a compiler bug. File an issue!"
          );
        }
        this.local = other.local;
        this.#out = other.#out.map((item) => {
          if (item instanceof _Renderer) {
            item.subsume(item);
          }
          return item;
        });
        this.promise = other.promise;
        this.type = other.type;
      }
      get length() {
        return this.#out.length;
      }
      /**
       * Only available on the server and when compiling with the `server` option.
       * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} [options]
       * @returns {RenderOutput}
       */
      static render(component5, options2 = {}) {
        let sync;
        const result = (
          /** @type {RenderOutput} */
          {}
        );
        Object.defineProperties(result, {
          html: {
            get: /* @__PURE__ */ __name(() => {
              return (sync ??= _Renderer.#render(component5, options2)).body;
            }, "get")
          },
          head: {
            get: /* @__PURE__ */ __name(() => {
              return (sync ??= _Renderer.#render(component5, options2)).head;
            }, "get")
          },
          body: {
            get: /* @__PURE__ */ __name(() => {
              return (sync ??= _Renderer.#render(component5, options2)).body;
            }, "get")
          },
          then: {
            value: (
              /**
               * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
               *
               * @template TResult1
               * @template [TResult2=never]
               * @param { (value: SyncRenderOutput) => TResult1 } onfulfilled
               * @param { (reason: unknown) => TResult2 } onrejected
               */
              /* @__PURE__ */ __name((onfulfilled, onrejected) => {
                {
                  const result2 = sync ??= _Renderer.#render(component5, options2);
                  const user_result = onfulfilled({
                    head: result2.head,
                    body: result2.body,
                    html: result2.body
                  });
                  return Promise.resolve(user_result);
                }
              }, "value")
            )
          }
        });
        return result;
      }
      /**
       * Collect all of the `onDestroy` callbacks registered during rendering. In an async context, this is only safe to call
       * after awaiting `collect_async`.
       *
       * Child renderers are "porous" and don't affect execution order, but component body renderers
       * create ordering boundaries. Within a renderer, callbacks run in order until hitting a component boundary.
       * @returns {Iterable<() => void>}
       */
      *#collect_on_destroy() {
        for (const component5 of this.#traverse_components()) {
          yield* component5.#collect_ondestroy();
        }
      }
      /**
       * Performs a depth-first search of renderers, yielding the deepest components first, then additional components as we backtrack up the tree.
       * @returns {Iterable<Renderer>}
       */
      *#traverse_components() {
        for (const child of this.#out) {
          if (typeof child !== "string") {
            yield* child.#traverse_components();
          }
        }
        if (this.#is_component_body) {
          yield this;
        }
      }
      /**
       * @returns {Iterable<() => void>}
       */
      *#collect_ondestroy() {
        if (this.#on_destroy) {
          for (const fn of this.#on_destroy) {
            yield fn;
          }
        }
        for (const child of this.#out) {
          if (child instanceof _Renderer && !child.#is_component_body) {
            yield* child.#collect_ondestroy();
          }
        }
      }
      /**
       * Render a component. Throws if any of the children are performing asynchronous work.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {AccumulatedContent}
       */
      static #render(component5, options2) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("sync", component5, options2);
          const content = renderer.#collect_content();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort2();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Render a component.
       *
       * @template {Record<string, any>} Props
       * @param {Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Promise<AccumulatedContent>}
       */
      static async #render_async(component5, options2) {
        var previous_context = ssr_context;
        try {
          const renderer = _Renderer.#open_render("async", component5, options2);
          const content = await renderer.#collect_content_async();
          return _Renderer.#close_render(content, renderer);
        } finally {
          abort2();
          set_ssr_context(previous_context);
        }
      }
      /**
       * Collect all of the code from the `out` array and return it as a string, or a promise resolving to a string.
       * @param {AccumulatedContent} content
       * @returns {AccumulatedContent}
       */
      #collect_content(content = { head: "", body: "" }) {
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            item.#collect_content(content);
          }
        }
        return content;
      }
      /**
       * Collect all of the code from the `out` array and return it as a string.
       * @param {AccumulatedContent} content
       * @returns {Promise<AccumulatedContent>}
       */
      async #collect_content_async(content = { head: "", body: "" }) {
        await this.promise;
        for (const item of this.#out) {
          if (typeof item === "string") {
            content[this.type] += item;
          } else if (item instanceof _Renderer) {
            await item.#collect_content_async(content);
          }
        }
        return content;
      }
      /**
       * @template {Record<string, any>} Props
       * @param {'sync' | 'async'} mode
       * @param {import('svelte').Component<Props>} component
       * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any>; idPrefix?: string }} options
       * @returns {Renderer}
       */
      static #open_render(mode, component5, options2) {
        const renderer = new _Renderer(
          new SSRState(mode, options2.idPrefix ? options2.idPrefix + "-" : "")
        );
        renderer.push(BLOCK_OPEN);
        if (options2.context) {
          push();
          ssr_context.c = options2.context;
          ssr_context.r = renderer;
        }
        component5(renderer, options2.props ?? {});
        if (options2.context) {
          pop();
        }
        renderer.push(BLOCK_CLOSE);
        return renderer;
      }
      /**
       * @param {AccumulatedContent} content
       * @param {Renderer} renderer
       */
      static #close_render(content, renderer) {
        for (const cleanup of renderer.#collect_on_destroy()) {
          cleanup();
        }
        let head2 = content.head + renderer.global.get_title();
        let body2 = content.body;
        for (const { hash: hash2, code } of renderer.global.css) {
          head2 += `<style id="${hash2}">${code}</style>`;
        }
        return {
          head: head2,
          body: body2
        };
      }
    };
    SSRState = class {
      static {
        __name(this, "SSRState");
      }
      /** @readonly @type {'sync' | 'async'} */
      mode;
      /** @readonly @type {() => string} */
      uid;
      /** @readonly @type {Set<{ hash: string; code: string }>} */
      css = /* @__PURE__ */ new Set();
      /** @type {{ path: number[], value: string }} */
      #title = { path: [], value: "" };
      /**
       * @param {'sync' | 'async'} mode
       * @param {string} [id_prefix]
       */
      constructor(mode, id_prefix = "") {
        this.mode = mode;
        let uid = 1;
        this.uid = () => `${id_prefix}s${uid++}`;
      }
      get_title() {
        return this.#title.value;
      }
      /**
       * Performs a depth-first (lexicographic) comparison using the path. Rejects sets
       * from earlier than or equal to the current value.
       * @param {string} value
       * @param {number[]} path
       */
      set_title(value, path2) {
        const current2 = this.#title.path;
        let i2 = 0;
        let l2 = Math.min(path2.length, current2.length);
        while (i2 < l2 && path2[i2] === current2[i2]) i2 += 1;
        if (path2[i2] === void 0) return;
        if (current2[i2] === void 0 || path2[i2] > current2[i2]) {
          this.#title.path = path2;
          this.#title.value = value;
        }
      }
    };
    INVALID_ATTR_NAME_CHAR_REGEX = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    __name(render, "render");
    __name(head, "head");
    __name(attributes, "attributes");
    __name(slot, "slot");
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.parse = parse3;
    exports.serialize = serialize2;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse3(str, options2) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options2 || {};
      var dec = opt.decode || decode2;
      var index5 = 0;
      while (index5 < str.length) {
        var eqIdx = str.indexOf("=", index5);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index5);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index5 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key2 = str.slice(index5, eqIdx).trim();
        if (void 0 === obj[key2]) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key2] = tryDecode(val, dec);
        }
        index5 = endIdx + 1;
      }
      return obj;
    }
    __name(parse3, "parse");
    function serialize2(name, val, options2) {
      var opt = options2 || {};
      var enc = opt.encode || encode3;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.partitioned) {
        str += "; Partitioned";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    __name(serialize2, "serialize");
    function decode2(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    __name(decode2, "decode");
    function encode3(val) {
      return encodeURIComponent(val);
    }
    __name(encode3, "encode");
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    __name(isDate, "isDate");
    function tryDecode(str, decode3) {
      try {
        return decode3(str);
      } catch (e5) {
        return str;
      }
    }
    __name(tryDecode, "tryDecode");
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isForbiddenKey(key2) {
      return typeof key2 !== "string" || key2 in {};
    }
    __name(isForbiddenKey, "isForbiddenKey");
    function createNullObj() {
      return /* @__PURE__ */ Object.create(null);
    }
    __name(createNullObj, "createNullObj");
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    __name(isNonEmptyString, "isNonEmptyString");
    function parseString2(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (isForbiddenKey(name)) {
        return null;
      }
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e5) {
        console.error(
          "set-cookie-parser: failed to decode cookie value. Set options.decodeValues=false to disable decoding.",
          e5
        );
      }
      var cookie = createNullObj();
      cookie.name = name;
      cookie.value = value;
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key2 = sides.shift().trimLeft().toLowerCase();
        if (isForbiddenKey(key2)) {
          return;
        }
        var value2 = sides.join("=");
        if (key2 === "expires") {
          cookie.expires = new Date(value2);
        } else if (key2 === "max-age") {
          var n3 = parseInt(value2, 10);
          if (!Number.isNaN(n3)) cookie.maxAge = n3;
        } else if (key2 === "secure") {
          cookie.secure = true;
        } else if (key2 === "httponly") {
          cookie.httpOnly = true;
        } else if (key2 === "samesite") {
          cookie.sameSite = value2;
        } else if (key2 === "partitioned") {
          cookie.partitioned = true;
        } else if (key2) {
          cookie[key2] = value2;
        }
      });
      return cookie;
    }
    __name(parseString2, "parseString");
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    __name(parseNameValuePair, "parseNameValuePair");
    function parse3(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return createNullObj();
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key2) {
            return key2.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options2.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString2(str, options2);
        }).filter(Boolean);
      } else {
        var cookies = createNullObj();
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString2(str, options2);
          if (cookie && !isForbiddenKey(cookie.name)) {
            cookies2[cookie.name] = cookie;
          }
          return cookies2;
        }, cookies);
      }
    }
    __name(parse3, "parse");
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      __name(skipWhitespace, "skipWhitespace");
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      __name(notSpecialChar, "notSpecialChar");
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    __name(splitCookiesString2, "splitCookiesString");
    module2.exports = parse3;
    module2.exports.parse = parse3;
    module2.exports.parseString = parseString2;
    module2.exports.splitCookiesString = splitCookiesString2;
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
function _layout($$renderer, $$props) {
  $$renderer.push(`<!--[-->`);
  slot($$renderer, $$props, "default", {});
  $$renderer.push(`<!--]-->`);
}
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunks();
    __name(_layout, "_layout");
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  stylesheets: () => stylesheets
});
var index, component_cache, component, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index = 0;
    component = /* @__PURE__ */ __name(async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default, "component");
    imports = ["_app/immutable/nodes/0.Ds_eWx-U.js", "_app/immutable/chunks/DFqY95ai.js", "_app/immutable/chunks/H8HRPmpP.js", "_app/immutable/chunks/Di_XG6Ig.js"];
    stylesheets = ["_app/immutable/assets/0.DNMtJkfe.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error$1
});
function create_updated_store() {
  const { set: set2, subscribe } = writable(false);
  {
    return {
      subscribe,
      // eslint-disable-next-line @typescript-eslint/require-await
      check: /* @__PURE__ */ __name(async () => false, "check")
    };
  }
}
function context2() {
  return getContext("__request__");
}
function Error$1($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    $$renderer2.push(`<h1>${escape_html(page.status)}</h1> <p>${escape_html(page.error?.message)}</p>`);
  });
}
var is_legacy, stores, page$1, page;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_escaping();
    init_clsx();
    init_equality();
    init_server();
    init_internal();
    init_exports2();
    init_utils3();
    init_context();
    __name(create_updated_store, "create_updated_store");
    is_legacy = noop.toString().includes("$$") || /function \w+\(\) \{\}/.test(noop.toString());
    if (is_legacy) {
      ({
        data: {},
        form: null,
        error: null,
        params: {},
        route: { id: null },
        state: {},
        status: -1,
        url: new URL("https://example.com")
      });
    }
    stores = {
      updated: /* @__PURE__ */ create_updated_store()
    };
    ({
      check: stores.updated.check
    });
    __name(context2, "context");
    page$1 = {
      get error() {
        return context2().page.error;
      },
      get status() {
        return context2().page.status;
      }
    };
    page = page$1;
    __name(Error$1, "Error$1");
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index2 = 1;
    component2 = /* @__PURE__ */ __name(async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default, "component");
    imports2 = ["_app/immutable/nodes/1.BJ_EE-mw.js", "_app/immutable/chunks/DFqY95ai.js", "_app/immutable/chunks/H8HRPmpP.js", "_app/immutable/chunks/Di_XG6Ig.js", "_app/immutable/chunks/DWDlLD0t.js", "_app/immutable/chunks/CGKANyzZ.js", "_app/immutable/chunks/C_Sh5Hij.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => _page
});
function Counter($$renderer) {
  let count3 = 0;
  $$renderer.push(`<button>count is ${escape_html(count3)}</button>`);
}
function _page($$renderer) {
  $$renderer.push(`<main><div class="card">`);
  Counter($$renderer);
  $$renderer.push(`<!----></div> <p>Check out <a href="https://github.com/sveltejs/kit#readme" target="_blank" rel="noreferrer">SvelteKit</a>, the official Svelte app framework powered by Vite!</p> <p class="read-the-docs svelte-1uha8ag">Click on the Vite and Svelte logos to learn more</p> <p><a href="/game">Play the Game!</a></p></main>`);
}
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_clsx();
    init_escaping();
    __name(Counter, "Counter");
    __name(_page, "_page");
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    index3 = 2;
    component3 = /* @__PURE__ */ __name(async () => component_cache3 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default, "component");
    imports3 = ["_app/immutable/nodes/2.B2EiJEZV.js", "_app/immutable/chunks/DFqY95ai.js", "_app/immutable/chunks/H8HRPmpP.js", "_app/immutable/chunks/Di_XG6Ig.js", "_app/immutable/chunks/DWDlLD0t.js"];
    stylesheets3 = ["_app/immutable/assets/2.9XHcVk5V.css"];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/game/_page.server.ts.js
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  load: () => load
});
var load;
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/game/_page.server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    load = /* @__PURE__ */ __name(async ({ platform: platform2 }) => {
      const spacetimedbHost = platform2?.env?.SPACETIMEDB_HOST || "ws://localhost:3000";
      const spacetimedbDbName = platform2?.env?.SPACETIMEDB_DB_NAME || "marbles2";
      return {
        spacetimedbConfig: {
          host: spacetimedbHost,
          moduleName: spacetimedbDbName
        }
      };
    }, "load");
  }
});

// .svelte-kit/output/server/entries/pages/game/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => _page2
});
function _page2($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let { data } = $$props;
    head("4p1id7", $$renderer2, ($$renderer3) => {
      $$renderer3.title(($$renderer4) => {
        $$renderer4.push(`<title>Unity Web Player | MarblesUnityClient</title>`);
      });
      $$renderer3.push(`<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes"/>`);
    });
    $$renderer2.push(`<div class="unity-container svelte-4p1id7"><canvas id="unity-canvas" tabindex="-1" class="svelte-4p1id7"></canvas></div>`);
  });
}
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/game/_page.svelte.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_chunks();
    __name(_page2, "_page");
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  server: () => page_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, server_id, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_page_server_ts();
    index4 = 3;
    component4 = /* @__PURE__ */ __name(async () => component_cache4 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default, "component");
    server_id = "src/routes/game/+page.server.ts";
    imports4 = ["_app/immutable/nodes/3.D6V_G3qs.js", "_app/immutable/chunks/DFqY95ai.js", "_app/immutable/chunks/H8HRPmpP.js", "_app/immutable/chunks/C_Sh5Hij.js", "_app/immutable/chunks/yg97jW04.js"];
    stylesheets4 = ["_app/immutable/assets/3.CtrtHYcH.css"];
    fonts4 = [];
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.byteLength = byteLength2;
    exports.toByteArray = toByteArray2;
    exports.fromByteArray = fromByteArray3;
    var lookup2 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup2[i2] = code[i2];
      revLookup2[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength2(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength2, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr2(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup2[b64.charCodeAt(i3)] << 18 | revLookup2[b64.charCodeAt(i3 + 1)] << 12 | revLookup2[b64.charCodeAt(i3 + 2)] << 6 | revLookup2[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i3)] << 2 | revLookup2[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i3)] << 10 | revLookup2[b64.charCodeAt(i3 + 1)] << 4 | revLookup2[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray2, "toByteArray");
    function tripletToBase642(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    __name(tripletToBase642, "tripletToBase64");
    function encodeChunk2(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase642(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk2, "encodeChunk");
    function fromByteArray3(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray3, "fromByteArray");
  }
});

// node_modules/spacetimedb/dist/index.browser.mjs
function deepEqual(obj1, obj2) {
  if (obj1 === obj2) return true;
  if (typeof obj1 !== "object" || obj1 === null || typeof obj2 !== "object" || obj2 === null) {
    return false;
  }
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;
  for (const key2 of keys1) {
    if (!keys2.includes(key2) || !deepEqual(obj1[key2], obj2[key2])) {
      return false;
    }
  }
  return true;
}
function uint8ArrayToHexString(array2) {
  return Array.prototype.map.call(array2.reverse(), (x2) => ("00" + x2.toString(16)).slice(-2)).join("");
}
function uint8ArrayToU128(array2) {
  if (array2.length != 16) {
    throw new Error(`Uint8Array is not 16 bytes long: ${array2}`);
  }
  return new BinaryReader(array2).readU128();
}
function uint8ArrayToU256(array2) {
  if (array2.length != 32) {
    throw new Error(`Uint8Array is not 32 bytes long: [${array2}]`);
  }
  return new BinaryReader(array2).readU256();
}
function hexStringToUint8Array(str) {
  if (str.startsWith("0x")) {
    str = str.slice(2);
  }
  const matches = str.match(/.{1,2}/g) || [];
  const data = Uint8Array.from(
    matches.map((byte) => parseInt(byte, 16))
  );
  return data.reverse();
}
function hexStringToU128(str) {
  return uint8ArrayToU128(hexStringToUint8Array(str));
}
function hexStringToU256(str) {
  return uint8ArrayToU256(hexStringToUint8Array(str));
}
function u128ToUint8Array(data) {
  const writer = new BinaryWriter(16);
  writer.writeU128(data);
  return writer.getBuffer();
}
function u128ToHexString(data) {
  return uint8ArrayToHexString(u128ToUint8Array(data));
}
function u256ToUint8Array(data) {
  const writer = new BinaryWriter(32);
  writer.writeU256(data);
  return writer.getBuffer();
}
function u256ToHexString(data) {
  return uint8ArrayToHexString(u256ToUint8Array(data));
}
function parseValue(ty, src2) {
  const reader = new BinaryReader(src2);
  return ty.deserialize(reader);
}
function comparePreReleases(a2, b2) {
  const len = Math.min(a2.length, b2.length);
  for (let i2 = 0; i2 < len; i2++) {
    const aPart = a2[i2];
    const bPart = b2[i2];
    if (aPart === bPart) continue;
    if (typeof aPart === "number" && typeof bPart === "number") {
      return aPart - bPart;
    }
    if (typeof aPart === "string" && typeof bPart === "string") {
      return aPart.localeCompare(bPart);
    }
    return typeof aPart === "string" ? 1 : -1;
  }
  return a2.length - b2.length;
}
function ensureMinimumVersionOrThrow(versionString) {
  if (versionString === void 0) {
    throw new Error(versionErrorMessage(versionString));
  }
  const version2 = SemanticVersion.parseVersionString(versionString);
  if (version2.compare(_MINIMUM_CLI_VERSION) < 0) {
    throw new Error(versionErrorMessage(versionString));
  }
}
function versionErrorMessage(incompatibleVersion) {
  return `Module code was generated with an incompatible version of the spacetimedb cli (${incompatibleVersion}). Update the cli version to at least ${_MINIMUM_CLI_VERSION.toString()} and regenerate the bindings. You can upgrade to the latest cli version by running: spacetime version upgrade`;
}
async function decompress(buffer, type, chunkSize = 128 * 1024) {
  let offset = 0;
  const readableStream2 = new ReadableStream({
    pull(controller2) {
      if (offset < buffer.length) {
        const chunk = buffer.subarray(
          offset,
          Math.min(offset + chunkSize, buffer.length)
        );
        controller2.enqueue(chunk);
        offset += chunkSize;
      } else {
        controller2.close();
      }
    }
  });
  const decompressionStream = new DecompressionStream(type);
  const decompressedStream = readableStream2.pipeThrough(decompressionStream);
  const reader = decompressedStream.getReader();
  const chunks = [];
  let totalLength = 0;
  let result;
  while (!(result = await reader.read()).done) {
    chunks.push(result.value);
    totalLength += result.value.length;
  }
  const decompressedArray = new Uint8Array(totalLength);
  let chunkOffset = 0;
  for (const chunk of chunks) {
    decompressedArray.set(chunk, chunkOffset);
    chunkOffset += chunk.length;
  }
  return decompressedArray;
}
async function resolveWS() {
  if (typeof globalThis.WebSocket !== "undefined") {
    return globalThis.WebSocket;
  }
  const dynamicImport = new Function("m", "return import(m)");
  try {
    const { WebSocket: UndiciWS } = await dynamicImport("undici");
    return UndiciWS;
  } catch (err) {
    console.warn(
      "[spacetimedb-sdk] No global WebSocket found. On Node 18\u201321, please install `undici` (npm install undici) to enable WebSocket support."
    );
    throw err;
  }
}
function callReducerFlagsToNumber(flags2) {
  switch (flags2) {
    case "FullUpdate":
      return 0;
    case "NoSuccessNotify":
      return 1;
  }
}
var import_base64_js, TimeDuration, Timestamp, BinaryWriter, BinaryReader, Identity, Option, _cached_SumTypeVariant_type_value, SumTypeVariant, _cached_SumType_type_value, SumType, _cached_ProductTypeElement_type_value, ProductTypeElement, _cached_ProductType_type_value, ProductType, _cached_AlgebraicType_type_value, AlgebraicType2, ScheduleAt, Interval, Time, schedule_at_default, AlgebraicType, ProductType2, SumType2, ConnectionId, _cached_RowSizeHint_type_value, RowSizeHint, _cached_BsatnRowList_type_value, BsatnRowList, _cached_CallReducer_type_value, CallReducer, _cached_Subscribe_type_value, Subscribe, _cached_OneOffQuery_type_value, OneOffQuery, _cached_QueryId_type_value, QueryId, _cached_SubscribeSingle_type_value, SubscribeSingle, _cached_SubscribeMulti_type_value, SubscribeMulti, _cached_Unsubscribe_type_value, Unsubscribe, _cached_UnsubscribeMulti_type_value, UnsubscribeMulti, _cached_ClientMessage_type_value, ClientMessage, _cached_QueryUpdate_type_value, QueryUpdate, _cached_CompressableQueryUpdate_type_value, CompressableQueryUpdate, _cached_TableUpdate_type_value, TableUpdate, _cached_DatabaseUpdate_type_value, DatabaseUpdate, _cached_InitialSubscription_type_value, InitialSubscription, _cached_UpdateStatus_type_value, UpdateStatus, _cached_ReducerCallInfo_type_value, ReducerCallInfo, _cached_EnergyQuanta_type_value, EnergyQuanta, _cached_TransactionUpdate_type_value, TransactionUpdate, _cached_TransactionUpdateLight_type_value, TransactionUpdateLight, _cached_IdentityToken_type_value, IdentityToken, _cached_OneOffTable_type_value, OneOffTable, _cached_OneOffQueryResponse_type_value, OneOffQueryResponse, _cached_SubscribeRows_type_value, SubscribeRows, _cached_SubscribeApplied_type_value, SubscribeApplied, _cached_UnsubscribeApplied_type_value, UnsubscribeApplied, _cached_SubscriptionError_type_value, SubscriptionError, _cached_SubscribeMultiApplied_type_value, SubscribeMultiApplied, _cached_UnsubscribeMultiApplied_type_value, UnsubscribeMultiApplied, _cached_ServerMessage_type_value, ServerMessage, EventEmitter2, LogLevelIdentifierIcon, LogStyle, LogTextStyle, stdbLogger, TableCache, ClientCache, SemanticVersion, _MINIMUM_CLI_VERSION, WebsocketDecompressAdapter, DbConnectionBuilder, SubscriptionBuilderImpl, SubscriptionManager, SubscriptionHandleImpl, DbConnectionImpl;
var init_index_browser = __esm({
  "node_modules/spacetimedb/dist/index.browser.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    import_base64_js = __toESM(require_base64_js(), 1);
    TimeDuration = class _TimeDuration {
      static {
        __name(this, "_TimeDuration");
      }
      __time_duration_micros__;
      static MICROS_PER_MILLIS = 1000n;
      /**
       * Get the algebraic type representation of the {@link TimeDuration} type.
       * @returns The algebraic type representation of the type.
       */
      static getAlgebraicType() {
        return AlgebraicType.Product({
          elements: [
            {
              name: "__time_duration_micros__",
              algebraicType: AlgebraicType.I64
            }
          ]
        });
      }
      get micros() {
        return this.__time_duration_micros__;
      }
      get millis() {
        return Number(this.micros / _TimeDuration.MICROS_PER_MILLIS);
      }
      constructor(micros) {
        this.__time_duration_micros__ = micros;
      }
      static fromMillis(millis) {
        return new _TimeDuration(BigInt(millis) * _TimeDuration.MICROS_PER_MILLIS);
      }
      /** This outputs the same string format that we use in the host and in Rust modules */
      toString() {
        const micros = this.micros;
        const sign = micros < 0 ? "-" : "+";
        const pos = micros < 0 ? -micros : micros;
        const secs = pos / 1000000n;
        const micros_remaining = pos % 1000000n;
        return `${sign}${secs}.${String(micros_remaining).padStart(6, "0")}`;
      }
    };
    Timestamp = class _Timestamp {
      static {
        __name(this, "_Timestamp");
      }
      __timestamp_micros_since_unix_epoch__;
      static MICROS_PER_MILLIS = 1000n;
      get microsSinceUnixEpoch() {
        return this.__timestamp_micros_since_unix_epoch__;
      }
      constructor(micros) {
        this.__timestamp_micros_since_unix_epoch__ = micros;
      }
      /**
       * Get the algebraic type representation of the {@link Timestamp} type.
       * @returns The algebraic type representation of the type.
       */
      static getAlgebraicType() {
        return AlgebraicType.Product({
          elements: [
            {
              name: "__timestamp_micros_since_unix_epoch__",
              algebraicType: AlgebraicType.I64
            }
          ]
        });
      }
      /**
       * The Unix epoch, the midnight at the beginning of January 1, 1970, UTC.
       */
      static UNIX_EPOCH = new _Timestamp(0n);
      /**
       * Get a `Timestamp` representing the execution environment's belief of the current moment in time.
       */
      static now() {
        return _Timestamp.fromDate(/* @__PURE__ */ new Date());
      }
      /**
       * Get a `Timestamp` representing the same point in time as `date`.
       */
      static fromDate(date2) {
        const millis = date2.getTime();
        const micros = BigInt(millis) * _Timestamp.MICROS_PER_MILLIS;
        return new _Timestamp(micros);
      }
      /**
       * Get a `Date` representing approximately the same point in time as `this`.
       *
       * This method truncates to millisecond precision,
       * and throws `RangeError` if the `Timestamp` is outside the range representable as a `Date`.
       */
      toDate() {
        const micros = this.__timestamp_micros_since_unix_epoch__;
        const millis = micros / _Timestamp.MICROS_PER_MILLIS;
        if (millis > BigInt(Number.MAX_SAFE_INTEGER) || millis < BigInt(Number.MIN_SAFE_INTEGER)) {
          throw new RangeError(
            "Timestamp is outside of the representable range of JS's Date"
          );
        }
        return new Date(Number(millis));
      }
      since(other) {
        return new TimeDuration(
          this.__timestamp_micros_since_unix_epoch__ - other.__timestamp_micros_since_unix_epoch__
        );
      }
    };
    BinaryWriter = class {
      static {
        __name(this, "BinaryWriter");
      }
      #buffer;
      #view;
      #offset = 0;
      constructor(size) {
        this.#buffer = new Uint8Array(size);
        this.#view = new DataView(this.#buffer.buffer);
      }
      #expandBuffer(additionalCapacity) {
        const minCapacity = this.#offset + additionalCapacity + 1;
        if (minCapacity <= this.#buffer.length) return;
        let newCapacity = this.#buffer.length * 2;
        if (newCapacity < minCapacity) newCapacity = minCapacity;
        const newBuffer = new Uint8Array(newCapacity);
        newBuffer.set(this.#buffer);
        this.#buffer = newBuffer;
        this.#view = new DataView(this.#buffer.buffer);
      }
      toBase64() {
        return (0, import_base64_js.fromByteArray)(this.#buffer.subarray(0, this.#offset));
      }
      getBuffer() {
        return this.#buffer.slice(0, this.#offset);
      }
      get offset() {
        return this.#offset;
      }
      writeUInt8Array(value) {
        const length = value.length;
        this.#expandBuffer(4 + length);
        this.writeU32(length);
        this.#buffer.set(value, this.#offset);
        this.#offset += value.length;
      }
      writeBool(value) {
        this.#expandBuffer(1);
        this.#view.setUint8(this.#offset, value ? 1 : 0);
        this.#offset += 1;
      }
      writeByte(value) {
        this.#expandBuffer(1);
        this.#view.setUint8(this.#offset, value);
        this.#offset += 1;
      }
      writeI8(value) {
        this.#expandBuffer(1);
        this.#view.setInt8(this.#offset, value);
        this.#offset += 1;
      }
      writeU8(value) {
        this.#expandBuffer(1);
        this.#view.setUint8(this.#offset, value);
        this.#offset += 1;
      }
      writeI16(value) {
        this.#expandBuffer(2);
        this.#view.setInt16(this.#offset, value, true);
        this.#offset += 2;
      }
      writeU16(value) {
        this.#expandBuffer(2);
        this.#view.setUint16(this.#offset, value, true);
        this.#offset += 2;
      }
      writeI32(value) {
        this.#expandBuffer(4);
        this.#view.setInt32(this.#offset, value, true);
        this.#offset += 4;
      }
      writeU32(value) {
        this.#expandBuffer(4);
        this.#view.setUint32(this.#offset, value, true);
        this.#offset += 4;
      }
      writeI64(value) {
        this.#expandBuffer(8);
        this.#view.setBigInt64(this.#offset, value, true);
        this.#offset += 8;
      }
      writeU64(value) {
        this.#expandBuffer(8);
        this.#view.setBigUint64(this.#offset, value, true);
        this.#offset += 8;
      }
      writeU128(value) {
        this.#expandBuffer(16);
        const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
        const upperPart = value >> BigInt(64);
        this.#view.setBigUint64(this.#offset, lowerPart, true);
        this.#view.setBigUint64(this.#offset + 8, upperPart, true);
        this.#offset += 16;
      }
      writeI128(value) {
        this.#expandBuffer(16);
        const lowerPart = value & BigInt("0xFFFFFFFFFFFFFFFF");
        const upperPart = value >> BigInt(64);
        this.#view.setBigInt64(this.#offset, lowerPart, true);
        this.#view.setBigInt64(this.#offset + 8, upperPart, true);
        this.#offset += 16;
      }
      writeU256(value) {
        this.#expandBuffer(32);
        const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
        const p0 = value & low_64_mask;
        const p1 = value >> BigInt(64 * 1) & low_64_mask;
        const p2 = value >> BigInt(64 * 2) & low_64_mask;
        const p3 = value >> BigInt(64 * 3);
        this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
        this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
        this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
        this.#view.setBigUint64(this.#offset + 8 * 3, p3, true);
        this.#offset += 32;
      }
      writeI256(value) {
        this.#expandBuffer(32);
        const low_64_mask = BigInt("0xFFFFFFFFFFFFFFFF");
        const p0 = value & low_64_mask;
        const p1 = value >> BigInt(64 * 1) & low_64_mask;
        const p2 = value >> BigInt(64 * 2) & low_64_mask;
        const p3 = value >> BigInt(64 * 3);
        this.#view.setBigUint64(this.#offset + 8 * 0, p0, true);
        this.#view.setBigUint64(this.#offset + 8 * 1, p1, true);
        this.#view.setBigUint64(this.#offset + 8 * 2, p2, true);
        this.#view.setBigInt64(this.#offset + 8 * 3, p3, true);
        this.#offset += 32;
      }
      writeF32(value) {
        this.#expandBuffer(4);
        this.#view.setFloat32(this.#offset, value, true);
        this.#offset += 4;
      }
      writeF64(value) {
        this.#expandBuffer(8);
        this.#view.setFloat64(this.#offset, value, true);
        this.#offset += 8;
      }
      writeString(value) {
        const encoder2 = new TextEncoder();
        const encodedString = encoder2.encode(value);
        this.writeU32(encodedString.length);
        this.#expandBuffer(encodedString.length);
        this.#buffer.set(encodedString, this.#offset);
        this.#offset += encodedString.length;
      }
    };
    BinaryReader = class {
      static {
        __name(this, "BinaryReader");
      }
      /**
       * The DataView used to read values from the binary data.
       *
       * Note: The DataView's `byteOffset` is relative to the beginning of the
       * underlying ArrayBuffer, not the start of the provided Uint8Array input.
       * This `BinaryReader`'s `#offset` field is used to track the current read position
       * relative to the start of the provided Uint8Array input.
       */
      #view;
      /**
       * Represents the offset (in bytes) relative to the start of the DataView
       * and provided Uint8Array input.
       *
       * Note: This is *not* the absolute byte offset within the underlying ArrayBuffer.
       */
      #offset = 0;
      constructor(input) {
        this.#view = new DataView(input.buffer, input.byteOffset, input.byteLength);
        this.#offset = 0;
      }
      get offset() {
        return this.#offset;
      }
      get remaining() {
        return this.#view.byteLength - this.#offset;
      }
      /** Ensure we have at least `n` bytes left to read */
      #ensure(n3) {
        if (this.#offset + n3 > this.#view.byteLength) {
          throw new RangeError(
            `Tried to read ${n3} byte(s) at relative offset ${this.#offset}, but only ${this.remaining} byte(s) remain`
          );
        }
      }
      readUInt8Array() {
        const length = this.readU32();
        this.#ensure(length);
        return this.readBytes(length);
      }
      readBool() {
        const value = this.#view.getUint8(this.#offset);
        this.#offset += 1;
        return value !== 0;
      }
      readByte() {
        const value = this.#view.getUint8(this.#offset);
        this.#offset += 1;
        return value;
      }
      readBytes(length) {
        const array2 = new Uint8Array(
          this.#view.buffer,
          this.#view.byteOffset + this.#offset,
          length
        );
        this.#offset += length;
        return array2;
      }
      readI8() {
        const value = this.#view.getInt8(this.#offset);
        this.#offset += 1;
        return value;
      }
      readU8() {
        return this.readByte();
      }
      readI16() {
        const value = this.#view.getInt16(this.#offset, true);
        this.#offset += 2;
        return value;
      }
      readU16() {
        const value = this.#view.getUint16(this.#offset, true);
        this.#offset += 2;
        return value;
      }
      readI32() {
        const value = this.#view.getInt32(this.#offset, true);
        this.#offset += 4;
        return value;
      }
      readU32() {
        const value = this.#view.getUint32(this.#offset, true);
        this.#offset += 4;
        return value;
      }
      readI64() {
        const value = this.#view.getBigInt64(this.#offset, true);
        this.#offset += 8;
        return value;
      }
      readU64() {
        const value = this.#view.getBigUint64(this.#offset, true);
        this.#offset += 8;
        return value;
      }
      readU128() {
        const lowerPart = this.#view.getBigUint64(this.#offset, true);
        const upperPart = this.#view.getBigUint64(this.#offset + 8, true);
        this.#offset += 16;
        return (upperPart << BigInt(64)) + lowerPart;
      }
      readI128() {
        const lowerPart = this.#view.getBigUint64(this.#offset, true);
        const upperPart = this.#view.getBigInt64(this.#offset + 8, true);
        this.#offset += 16;
        return (upperPart << BigInt(64)) + lowerPart;
      }
      readU256() {
        const p0 = this.#view.getBigUint64(this.#offset, true);
        const p1 = this.#view.getBigUint64(this.#offset + 8, true);
        const p2 = this.#view.getBigUint64(this.#offset + 16, true);
        const p3 = this.#view.getBigUint64(this.#offset + 24, true);
        this.#offset += 32;
        return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
      }
      readI256() {
        const p0 = this.#view.getBigUint64(this.#offset, true);
        const p1 = this.#view.getBigUint64(this.#offset + 8, true);
        const p2 = this.#view.getBigUint64(this.#offset + 16, true);
        const p3 = this.#view.getBigInt64(this.#offset + 24, true);
        this.#offset += 32;
        return (p3 << BigInt(3 * 64)) + (p2 << BigInt(2 * 64)) + (p1 << BigInt(1 * 64)) + p0;
      }
      readF32() {
        const value = this.#view.getFloat32(this.#offset, true);
        this.#offset += 4;
        return value;
      }
      readF64() {
        const value = this.#view.getFloat64(this.#offset, true);
        this.#offset += 8;
        return value;
      }
      readString() {
        const uint8Array = this.readUInt8Array();
        return new TextDecoder("utf-8").decode(uint8Array);
      }
    };
    __name(deepEqual, "deepEqual");
    __name(uint8ArrayToHexString, "uint8ArrayToHexString");
    __name(uint8ArrayToU128, "uint8ArrayToU128");
    __name(uint8ArrayToU256, "uint8ArrayToU256");
    __name(hexStringToUint8Array, "hexStringToUint8Array");
    __name(hexStringToU128, "hexStringToU128");
    __name(hexStringToU256, "hexStringToU256");
    __name(u128ToUint8Array, "u128ToUint8Array");
    __name(u128ToHexString, "u128ToHexString");
    __name(u256ToUint8Array, "u256ToUint8Array");
    __name(u256ToHexString, "u256ToHexString");
    Identity = class _Identity {
      static {
        __name(this, "_Identity");
      }
      __identity__;
      /**
       * Creates a new `Identity`.
       *
       * `data` can be a hexadecimal string or a `bigint`.
       */
      constructor(data) {
        this.__identity__ = typeof data === "string" ? hexStringToU256(data) : data;
      }
      /**
       * Get the algebraic type representation of the {@link Identity} type.
       * @returns The algebraic type representation of the type.
       */
      static getAlgebraicType() {
        return AlgebraicType.Product({
          elements: [{ name: "__identity__", algebraicType: AlgebraicType.U256 }]
        });
      }
      /**
       * Compare two identities for equality.
       */
      isEqual(other) {
        return this.toHexString() === other.toHexString();
      }
      /**
       * Print the identity as a hexadecimal string.
       */
      toHexString() {
        return u256ToHexString(this.__identity__);
      }
      /**
       * Convert the address to a Uint8Array.
       */
      toUint8Array() {
        return u256ToUint8Array(this.__identity__);
      }
      /**
       * Parse an Identity from a hexadecimal string.
       */
      static fromString(str) {
        return new _Identity(str);
      }
      /**
       * Zero identity (0x0000000000000000000000000000000000000000000000000000000000000000)
       */
      static zero() {
        return new _Identity(0n);
      }
      toString() {
        return this.toHexString();
      }
    };
    Option = {
      getAlgebraicType(innerType) {
        return AlgebraicType.Sum({
          variants: [
            { name: "some", algebraicType: innerType },
            {
              name: "none",
              algebraicType: AlgebraicType.Product({ elements: [] })
            }
          ]
        });
      }
    };
    _cached_SumTypeVariant_type_value = null;
    SumTypeVariant = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SumTypeVariant_type_value)
          return _cached_SumTypeVariant_type_value;
        _cached_SumTypeVariant_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SumTypeVariant_type_value.value.elements.push(
          {
            name: "name",
            algebraicType: AlgebraicType.createOptionType(
              AlgebraicType.String
            )
          },
          {
            name: "algebraicType",
            algebraicType: AlgebraicType2.getTypeScriptAlgebraicType()
          }
        );
        return _cached_SumTypeVariant_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SumTypeVariant.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SumTypeVariant.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SumType_type_value = null;
    SumType = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SumType_type_value) return _cached_SumType_type_value;
        _cached_SumType_type_value = AlgebraicType.Product({ elements: [] });
        _cached_SumType_type_value.value.elements.push({
          name: "variants",
          algebraicType: AlgebraicType.Array(
            SumTypeVariant.getTypeScriptAlgebraicType()
          )
        });
        return _cached_SumType_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SumType.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SumType.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_ProductTypeElement_type_value = null;
    ProductTypeElement = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_ProductTypeElement_type_value)
          return _cached_ProductTypeElement_type_value;
        _cached_ProductTypeElement_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_ProductTypeElement_type_value.value.elements.push(
          {
            name: "name",
            algebraicType: AlgebraicType.createOptionType(
              AlgebraicType.String
            )
          },
          {
            name: "algebraicType",
            algebraicType: AlgebraicType2.getTypeScriptAlgebraicType()
          }
        );
        return _cached_ProductTypeElement_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          ProductTypeElement.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          ProductTypeElement.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_ProductType_type_value = null;
    ProductType = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_ProductType_type_value) return _cached_ProductType_type_value;
        _cached_ProductType_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_ProductType_type_value.value.elements.push({
          name: "elements",
          algebraicType: AlgebraicType.Array(
            ProductTypeElement.getTypeScriptAlgebraicType()
          )
        });
        return _cached_ProductType_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          ProductType.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          ProductType.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_AlgebraicType_type_value = null;
    AlgebraicType2 = {
      // Helper functions for constructing each variant of the tagged union.
      // ```
      // const foo = Foo.A(42);
      // assert!(foo.tag === "A");
      // assert!(foo.value === 42);
      // ```
      Ref: /* @__PURE__ */ __name((value) => ({ tag: "Ref", value }), "Ref"),
      Sum: /* @__PURE__ */ __name((value) => ({ tag: "Sum", value }), "Sum"),
      Product: /* @__PURE__ */ __name((value) => ({
        tag: "Product",
        value
      }), "Product"),
      Array: /* @__PURE__ */ __name((value) => ({
        tag: "Array",
        value
      }), "Array"),
      String: { tag: "String" },
      Bool: { tag: "Bool" },
      I8: { tag: "I8" },
      U8: { tag: "U8" },
      I16: { tag: "I16" },
      U16: { tag: "U16" },
      I32: { tag: "I32" },
      U32: { tag: "U32" },
      I64: { tag: "I64" },
      U64: { tag: "U64" },
      I128: { tag: "I128" },
      U128: { tag: "U128" },
      I256: { tag: "I256" },
      U256: { tag: "U256" },
      F32: { tag: "F32" },
      F64: { tag: "F64" },
      getTypeScriptAlgebraicType() {
        if (_cached_AlgebraicType_type_value)
          return _cached_AlgebraicType_type_value;
        _cached_AlgebraicType_type_value = AlgebraicType.Sum({
          variants: []
        });
        _cached_AlgebraicType_type_value.value.variants.push(
          { name: "Ref", algebraicType: AlgebraicType.U32 },
          { name: "Sum", algebraicType: SumType.getTypeScriptAlgebraicType() },
          {
            name: "Product",
            algebraicType: ProductType.getTypeScriptAlgebraicType()
          },
          {
            name: "Array",
            algebraicType: AlgebraicType2.getTypeScriptAlgebraicType()
          },
          {
            name: "String",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "Bool",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "I8",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "U8",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "I16",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "U16",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "I32",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "U32",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "I64",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "U64",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "I128",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "U128",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "I256",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "U256",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "F32",
            algebraicType: AlgebraicType.Product({ elements: [] })
          },
          {
            name: "F64",
            algebraicType: AlgebraicType.Product({ elements: [] })
          }
        );
        return _cached_AlgebraicType_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          AlgebraicType2.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          AlgebraicType2.getTypeScriptAlgebraicType()
        );
      }
    };
    ScheduleAt = {
      interval(value) {
        return Interval(value);
      },
      time(value) {
        return Time(value);
      },
      getAlgebraicType() {
        return AlgebraicType.Sum({
          variants: [
            {
              name: "Interval",
              algebraicType: TimeDuration.getAlgebraicType()
            },
            { name: "Time", algebraicType: Timestamp.getAlgebraicType() }
          ]
        });
      }
    };
    Interval = /* @__PURE__ */ __name((micros) => ({
      tag: "Interval",
      value: new TimeDuration(micros)
    }), "Interval");
    Time = /* @__PURE__ */ __name((microsSinceUnixEpoch) => ({
      tag: "Time",
      value: new Timestamp(microsSinceUnixEpoch)
    }), "Time");
    schedule_at_default = ScheduleAt;
    AlgebraicType = {
      ...AlgebraicType2,
      Sum: /* @__PURE__ */ __name((value) => ({
        tag: "Sum",
        value
      }), "Sum"),
      Product: /* @__PURE__ */ __name((value) => ({
        tag: "Product",
        value
      }), "Product"),
      Array: /* @__PURE__ */ __name((value) => ({
        tag: "Array",
        value
      }), "Array"),
      createOptionType: /* @__PURE__ */ __name(function(innerType) {
        return Option.getAlgebraicType(innerType);
      }, "createOptionType"),
      createIdentityType: /* @__PURE__ */ __name(function() {
        return Identity.getAlgebraicType();
      }, "createIdentityType"),
      createConnectionIdType: /* @__PURE__ */ __name(function() {
        return ConnectionId.getAlgebraicType();
      }, "createConnectionIdType"),
      createScheduleAtType: /* @__PURE__ */ __name(function() {
        return schedule_at_default.getAlgebraicType();
      }, "createScheduleAtType"),
      createTimestampType: /* @__PURE__ */ __name(function() {
        return Timestamp.getAlgebraicType();
      }, "createTimestampType"),
      createTimeDurationType: /* @__PURE__ */ __name(function() {
        return TimeDuration.getAlgebraicType();
      }, "createTimeDurationType"),
      serializeValue: /* @__PURE__ */ __name(function(writer, ty, value, typespace) {
        if (ty.tag === "Ref") {
          if (!typespace)
            throw new Error("cannot serialize refs without a typespace");
          while (ty.tag === "Ref") ty = typespace.types[ty.value];
        }
        switch (ty.tag) {
          case "Product":
            ProductType2.serializeValue(writer, ty.value, value, typespace);
            break;
          case "Sum":
            SumType2.serializeValue(writer, ty.value, value, typespace);
            break;
          case "Array":
            if (ty.value.tag === "U8") {
              writer.writeUInt8Array(value);
            } else {
              const elemType = ty.value;
              writer.writeU32(value.length);
              for (const elem of value) {
                AlgebraicType.serializeValue(writer, elemType, elem, typespace);
              }
            }
            break;
          case "Bool":
            writer.writeBool(value);
            break;
          case "I8":
            writer.writeI8(value);
            break;
          case "U8":
            writer.writeU8(value);
            break;
          case "I16":
            writer.writeI16(value);
            break;
          case "U16":
            writer.writeU16(value);
            break;
          case "I32":
            writer.writeI32(value);
            break;
          case "U32":
            writer.writeU32(value);
            break;
          case "I64":
            writer.writeI64(value);
            break;
          case "U64":
            writer.writeU64(value);
            break;
          case "I128":
            writer.writeI128(value);
            break;
          case "U128":
            writer.writeU128(value);
            break;
          case "I256":
            writer.writeI256(value);
            break;
          case "U256":
            writer.writeU256(value);
            break;
          case "F32":
            writer.writeF32(value);
            break;
          case "F64":
            writer.writeF64(value);
            break;
          case "String":
            writer.writeString(value);
            break;
        }
      }, "serializeValue"),
      deserializeValue: /* @__PURE__ */ __name(function(reader, ty, typespace) {
        if (ty.tag === "Ref") {
          if (!typespace)
            throw new Error("cannot deserialize refs without a typespace");
          while (ty.tag === "Ref") ty = typespace.types[ty.value];
        }
        switch (ty.tag) {
          case "Product":
            return ProductType2.deserializeValue(reader, ty.value, typespace);
          case "Sum":
            return SumType2.deserializeValue(reader, ty.value, typespace);
          case "Array":
            if (ty.value.tag === "U8") {
              return reader.readUInt8Array();
            } else {
              const elemType = ty.value;
              const length = reader.readU32();
              const result = [];
              for (let i2 = 0; i2 < length; i2++) {
                result.push(
                  AlgebraicType.deserializeValue(reader, elemType, typespace)
                );
              }
              return result;
            }
          case "Bool":
            return reader.readBool();
          case "I8":
            return reader.readI8();
          case "U8":
            return reader.readU8();
          case "I16":
            return reader.readI16();
          case "U16":
            return reader.readU16();
          case "I32":
            return reader.readI32();
          case "U32":
            return reader.readU32();
          case "I64":
            return reader.readI64();
          case "U64":
            return reader.readU64();
          case "I128":
            return reader.readI128();
          case "U128":
            return reader.readU128();
          case "I256":
            return reader.readI256();
          case "U256":
            return reader.readU256();
          case "F32":
            return reader.readF32();
          case "F64":
            return reader.readF64();
          case "String":
            return reader.readString();
        }
      }, "deserializeValue"),
      /**
       * Convert a value of the algebraic type into something that can be used as a key in a map.
       * There are no guarantees about being able to order it.
       * This is only guaranteed to be comparable to other values of the same type.
       * @param value A value of the algebraic type
       * @returns Something that can be used as a key in a map.
       */
      intoMapKey: /* @__PURE__ */ __name(function(ty, value) {
        switch (ty.tag) {
          case "U8":
          case "U16":
          case "U32":
          case "U64":
          case "U128":
          case "U256":
          case "I8":
          case "I16":
          case "I32":
          case "I64":
          case "I128":
          case "I256":
          case "F32":
          case "F64":
          case "String":
          case "Bool":
            return value;
          case "Product":
            return ProductType2.intoMapKey(ty.value, value);
          default: {
            const writer = new BinaryWriter(10);
            AlgebraicType.serializeValue(writer, ty, value);
            return writer.toBase64();
          }
        }
      }, "intoMapKey")
    };
    ProductType2 = {
      ...ProductType,
      serializeValue(writer, ty, value, typespace) {
        for (const element of ty.elements) {
          AlgebraicType.serializeValue(
            writer,
            element.algebraicType,
            value[element.name],
            typespace
          );
        }
      },
      deserializeValue(reader, ty, typespace) {
        const result = {};
        if (ty.elements.length === 1) {
          if (ty.elements[0].name === "__time_duration_micros__") {
            return new TimeDuration(reader.readI64());
          }
          if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
            return new Timestamp(reader.readI64());
          }
          if (ty.elements[0].name === "__identity__") {
            return new Identity(reader.readU256());
          }
          if (ty.elements[0].name === "__connection_id__") {
            return new ConnectionId(reader.readU128());
          }
        }
        for (const element of ty.elements) {
          result[element.name] = AlgebraicType.deserializeValue(
            reader,
            element.algebraicType,
            typespace
          );
        }
        return result;
      },
      intoMapKey(ty, value) {
        if (ty.elements.length === 1) {
          if (ty.elements[0].name === "__time_duration_micros__") {
            return value.__time_duration_micros__;
          }
          if (ty.elements[0].name === "__timestamp_micros_since_unix_epoch__") {
            return value.__timestamp_micros_since_unix_epoch__;
          }
          if (ty.elements[0].name === "__identity__") {
            return value.__identity__;
          }
          if (ty.elements[0].name === "__connection_id__") {
            return value.__connection_id__;
          }
        }
        const writer = new BinaryWriter(10);
        AlgebraicType.serializeValue(writer, AlgebraicType.Product(ty), value);
        return writer.toBase64();
      }
    };
    SumType2 = {
      ...SumType,
      serializeValue: /* @__PURE__ */ __name(function(writer, ty, value, typespace) {
        if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
          if (value !== null && value !== void 0) {
            writer.writeByte(0);
            AlgebraicType.serializeValue(
              writer,
              ty.variants[0].algebraicType,
              value,
              typespace
            );
          } else {
            writer.writeByte(1);
          }
        } else {
          const variant = value["tag"];
          const index5 = ty.variants.findIndex((v2) => v2.name === variant);
          if (index5 < 0) {
            throw `Can't serialize a sum type, couldn't find ${value.tag} tag`;
          }
          writer.writeU8(index5);
          AlgebraicType.serializeValue(
            writer,
            ty.variants[index5].algebraicType,
            value["value"],
            typespace
          );
        }
      }, "serializeValue"),
      deserializeValue: /* @__PURE__ */ __name(function(reader, ty, typespace) {
        const tag = reader.readU8();
        if (ty.variants.length == 2 && ty.variants[0].name === "some" && ty.variants[1].name === "none") {
          if (tag === 0) {
            return AlgebraicType.deserializeValue(
              reader,
              ty.variants[0].algebraicType,
              typespace
            );
          } else if (tag === 1) {
            return void 0;
          } else {
            throw `Can't deserialize an option type, couldn't find ${tag} tag`;
          }
        } else {
          const variant = ty.variants[tag];
          const value = AlgebraicType.deserializeValue(
            reader,
            variant.algebraicType,
            typespace
          );
          return { tag: variant.name, value };
        }
      }, "deserializeValue")
    };
    ConnectionId = class _ConnectionId {
      static {
        __name(this, "_ConnectionId");
      }
      __connection_id__;
      /**
       * Creates a new `ConnectionId`.
       */
      constructor(data) {
        this.__connection_id__ = data;
      }
      /**
       * Get the algebraic type representation of the {@link ConnectionId} type.
       * @returns The algebraic type representation of the type.
       */
      static getAlgebraicType() {
        return AlgebraicType.Product({
          elements: [
            { name: "__connection_id__", algebraicType: AlgebraicType.U128 }
          ]
        });
      }
      isZero() {
        return this.__connection_id__ === BigInt(0);
      }
      static nullIfZero(addr) {
        if (addr.isZero()) {
          return null;
        } else {
          return addr;
        }
      }
      static random() {
        function randomU8() {
          return Math.floor(Math.random() * 255);
        }
        __name(randomU8, "randomU8");
        let result = BigInt(0);
        for (let i2 = 0; i2 < 16; i2++) {
          result = result << BigInt(8) | BigInt(randomU8());
        }
        return new _ConnectionId(result);
      }
      /**
       * Compare two connection IDs for equality.
       */
      isEqual(other) {
        return this.__connection_id__ == other.__connection_id__;
      }
      /**
       * Print the connection ID as a hexadecimal string.
       */
      toHexString() {
        return u128ToHexString(this.__connection_id__);
      }
      /**
       * Convert the connection ID to a Uint8Array.
       */
      toUint8Array() {
        return u128ToUint8Array(this.__connection_id__);
      }
      /**
       * Parse a connection ID from a hexadecimal string.
       */
      static fromString(str) {
        return new _ConnectionId(hexStringToU128(str));
      }
      static fromStringOrNull(str) {
        const addr = _ConnectionId.fromString(str);
        if (addr.isZero()) {
          return null;
        } else {
          return addr;
        }
      }
    };
    __name(parseValue, "parseValue");
    _cached_RowSizeHint_type_value = null;
    RowSizeHint = {
      // Helper functions for constructing each variant of the tagged union.
      // ```
      // const foo = Foo.A(42);
      // assert!(foo.tag === "A");
      // assert!(foo.value === 42);
      // ```
      FixedSize: /* @__PURE__ */ __name((value) => ({
        tag: "FixedSize",
        value
      }), "FixedSize"),
      RowOffsets: /* @__PURE__ */ __name((value) => ({
        tag: "RowOffsets",
        value
      }), "RowOffsets"),
      getTypeScriptAlgebraicType() {
        if (_cached_RowSizeHint_type_value) return _cached_RowSizeHint_type_value;
        _cached_RowSizeHint_type_value = AlgebraicType.Sum({ variants: [] });
        _cached_RowSizeHint_type_value.value.variants.push(
          { name: "FixedSize", algebraicType: AlgebraicType.U16 },
          {
            name: "RowOffsets",
            algebraicType: AlgebraicType.Array(AlgebraicType.U64)
          }
        );
        return _cached_RowSizeHint_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          RowSizeHint.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          RowSizeHint.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_BsatnRowList_type_value = null;
    BsatnRowList = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_BsatnRowList_type_value) return _cached_BsatnRowList_type_value;
        _cached_BsatnRowList_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_BsatnRowList_type_value.value.elements.push(
          {
            name: "sizeHint",
            algebraicType: RowSizeHint.getTypeScriptAlgebraicType()
          },
          {
            name: "rowsData",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          }
        );
        return _cached_BsatnRowList_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          BsatnRowList.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          BsatnRowList.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_CallReducer_type_value = null;
    CallReducer = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_CallReducer_type_value) return _cached_CallReducer_type_value;
        _cached_CallReducer_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_CallReducer_type_value.value.elements.push(
          { name: "reducer", algebraicType: AlgebraicType.String },
          {
            name: "args",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          },
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          { name: "flags", algebraicType: AlgebraicType.U8 }
        );
        return _cached_CallReducer_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          CallReducer.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          CallReducer.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_Subscribe_type_value = null;
    Subscribe = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_Subscribe_type_value) return _cached_Subscribe_type_value;
        _cached_Subscribe_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_Subscribe_type_value.value.elements.push(
          {
            name: "queryStrings",
            algebraicType: AlgebraicType.Array(AlgebraicType.String)
          },
          { name: "requestId", algebraicType: AlgebraicType.U32 }
        );
        return _cached_Subscribe_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          Subscribe.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          Subscribe.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_OneOffQuery_type_value = null;
    OneOffQuery = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_OneOffQuery_type_value) return _cached_OneOffQuery_type_value;
        _cached_OneOffQuery_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_OneOffQuery_type_value.value.elements.push(
          {
            name: "messageId",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          },
          { name: "queryString", algebraicType: AlgebraicType.String }
        );
        return _cached_OneOffQuery_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          OneOffQuery.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          OneOffQuery.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_QueryId_type_value = null;
    QueryId = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_QueryId_type_value) return _cached_QueryId_type_value;
        _cached_QueryId_type_value = AlgebraicType.Product({ elements: [] });
        _cached_QueryId_type_value.value.elements.push({
          name: "id",
          algebraicType: AlgebraicType.U32
        });
        return _cached_QueryId_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          QueryId.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          QueryId.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SubscribeSingle_type_value = null;
    SubscribeSingle = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SubscribeSingle_type_value)
          return _cached_SubscribeSingle_type_value;
        _cached_SubscribeSingle_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SubscribeSingle_type_value.value.elements.push(
          { name: "query", algebraicType: AlgebraicType.String },
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() }
        );
        return _cached_SubscribeSingle_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SubscribeSingle.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SubscribeSingle.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SubscribeMulti_type_value = null;
    SubscribeMulti = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SubscribeMulti_type_value)
          return _cached_SubscribeMulti_type_value;
        _cached_SubscribeMulti_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SubscribeMulti_type_value.value.elements.push(
          {
            name: "queryStrings",
            algebraicType: AlgebraicType.Array(AlgebraicType.String)
          },
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() }
        );
        return _cached_SubscribeMulti_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SubscribeMulti.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SubscribeMulti.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_Unsubscribe_type_value = null;
    Unsubscribe = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_Unsubscribe_type_value) return _cached_Unsubscribe_type_value;
        _cached_Unsubscribe_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_Unsubscribe_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() }
        );
        return _cached_Unsubscribe_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          Unsubscribe.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          Unsubscribe.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_UnsubscribeMulti_type_value = null;
    UnsubscribeMulti = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_UnsubscribeMulti_type_value)
          return _cached_UnsubscribeMulti_type_value;
        _cached_UnsubscribeMulti_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_UnsubscribeMulti_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() }
        );
        return _cached_UnsubscribeMulti_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          UnsubscribeMulti.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          UnsubscribeMulti.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_ClientMessage_type_value = null;
    ClientMessage = {
      // Helper functions for constructing each variant of the tagged union.
      // ```
      // const foo = Foo.A(42);
      // assert!(foo.tag === "A");
      // assert!(foo.value === 42);
      // ```
      CallReducer: /* @__PURE__ */ __name((value) => ({
        tag: "CallReducer",
        value
      }), "CallReducer"),
      Subscribe: /* @__PURE__ */ __name((value) => ({
        tag: "Subscribe",
        value
      }), "Subscribe"),
      OneOffQuery: /* @__PURE__ */ __name((value) => ({
        tag: "OneOffQuery",
        value
      }), "OneOffQuery"),
      SubscribeSingle: /* @__PURE__ */ __name((value) => ({
        tag: "SubscribeSingle",
        value
      }), "SubscribeSingle"),
      SubscribeMulti: /* @__PURE__ */ __name((value) => ({ tag: "SubscribeMulti", value }), "SubscribeMulti"),
      Unsubscribe: /* @__PURE__ */ __name((value) => ({
        tag: "Unsubscribe",
        value
      }), "Unsubscribe"),
      UnsubscribeMulti: /* @__PURE__ */ __name((value) => ({
        tag: "UnsubscribeMulti",
        value
      }), "UnsubscribeMulti"),
      getTypeScriptAlgebraicType() {
        if (_cached_ClientMessage_type_value)
          return _cached_ClientMessage_type_value;
        _cached_ClientMessage_type_value = AlgebraicType.Sum({
          variants: []
        });
        _cached_ClientMessage_type_value.value.variants.push(
          {
            name: "CallReducer",
            algebraicType: CallReducer.getTypeScriptAlgebraicType()
          },
          {
            name: "Subscribe",
            algebraicType: Subscribe.getTypeScriptAlgebraicType()
          },
          {
            name: "OneOffQuery",
            algebraicType: OneOffQuery.getTypeScriptAlgebraicType()
          },
          {
            name: "SubscribeSingle",
            algebraicType: SubscribeSingle.getTypeScriptAlgebraicType()
          },
          {
            name: "SubscribeMulti",
            algebraicType: SubscribeMulti.getTypeScriptAlgebraicType()
          },
          {
            name: "Unsubscribe",
            algebraicType: Unsubscribe.getTypeScriptAlgebraicType()
          },
          {
            name: "UnsubscribeMulti",
            algebraicType: UnsubscribeMulti.getTypeScriptAlgebraicType()
          }
        );
        return _cached_ClientMessage_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          ClientMessage.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          ClientMessage.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_QueryUpdate_type_value = null;
    QueryUpdate = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_QueryUpdate_type_value) return _cached_QueryUpdate_type_value;
        _cached_QueryUpdate_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_QueryUpdate_type_value.value.elements.push(
          {
            name: "deletes",
            algebraicType: BsatnRowList.getTypeScriptAlgebraicType()
          },
          {
            name: "inserts",
            algebraicType: BsatnRowList.getTypeScriptAlgebraicType()
          }
        );
        return _cached_QueryUpdate_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          QueryUpdate.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          QueryUpdate.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_CompressableQueryUpdate_type_value = null;
    CompressableQueryUpdate = {
      // Helper functions for constructing each variant of the tagged union.
      // ```
      // const foo = Foo.A(42);
      // assert!(foo.tag === "A");
      // assert!(foo.value === 42);
      // ```
      Uncompressed: /* @__PURE__ */ __name((value) => ({
        tag: "Uncompressed",
        value
      }), "Uncompressed"),
      Brotli: /* @__PURE__ */ __name((value) => ({
        tag: "Brotli",
        value
      }), "Brotli"),
      Gzip: /* @__PURE__ */ __name((value) => ({
        tag: "Gzip",
        value
      }), "Gzip"),
      getTypeScriptAlgebraicType() {
        if (_cached_CompressableQueryUpdate_type_value)
          return _cached_CompressableQueryUpdate_type_value;
        _cached_CompressableQueryUpdate_type_value = AlgebraicType.Sum({
          variants: []
        });
        _cached_CompressableQueryUpdate_type_value.value.variants.push(
          {
            name: "Uncompressed",
            algebraicType: QueryUpdate.getTypeScriptAlgebraicType()
          },
          {
            name: "Brotli",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          },
          {
            name: "Gzip",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          }
        );
        return _cached_CompressableQueryUpdate_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          CompressableQueryUpdate.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          CompressableQueryUpdate.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_TableUpdate_type_value = null;
    TableUpdate = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_TableUpdate_type_value) return _cached_TableUpdate_type_value;
        _cached_TableUpdate_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_TableUpdate_type_value.value.elements.push(
          { name: "tableId", algebraicType: AlgebraicType.U32 },
          { name: "tableName", algebraicType: AlgebraicType.String },
          { name: "numRows", algebraicType: AlgebraicType.U64 },
          {
            name: "updates",
            algebraicType: AlgebraicType.Array(
              CompressableQueryUpdate.getTypeScriptAlgebraicType()
            )
          }
        );
        return _cached_TableUpdate_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          TableUpdate.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          TableUpdate.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_DatabaseUpdate_type_value = null;
    DatabaseUpdate = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_DatabaseUpdate_type_value)
          return _cached_DatabaseUpdate_type_value;
        _cached_DatabaseUpdate_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_DatabaseUpdate_type_value.value.elements.push({
          name: "tables",
          algebraicType: AlgebraicType.Array(
            TableUpdate.getTypeScriptAlgebraicType()
          )
        });
        return _cached_DatabaseUpdate_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          DatabaseUpdate.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          DatabaseUpdate.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_InitialSubscription_type_value = null;
    InitialSubscription = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_InitialSubscription_type_value)
          return _cached_InitialSubscription_type_value;
        _cached_InitialSubscription_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_InitialSubscription_type_value.value.elements.push(
          {
            name: "databaseUpdate",
            algebraicType: DatabaseUpdate.getTypeScriptAlgebraicType()
          },
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          {
            name: "totalHostExecutionDuration",
            algebraicType: AlgebraicType.createTimeDurationType()
          }
        );
        return _cached_InitialSubscription_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          InitialSubscription.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          InitialSubscription.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_UpdateStatus_type_value = null;
    UpdateStatus = {
      // Helper functions for constructing each variant of the tagged union.
      // ```
      // const foo = Foo.A(42);
      // assert!(foo.tag === "A");
      // assert!(foo.value === 42);
      // ```
      Committed: /* @__PURE__ */ __name((value) => ({
        tag: "Committed",
        value
      }), "Committed"),
      Failed: /* @__PURE__ */ __name((value) => ({
        tag: "Failed",
        value
      }), "Failed"),
      OutOfEnergy: { tag: "OutOfEnergy" },
      getTypeScriptAlgebraicType() {
        if (_cached_UpdateStatus_type_value) return _cached_UpdateStatus_type_value;
        _cached_UpdateStatus_type_value = AlgebraicType.Sum({
          variants: []
        });
        _cached_UpdateStatus_type_value.value.variants.push(
          {
            name: "Committed",
            algebraicType: DatabaseUpdate.getTypeScriptAlgebraicType()
          },
          { name: "Failed", algebraicType: AlgebraicType.String },
          {
            name: "OutOfEnergy",
            algebraicType: AlgebraicType.Product({ elements: [] })
          }
        );
        return _cached_UpdateStatus_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          UpdateStatus.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          UpdateStatus.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_ReducerCallInfo_type_value = null;
    ReducerCallInfo = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_ReducerCallInfo_type_value)
          return _cached_ReducerCallInfo_type_value;
        _cached_ReducerCallInfo_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_ReducerCallInfo_type_value.value.elements.push(
          { name: "reducerName", algebraicType: AlgebraicType.String },
          { name: "reducerId", algebraicType: AlgebraicType.U32 },
          {
            name: "args",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          },
          { name: "requestId", algebraicType: AlgebraicType.U32 }
        );
        return _cached_ReducerCallInfo_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          ReducerCallInfo.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          ReducerCallInfo.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_EnergyQuanta_type_value = null;
    EnergyQuanta = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_EnergyQuanta_type_value) return _cached_EnergyQuanta_type_value;
        _cached_EnergyQuanta_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_EnergyQuanta_type_value.value.elements.push({
          name: "quanta",
          algebraicType: AlgebraicType.U128
        });
        return _cached_EnergyQuanta_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          EnergyQuanta.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          EnergyQuanta.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_TransactionUpdate_type_value = null;
    TransactionUpdate = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_TransactionUpdate_type_value)
          return _cached_TransactionUpdate_type_value;
        _cached_TransactionUpdate_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_TransactionUpdate_type_value.value.elements.push(
          {
            name: "status",
            algebraicType: UpdateStatus.getTypeScriptAlgebraicType()
          },
          {
            name: "timestamp",
            algebraicType: AlgebraicType.createTimestampType()
          },
          {
            name: "callerIdentity",
            algebraicType: AlgebraicType.createIdentityType()
          },
          {
            name: "callerConnectionId",
            algebraicType: AlgebraicType.createConnectionIdType()
          },
          {
            name: "reducerCall",
            algebraicType: ReducerCallInfo.getTypeScriptAlgebraicType()
          },
          {
            name: "energyQuantaUsed",
            algebraicType: EnergyQuanta.getTypeScriptAlgebraicType()
          },
          {
            name: "totalHostExecutionDuration",
            algebraicType: AlgebraicType.createTimeDurationType()
          }
        );
        return _cached_TransactionUpdate_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          TransactionUpdate.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          TransactionUpdate.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_TransactionUpdateLight_type_value = null;
    TransactionUpdateLight = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_TransactionUpdateLight_type_value)
          return _cached_TransactionUpdateLight_type_value;
        _cached_TransactionUpdateLight_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_TransactionUpdateLight_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          {
            name: "update",
            algebraicType: DatabaseUpdate.getTypeScriptAlgebraicType()
          }
        );
        return _cached_TransactionUpdateLight_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          TransactionUpdateLight.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          TransactionUpdateLight.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_IdentityToken_type_value = null;
    IdentityToken = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_IdentityToken_type_value)
          return _cached_IdentityToken_type_value;
        _cached_IdentityToken_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_IdentityToken_type_value.value.elements.push(
          {
            name: "identity",
            algebraicType: AlgebraicType.createIdentityType()
          },
          { name: "token", algebraicType: AlgebraicType.String },
          {
            name: "connectionId",
            algebraicType: AlgebraicType.createConnectionIdType()
          }
        );
        return _cached_IdentityToken_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          IdentityToken.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          IdentityToken.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_OneOffTable_type_value = null;
    OneOffTable = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_OneOffTable_type_value) return _cached_OneOffTable_type_value;
        _cached_OneOffTable_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_OneOffTable_type_value.value.elements.push(
          { name: "tableName", algebraicType: AlgebraicType.String },
          { name: "rows", algebraicType: BsatnRowList.getTypeScriptAlgebraicType() }
        );
        return _cached_OneOffTable_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          OneOffTable.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          OneOffTable.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_OneOffQueryResponse_type_value = null;
    OneOffQueryResponse = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_OneOffQueryResponse_type_value)
          return _cached_OneOffQueryResponse_type_value;
        _cached_OneOffQueryResponse_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_OneOffQueryResponse_type_value.value.elements.push(
          {
            name: "messageId",
            algebraicType: AlgebraicType.Array(AlgebraicType.U8)
          },
          {
            name: "error",
            algebraicType: AlgebraicType.createOptionType(
              AlgebraicType.String
            )
          },
          {
            name: "tables",
            algebraicType: AlgebraicType.Array(
              OneOffTable.getTypeScriptAlgebraicType()
            )
          },
          {
            name: "totalHostExecutionDuration",
            algebraicType: AlgebraicType.createTimeDurationType()
          }
        );
        return _cached_OneOffQueryResponse_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          OneOffQueryResponse.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          OneOffQueryResponse.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SubscribeRows_type_value = null;
    SubscribeRows = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SubscribeRows_type_value)
          return _cached_SubscribeRows_type_value;
        _cached_SubscribeRows_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SubscribeRows_type_value.value.elements.push(
          { name: "tableId", algebraicType: AlgebraicType.U32 },
          { name: "tableName", algebraicType: AlgebraicType.String },
          {
            name: "tableRows",
            algebraicType: TableUpdate.getTypeScriptAlgebraicType()
          }
        );
        return _cached_SubscribeRows_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SubscribeRows.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SubscribeRows.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SubscribeApplied_type_value = null;
    SubscribeApplied = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SubscribeApplied_type_value)
          return _cached_SubscribeApplied_type_value;
        _cached_SubscribeApplied_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SubscribeApplied_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          {
            name: "totalHostExecutionDurationMicros",
            algebraicType: AlgebraicType.U64
          },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() },
          {
            name: "rows",
            algebraicType: SubscribeRows.getTypeScriptAlgebraicType()
          }
        );
        return _cached_SubscribeApplied_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SubscribeApplied.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SubscribeApplied.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_UnsubscribeApplied_type_value = null;
    UnsubscribeApplied = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_UnsubscribeApplied_type_value)
          return _cached_UnsubscribeApplied_type_value;
        _cached_UnsubscribeApplied_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_UnsubscribeApplied_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          {
            name: "totalHostExecutionDurationMicros",
            algebraicType: AlgebraicType.U64
          },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() },
          {
            name: "rows",
            algebraicType: SubscribeRows.getTypeScriptAlgebraicType()
          }
        );
        return _cached_UnsubscribeApplied_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          UnsubscribeApplied.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          UnsubscribeApplied.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SubscriptionError_type_value = null;
    SubscriptionError = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SubscriptionError_type_value)
          return _cached_SubscriptionError_type_value;
        _cached_SubscriptionError_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SubscriptionError_type_value.value.elements.push(
          {
            name: "totalHostExecutionDurationMicros",
            algebraicType: AlgebraicType.U64
          },
          {
            name: "requestId",
            algebraicType: AlgebraicType.createOptionType(
              AlgebraicType.U32
            )
          },
          {
            name: "queryId",
            algebraicType: AlgebraicType.createOptionType(
              AlgebraicType.U32
            )
          },
          {
            name: "tableId",
            algebraicType: AlgebraicType.createOptionType(
              AlgebraicType.U32
            )
          },
          { name: "error", algebraicType: AlgebraicType.String }
        );
        return _cached_SubscriptionError_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SubscriptionError.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SubscriptionError.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_SubscribeMultiApplied_type_value = null;
    SubscribeMultiApplied = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_SubscribeMultiApplied_type_value)
          return _cached_SubscribeMultiApplied_type_value;
        _cached_SubscribeMultiApplied_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_SubscribeMultiApplied_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          {
            name: "totalHostExecutionDurationMicros",
            algebraicType: AlgebraicType.U64
          },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() },
          {
            name: "update",
            algebraicType: DatabaseUpdate.getTypeScriptAlgebraicType()
          }
        );
        return _cached_SubscribeMultiApplied_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          SubscribeMultiApplied.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          SubscribeMultiApplied.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_UnsubscribeMultiApplied_type_value = null;
    UnsubscribeMultiApplied = {
      /**
       * A function which returns this type represented as an AlgebraicType.
       * This function is derived from the AlgebraicType used to generate this type.
       */
      getTypeScriptAlgebraicType() {
        if (_cached_UnsubscribeMultiApplied_type_value)
          return _cached_UnsubscribeMultiApplied_type_value;
        _cached_UnsubscribeMultiApplied_type_value = AlgebraicType.Product({
          elements: []
        });
        _cached_UnsubscribeMultiApplied_type_value.value.elements.push(
          { name: "requestId", algebraicType: AlgebraicType.U32 },
          {
            name: "totalHostExecutionDurationMicros",
            algebraicType: AlgebraicType.U64
          },
          { name: "queryId", algebraicType: QueryId.getTypeScriptAlgebraicType() },
          {
            name: "update",
            algebraicType: DatabaseUpdate.getTypeScriptAlgebraicType()
          }
        );
        return _cached_UnsubscribeMultiApplied_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          UnsubscribeMultiApplied.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          UnsubscribeMultiApplied.getTypeScriptAlgebraicType()
        );
      }
    };
    _cached_ServerMessage_type_value = null;
    ServerMessage = {
      // Helper functions for constructing each variant of the tagged union.
      // ```
      // const foo = Foo.A(42);
      // assert!(foo.tag === "A");
      // assert!(foo.value === 42);
      // ```
      InitialSubscription: /* @__PURE__ */ __name((value) => ({
        tag: "InitialSubscription",
        value
      }), "InitialSubscription"),
      TransactionUpdate: /* @__PURE__ */ __name((value) => ({
        tag: "TransactionUpdate",
        value
      }), "TransactionUpdate"),
      TransactionUpdateLight: /* @__PURE__ */ __name((value) => ({
        tag: "TransactionUpdateLight",
        value
      }), "TransactionUpdateLight"),
      IdentityToken: /* @__PURE__ */ __name((value) => ({ tag: "IdentityToken", value }), "IdentityToken"),
      OneOffQueryResponse: /* @__PURE__ */ __name((value) => ({
        tag: "OneOffQueryResponse",
        value
      }), "OneOffQueryResponse"),
      SubscribeApplied: /* @__PURE__ */ __name((value) => ({
        tag: "SubscribeApplied",
        value
      }), "SubscribeApplied"),
      UnsubscribeApplied: /* @__PURE__ */ __name((value) => ({
        tag: "UnsubscribeApplied",
        value
      }), "UnsubscribeApplied"),
      SubscriptionError: /* @__PURE__ */ __name((value) => ({
        tag: "SubscriptionError",
        value
      }), "SubscriptionError"),
      SubscribeMultiApplied: /* @__PURE__ */ __name((value) => ({
        tag: "SubscribeMultiApplied",
        value
      }), "SubscribeMultiApplied"),
      UnsubscribeMultiApplied: /* @__PURE__ */ __name((value) => ({
        tag: "UnsubscribeMultiApplied",
        value
      }), "UnsubscribeMultiApplied"),
      getTypeScriptAlgebraicType() {
        if (_cached_ServerMessage_type_value)
          return _cached_ServerMessage_type_value;
        _cached_ServerMessage_type_value = AlgebraicType.Sum({
          variants: []
        });
        _cached_ServerMessage_type_value.value.variants.push(
          {
            name: "InitialSubscription",
            algebraicType: InitialSubscription.getTypeScriptAlgebraicType()
          },
          {
            name: "TransactionUpdate",
            algebraicType: TransactionUpdate.getTypeScriptAlgebraicType()
          },
          {
            name: "TransactionUpdateLight",
            algebraicType: TransactionUpdateLight.getTypeScriptAlgebraicType()
          },
          {
            name: "IdentityToken",
            algebraicType: IdentityToken.getTypeScriptAlgebraicType()
          },
          {
            name: "OneOffQueryResponse",
            algebraicType: OneOffQueryResponse.getTypeScriptAlgebraicType()
          },
          {
            name: "SubscribeApplied",
            algebraicType: SubscribeApplied.getTypeScriptAlgebraicType()
          },
          {
            name: "UnsubscribeApplied",
            algebraicType: UnsubscribeApplied.getTypeScriptAlgebraicType()
          },
          {
            name: "SubscriptionError",
            algebraicType: SubscriptionError.getTypeScriptAlgebraicType()
          },
          {
            name: "SubscribeMultiApplied",
            algebraicType: SubscribeMultiApplied.getTypeScriptAlgebraicType()
          },
          {
            name: "UnsubscribeMultiApplied",
            algebraicType: UnsubscribeMultiApplied.getTypeScriptAlgebraicType()
          }
        );
        return _cached_ServerMessage_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(
          writer,
          ServerMessage.getTypeScriptAlgebraicType(),
          value
        );
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(
          reader,
          ServerMessage.getTypeScriptAlgebraicType()
        );
      }
    };
    EventEmitter2 = class {
      static {
        __name(this, "EventEmitter");
      }
      #events = /* @__PURE__ */ new Map();
      on(event, callback) {
        let callbacks = this.#events.get(event);
        if (!callbacks) {
          callbacks = /* @__PURE__ */ new Set();
          this.#events.set(event, callbacks);
        }
        callbacks.add(callback);
      }
      off(event, callback) {
        const callbacks = this.#events.get(event);
        if (!callbacks) {
          return;
        }
        callbacks.delete(callback);
      }
      emit(event, ...args) {
        const callbacks = this.#events.get(event);
        if (!callbacks) {
          return;
        }
        for (const callback of callbacks) {
          callback(...args);
        }
      }
    };
    LogLevelIdentifierIcon = {
      component: "\u{1F4E6}",
      info: "\u2139\uFE0F",
      warn: "\u26A0\uFE0F",
      error: "\u274C",
      debug: "\u{1F41B}"
    };
    LogStyle = {
      component: "color: #fff; background-color: #8D6FDD; padding: 2px 5px; border-radius: 3px;",
      info: "color: #fff; background-color: #007bff; padding: 2px 5px; border-radius: 3px;",
      warn: "color: #fff; background-color: #ffc107; padding: 2px 5px; border-radius: 3px;",
      error: "color: #fff; background-color: #dc3545; padding: 2px 5px; border-radius: 3px;",
      debug: "color: #fff; background-color: #28a745; padding: 2px 5px; border-radius: 3px;"
    };
    LogTextStyle = {
      component: "color: #8D6FDD;",
      info: "color: #007bff;",
      warn: "color: #ffc107;",
      error: "color: #dc3545;",
      debug: "color: #28a745;"
    };
    stdbLogger = /* @__PURE__ */ __name((level, message) => {
      console.log(
        `%c${LogLevelIdentifierIcon[level]} ${level.toUpperCase()}%c ${message}`,
        LogStyle[level],
        LogTextStyle[level]
      );
    }, "stdbLogger");
    TableCache = class {
      static {
        __name(this, "TableCache");
      }
      rows;
      tableTypeInfo;
      emitter;
      /**
       * @param name the table name
       * @param primaryKeyCol column index designated as `#[primarykey]`
       * @param primaryKey column name designated as `#[primarykey]`
       * @param entityClass the entityClass
       */
      constructor(tableTypeInfo) {
        this.tableTypeInfo = tableTypeInfo;
        this.rows = /* @__PURE__ */ new Map();
        this.emitter = new EventEmitter2();
      }
      /**
       * @returns number of rows in the table
       */
      count() {
        return this.rows.size;
      }
      /**
       * @returns The values of the rows in the table
       */
      iter() {
        return Array.from(this.rows.values()).map(([row]) => row);
      }
      applyOperations = /* @__PURE__ */ __name((operations2, ctx) => {
        const pendingCallbacks = [];
        if (this.tableTypeInfo.primaryKeyInfo !== void 0) {
          const insertMap = /* @__PURE__ */ new Map();
          const deleteMap = /* @__PURE__ */ new Map();
          for (const op of operations2) {
            if (op.type === "insert") {
              const [_2, prevCount] = insertMap.get(op.rowId) || [op, 0];
              insertMap.set(op.rowId, [op, prevCount + 1]);
            } else {
              const [_2, prevCount] = deleteMap.get(op.rowId) || [op, 0];
              deleteMap.set(op.rowId, [op, prevCount + 1]);
            }
          }
          for (const [primaryKey, [insertOp, refCount]] of insertMap) {
            const deleteEntry = deleteMap.get(primaryKey);
            if (deleteEntry) {
              const [_2, deleteCount] = deleteEntry;
              const refCountDelta = refCount - deleteCount;
              const maybeCb = this.update(
                ctx,
                primaryKey,
                insertOp.row,
                refCountDelta
              );
              if (maybeCb) {
                pendingCallbacks.push(maybeCb);
              }
              deleteMap.delete(primaryKey);
            } else {
              const maybeCb = this.insert(ctx, insertOp, refCount);
              if (maybeCb) {
                pendingCallbacks.push(maybeCb);
              }
            }
          }
          for (const [deleteOp, refCount] of deleteMap.values()) {
            const maybeCb = this.delete(ctx, deleteOp, refCount);
            if (maybeCb) {
              pendingCallbacks.push(maybeCb);
            }
          }
        } else {
          for (const op of operations2) {
            if (op.type === "insert") {
              const maybeCb = this.insert(ctx, op);
              if (maybeCb) {
                pendingCallbacks.push(maybeCb);
              }
            } else {
              const maybeCb = this.delete(ctx, op);
              if (maybeCb) {
                pendingCallbacks.push(maybeCb);
              }
            }
          }
        }
        return pendingCallbacks;
      }, "applyOperations");
      update = /* @__PURE__ */ __name((ctx, rowId, newRow, refCountDelta = 0) => {
        const existingEntry = this.rows.get(rowId);
        if (!existingEntry) {
          stdbLogger(
            "error",
            `Updating a row that was not present in the cache. Table: ${this.tableTypeInfo.tableName}, RowId: ${rowId}`
          );
          return void 0;
        }
        const [oldRow, previousCount] = existingEntry;
        const refCount = Math.max(1, previousCount + refCountDelta);
        if (previousCount + refCountDelta <= 0) {
          stdbLogger(
            "error",
            `Negative reference count for in table ${this.tableTypeInfo.tableName} row ${rowId} (${previousCount} + ${refCountDelta})`
          );
          return void 0;
        }
        this.rows.set(rowId, [newRow, refCount]);
        if (previousCount === 0) {
          stdbLogger(
            "error",
            `Updating a row id in table ${this.tableTypeInfo.tableName} which was not present in the cache (rowId: ${rowId})`
          );
          return {
            type: "insert",
            table: this.tableTypeInfo.tableName,
            cb: /* @__PURE__ */ __name(() => {
              this.emitter.emit("insert", ctx, newRow);
            }, "cb")
          };
        }
        return {
          type: "update",
          table: this.tableTypeInfo.tableName,
          cb: /* @__PURE__ */ __name(() => {
            this.emitter.emit("update", ctx, oldRow, newRow);
          }, "cb")
        };
      }, "update");
      insert = /* @__PURE__ */ __name((ctx, operation, count3 = 1) => {
        const [_2, previousCount] = this.rows.get(operation.rowId) || [
          operation.row,
          0
        ];
        this.rows.set(operation.rowId, [operation.row, previousCount + count3]);
        if (previousCount === 0) {
          return {
            type: "insert",
            table: this.tableTypeInfo.tableName,
            cb: /* @__PURE__ */ __name(() => {
              this.emitter.emit("insert", ctx, operation.row);
            }, "cb")
          };
        }
        return void 0;
      }, "insert");
      delete = /* @__PURE__ */ __name((ctx, operation, count3 = 1) => {
        const [_2, previousCount] = this.rows.get(operation.rowId) || [
          operation.row,
          0
        ];
        if (previousCount === 0) {
          stdbLogger("warn", "Deleting a row that was not present in the cache");
          return void 0;
        }
        if (previousCount <= count3) {
          this.rows.delete(operation.rowId);
          return {
            type: "delete",
            table: this.tableTypeInfo.tableName,
            cb: /* @__PURE__ */ __name(() => {
              this.emitter.emit("delete", ctx, operation.row);
            }, "cb")
          };
        }
        this.rows.set(operation.rowId, [operation.row, previousCount - count3]);
        return void 0;
      }, "delete");
      /**
       * Register a callback for when a row is newly inserted into the database.
       *
       * ```ts
       * User.onInsert((user, reducerEvent) => {
       *   if (reducerEvent) {
       *      console.log("New user on reducer", reducerEvent, user);
       *   } else {
       *      console.log("New user received during subscription update on insert", user);
       *  }
       * });
       * ```
       *
       * @param cb Callback to be called when a new row is inserted
       */
      onInsert = /* @__PURE__ */ __name((cb) => {
        this.emitter.on("insert", cb);
      }, "onInsert");
      /**
       * Register a callback for when a row is deleted from the database.
       *
       * ```ts
       * User.onDelete((user, reducerEvent) => {
       *   if (reducerEvent) {
       *      console.log("Deleted user on reducer", reducerEvent, user);
       *   } else {
       *      console.log("Deleted user received during subscription update on update", user);
       *  }
       * });
       * ```
       *
       * @param cb Callback to be called when a new row is inserted
       */
      onDelete = /* @__PURE__ */ __name((cb) => {
        this.emitter.on("delete", cb);
      }, "onDelete");
      /**
       * Register a callback for when a row is updated into the database.
       *
       * ```ts
       * User.onInsert((user, reducerEvent) => {
       *   if (reducerEvent) {
       *      console.log("Updated user on reducer", reducerEvent, user);
       *   } else {
       *      console.log("Updated user received during subscription update on delete", user);
       *  }
       * });
       * ```
       *
       * @param cb Callback to be called when a new row is inserted
       */
      onUpdate = /* @__PURE__ */ __name((cb) => {
        this.emitter.on("update", cb);
      }, "onUpdate");
      /**
       * Remove a callback for when a row is newly inserted into the database.
       *
       * @param cb Callback to be removed
       */
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        this.emitter.off("insert", cb);
      }, "removeOnInsert");
      /**
       * Remove a callback for when a row is deleted from the database.
       *
       * @param cb Callback to be removed
       */
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        this.emitter.off("delete", cb);
      }, "removeOnDelete");
      /**
       * Remove a callback for when a row is updated into the database.
       *
       * @param cb Callback to be removed
       */
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        this.emitter.off("update", cb);
      }, "removeOnUpdate");
    };
    ClientCache = class {
      static {
        __name(this, "ClientCache");
      }
      /**
       * The tables in the database.
       */
      tables;
      constructor() {
        this.tables = /* @__PURE__ */ new Map();
      }
      /**
       * Returns the table with the given name.
       * @param name The name of the table.
       * @returns The table
       */
      getTable(name) {
        const table3 = this.tables.get(name);
        if (!table3) {
          console.error(
            "The table has not been registered for this client. Please register the table before using it. If you have registered global tables using the SpacetimeDBClient.registerTables() or `registerTable()` method, please make sure that is executed first!"
          );
          throw new Error(`Table ${name} does not exist`);
        }
        return table3;
      }
      getOrCreateTable(tableTypeInfo) {
        let table3;
        if (!this.tables.has(tableTypeInfo.tableName)) {
          table3 = new TableCache(tableTypeInfo);
          this.tables.set(tableTypeInfo.tableName, table3);
        } else {
          table3 = this.tables.get(tableTypeInfo.tableName);
        }
        return table3;
      }
    };
    __name(comparePreReleases, "comparePreReleases");
    SemanticVersion = class _SemanticVersion {
      static {
        __name(this, "_SemanticVersion");
      }
      major;
      minor;
      patch;
      preRelease;
      buildInfo;
      constructor(major, minor, patch, preRelease = null, buildInfo = null) {
        this.major = major;
        this.minor = minor;
        this.patch = patch;
        this.preRelease = preRelease;
        this.buildInfo = buildInfo;
      }
      toString() {
        let versionString = `${this.major}.${this.minor}.${this.patch}`;
        if (this.preRelease) {
          versionString += `-${this.preRelease.join(".")}`;
        }
        if (this.buildInfo) {
          versionString += `+${this.buildInfo}`;
        }
        return versionString;
      }
      compare(other) {
        if (this.major !== other.major) {
          return this.major - other.major;
        }
        if (this.minor !== other.minor) {
          return this.minor - other.minor;
        }
        if (this.patch !== other.patch) {
          return this.patch - other.patch;
        }
        if (this.preRelease && other.preRelease) {
          return comparePreReleases(this.preRelease, other.preRelease);
        }
        if (this.preRelease) {
          return -1;
        }
        if (other.preRelease) {
          return -1;
        }
        return 0;
      }
      clone() {
        return new _SemanticVersion(
          this.major,
          this.minor,
          this.patch,
          this.preRelease ? [...this.preRelease] : null,
          this.buildInfo
        );
      }
      static parseVersionString(version2) {
        const regex = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-([\da-zA-Z-]+(?:\.[\da-zA-Z-]+)*))?(?:\+([\da-zA-Z-]+(?:\.[\da-zA-Z-]+)*))?$/;
        const match = version2.match(regex);
        if (!match) {
          throw new Error(`Invalid version string: ${version2}`);
        }
        const major = parseInt(match[1], 10);
        const minor = parseInt(match[2], 10);
        const patch = parseInt(match[3], 10);
        const preRelease = match[4] ? match[4].split(".").map((id) => isNaN(Number(id)) ? id : Number(id)) : null;
        const buildInfo = match[5] || null;
        return new _SemanticVersion(major, minor, patch, preRelease, buildInfo);
      }
    };
    _MINIMUM_CLI_VERSION = new SemanticVersion(
      1,
      4,
      0
    );
    __name(ensureMinimumVersionOrThrow, "ensureMinimumVersionOrThrow");
    __name(versionErrorMessage, "versionErrorMessage");
    __name(decompress, "decompress");
    __name(resolveWS, "resolveWS");
    WebsocketDecompressAdapter = class _WebsocketDecompressAdapter {
      static {
        __name(this, "_WebsocketDecompressAdapter");
      }
      onclose;
      onopen;
      onmessage;
      onerror;
      #ws;
      async #handleOnMessage(msg) {
        const buffer = new Uint8Array(msg.data);
        let decompressed;
        if (buffer[0] === 0) {
          decompressed = buffer.slice(1);
        } else if (buffer[0] === 1) {
          throw new Error(
            "Brotli Compression not supported. Please use gzip or none compression in withCompression method on DbConnection."
          );
        } else if (buffer[0] === 2) {
          decompressed = await decompress(buffer.slice(1), "gzip");
        } else {
          throw new Error(
            "Unexpected Compression Algorithm. Please use `gzip` or `none`"
          );
        }
        this.onmessage?.({ data: decompressed });
      }
      #handleOnOpen(msg) {
        this.onopen?.(msg);
      }
      #handleOnError(msg) {
        this.onerror?.(msg);
      }
      #handleOnClose(msg) {
        this.onclose?.(msg);
      }
      send(msg) {
        this.#ws.send(msg);
      }
      close() {
        this.#ws.close();
      }
      constructor(ws) {
        this.onmessage = void 0;
        this.onopen = void 0;
        this.onmessage = void 0;
        this.onerror = void 0;
        ws.onmessage = this.#handleOnMessage.bind(this);
        ws.onerror = this.#handleOnError.bind(this);
        ws.onclose = this.#handleOnClose.bind(this);
        ws.onopen = this.#handleOnOpen.bind(this);
        ws.binaryType = "arraybuffer";
        this.#ws = ws;
      }
      static async createWebSocketFn({
        url,
        nameOrAddress,
        wsProtocol,
        authToken,
        compression,
        lightMode,
        confirmedReads
      }) {
        const headers2 = new Headers();
        const WS = await resolveWS();
        let temporaryAuthToken = void 0;
        if (authToken) {
          headers2.set("Authorization", `Bearer ${authToken}`);
          const tokenUrl = new URL("v1/identity/websocket-token", url);
          tokenUrl.protocol = url.protocol === "wss:" ? "https:" : "http:";
          const response = await fetch(tokenUrl, { method: "POST", headers: headers2 });
          if (response.ok) {
            const { token } = await response.json();
            temporaryAuthToken = token;
          } else {
            return Promise.reject(
              new Error(`Failed to verify token: ${response.statusText}`)
            );
          }
        }
        const databaseUrl = new URL(`v1/database/${nameOrAddress}/subscribe`, url);
        if (temporaryAuthToken) {
          databaseUrl.searchParams.set("token", temporaryAuthToken);
        }
        databaseUrl.searchParams.set(
          "compression",
          compression === "gzip" ? "Gzip" : "None"
        );
        if (lightMode) {
          databaseUrl.searchParams.set("light", "true");
        }
        if (confirmedReads !== void 0) {
          databaseUrl.searchParams.set("confirmed", confirmedReads.toString());
        }
        const ws = new WS(databaseUrl.toString(), wsProtocol);
        return new _WebsocketDecompressAdapter(ws);
      }
    };
    DbConnectionBuilder = class {
      static {
        __name(this, "DbConnectionBuilder");
      }
      /**
       * Creates a new `DbConnectionBuilder` database client and set the initial parameters.
       *
       * Users are not expected to call this constructor directly. Instead, use the static method `DbConnection.builder()`.
       *
       * @param remoteModule The remote module to use to connect to the SpacetimeDB server.
       * @param dbConnectionConstructor The constructor to use to create a new `DbConnection`.
       */
      constructor(remoteModule, dbConnectionConstructor) {
        this.remoteModule = remoteModule;
        this.dbConnectionConstructor = dbConnectionConstructor;
        this.#createWSFn = WebsocketDecompressAdapter.createWebSocketFn;
      }
      #uri;
      #nameOrAddress;
      #identity;
      #token;
      #emitter = new EventEmitter2();
      #compression = "gzip";
      #lightMode = false;
      #confirmedReads;
      #createWSFn;
      /**
       * Set the URI of the SpacetimeDB server to connect to.
       *
       * @param uri The URI of the SpacetimeDB server to connect to.
       *
       **/
      withUri(uri) {
        this.#uri = new URL(uri);
        return this;
      }
      /**
       * Set the name or Identity of the database module to connect to.
       *
       * @param nameOrAddress
       *
       * @returns The `DbConnectionBuilder` instance.
       */
      withModuleName(nameOrAddress) {
        this.#nameOrAddress = nameOrAddress;
        return this;
      }
      /**
       * Set the identity of the client to connect to the database.
       *
       * @param token The credentials to use to authenticate with SpacetimeDB. This
       * is optional. You can store the token returned by the `onConnect` callback
       * to use in future connections.
       *
       * @returns The `DbConnectionBuilder` instance.
       */
      withToken(token) {
        this.#token = token;
        return this;
      }
      withWSFn(createWSFn) {
        this.#createWSFn = createWSFn;
        return this;
      }
      /**
       * Set the compression algorithm to use for the connection.
       *
       * @param compression The compression algorithm to use for the connection.
       */
      withCompression(compression) {
        this.#compression = compression;
        return this;
      }
      /**
       * Sets the connection to operate in light mode.
       *
       * Light mode is a mode that reduces the amount of data sent over the network.
       *
       * @param lightMode The light mode for the connection.
       */
      withLightMode(lightMode) {
        this.#lightMode = lightMode;
        return this;
      }
      /**
       * Sets the connection to use confirmed reads.
       *
       * When enabled, the server will send query results only after they are
       * confirmed to be durable.
       *
       * What durable means depends on the server configuration: a single node
       * server may consider a transaction durable once it is `fsync`'ed to disk,
       * whereas a cluster may require that some number of replicas have
       * acknowledge that they have stored the transactions.
       *
       * Note that enabling confirmed reads will increase the latency between a
       * reducer call and the corresponding subscription update arriving at the
       * client.
       *
       * If this method is not called, not preference is sent to the server, and
       * the server will choose the default.
       *
       * @param confirmedReads `true` to enable confirmed reads, `false` to disable.
       */
      withConfirmedReads(confirmedReads) {
        this.#confirmedReads = confirmedReads;
        return this;
      }
      /**
       * Register a callback to be invoked upon authentication with the database.
       *
       * @param identity A unique identifier for a client connected to a database.
       * @param token The credentials to use to authenticate with SpacetimeDB.
       *
       * @returns The `DbConnectionBuilder` instance.
       *
       * The callback will be invoked with the `Identity` and private authentication `token` provided by the database to identify this connection.
       *
       * If credentials were supplied to connect, those passed to the callback will be equivalent to the ones used to connect.
       *
       * If the initial connection was anonymous, a new set of credentials will be generated by the database to identify this user.
       *
       * The credentials passed to the callback can be saved and used to authenticate the same user in future connections.
       *
       * @example
       *
       * ```ts
       * DbConnection.builder().onConnect((ctx, identity, token) => {
       *  console.log("Connected to SpacetimeDB with identity:", identity.toHexString());
       * });
       * ```
       */
      onConnect(callback) {
        this.#emitter.on("connect", callback);
        return this;
      }
      /**
       * Register a callback to be invoked upon an error.
       *
       * @example
       *
       * ```ts
       * DbConnection.builder().onConnectError((ctx, error) => {
       *   console.log("Error connecting to SpacetimeDB:", error);
       * });
       * ```
       */
      onConnectError(callback) {
        this.#emitter.on("connectError", callback);
        return this;
      }
      /**
       * Registers a callback to run when a {@link DbConnection} whose connection initially succeeded
       * is disconnected, either after a {@link DbConnection.disconnect} call or due to an error.
       *
       * If the connection ended because of an error, the error is passed to the callback.
       *
       * The `callback` will be installed on the `DbConnection` created by `build`
       * before initiating the connection, ensuring there's no opportunity for the disconnect to happen
       * before the callback is installed.
       *
       * Note that this does not trigger if `build` fails
       * or in cases where {@link DbConnectionBuilder.onConnectError} would trigger.
       * This callback only triggers if the connection closes after `build` returns successfully
       * and {@link DbConnectionBuilder.onConnect} is invoked, i.e., after the `IdentityToken` is received.
       *
       * To simplify SDK implementation, at most one such callback can be registered.
       * Calling `onDisconnect` on the same `DbConnectionBuilder` multiple times throws an error.
       *
       * Unlike callbacks registered via {@link DbConnection},
       * no mechanism is provided to unregister the provided callback.
       * This is a concession to ergonomics; there's no clean place to return a `CallbackId` from this method
       * or from `build`.
       *
       * @param {function(error?: Error): void} callback - The callback to invoke upon disconnection.
       * @throws {Error} Throws an error if called multiple times on the same `DbConnectionBuilder`.
       */
      onDisconnect(callback) {
        this.#emitter.on("disconnect", callback);
        return this;
      }
      /**
       * Builds a new `DbConnection` with the parameters set on this `DbConnectionBuilder` and attempts to connect to the SpacetimeDB server.
       *
       * @returns A new `DbConnection` with the parameters set on this `DbConnectionBuilder`.
       *
       * @example
       *
       * ```ts
       * const host = "http://localhost:3000";
       * const name_or_address = "database_name"
       * const auth_token = undefined;
       * DbConnection.builder().withUri(host).withModuleName(name_or_address).withToken(auth_token).build();
       * ```
       */
      build() {
        if (!this.#uri) {
          throw new Error("URI is required to connect to SpacetimeDB");
        }
        if (!this.#nameOrAddress) {
          throw new Error(
            "Database name or address is required to connect to SpacetimeDB"
          );
        }
        ensureMinimumVersionOrThrow(this.remoteModule.versionInfo?.cliVersion);
        return this.dbConnectionConstructor(
          new DbConnectionImpl({
            uri: this.#uri,
            nameOrAddress: this.#nameOrAddress,
            identity: this.#identity,
            token: this.#token,
            emitter: this.#emitter,
            compression: this.#compression,
            lightMode: this.#lightMode,
            confirmedReads: this.#confirmedReads,
            createWSFn: this.#createWSFn,
            remoteModule: this.remoteModule
          })
        );
      }
    };
    SubscriptionBuilderImpl = class {
      static {
        __name(this, "SubscriptionBuilderImpl");
      }
      constructor(db) {
        this.db = db;
      }
      #onApplied = void 0;
      #onError = void 0;
      /**
       * Registers `callback` to run when this query is successfully added to our subscribed set,
       * I.e. when its `SubscriptionApplied` message is received.
       *
       * The database state exposed via the `&EventContext` argument
       * includes all the rows added to the client cache as a result of the new subscription.
       *
       * The event in the `&EventContext` argument is `Event::SubscribeApplied`.
       *
       * Multiple `on_applied` callbacks for the same query may coexist.
       * No mechanism for un-registering `on_applied` callbacks is exposed.
       *
       * @param cb - Callback to run when the subscription is applied.
       * @returns The current `SubscriptionBuilder` instance.
       */
      onApplied(cb) {
        this.#onApplied = cb;
        return this;
      }
      /**
       * Registers `callback` to run when this query either:
       * - Fails to be added to our subscribed set.
       * - Is unexpectedly removed from our subscribed set.
       *
       * If the subscription had previously started and has been unexpectedly removed,
       * the database state exposed via the `&EventContext` argument contains no rows
       * from any subscriptions removed within the same error event.
       * As proposed, it must therefore contain no rows.
       *
       * The event in the `&EventContext` argument is `Event::SubscribeError`,
       * containing a dynamic error object with a human-readable description of the error
       * for diagnostic purposes.
       *
       * Multiple `on_error` callbacks for the same query may coexist.
       * No mechanism for un-registering `on_error` callbacks is exposed.
       *
       * @param cb - Callback to run when there is an error in subscription.
       * @returns The current `SubscriptionBuilder` instance.
       */
      onError(cb) {
        this.#onError = cb;
        return this;
      }
      /**
       * Subscribe to a single query. The results of the query will be merged into the client
       * cache and deduplicated on the client.
       *
       * @param query_sql A `SQL` query to subscribe to.
       *
       * @example
       *
       * ```ts
       * const subscription = connection.subscriptionBuilder().onApplied(() => {
       *   console.log("SDK client cache initialized.");
       * }).subscribe("SELECT * FROM User");
       *
       * subscription.unsubscribe();
       * ```
       */
      subscribe(query_sql) {
        const queries = Array.isArray(query_sql) ? query_sql : [query_sql];
        if (queries.length === 0) {
          throw new Error("Subscriptions must have at least one query");
        }
        return new SubscriptionHandleImpl(
          this.db,
          queries,
          this.#onApplied,
          this.#onError
        );
      }
      /**
       * Subscribes to all rows from all tables.
       *
       * This method is intended as a convenience
       * for applications where client-side memory use and network bandwidth are not concerns.
       * Applications where these resources are a constraint
       * should register more precise queries via `subscribe`
       * in order to replicate only the subset of data which the client needs to function.
       *
       * This method should not be combined with `subscribe` on the same `DbConnection`.
       * A connection may either `subscribe` to particular queries,
       * or `subscribeToAllTables`, but not both.
       * Attempting to call `subscribe`
       * on a `DbConnection` that has previously used `subscribeToAllTables`,
       * or vice versa, may misbehave in any number of ways,
       * including dropping subscriptions, corrupting the client cache, or throwing errors.
       */
      subscribeToAllTables() {
        this.subscribe("SELECT * FROM *");
      }
    };
    SubscriptionManager = class {
      static {
        __name(this, "SubscriptionManager");
      }
      subscriptions = /* @__PURE__ */ new Map();
    };
    SubscriptionHandleImpl = class {
      static {
        __name(this, "SubscriptionHandleImpl");
      }
      constructor(db, querySql, onApplied, onError) {
        this.db = db;
        this.#emitter.on(
          "applied",
          (ctx) => {
            this.#activeState = true;
            if (onApplied) {
              onApplied(ctx);
            }
          }
        );
        this.#emitter.on(
          "error",
          (ctx, error4) => {
            this.#activeState = false;
            this.#endedState = true;
            if (onError) {
              onError(ctx, error4);
            }
          }
        );
        this.#queryId = this.db.registerSubscription(this, this.#emitter, querySql);
      }
      #queryId;
      #unsubscribeCalled = false;
      #endedState = false;
      #activeState = false;
      #emitter = new EventEmitter2();
      /**
       * Consumes self and issues an `Unsubscribe` message,
       * removing this query from the client's set of subscribed queries.
       * It is only valid to call this method if `is_active()` is `true`.
       */
      unsubscribe() {
        if (this.#unsubscribeCalled) {
          throw new Error("Unsubscribe has already been called");
        }
        this.#unsubscribeCalled = true;
        this.db.unregisterSubscription(this.#queryId);
        this.#emitter.on(
          "end",
          (_ctx) => {
            this.#endedState = true;
            this.#activeState = false;
          }
        );
      }
      /**
       * Unsubscribes and also registers a callback to run upon success.
       * I.e. when an `UnsubscribeApplied` message is received.
       *
       * If `Unsubscribe` returns an error,
       * or if the `on_error` callback(s) are invoked before this subscription would end normally,
       * the `on_end` callback is not invoked.
       *
       * @param onEnd - Callback to run upon successful unsubscribe.
       */
      unsubscribeThen(onEnd) {
        if (this.#endedState) {
          throw new Error("Subscription has already ended");
        }
        if (this.#unsubscribeCalled) {
          throw new Error("Unsubscribe has already been called");
        }
        this.#unsubscribeCalled = true;
        this.db.unregisterSubscription(this.#queryId);
        this.#emitter.on(
          "end",
          (ctx) => {
            this.#endedState = true;
            this.#activeState = false;
            onEnd(ctx);
          }
        );
      }
      /**
       * True if this `SubscriptionHandle` has ended,
       * either due to an error or a call to `unsubscribe`.
       *
       * This is initially false, and becomes true when either the `on_end` or `on_error` callback is invoked.
       * A subscription which has not yet been applied is not active, but is also not ended.
       */
      isEnded() {
        return this.#endedState;
      }
      /**
       * True if this `SubscriptionHandle` is active, meaning it has been successfully applied
       * and has not since ended, either due to an error or a complete `unsubscribe` request-response pair.
       *
       * This corresponds exactly to the interval bounded at the start by the `on_applied` callback
       * and at the end by either the `on_end` or `on_error` callback.
       */
      isActive() {
        return this.#activeState;
      }
    };
    __name(callReducerFlagsToNumber, "callReducerFlagsToNumber");
    DbConnectionImpl = class {
      static {
        __name(this, "DbConnectionImpl");
      }
      /**
       * Whether or not the connection is active.
       */
      isActive = false;
      /**
       * This connection's public identity.
       */
      identity = void 0;
      /**
       * This connection's private authentication token.
       */
      token = void 0;
      /**
       * The accessor field to access the tables in the database and associated
       * callback functions.
       */
      db;
      /**
       * The accessor field to access the reducers in the database and associated
       * callback functions.
       */
      reducers;
      /**
       * The accessor field to access functions related to setting flags on
       * reducers regarding how the server should handle the reducer call and
       * the events that it sends back to the client.
       */
      setReducerFlags;
      /**
       * The `ConnectionId` of the connection to to the database.
       */
      connectionId = ConnectionId.random();
      // These fields are meant to be strictly private.
      #queryId = 0;
      #emitter;
      #reducerEmitter = new EventEmitter2();
      #onApplied;
      #remoteModule;
      #messageQueue = Promise.resolve();
      #subscriptionManager = new SubscriptionManager();
      // These fields are not part of the public API, but in a pinch you
      // could use JavaScript to access them by bypassing TypeScript's
      // private fields.
      // We use them in testing.
      clientCache;
      ws;
      wsPromise;
      constructor({
        uri,
        nameOrAddress,
        identity,
        token,
        emitter,
        remoteModule,
        createWSFn,
        compression,
        lightMode,
        confirmedReads
      }) {
        stdbLogger("info", "Connecting to SpacetimeDB WS...");
        const url = new URL(uri.toString());
        if (!/^wss?:/.test(uri.protocol)) {
          url.protocol = url.protocol === "https:" ? "wss:" : "ws:";
        }
        this.identity = identity;
        this.token = token;
        this.#remoteModule = remoteModule;
        this.#emitter = emitter;
        const connectionId = this.connectionId.toHexString();
        url.searchParams.set("connection_id", connectionId);
        this.clientCache = new ClientCache();
        this.db = this.#remoteModule.dbViewConstructor(this);
        this.setReducerFlags = this.#remoteModule.setReducerFlagsConstructor();
        this.reducers = this.#remoteModule.reducersConstructor(
          this,
          this.setReducerFlags
        );
        this.wsPromise = createWSFn({
          url,
          nameOrAddress,
          wsProtocol: "v1.bsatn.spacetimedb",
          authToken: token,
          compression,
          lightMode,
          confirmedReads
        }).then((v2) => {
          this.ws = v2;
          this.ws.onclose = () => {
            this.#emitter.emit("disconnect", this);
          };
          this.ws.onerror = (e5) => {
            this.#emitter.emit("connectError", this, e5);
          };
          this.ws.onopen = this.#handleOnOpen.bind(this);
          this.ws.onmessage = this.#handleOnMessage.bind(this);
          return v2;
        }).catch((e5) => {
          stdbLogger("error", "Error connecting to SpacetimeDB WS");
          this.#emitter.emit("connectError", this, e5);
          return void 0;
        });
      }
      #getNextQueryId = /* @__PURE__ */ __name(() => {
        const queryId = this.#queryId;
        this.#queryId += 1;
        return queryId;
      }, "#getNextQueryId");
      // NOTE: This is very important!!! This is the actual function that
      // gets called when you call `connection.subscriptionBuilder()`.
      // The `subscriptionBuilder` function which is generated, just shadows
      // this function in the type system, but not the actual implementation!
      // Do not remove this function, or shoot yourself in the foot please.
      // It's not clear what would be a better way to do this at this exact
      // moment.
      subscriptionBuilder = /* @__PURE__ */ __name(() => {
        return new SubscriptionBuilderImpl(this);
      }, "subscriptionBuilder");
      registerSubscription(handle, handleEmitter, querySql) {
        const queryId = this.#getNextQueryId();
        this.#subscriptionManager.subscriptions.set(queryId, {
          handle,
          emitter: handleEmitter
        });
        this.#sendMessage(
          ClientMessage.SubscribeMulti({
            queryStrings: querySql,
            queryId: { id: queryId },
            // The TypeScript SDK doesn't currently track `request_id`s,
            // so always use 0.
            requestId: 0
          })
        );
        return queryId;
      }
      unregisterSubscription(queryId) {
        this.#sendMessage(
          ClientMessage.UnsubscribeMulti({
            queryId: { id: queryId },
            // The TypeScript SDK doesn't currently track `request_id`s,
            // so always use 0.
            requestId: 0
          })
        );
      }
      // This function is async because we decompress the message async
      async #processParsedMessage(message) {
        const parseRowList = /* @__PURE__ */ __name((type, tableName, rowList) => {
          const buffer = rowList.rowsData;
          const reader = new BinaryReader(buffer);
          const rows = [];
          const rowType = this.#remoteModule.tables[tableName].rowType;
          let previousOffset = 0;
          const primaryKeyInfo = this.#remoteModule.tables[tableName].primaryKeyInfo;
          while (reader.remaining > 0) {
            const row = AlgebraicType.deserializeValue(reader, rowType);
            let rowId = void 0;
            if (primaryKeyInfo !== void 0) {
              rowId = AlgebraicType.intoMapKey(
                primaryKeyInfo.colType,
                row[primaryKeyInfo.colName]
              );
            } else {
              const rowBytes = buffer.subarray(previousOffset, reader.offset);
              const asBase64 = (0, import_base64_js.fromByteArray)(rowBytes);
              rowId = asBase64;
            }
            previousOffset = reader.offset;
            rows.push({
              type,
              rowId,
              row
            });
          }
          return rows;
        }, "parseRowList");
        const parseTableUpdate = /* @__PURE__ */ __name(async (rawTableUpdate) => {
          const tableName = rawTableUpdate.tableName;
          let operations2 = [];
          for (const update of rawTableUpdate.updates) {
            let decompressed;
            if (update.tag === "Gzip") {
              const decompressedBuffer = await decompress(update.value, "gzip");
              decompressed = QueryUpdate.deserialize(
                new BinaryReader(decompressedBuffer)
              );
            } else if (update.tag === "Brotli") {
              throw new Error(
                "Brotli compression not supported. Please use gzip or none compression in withCompression method on DbConnection."
              );
            } else {
              decompressed = update.value;
            }
            operations2 = operations2.concat(
              parseRowList("insert", tableName, decompressed.inserts)
            );
            operations2 = operations2.concat(
              parseRowList("delete", tableName, decompressed.deletes)
            );
          }
          return {
            tableName,
            operations: operations2
          };
        }, "parseTableUpdate");
        const parseDatabaseUpdate = /* @__PURE__ */ __name(async (dbUpdate) => {
          const tableUpdates = [];
          for (const rawTableUpdate of dbUpdate.tables) {
            tableUpdates.push(await parseTableUpdate(rawTableUpdate));
          }
          return tableUpdates;
        }, "parseDatabaseUpdate");
        switch (message.tag) {
          case "InitialSubscription": {
            const dbUpdate = message.value.databaseUpdate;
            const tableUpdates = await parseDatabaseUpdate(dbUpdate);
            const subscriptionUpdate = {
              tag: "InitialSubscription",
              tableUpdates
            };
            return subscriptionUpdate;
          }
          case "TransactionUpdateLight": {
            const dbUpdate = message.value.update;
            const tableUpdates = await parseDatabaseUpdate(dbUpdate);
            const subscriptionUpdate = {
              tag: "TransactionUpdateLight",
              tableUpdates
            };
            return subscriptionUpdate;
          }
          case "TransactionUpdate": {
            const txUpdate = message.value;
            const identity = txUpdate.callerIdentity;
            const connectionId = ConnectionId.nullIfZero(
              txUpdate.callerConnectionId
            );
            const reducerName = txUpdate.reducerCall.reducerName;
            const args = txUpdate.reducerCall.args;
            const energyQuantaUsed = txUpdate.energyQuantaUsed;
            let tableUpdates = [];
            let errMessage = "";
            switch (txUpdate.status.tag) {
              case "Committed":
                tableUpdates = await parseDatabaseUpdate(txUpdate.status.value);
                break;
              case "Failed":
                tableUpdates = [];
                errMessage = txUpdate.status.value;
                break;
              case "OutOfEnergy":
                tableUpdates = [];
                break;
            }
            if (reducerName === "<none>") {
              const errorMessage = errMessage;
              console.error(`Received an error from the database: ${errorMessage}`);
              return;
            }
            let reducerInfo;
            if (reducerName !== "") {
              reducerInfo = {
                reducerName,
                args
              };
            }
            const transactionUpdate = {
              tag: "TransactionUpdate",
              tableUpdates,
              identity,
              connectionId,
              reducerInfo,
              status: txUpdate.status,
              energyConsumed: energyQuantaUsed.quanta,
              message: errMessage,
              timestamp: txUpdate.timestamp
            };
            return transactionUpdate;
          }
          case "IdentityToken": {
            const identityTokenMessage = {
              tag: "IdentityToken",
              identity: message.value.identity,
              token: message.value.token,
              connectionId: message.value.connectionId
            };
            return identityTokenMessage;
          }
          case "OneOffQueryResponse": {
            throw new Error(
              `TypeScript SDK never sends one-off queries, but got OneOffQueryResponse ${message}`
            );
          }
          case "SubscribeMultiApplied": {
            const parsedTableUpdates = await parseDatabaseUpdate(
              message.value.update
            );
            const subscribeAppliedMessage = {
              tag: "SubscribeApplied",
              queryId: message.value.queryId.id,
              tableUpdates: parsedTableUpdates
            };
            return subscribeAppliedMessage;
          }
          case "UnsubscribeMultiApplied": {
            const parsedTableUpdates = await parseDatabaseUpdate(
              message.value.update
            );
            const unsubscribeAppliedMessage = {
              tag: "UnsubscribeApplied",
              queryId: message.value.queryId.id,
              tableUpdates: parsedTableUpdates
            };
            return unsubscribeAppliedMessage;
          }
          case "SubscriptionError": {
            return {
              tag: "SubscriptionError",
              queryId: message.value.queryId,
              error: message.value.error
            };
          }
        }
      }
      #sendMessage(message) {
        this.wsPromise.then((wsResolved) => {
          if (wsResolved) {
            const writer = new BinaryWriter(1024);
            ClientMessage.serialize(writer, message);
            const encoded = writer.getBuffer();
            wsResolved.send(encoded);
          }
        });
      }
      /**
       * Handles WebSocket onOpen event.
       */
      #handleOnOpen() {
        this.isActive = true;
      }
      #applyTableUpdates(tableUpdates, eventContext) {
        const pendingCallbacks = [];
        for (const tableUpdate of tableUpdates) {
          const tableName = tableUpdate.tableName;
          const tableTypeInfo = this.#remoteModule.tables[tableName];
          const table3 = this.clientCache.getOrCreateTable(tableTypeInfo);
          const newCallbacks = table3.applyOperations(
            tableUpdate.operations,
            eventContext
          );
          for (const callback of newCallbacks) {
            pendingCallbacks.push(callback);
          }
        }
        return pendingCallbacks;
      }
      async #processMessage(data) {
        const serverMessage = parseValue(ServerMessage, data);
        const message = await this.#processParsedMessage(serverMessage);
        if (!message) {
          return;
        }
        switch (message.tag) {
          case "InitialSubscription": {
            const event = { tag: "SubscribeApplied" };
            const eventContext = this.#remoteModule.eventContextConstructor(
              this,
              event
            );
            const { event: _2, ...subscriptionEventContext } = eventContext;
            const callbacks = this.#applyTableUpdates(
              message.tableUpdates,
              eventContext
            );
            if (this.#emitter) {
              this.#onApplied?.(subscriptionEventContext);
            }
            for (const callback of callbacks) {
              callback.cb();
            }
            break;
          }
          case "TransactionUpdateLight": {
            const event = { tag: "UnknownTransaction" };
            const eventContext = this.#remoteModule.eventContextConstructor(
              this,
              event
            );
            const callbacks = this.#applyTableUpdates(
              message.tableUpdates,
              eventContext
            );
            for (const callback of callbacks) {
              callback.cb();
            }
            break;
          }
          case "TransactionUpdate": {
            let reducerInfo = message.reducerInfo;
            let unknownTransaction = false;
            let reducerArgs;
            let reducerTypeInfo;
            if (!reducerInfo) {
              unknownTransaction = true;
            } else {
              reducerTypeInfo = this.#remoteModule.reducers[reducerInfo.reducerName];
              try {
                const reader = new BinaryReader(reducerInfo.args);
                reducerArgs = AlgebraicType.deserializeValue(
                  reader,
                  reducerTypeInfo.argsType
                );
              } catch {
                console.debug("Failed to deserialize reducer arguments");
                unknownTransaction = true;
              }
            }
            if (unknownTransaction) {
              const event2 = { tag: "UnknownTransaction" };
              const eventContext2 = this.#remoteModule.eventContextConstructor(
                this,
                event2
              );
              const callbacks2 = this.#applyTableUpdates(
                message.tableUpdates,
                eventContext2
              );
              for (const callback of callbacks2) {
                callback.cb();
              }
              return;
            }
            reducerInfo = reducerInfo;
            reducerTypeInfo = reducerTypeInfo;
            const reducerEvent = {
              callerIdentity: message.identity,
              status: message.status,
              callerConnectionId: message.connectionId,
              timestamp: message.timestamp,
              energyConsumed: message.energyConsumed,
              reducer: {
                name: reducerInfo.reducerName,
                args: reducerArgs
              }
            };
            const event = {
              tag: "Reducer",
              value: reducerEvent
            };
            const eventContext = this.#remoteModule.eventContextConstructor(
              this,
              event
            );
            const reducerEventContext = {
              ...eventContext,
              event: reducerEvent
            };
            const callbacks = this.#applyTableUpdates(
              message.tableUpdates,
              eventContext
            );
            const argsArray = [];
            reducerTypeInfo.argsType.value.elements.forEach((element) => {
              argsArray.push(reducerArgs[element.name]);
            });
            this.#reducerEmitter.emit(
              reducerInfo.reducerName,
              reducerEventContext,
              ...argsArray
            );
            for (const callback of callbacks) {
              callback.cb();
            }
            break;
          }
          case "IdentityToken": {
            this.identity = message.identity;
            if (!this.token && message.token) {
              this.token = message.token;
            }
            this.connectionId = message.connectionId;
            this.#emitter.emit("connect", this, this.identity, this.token);
            break;
          }
          case "SubscribeApplied": {
            const subscription = this.#subscriptionManager.subscriptions.get(
              message.queryId
            );
            if (subscription === void 0) {
              stdbLogger(
                "error",
                `Received SubscribeApplied for unknown queryId ${message.queryId}.`
              );
              break;
            }
            const event = { tag: "SubscribeApplied" };
            const eventContext = this.#remoteModule.eventContextConstructor(
              this,
              event
            );
            const { event: _2, ...subscriptionEventContext } = eventContext;
            const callbacks = this.#applyTableUpdates(
              message.tableUpdates,
              eventContext
            );
            subscription?.emitter.emit("applied", subscriptionEventContext);
            for (const callback of callbacks) {
              callback.cb();
            }
            break;
          }
          case "UnsubscribeApplied": {
            const subscription = this.#subscriptionManager.subscriptions.get(
              message.queryId
            );
            if (subscription === void 0) {
              stdbLogger(
                "error",
                `Received UnsubscribeApplied for unknown queryId ${message.queryId}.`
              );
              break;
            }
            const event = { tag: "UnsubscribeApplied" };
            const eventContext = this.#remoteModule.eventContextConstructor(
              this,
              event
            );
            const { event: _2, ...subscriptionEventContext } = eventContext;
            const callbacks = this.#applyTableUpdates(
              message.tableUpdates,
              eventContext
            );
            subscription?.emitter.emit("end", subscriptionEventContext);
            this.#subscriptionManager.subscriptions.delete(message.queryId);
            for (const callback of callbacks) {
              callback.cb();
            }
            break;
          }
          case "SubscriptionError": {
            const error4 = Error(message.error);
            const event = { tag: "Error", value: error4 };
            const eventContext = this.#remoteModule.eventContextConstructor(
              this,
              event
            );
            const errorContext = {
              ...eventContext,
              event: error4
            };
            if (message.queryId !== void 0) {
              this.#subscriptionManager.subscriptions.get(message.queryId)?.emitter.emit("error", errorContext, error4);
              this.#subscriptionManager.subscriptions.delete(message.queryId);
            } else {
              console.error("Received an error message without a queryId: ", error4);
              this.#subscriptionManager.subscriptions.forEach(({ emitter }) => {
                emitter.emit("error", errorContext, error4);
              });
            }
          }
        }
      }
      /**
       * Handles WebSocket onMessage event.
       * @param wsMessage MessageEvent object.
       */
      #handleOnMessage(wsMessage) {
        this.#messageQueue = this.#messageQueue.then(() => {
          return this.#processMessage(wsMessage.data);
        });
      }
      /**
       * Call a reducer on your SpacetimeDB module.
       *
       * @param reducerName The name of the reducer to call
       * @param argsSerializer The arguments to pass to the reducer
       */
      callReducer(reducerName, argsBuffer, flags2) {
        const message = ClientMessage.CallReducer({
          reducer: reducerName,
          args: argsBuffer,
          // The TypeScript SDK doesn't currently track `request_id`s,
          // so always use 0.
          requestId: 0,
          flags: callReducerFlagsToNumber(flags2)
        });
        this.#sendMessage(message);
      }
      /**
       * Close the current connection.
       *
       * @example
       *
       * ```ts
       * const connection = DbConnection.builder().build();
       * connection.disconnect()
       * ```
       */
      disconnect() {
        this.wsPromise.then((wsResolved) => {
          if (wsResolved) {
            wsResolved.close();
          }
        });
      }
      on(eventName, callback) {
        this.#emitter.on(eventName, callback);
      }
      off(eventName, callback) {
        this.#emitter.off(eventName, callback);
      }
      onConnect(callback) {
        this.#emitter.on("connect", callback);
      }
      onDisconnect(callback) {
        this.#emitter.on("disconnect", callback);
      }
      onConnectError(callback) {
        this.#emitter.on("connectError", callback);
      }
      removeOnConnect(callback) {
        this.#emitter.off("connect", callback);
      }
      removeOnDisconnect(callback) {
        this.#emitter.off("disconnect", callback);
      }
      removeOnConnectError(callback) {
        this.#emitter.off("connectError", callback);
      }
      // Note: This is required to be public because it needs to be
      // called from the `RemoteReducers` class.
      onReducer(reducerName, callback) {
        this.#reducerEmitter.on(reducerName, callback);
      }
      // Note: This is required to be public because it needs to be
      // called from the `RemoteReducers` class.
      offReducer(reducerName, callback) {
        this.#reducerEmitter.off(reducerName, callback);
      }
    };
  }
});

// node_modules/jimp/dist/browser/index.js
function getDefaultExportFromCjs(e5) {
  return e5 && e5.__esModule && Object.prototype.hasOwnProperty.call(e5, "default") ? e5.default : e5;
}
function getAugmentedNamespace(e5) {
  if (e5.__esModule) return e5;
  var t3 = e5.default;
  if ("function" == typeof t3) {
    var i2 = /* @__PURE__ */ __name(function e6() {
      return this instanceof e6 ? Reflect.construct(t3, arguments, this.constructor) : t3.apply(this, arguments);
    }, "e");
    i2.prototype = t3.prototype;
  } else i2 = {};
  return Object.defineProperty(i2, "__esModule", { value: true }), Object.keys(e5).forEach(function(t4) {
    var r4 = Object.getOwnPropertyDescriptor(e5, t4);
    Object.defineProperty(i2, t4, r4.get ? r4 : { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return e5[t4];
    }, "get") });
  }), i2;
}
function init2() {
  inited = true;
  for (var e5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t3 = 0; t3 < 64; ++t3) lookup[t3] = e5[t3], revLookup[e5.charCodeAt(t3)] = t3;
  revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(e5) {
  var t3, i2, r4, n3, a2, o3;
  inited || init2();
  var s4 = e5.length;
  if (s4 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  a2 = "=" === e5[s4 - 2] ? 2 : "=" === e5[s4 - 1] ? 1 : 0, o3 = new Arr(3 * s4 / 4 - a2), r4 = a2 > 0 ? s4 - 4 : s4;
  var l2 = 0;
  for (t3 = 0, i2 = 0; t3 < r4; t3 += 4, i2 += 3) n3 = revLookup[e5.charCodeAt(t3)] << 18 | revLookup[e5.charCodeAt(t3 + 1)] << 12 | revLookup[e5.charCodeAt(t3 + 2)] << 6 | revLookup[e5.charCodeAt(t3 + 3)], o3[l2++] = n3 >> 16 & 255, o3[l2++] = n3 >> 8 & 255, o3[l2++] = 255 & n3;
  return 2 === a2 ? (n3 = revLookup[e5.charCodeAt(t3)] << 2 | revLookup[e5.charCodeAt(t3 + 1)] >> 4, o3[l2++] = 255 & n3) : 1 === a2 && (n3 = revLookup[e5.charCodeAt(t3)] << 10 | revLookup[e5.charCodeAt(t3 + 1)] << 4 | revLookup[e5.charCodeAt(t3 + 2)] >> 2, o3[l2++] = n3 >> 8 & 255, o3[l2++] = 255 & n3), o3;
}
function tripletToBase64(e5) {
  return lookup[e5 >> 18 & 63] + lookup[e5 >> 12 & 63] + lookup[e5 >> 6 & 63] + lookup[63 & e5];
}
function encodeChunk(e5, t3, i2) {
  for (var r4, n3 = [], a2 = t3; a2 < i2; a2 += 3) r4 = (e5[a2] << 16) + (e5[a2 + 1] << 8) + e5[a2 + 2], n3.push(tripletToBase64(r4));
  return n3.join("");
}
function fromByteArray2(e5) {
  var t3;
  inited || init2();
  for (var i2 = e5.length, r4 = i2 % 3, n3 = "", a2 = [], o3 = 16383, s4 = 0, l2 = i2 - r4; s4 < l2; s4 += o3) a2.push(encodeChunk(e5, s4, s4 + o3 > l2 ? l2 : s4 + o3));
  return 1 === r4 ? (t3 = e5[i2 - 1], n3 += lookup[t3 >> 2], n3 += lookup[t3 << 4 & 63], n3 += "==") : 2 === r4 && (t3 = (e5[i2 - 2] << 8) + e5[i2 - 1], n3 += lookup[t3 >> 10], n3 += lookup[t3 >> 4 & 63], n3 += lookup[t3 << 2 & 63], n3 += "="), a2.push(n3), a2.join("");
}
function read(e5, t3, i2, r4, n3) {
  var a2, o3, s4 = 8 * n3 - r4 - 1, l2 = (1 << s4) - 1, u2 = l2 >> 1, h2 = -7, c3 = i2 ? n3 - 1 : 0, f2 = i2 ? -1 : 1, d = e5[t3 + c3];
  for (c3 += f2, a2 = d & (1 << -h2) - 1, d >>= -h2, h2 += s4; h2 > 0; a2 = 256 * a2 + e5[t3 + c3], c3 += f2, h2 -= 8) ;
  for (o3 = a2 & (1 << -h2) - 1, a2 >>= -h2, h2 += r4; h2 > 0; o3 = 256 * o3 + e5[t3 + c3], c3 += f2, h2 -= 8) ;
  if (0 === a2) a2 = 1 - u2;
  else {
    if (a2 === l2) return o3 ? NaN : 1 / 0 * (d ? -1 : 1);
    o3 += Math.pow(2, r4), a2 -= u2;
  }
  return (d ? -1 : 1) * o3 * Math.pow(2, a2 - r4);
}
function write(e5, t3, i2, r4, n3, a2) {
  var o3, s4, l2, u2 = 8 * a2 - n3 - 1, h2 = (1 << u2) - 1, c3 = h2 >> 1, f2 = 23 === n3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r4 ? 0 : a2 - 1, p2 = r4 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (s4 = isNaN(t3) ? 1 : 0, o3 = h2) : (o3 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l2 = Math.pow(2, -o3)) < 1 && (o3--, l2 *= 2), (t3 += o3 + c3 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - c3)) * l2 >= 2 && (o3++, l2 /= 2), o3 + c3 >= h2 ? (s4 = 0, o3 = h2) : o3 + c3 >= 1 ? (s4 = (t3 * l2 - 1) * Math.pow(2, n3), o3 += c3) : (s4 = t3 * Math.pow(2, c3 - 1) * Math.pow(2, n3), o3 = 0)); n3 >= 8; e5[i2 + d] = 255 & s4, d += p2, s4 /= 256, n3 -= 8) ;
  for (o3 = o3 << n3 | s4, u2 += n3; u2 > 0; e5[i2 + d] = 255 & o3, d += p2, o3 /= 256, u2 -= 8) ;
  e5[i2 + d - p2] |= 128 * m;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(e5, t3) {
  if (kMaxLength() < t3) throw new RangeError("Invalid typed array length");
  return Buffer2.TYPED_ARRAY_SUPPORT ? (e5 = new Uint8Array(t3)).__proto__ = Buffer2.prototype : (null === e5 && (e5 = new Buffer2(t3)), e5.length = t3), e5;
}
function Buffer2(e5, t3, i2) {
  if (!(Buffer2.TYPED_ARRAY_SUPPORT || this instanceof Buffer2)) return new Buffer2(e5, t3, i2);
  if ("number" == typeof e5) {
    if ("string" == typeof t3) throw new Error("If encoding is specified then the first argument must be a string");
    return allocUnsafe(this, e5);
  }
  return from(this, e5, t3, i2);
}
function from(e5, t3, i2, r4) {
  if ("number" == typeof t3) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t3 instanceof ArrayBuffer ? fromArrayBuffer(e5, t3, i2, r4) : "string" == typeof t3 ? fromString(e5, t3, i2) : fromObject(e5, t3);
}
function assertSize(e5) {
  if ("number" != typeof e5) throw new TypeError('"size" argument must be a number');
  if (e5 < 0) throw new RangeError('"size" argument must not be negative');
}
function alloc(e5, t3, i2, r4) {
  return assertSize(t3), t3 <= 0 ? createBuffer(e5, t3) : void 0 !== i2 ? "string" == typeof r4 ? createBuffer(e5, t3).fill(i2, r4) : createBuffer(e5, t3).fill(i2) : createBuffer(e5, t3);
}
function allocUnsafe(e5, t3) {
  if (assertSize(t3), e5 = createBuffer(e5, t3 < 0 ? 0 : 0 | checked(t3)), !Buffer2.TYPED_ARRAY_SUPPORT) for (var i2 = 0; i2 < t3; ++i2) e5[i2] = 0;
  return e5;
}
function fromString(e5, t3, i2) {
  if ("string" == typeof i2 && "" !== i2 || (i2 = "utf8"), !Buffer2.isEncoding(i2)) throw new TypeError('"encoding" must be a valid string encoding');
  var r4 = 0 | byteLength(t3, i2), n3 = (e5 = createBuffer(e5, r4)).write(t3, i2);
  return n3 !== r4 && (e5 = e5.slice(0, n3)), e5;
}
function fromArrayLike(e5, t3) {
  var i2 = t3.length < 0 ? 0 : 0 | checked(t3.length);
  e5 = createBuffer(e5, i2);
  for (var r4 = 0; r4 < i2; r4 += 1) e5[r4] = 255 & t3[r4];
  return e5;
}
function fromArrayBuffer(e5, t3, i2, r4) {
  if (t3.byteLength, i2 < 0 || t3.byteLength < i2) throw new RangeError("'offset' is out of bounds");
  if (t3.byteLength < i2 + (r4 || 0)) throw new RangeError("'length' is out of bounds");
  return t3 = void 0 === i2 && void 0 === r4 ? new Uint8Array(t3) : void 0 === r4 ? new Uint8Array(t3, i2) : new Uint8Array(t3, i2, r4), Buffer2.TYPED_ARRAY_SUPPORT ? (e5 = t3).__proto__ = Buffer2.prototype : e5 = fromArrayLike(e5, t3), e5;
}
function fromObject(e5, t3) {
  if (internalIsBuffer(t3)) {
    var i2 = 0 | checked(t3.length);
    return 0 === (e5 = createBuffer(e5, i2)).length || t3.copy(e5, 0, 0, i2), e5;
  }
  if (t3) {
    if ("undefined" != typeof ArrayBuffer && t3.buffer instanceof ArrayBuffer || "length" in t3) return "number" != typeof t3.length || isnan(t3.length) ? createBuffer(e5, 0) : fromArrayLike(e5, t3);
    if ("Buffer" === t3.type && isArray(t3.data)) return fromArrayLike(e5, t3.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(e5) {
  if (e5 >= kMaxLength()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  return 0 | e5;
}
function internalIsBuffer(e5) {
  return !(null == e5 || !e5._isBuffer);
}
function byteLength(e5, t3) {
  if (internalIsBuffer(e5)) return e5.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e5) || e5 instanceof ArrayBuffer)) return e5.byteLength;
  "string" != typeof e5 && (e5 = "" + e5);
  var i2 = e5.length;
  if (0 === i2) return 0;
  for (var r4 = false; ; ) switch (t3) {
    case "ascii":
    case "latin1":
    case "binary":
      return i2;
    case "utf8":
    case "utf-8":
    case void 0:
      return utf8ToBytes(e5).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * i2;
    case "hex":
      return i2 >>> 1;
    case "base64":
      return base64ToBytes(e5).length;
    default:
      if (r4) return utf8ToBytes(e5).length;
      t3 = ("" + t3).toLowerCase(), r4 = true;
  }
}
function slowToString(e5, t3, i2) {
  var r4 = false;
  if ((void 0 === t3 || t3 < 0) && (t3 = 0), t3 > this.length) return "";
  if ((void 0 === i2 || i2 > this.length) && (i2 = this.length), i2 <= 0) return "";
  if ((i2 >>>= 0) <= (t3 >>>= 0)) return "";
  for (e5 || (e5 = "utf8"); ; ) switch (e5) {
    case "hex":
      return hexSlice(this, t3, i2);
    case "utf8":
    case "utf-8":
      return utf8Slice(this, t3, i2);
    case "ascii":
      return asciiSlice(this, t3, i2);
    case "latin1":
    case "binary":
      return latin1Slice(this, t3, i2);
    case "base64":
      return base64Slice(this, t3, i2);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return utf16leSlice(this, t3, i2);
    default:
      if (r4) throw new TypeError("Unknown encoding: " + e5);
      e5 = (e5 + "").toLowerCase(), r4 = true;
  }
}
function swap(e5, t3, i2) {
  var r4 = e5[t3];
  e5[t3] = e5[i2], e5[i2] = r4;
}
function bidirectionalIndexOf(e5, t3, i2, r4, n3) {
  if (0 === e5.length) return -1;
  if ("string" == typeof i2 ? (r4 = i2, i2 = 0) : i2 > 2147483647 ? i2 = 2147483647 : i2 < -2147483648 && (i2 = -2147483648), i2 = +i2, isNaN(i2) && (i2 = n3 ? 0 : e5.length - 1), i2 < 0 && (i2 = e5.length + i2), i2 >= e5.length) {
    if (n3) return -1;
    i2 = e5.length - 1;
  } else if (i2 < 0) {
    if (!n3) return -1;
    i2 = 0;
  }
  if ("string" == typeof t3 && (t3 = Buffer2.from(t3, r4)), internalIsBuffer(t3)) return 0 === t3.length ? -1 : arrayIndexOf(e5, t3, i2, r4, n3);
  if ("number" == typeof t3) return t3 &= 255, Buffer2.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? n3 ? Uint8Array.prototype.indexOf.call(e5, t3, i2) : Uint8Array.prototype.lastIndexOf.call(e5, t3, i2) : arrayIndexOf(e5, [t3], i2, r4, n3);
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(e5, t3, i2, r4, n3) {
  var a2, o3 = 1, s4 = e5.length, l2 = t3.length;
  if (void 0 !== r4 && ("ucs2" === (r4 = String(r4).toLowerCase()) || "ucs-2" === r4 || "utf16le" === r4 || "utf-16le" === r4)) {
    if (e5.length < 2 || t3.length < 2) return -1;
    o3 = 2, s4 /= 2, l2 /= 2, i2 /= 2;
  }
  function u2(e6, t4) {
    return 1 === o3 ? e6[t4] : e6.readUInt16BE(t4 * o3);
  }
  __name(u2, "u");
  if (n3) {
    var h2 = -1;
    for (a2 = i2; a2 < s4; a2++) if (u2(e5, a2) === u2(t3, -1 === h2 ? 0 : a2 - h2)) {
      if (-1 === h2 && (h2 = a2), a2 - h2 + 1 === l2) return h2 * o3;
    } else -1 !== h2 && (a2 -= a2 - h2), h2 = -1;
  } else for (i2 + l2 > s4 && (i2 = s4 - l2), a2 = i2; a2 >= 0; a2--) {
    for (var c3 = true, f2 = 0; f2 < l2; f2++) if (u2(e5, a2 + f2) !== u2(t3, f2)) {
      c3 = false;
      break;
    }
    if (c3) return a2;
  }
  return -1;
}
function hexWrite(e5, t3, i2, r4) {
  i2 = Number(i2) || 0;
  var n3 = e5.length - i2;
  r4 ? (r4 = Number(r4)) > n3 && (r4 = n3) : r4 = n3;
  var a2 = t3.length;
  if (a2 % 2 != 0) throw new TypeError("Invalid hex string");
  r4 > a2 / 2 && (r4 = a2 / 2);
  for (var o3 = 0; o3 < r4; ++o3) {
    var s4 = parseInt(t3.substr(2 * o3, 2), 16);
    if (isNaN(s4)) return o3;
    e5[i2 + o3] = s4;
  }
  return o3;
}
function utf8Write(e5, t3, i2, r4) {
  return blitBuffer(utf8ToBytes(t3, e5.length - i2), e5, i2, r4);
}
function asciiWrite(e5, t3, i2, r4) {
  return blitBuffer(asciiToBytes(t3), e5, i2, r4);
}
function latin1Write(e5, t3, i2, r4) {
  return asciiWrite(e5, t3, i2, r4);
}
function base64Write(e5, t3, i2, r4) {
  return blitBuffer(base64ToBytes(t3), e5, i2, r4);
}
function ucs2Write(e5, t3, i2, r4) {
  return blitBuffer(utf16leToBytes(t3, e5.length - i2), e5, i2, r4);
}
function base64Slice(e5, t3, i2) {
  return 0 === t3 && i2 === e5.length ? fromByteArray2(e5) : fromByteArray2(e5.slice(t3, i2));
}
function utf8Slice(e5, t3, i2) {
  i2 = Math.min(e5.length, i2);
  for (var r4 = [], n3 = t3; n3 < i2; ) {
    var a2, o3, s4, l2, u2 = e5[n3], h2 = null, c3 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
    if (n3 + c3 <= i2) switch (c3) {
      case 1:
        u2 < 128 && (h2 = u2);
        break;
      case 2:
        128 == (192 & (a2 = e5[n3 + 1])) && (l2 = (31 & u2) << 6 | 63 & a2) > 127 && (h2 = l2);
        break;
      case 3:
        a2 = e5[n3 + 1], o3 = e5[n3 + 2], 128 == (192 & a2) && 128 == (192 & o3) && (l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o3) > 2047 && (l2 < 55296 || l2 > 57343) && (h2 = l2);
        break;
      case 4:
        a2 = e5[n3 + 1], o3 = e5[n3 + 2], s4 = e5[n3 + 3], 128 == (192 & a2) && 128 == (192 & o3) && 128 == (192 & s4) && (l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o3) << 6 | 63 & s4) > 65535 && l2 < 1114112 && (h2 = l2);
    }
    null === h2 ? (h2 = 65533, c3 = 1) : h2 > 65535 && (h2 -= 65536, r4.push(h2 >>> 10 & 1023 | 55296), h2 = 56320 | 1023 & h2), r4.push(h2), n3 += c3;
  }
  return decodeCodePointsArray(r4);
}
function decodeCodePointsArray(e5) {
  var t3 = e5.length;
  if (t3 <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, e5);
  for (var i2 = "", r4 = 0; r4 < t3; ) i2 += String.fromCharCode.apply(String, e5.slice(r4, r4 += MAX_ARGUMENTS_LENGTH));
  return i2;
}
function asciiSlice(e5, t3, i2) {
  var r4 = "";
  i2 = Math.min(e5.length, i2);
  for (var n3 = t3; n3 < i2; ++n3) r4 += String.fromCharCode(127 & e5[n3]);
  return r4;
}
function latin1Slice(e5, t3, i2) {
  var r4 = "";
  i2 = Math.min(e5.length, i2);
  for (var n3 = t3; n3 < i2; ++n3) r4 += String.fromCharCode(e5[n3]);
  return r4;
}
function hexSlice(e5, t3, i2) {
  var r4 = e5.length;
  (!t3 || t3 < 0) && (t3 = 0), (!i2 || i2 < 0 || i2 > r4) && (i2 = r4);
  for (var n3 = "", a2 = t3; a2 < i2; ++a2) n3 += toHex(e5[a2]);
  return n3;
}
function utf16leSlice(e5, t3, i2) {
  for (var r4 = e5.slice(t3, i2), n3 = "", a2 = 0; a2 < r4.length; a2 += 2) n3 += String.fromCharCode(r4[a2] + 256 * r4[a2 + 1]);
  return n3;
}
function checkOffset(e5, t3, i2) {
  if (e5 % 1 != 0 || e5 < 0) throw new RangeError("offset is not uint");
  if (e5 + t3 > i2) throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(e5, t3, i2, r4, n3, a2) {
  if (!internalIsBuffer(e5)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t3 > n3 || t3 < a2) throw new RangeError('"value" argument is out of bounds');
  if (i2 + r4 > e5.length) throw new RangeError("Index out of range");
}
function objectWriteUInt16(e5, t3, i2, r4) {
  t3 < 0 && (t3 = 65535 + t3 + 1);
  for (var n3 = 0, a2 = Math.min(e5.length - i2, 2); n3 < a2; ++n3) e5[i2 + n3] = (t3 & 255 << 8 * (r4 ? n3 : 1 - n3)) >>> 8 * (r4 ? n3 : 1 - n3);
}
function objectWriteUInt32(e5, t3, i2, r4) {
  t3 < 0 && (t3 = 4294967295 + t3 + 1);
  for (var n3 = 0, a2 = Math.min(e5.length - i2, 4); n3 < a2; ++n3) e5[i2 + n3] = t3 >>> 8 * (r4 ? n3 : 3 - n3) & 255;
}
function checkIEEE754(e5, t3, i2, r4, n3, a2) {
  if (i2 + r4 > e5.length) throw new RangeError("Index out of range");
  if (i2 < 0) throw new RangeError("Index out of range");
}
function writeFloat(e5, t3, i2, r4, n3) {
  return n3 || checkIEEE754(e5, t3, i2, 4), write(e5, t3, i2, r4, 23, 4), i2 + 4;
}
function writeDouble(e5, t3, i2, r4, n3) {
  return n3 || checkIEEE754(e5, t3, i2, 8), write(e5, t3, i2, r4, 52, 8), i2 + 8;
}
function base64clean(e5) {
  if ((e5 = stringtrim(e5).replace(INVALID_BASE64_RE, "")).length < 2) return "";
  for (; e5.length % 4 != 0; ) e5 += "=";
  return e5;
}
function stringtrim(e5) {
  return e5.trim ? e5.trim() : e5.replace(/^\s+|\s+$/g, "");
}
function toHex(e5) {
  return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
}
function utf8ToBytes(e5, t3) {
  var i2;
  t3 = t3 || 1 / 0;
  for (var r4 = e5.length, n3 = null, a2 = [], o3 = 0; o3 < r4; ++o3) {
    if ((i2 = e5.charCodeAt(o3)) > 55295 && i2 < 57344) {
      if (!n3) {
        if (i2 > 56319) {
          (t3 -= 3) > -1 && a2.push(239, 191, 189);
          continue;
        }
        if (o3 + 1 === r4) {
          (t3 -= 3) > -1 && a2.push(239, 191, 189);
          continue;
        }
        n3 = i2;
        continue;
      }
      if (i2 < 56320) {
        (t3 -= 3) > -1 && a2.push(239, 191, 189), n3 = i2;
        continue;
      }
      i2 = 65536 + (n3 - 55296 << 10 | i2 - 56320);
    } else n3 && (t3 -= 3) > -1 && a2.push(239, 191, 189);
    if (n3 = null, i2 < 128) {
      if ((t3 -= 1) < 0) break;
      a2.push(i2);
    } else if (i2 < 2048) {
      if ((t3 -= 2) < 0) break;
      a2.push(i2 >> 6 | 192, 63 & i2 | 128);
    } else if (i2 < 65536) {
      if ((t3 -= 3) < 0) break;
      a2.push(i2 >> 12 | 224, i2 >> 6 & 63 | 128, 63 & i2 | 128);
    } else {
      if (!(i2 < 1114112)) throw new Error("Invalid code point");
      if ((t3 -= 4) < 0) break;
      a2.push(i2 >> 18 | 240, i2 >> 12 & 63 | 128, i2 >> 6 & 63 | 128, 63 & i2 | 128);
    }
  }
  return a2;
}
function asciiToBytes(e5) {
  for (var t3 = [], i2 = 0; i2 < e5.length; ++i2) t3.push(255 & e5.charCodeAt(i2));
  return t3;
}
function utf16leToBytes(e5, t3) {
  for (var i2, r4, n3, a2 = [], o3 = 0; o3 < e5.length && !((t3 -= 2) < 0); ++o3) r4 = (i2 = e5.charCodeAt(o3)) >> 8, n3 = i2 % 256, a2.push(n3), a2.push(r4);
  return a2;
}
function base64ToBytes(e5) {
  return toByteArray(base64clean(e5));
}
function blitBuffer(e5, t3, i2, r4) {
  for (var n3 = 0; n3 < r4 && !(n3 + i2 >= t3.length || n3 >= e5.length); ++n3) t3[n3 + i2] = e5[n3];
  return n3;
}
function isnan(e5) {
  return e5 != e5;
}
function isBuffer(e5) {
  return null != e5 && (!!e5._isBuffer || isFastBuffer(e5) || isSlowBuffer(e5));
}
function isFastBuffer(e5) {
  return !!e5.constructor && "function" == typeof e5.constructor.isBuffer && e5.constructor.isBuffer(e5);
}
function isSlowBuffer(e5) {
  return "function" == typeof e5.readFloatLE && "function" == typeof e5.slice && isFastBuffer(e5.slice(0, 0));
}
function maskColor(e5, t3, i2, r4) {
  const n3 = 1 + ~e5 & e5, a2 = 1 + ~t3 & t3, o3 = 1 + ~i2 & i2, s4 = 1 + ~r4 & r4, l2 = e5 / n3 + 1, u2 = t3 / a2 + 1, h2 = i2 / o3 + 1, c3 = r4 / s4 + 1;
  return { shiftRed: /* @__PURE__ */ __name((t4) => (t4 & e5) / n3 * 256 / l2, "shiftRed"), shiftGreen: /* @__PURE__ */ __name((e6) => (e6 & t3) / a2 * 256 / u2, "shiftGreen"), shiftBlue: /* @__PURE__ */ __name((e6) => (e6 & i2) / o3 * 256 / h2, "shiftBlue"), shiftAlpha: 0 !== r4 ? (e6) => (e6 & r4) / s4 * 256 / c3 : () => 255 };
}
function createInteger(e5) {
  return e5.reduce((e6, t3) => e6 << 1 | t3, 0);
}
function createColor(e5) {
  return e5.quad << 24 | e5.red << 16 | e5.green << 8 | e5.blue;
}
function decode$2(e5, t3) {
  return new BmpDecoder(e5, t3);
}
function encode$2(e5) {
  return new BmpEncoder(e5);
}
function _typeof(e5) {
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e6) {
    return typeof e6;
  } : function(e6) {
    return e6 && "function" == typeof Symbol && e6.constructor === Symbol && e6 !== Symbol.prototype ? "symbol" : typeof e6;
  }, _typeof(e5);
}
function tinycolor(e5, t3) {
  if (t3 = t3 || {}, (e5 = e5 || "") instanceof tinycolor) return e5;
  if (!(this instanceof tinycolor)) return new tinycolor(e5, t3);
  var i2 = inputToRGB(e5);
  this._originalInput = e5, this._r = i2.r, this._g = i2.g, this._b = i2.b, this._a = i2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = t3.format || i2.format, this._gradientType = t3.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = i2.ok;
}
function inputToRGB(e5) {
  var t3 = { r: 0, g: 0, b: 0 }, i2 = 1, r4 = null, n3 = null, a2 = null, o3 = false, s4 = false;
  return "string" == typeof e5 && (e5 = stringInputToObject(e5)), "object" == _typeof(e5) && (isValidCSSUnit(e5.r) && isValidCSSUnit(e5.g) && isValidCSSUnit(e5.b) ? (t3 = rgbToRgb(e5.r, e5.g, e5.b), o3 = true, s4 = "%" === String(e5.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(e5.h) && isValidCSSUnit(e5.s) && isValidCSSUnit(e5.v) ? (r4 = convertToPercentage(e5.s), n3 = convertToPercentage(e5.v), t3 = hsvToRgb(e5.h, r4, n3), o3 = true, s4 = "hsv") : isValidCSSUnit(e5.h) && isValidCSSUnit(e5.s) && isValidCSSUnit(e5.l) && (r4 = convertToPercentage(e5.s), a2 = convertToPercentage(e5.l), t3 = hslToRgb(e5.h, r4, a2), o3 = true, s4 = "hsl"), e5.hasOwnProperty("a") && (i2 = e5.a)), i2 = boundAlpha(i2), { ok: o3, format: e5.format || s4, r: Math.min(255, Math.max(t3.r, 0)), g: Math.min(255, Math.max(t3.g, 0)), b: Math.min(255, Math.max(t3.b, 0)), a: i2 };
}
function rgbToRgb(e5, t3, i2) {
  return { r: 255 * bound01(e5, 255), g: 255 * bound01(t3, 255), b: 255 * bound01(i2, 255) };
}
function rgbToHsl(e5, t3, i2) {
  e5 = bound01(e5, 255), t3 = bound01(t3, 255), i2 = bound01(i2, 255);
  var r4, n3, a2 = Math.max(e5, t3, i2), o3 = Math.min(e5, t3, i2), s4 = (a2 + o3) / 2;
  if (a2 == o3) r4 = n3 = 0;
  else {
    var l2 = a2 - o3;
    switch (n3 = s4 > 0.5 ? l2 / (2 - a2 - o3) : l2 / (a2 + o3), a2) {
      case e5:
        r4 = (t3 - i2) / l2 + (t3 < i2 ? 6 : 0);
        break;
      case t3:
        r4 = (i2 - e5) / l2 + 2;
        break;
      case i2:
        r4 = (e5 - t3) / l2 + 4;
    }
    r4 /= 6;
  }
  return { h: r4, s: n3, l: s4 };
}
function hslToRgb(e5, t3, i2) {
  var r4, n3, a2;
  function o3(e6, t4, i3) {
    return i3 < 0 && (i3 += 1), i3 > 1 && (i3 -= 1), i3 < 1 / 6 ? e6 + 6 * (t4 - e6) * i3 : i3 < 0.5 ? t4 : i3 < 2 / 3 ? e6 + (t4 - e6) * (2 / 3 - i3) * 6 : e6;
  }
  __name(o3, "o");
  if (e5 = bound01(e5, 360), t3 = bound01(t3, 100), i2 = bound01(i2, 100), 0 === t3) r4 = n3 = a2 = i2;
  else {
    var s4 = i2 < 0.5 ? i2 * (1 + t3) : i2 + t3 - i2 * t3, l2 = 2 * i2 - s4;
    r4 = o3(l2, s4, e5 + 1 / 3), n3 = o3(l2, s4, e5), a2 = o3(l2, s4, e5 - 1 / 3);
  }
  return { r: 255 * r4, g: 255 * n3, b: 255 * a2 };
}
function rgbToHsv(e5, t3, i2) {
  e5 = bound01(e5, 255), t3 = bound01(t3, 255), i2 = bound01(i2, 255);
  var r4, n3, a2 = Math.max(e5, t3, i2), o3 = Math.min(e5, t3, i2), s4 = a2, l2 = a2 - o3;
  if (n3 = 0 === a2 ? 0 : l2 / a2, a2 == o3) r4 = 0;
  else {
    switch (a2) {
      case e5:
        r4 = (t3 - i2) / l2 + (t3 < i2 ? 6 : 0);
        break;
      case t3:
        r4 = (i2 - e5) / l2 + 2;
        break;
      case i2:
        r4 = (e5 - t3) / l2 + 4;
    }
    r4 /= 6;
  }
  return { h: r4, s: n3, v: s4 };
}
function hsvToRgb(e5, t3, i2) {
  e5 = 6 * bound01(e5, 360), t3 = bound01(t3, 100), i2 = bound01(i2, 100);
  var r4 = Math.floor(e5), n3 = e5 - r4, a2 = i2 * (1 - t3), o3 = i2 * (1 - n3 * t3), s4 = i2 * (1 - (1 - n3) * t3), l2 = r4 % 6;
  return { r: 255 * [i2, o3, a2, a2, s4, i2][l2], g: 255 * [s4, i2, i2, o3, a2, a2][l2], b: 255 * [a2, a2, s4, i2, i2, o3][l2] };
}
function rgbToHex(e5, t3, i2, r4) {
  var n3 = [pad2(Math.round(e5).toString(16)), pad2(Math.round(t3).toString(16)), pad2(Math.round(i2).toString(16))];
  return r4 && n3[0].charAt(0) == n3[0].charAt(1) && n3[1].charAt(0) == n3[1].charAt(1) && n3[2].charAt(0) == n3[2].charAt(1) ? n3[0].charAt(0) + n3[1].charAt(0) + n3[2].charAt(0) : n3.join("");
}
function rgbaToHex(e5, t3, i2, r4, n3) {
  var a2 = [pad2(Math.round(e5).toString(16)), pad2(Math.round(t3).toString(16)), pad2(Math.round(i2).toString(16)), pad2(convertDecimalToHex(r4))];
  return n3 && a2[0].charAt(0) == a2[0].charAt(1) && a2[1].charAt(0) == a2[1].charAt(1) && a2[2].charAt(0) == a2[2].charAt(1) && a2[3].charAt(0) == a2[3].charAt(1) ? a2[0].charAt(0) + a2[1].charAt(0) + a2[2].charAt(0) + a2[3].charAt(0) : a2.join("");
}
function rgbaToArgbHex(e5, t3, i2, r4) {
  return [pad2(convertDecimalToHex(r4)), pad2(Math.round(e5).toString(16)), pad2(Math.round(t3).toString(16)), pad2(Math.round(i2).toString(16))].join("");
}
function _desaturate(e5, t3) {
  t3 = 0 === t3 ? 0 : t3 || 10;
  var i2 = tinycolor(e5).toHsl();
  return i2.s -= t3 / 100, i2.s = clamp01(i2.s), tinycolor(i2);
}
function _saturate(e5, t3) {
  t3 = 0 === t3 ? 0 : t3 || 10;
  var i2 = tinycolor(e5).toHsl();
  return i2.s += t3 / 100, i2.s = clamp01(i2.s), tinycolor(i2);
}
function _greyscale(e5) {
  return tinycolor(e5).desaturate(100);
}
function _lighten(e5, t3) {
  t3 = 0 === t3 ? 0 : t3 || 10;
  var i2 = tinycolor(e5).toHsl();
  return i2.l += t3 / 100, i2.l = clamp01(i2.l), tinycolor(i2);
}
function _brighten(e5, t3) {
  t3 = 0 === t3 ? 0 : t3 || 10;
  var i2 = tinycolor(e5).toRgb();
  return i2.r = Math.max(0, Math.min(255, i2.r - Math.round(-t3 / 100 * 255))), i2.g = Math.max(0, Math.min(255, i2.g - Math.round(-t3 / 100 * 255))), i2.b = Math.max(0, Math.min(255, i2.b - Math.round(-t3 / 100 * 255))), tinycolor(i2);
}
function _darken(e5, t3) {
  t3 = 0 === t3 ? 0 : t3 || 10;
  var i2 = tinycolor(e5).toHsl();
  return i2.l -= t3 / 100, i2.l = clamp01(i2.l), tinycolor(i2);
}
function _spin(e5, t3) {
  var i2 = tinycolor(e5).toHsl(), r4 = (i2.h + t3) % 360;
  return i2.h = r4 < 0 ? 360 + r4 : r4, tinycolor(i2);
}
function _complement(e5) {
  var t3 = tinycolor(e5).toHsl();
  return t3.h = (t3.h + 180) % 360, tinycolor(t3);
}
function polyad(e5, t3) {
  if (isNaN(t3) || t3 <= 0) throw new Error("Argument to polyad must be a positive number");
  for (var i2 = tinycolor(e5).toHsl(), r4 = [tinycolor(e5)], n3 = 360 / t3, a2 = 1; a2 < t3; a2++) r4.push(tinycolor({ h: (i2.h + a2 * n3) % 360, s: i2.s, l: i2.l }));
  return r4;
}
function _splitcomplement(e5) {
  var t3 = tinycolor(e5).toHsl(), i2 = t3.h;
  return [tinycolor(e5), tinycolor({ h: (i2 + 72) % 360, s: t3.s, l: t3.l }), tinycolor({ h: (i2 + 216) % 360, s: t3.s, l: t3.l })];
}
function _analogous(e5, t3, i2) {
  t3 = t3 || 6, i2 = i2 || 30;
  var r4 = tinycolor(e5).toHsl(), n3 = 360 / i2, a2 = [tinycolor(e5)];
  for (r4.h = (r4.h - (n3 * t3 >> 1) + 720) % 360; --t3; ) r4.h = (r4.h + n3) % 360, a2.push(tinycolor(r4));
  return a2;
}
function _monochromatic(e5, t3) {
  t3 = t3 || 6;
  for (var i2 = tinycolor(e5).toHsv(), r4 = i2.h, n3 = i2.s, a2 = i2.v, o3 = [], s4 = 1 / t3; t3--; ) o3.push(tinycolor({ h: r4, s: n3, v: a2 })), a2 = (a2 + s4) % 1;
  return o3;
}
function flip(e5) {
  var t3 = {};
  for (var i2 in e5) e5.hasOwnProperty(i2) && (t3[e5[i2]] = i2);
  return t3;
}
function boundAlpha(e5) {
  return e5 = parseFloat(e5), (isNaN(e5) || e5 < 0 || e5 > 1) && (e5 = 1), e5;
}
function bound01(e5, t3) {
  isOnePointZero(e5) && (e5 = "100%");
  var i2 = isPercentage(e5);
  return e5 = Math.min(t3, Math.max(0, parseFloat(e5))), i2 && (e5 = parseInt(e5 * t3, 10) / 100), Math.abs(e5 - t3) < 1e-6 ? 1 : e5 % t3 / parseFloat(t3);
}
function clamp01(e5) {
  return Math.min(1, Math.max(0, e5));
}
function parseIntFromHex(e5) {
  return parseInt(e5, 16);
}
function isOnePointZero(e5) {
  return "string" == typeof e5 && -1 != e5.indexOf(".") && 1 === parseFloat(e5);
}
function isPercentage(e5) {
  return "string" == typeof e5 && -1 != e5.indexOf("%");
}
function pad2(e5) {
  return 1 == e5.length ? "0" + e5 : "" + e5;
}
function convertToPercentage(e5) {
  return e5 <= 1 && (e5 = 100 * e5 + "%"), e5;
}
function convertDecimalToHex(e5) {
  return Math.round(255 * parseFloat(e5)).toString(16);
}
function convertHexToDecimal(e5) {
  return parseIntFromHex(e5) / 255;
}
function isValidCSSUnit(e5) {
  return !!matchers.CSS_UNIT.exec(e5);
}
function stringInputToObject(e5) {
  e5 = e5.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var t3, i2 = false;
  if (names$1[e5]) e5 = names$1[e5], i2 = true;
  else if ("transparent" == e5) return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  return (t3 = matchers.rgb.exec(e5)) ? { r: t3[1], g: t3[2], b: t3[3] } : (t3 = matchers.rgba.exec(e5)) ? { r: t3[1], g: t3[2], b: t3[3], a: t3[4] } : (t3 = matchers.hsl.exec(e5)) ? { h: t3[1], s: t3[2], l: t3[3] } : (t3 = matchers.hsla.exec(e5)) ? { h: t3[1], s: t3[2], l: t3[3], a: t3[4] } : (t3 = matchers.hsv.exec(e5)) ? { h: t3[1], s: t3[2], v: t3[3] } : (t3 = matchers.hsva.exec(e5)) ? { h: t3[1], s: t3[2], v: t3[3], a: t3[4] } : (t3 = matchers.hex8.exec(e5)) ? { r: parseIntFromHex(t3[1]), g: parseIntFromHex(t3[2]), b: parseIntFromHex(t3[3]), a: convertHexToDecimal(t3[4]), format: i2 ? "name" : "hex8" } : (t3 = matchers.hex6.exec(e5)) ? { r: parseIntFromHex(t3[1]), g: parseIntFromHex(t3[2]), b: parseIntFromHex(t3[3]), format: i2 ? "name" : "hex" } : (t3 = matchers.hex4.exec(e5)) ? { r: parseIntFromHex(t3[1] + "" + t3[1]), g: parseIntFromHex(t3[2] + "" + t3[2]), b: parseIntFromHex(t3[3] + "" + t3[3]), a: convertHexToDecimal(t3[4] + "" + t3[4]), format: i2 ? "name" : "hex8" } : !!(t3 = matchers.hex3.exec(e5)) && { r: parseIntFromHex(t3[1] + "" + t3[1]), g: parseIntFromHex(t3[2] + "" + t3[2]), b: parseIntFromHex(t3[3] + "" + t3[3]), format: i2 ? "name" : "hex" };
}
function validateWCAG2Parms(e5) {
  var t3, i2;
  return "AA" !== (t3 = ((e5 = e5 || { level: "AA", size: "small" }).level || "AA").toUpperCase()) && "AAA" !== t3 && (t3 = "AA"), "small" !== (i2 = (e5.size || "small").toLowerCase()) && "large" !== i2 && (i2 = "small"), { level: t3, size: i2 };
}
function clone(e5) {
  const t3 = { width: e5.bitmap.width, height: e5.bitmap.height, data: Buffer2.from(e5.bitmap.data) };
  return new e5.constructor(t3);
}
function scan(e5, t3, i2, r4, n3, a2) {
  let o3, s4, l2, u2, h2;
  if ("function" == typeof t3) h2 = t3, o3 = 0, s4 = 0, l2 = e5.bitmap.width, u2 = e5.bitmap.height;
  else {
    if (o3 = t3, "number" != typeof i2) throw new Error("y must be a number");
    if (s4 = i2, "number" != typeof r4) throw new Error("w must be a number");
    if (l2 = r4, "number" != typeof n3) throw new Error("h must be a number");
    if (u2 = n3, "function" != typeof a2) throw new Error("cb must be a function");
    h2 = a2;
  }
  o3 = Math.round(o3), s4 = Math.round(s4), l2 = Math.round(l2), u2 = Math.round(u2);
  const c3 = h2.bind(e5);
  for (let t4 = s4; t4 < s4 + u2; t4++) for (let i3 = o3; i3 < o3 + l2; i3++) {
    c3(i3, t4, e5.bitmap.width * t4 + i3 << 2);
  }
  return e5;
}
function* scanIterator(e5, t3, i2, r4, n3) {
  t3 = Math.round(t3), i2 = Math.round(i2), r4 = Math.round(r4), n3 = Math.round(n3);
  for (let a2 = i2; a2 < i2 + n3; a2++) for (let i3 = t3; i3 < t3 + r4; i3++) {
    const t4 = e5.bitmap.width * a2 + i3 << 2;
    yield { x: i3, y: a2, idx: t4, image: e5 };
  }
}
function intToRGBA$1(e5) {
  if ("number" != typeof e5) throw new Error("i must be a number");
  const t3 = { r: 0, g: 0, b: 0, a: 0 };
  return t3.r = Math.floor(e5 / Math.pow(256, 3)), t3.g = Math.floor((e5 - t3.r * Math.pow(256, 3)) / Math.pow(256, 2)), t3.b = Math.floor((e5 - t3.r * Math.pow(256, 3) - t3.g * Math.pow(256, 2)) / Math.pow(256, 1)), t3.a = Math.floor((e5 - t3.r * Math.pow(256, 3) - t3.g * Math.pow(256, 2) - t3.b * Math.pow(256, 1)) / Math.pow(256, 0)), t3;
}
function rgbaToInt(e5, t3, i2, r4) {
  if ("number" != typeof e5 || "number" != typeof t3 || "number" != typeof i2 || "number" != typeof r4) throw new Error("r, g, b and a must be numbers");
  if (e5 < 0 || e5 > 255) throw new Error("r must be between 0 and 255");
  if (t3 < 0 || t3 > 255) throw new Error("g must be between 0 and 255");
  if (i2 < 0 || i2 > 255) throw new Error("b must be between 0 and 255");
  if (r4 < 0 || r4 > 255) throw new Error("a must be between 0 and 255");
  let n3 = 255 & e5;
  return n3 <<= 8, n3 |= 255 & t3, n3 <<= 8, n3 |= 255 & i2, n3 <<= 8, n3 |= 255 & r4, n3 >>>= 0, n3;
}
function colorDiff(e5, t3) {
  const i2 = /* @__PURE__ */ __name((e6) => Math.pow(e6, 2), "i"), { max: r4 } = Math, n3 = "a" in e5 ? e5.a : 255, a2 = "a" in t3 ? t3.a : 255;
  return (r4(i2(e5.r - t3.r), i2(e5.r - t3.r - n3 + a2)) + r4(i2(e5.g - t3.g), i2(e5.g - t3.g - n3 + a2)) + r4(i2(e5.b - t3.b), i2(e5.b - t3.b - n3 + a2))) / 195075;
}
function limit255(e5) {
  return e5 = Math.max(e5, 0), e5 = Math.min(e5, 255);
}
function cssColorToHex(e5) {
  return "number" == typeof e5 ? e5 : parseInt(tinycolor(e5).toHex8(), 16);
}
function encode$1(e5, t3 = {}) {
  return scan({ bitmap: e5 }, 0, 0, e5.width, e5.height, function(t4, i2, r4) {
    const n3 = e5.data[r4 + 0], a2 = e5.data[r4 + 1], o3 = e5.data[r4 + 2], s4 = e5.data[r4 + 3];
    e5.data[r4 + 0] = s4, e5.data[r4 + 1] = o3, e5.data[r4 + 2] = a2, e5.data[r4 + 3] = n3;
  }), encode$2({ ...e5, ...t3 }).data;
}
function decode$1(e5, t3) {
  const i2 = decode$2(e5, t3);
  return scan({ bitmap: i2 }, 0, 0, i2.width, i2.height, function(e6, t4, r4) {
    const n3 = i2.data[r4 + 1], a2 = i2.data[r4 + 2], o3 = i2.data[r4 + 3];
    i2.data[r4 + 0] = o3, i2.data[r4 + 1] = a2, i2.data[r4 + 2] = n3, i2.data[r4 + 3] = 255;
  }), i2;
}
function msBmp() {
  return { mime: "image/x-ms-bmp", encode: encode$1, decode: decode$1 };
}
function bmp() {
  return { mime: "image/bmp", encode: encode$1, decode: decode$1 };
}
function GifWriter(e5, t3, i2, r4) {
  var n3 = 0, a2 = void 0 === (r4 = void 0 === r4 ? {} : r4).loop ? null : r4.loop, o3 = void 0 === r4.palette ? null : r4.palette;
  if (t3 <= 0 || i2 <= 0 || t3 > 65535 || i2 > 65535) throw new Error("Width/Height invalid.");
  function s4(e6) {
    var t4 = e6.length;
    if (t4 < 2 || t4 > 256 || t4 & t4 - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
    return t4;
  }
  __name(s4, "s");
  e5[n3++] = 71, e5[n3++] = 73, e5[n3++] = 70, e5[n3++] = 56, e5[n3++] = 57, e5[n3++] = 97;
  var l2 = 0, u2 = 0;
  if (null !== o3) {
    for (var h2 = s4(o3); h2 >>= 1; ) ++l2;
    if (h2 = 1 << l2, --l2, void 0 !== r4.background) {
      if ((u2 = r4.background) >= h2) throw new Error("Background index out of range.");
      if (0 === u2) throw new Error("Background index explicitly passed as 0.");
    }
  }
  if (e5[n3++] = 255 & t3, e5[n3++] = t3 >> 8 & 255, e5[n3++] = 255 & i2, e5[n3++] = i2 >> 8 & 255, e5[n3++] = (null !== o3 ? 128 : 0) | l2, e5[n3++] = u2, e5[n3++] = 0, null !== o3) for (var c3 = 0, f2 = o3.length; c3 < f2; ++c3) {
    var d = o3[c3];
    e5[n3++] = d >> 16 & 255, e5[n3++] = d >> 8 & 255, e5[n3++] = 255 & d;
  }
  if (null !== a2) {
    if (a2 < 0 || a2 > 65535) throw new Error("Loop count invalid.");
    e5[n3++] = 33, e5[n3++] = 255, e5[n3++] = 11, e5[n3++] = 78, e5[n3++] = 69, e5[n3++] = 84, e5[n3++] = 83, e5[n3++] = 67, e5[n3++] = 65, e5[n3++] = 80, e5[n3++] = 69, e5[n3++] = 50, e5[n3++] = 46, e5[n3++] = 48, e5[n3++] = 3, e5[n3++] = 1, e5[n3++] = 255 & a2, e5[n3++] = a2 >> 8 & 255, e5[n3++] = 0;
  }
  var p2 = false;
  this.addFrame = function(t4, i3, r5, a3, l3, u3) {
    if (true === p2 && (--n3, p2 = false), u3 = void 0 === u3 ? {} : u3, t4 < 0 || i3 < 0 || t4 > 65535 || i3 > 65535) throw new Error("x/y invalid.");
    if (r5 <= 0 || a3 <= 0 || r5 > 65535 || a3 > 65535) throw new Error("Width/Height invalid.");
    if (l3.length < r5 * a3) throw new Error("Not enough pixels for the frame size.");
    var h3 = true, c4 = u3.palette;
    if (null == c4 && (h3 = false, c4 = o3), null == c4) throw new Error("Must supply either a local or global palette.");
    for (var f3 = s4(c4), d2 = 0; f3 >>= 1; ) ++d2;
    f3 = 1 << d2;
    var m = void 0 === u3.delay ? 0 : u3.delay, _2 = void 0 === u3.disposal ? 0 : u3.disposal;
    if (_2 < 0 || _2 > 3) throw new Error("Disposal out of range.");
    var g = false, b2 = 0;
    if (void 0 !== u3.transparent && null !== u3.transparent && (g = true, (b2 = u3.transparent) < 0 || b2 >= f3)) throw new Error("Transparent color index.");
    if ((0 !== _2 || g || 0 !== m) && (e5[n3++] = 33, e5[n3++] = 249, e5[n3++] = 4, e5[n3++] = _2 << 2 | (true === g ? 1 : 0), e5[n3++] = 255 & m, e5[n3++] = m >> 8 & 255, e5[n3++] = b2, e5[n3++] = 0), e5[n3++] = 44, e5[n3++] = 255 & t4, e5[n3++] = t4 >> 8 & 255, e5[n3++] = 255 & i3, e5[n3++] = i3 >> 8 & 255, e5[n3++] = 255 & r5, e5[n3++] = r5 >> 8 & 255, e5[n3++] = 255 & a3, e5[n3++] = a3 >> 8 & 255, e5[n3++] = true === h3 ? 128 | d2 - 1 : 0, true === h3) for (var y2 = 0, w = c4.length; y2 < w; ++y2) {
      var v2 = c4[y2];
      e5[n3++] = v2 >> 16 & 255, e5[n3++] = v2 >> 8 & 255, e5[n3++] = 255 & v2;
    }
    return n3 = GifWriterOutputLZWCodeStream(e5, n3, d2 < 2 ? 2 : d2, l3);
  }, this.end = function() {
    return false === p2 && (e5[n3++] = 59, p2 = true), n3;
  }, this.getOutputBuffer = function() {
    return e5;
  }, this.setOutputBuffer = function(t4) {
    e5 = t4;
  }, this.getOutputBufferPosition = function() {
    return n3;
  }, this.setOutputBufferPosition = function(e6) {
    n3 = e6;
  };
}
function GifWriterOutputLZWCodeStream(e5, t3, i2, r4) {
  e5[t3++] = i2;
  var n3 = t3++, a2 = 1 << i2, o3 = a2 - 1, s4 = a2 + 1, l2 = s4 + 1, u2 = i2 + 1, h2 = 0, c3 = 0;
  function f2(i3) {
    for (; h2 >= i3; ) e5[t3++] = 255 & c3, c3 >>= 8, h2 -= 8, t3 === n3 + 256 && (e5[n3] = 255, n3 = t3++);
  }
  __name(f2, "f");
  function d(e6) {
    c3 |= e6 << h2, h2 += u2, f2(8);
  }
  __name(d, "d");
  var p2 = r4[0] & o3, m = {};
  d(a2);
  for (var _2 = 1, g = r4.length; _2 < g; ++_2) {
    var b2 = r4[_2] & o3, y2 = p2 << 8 | b2, w = m[y2];
    if (void 0 === w) {
      for (c3 |= p2 << h2, h2 += u2; h2 >= 8; ) e5[t3++] = 255 & c3, c3 >>= 8, h2 -= 8, t3 === n3 + 256 && (e5[n3] = 255, n3 = t3++);
      4096 === l2 ? (d(a2), l2 = s4 + 1, u2 = i2 + 1, m = {}) : (l2 >= 1 << u2 && ++u2, m[y2] = l2++), p2 = b2;
    } else p2 = w;
  }
  return d(p2), d(s4), f2(1), n3 + 1 === t3 ? e5[n3] = 0 : (e5[n3] = t3 - n3 - 1, e5[t3++] = 0), t3;
}
function GifReader(e5) {
  var t3 = 0;
  if (71 !== e5[t3++] || 73 !== e5[t3++] || 70 !== e5[t3++] || 56 !== e5[t3++] || 56 != (e5[t3++] + 1 & 253) || 97 !== e5[t3++]) throw new Error("Invalid GIF 87a/89a header.");
  var i2 = e5[t3++] | e5[t3++] << 8, r4 = e5[t3++] | e5[t3++] << 8, n3 = e5[t3++], a2 = n3 >> 7, o3 = 1 << (7 & n3) + 1;
  e5[t3++], e5[t3++];
  var s4 = null, l2 = null;
  a2 && (s4 = t3, l2 = o3, t3 += 3 * o3);
  var u2 = true, h2 = [], c3 = 0, f2 = null, d = 0, p2 = null;
  for (this.width = i2, this.height = r4; u2 && t3 < e5.length; ) switch (e5[t3++]) {
    case 33:
      switch (e5[t3++]) {
        case 255:
          if (11 !== e5[t3] || 78 == e5[t3 + 1] && 69 == e5[t3 + 2] && 84 == e5[t3 + 3] && 83 == e5[t3 + 4] && 67 == e5[t3 + 5] && 65 == e5[t3 + 6] && 80 == e5[t3 + 7] && 69 == e5[t3 + 8] && 50 == e5[t3 + 9] && 46 == e5[t3 + 10] && 48 == e5[t3 + 11] && 3 == e5[t3 + 12] && 1 == e5[t3 + 13] && 0 == e5[t3 + 16]) t3 += 14, p2 = e5[t3++] | e5[t3++] << 8, t3++;
          else for (t3 += 12; ; ) {
            if (!((I = e5[t3++]) >= 0)) throw Error("Invalid block size");
            if (0 === I) break;
            t3 += I;
          }
          break;
        case 249:
          if (4 !== e5[t3++] || 0 !== e5[t3 + 4]) throw new Error("Invalid graphics extension block.");
          var m = e5[t3++];
          c3 = e5[t3++] | e5[t3++] << 8, f2 = e5[t3++], 1 & m || (f2 = null), d = m >> 2 & 7, t3++;
          break;
        case 254:
          for (; ; ) {
            if (!((I = e5[t3++]) >= 0)) throw Error("Invalid block size");
            if (0 === I) break;
            t3 += I;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + e5[t3 - 1].toString(16));
      }
      break;
    case 44:
      var _2 = e5[t3++] | e5[t3++] << 8, g = e5[t3++] | e5[t3++] << 8, b2 = e5[t3++] | e5[t3++] << 8, y2 = e5[t3++] | e5[t3++] << 8, w = e5[t3++], v2 = w >> 6 & 1, x2 = 1 << (7 & w) + 1, E2 = s4, k2 = l2, S2 = false;
      if (w >> 7) {
        S2 = true;
        E2 = t3, k2 = x2, t3 += 3 * x2;
      }
      var A2 = t3;
      for (t3++; ; ) {
        var I;
        if (!((I = e5[t3++]) >= 0)) throw Error("Invalid block size");
        if (0 === I) break;
        t3 += I;
      }
      h2.push({ x: _2, y: g, width: b2, height: y2, has_local_palette: S2, palette_offset: E2, palette_size: k2, data_offset: A2, data_length: t3 - A2, transparent_index: f2, interlaced: !!v2, delay: c3, disposal: d });
      break;
    case 59:
      u2 = false;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + e5[t3 - 1].toString(16));
  }
  this.numFrames = function() {
    return h2.length;
  }, this.loopCount = function() {
    return p2;
  }, this.frameInfo = function(e6) {
    if (e6 < 0 || e6 >= h2.length) throw new Error("Frame index out of range.");
    return h2[e6];
  }, this.decodeAndBlitFrameBGRA = function(t4, r5) {
    var n4 = this.frameInfo(t4), a3 = n4.width * n4.height, o4 = new Uint8Array(a3);
    GifReaderLZWOutputIndexStream(e5, n4.data_offset, o4, a3);
    var s5 = n4.palette_offset, l3 = n4.transparent_index;
    null === l3 && (l3 = 256);
    var u3 = n4.width, h3 = i2 - u3, c4 = u3, f3 = 4 * (n4.y * i2 + n4.x), d2 = 4 * ((n4.y + n4.height) * i2 + n4.x), p3 = f3, m2 = 4 * h3;
    true === n4.interlaced && (m2 += 4 * i2 * 7);
    for (var _3 = 8, g2 = 0, b3 = o4.length; g2 < b3; ++g2) {
      var y3 = o4[g2];
      if (0 === c4 && (c4 = u3, (p3 += m2) >= d2 && (m2 = 4 * h3 + 4 * i2 * (_3 - 1), p3 = f3 + (u3 + h3) * (_3 << 1), _3 >>= 1)), y3 === l3) p3 += 4;
      else {
        var w2 = e5[s5 + 3 * y3], v3 = e5[s5 + 3 * y3 + 1], x3 = e5[s5 + 3 * y3 + 2];
        r5[p3++] = x3, r5[p3++] = v3, r5[p3++] = w2, r5[p3++] = 255;
      }
      --c4;
    }
  }, this.decodeAndBlitFrameRGBA = function(t4, r5) {
    var n4 = this.frameInfo(t4), a3 = n4.width * n4.height, o4 = new Uint8Array(a3);
    GifReaderLZWOutputIndexStream(e5, n4.data_offset, o4, a3);
    var s5 = n4.palette_offset, l3 = n4.transparent_index;
    null === l3 && (l3 = 256);
    var u3 = n4.width, h3 = i2 - u3, c4 = u3, f3 = 4 * (n4.y * i2 + n4.x), d2 = 4 * ((n4.y + n4.height) * i2 + n4.x), p3 = f3, m2 = 4 * h3;
    true === n4.interlaced && (m2 += 4 * i2 * 7);
    for (var _3 = 8, g2 = 0, b3 = o4.length; g2 < b3; ++g2) {
      var y3 = o4[g2];
      if (0 === c4 && (c4 = u3, (p3 += m2) >= d2 && (m2 = 4 * h3 + 4 * i2 * (_3 - 1), p3 = f3 + (u3 + h3) * (_3 << 1), _3 >>= 1)), y3 === l3) p3 += 4;
      else {
        var w2 = e5[s5 + 3 * y3], v3 = e5[s5 + 3 * y3 + 1], x3 = e5[s5 + 3 * y3 + 2];
        r5[p3++] = w2, r5[p3++] = v3, r5[p3++] = x3, r5[p3++] = 255;
      }
      --c4;
    }
  };
}
function GifReaderLZWOutputIndexStream(e5, t3, i2, r4) {
  for (var n3 = e5[t3++], a2 = 1 << n3, o3 = a2 + 1, s4 = o3 + 1, l2 = n3 + 1, u2 = (1 << l2) - 1, h2 = 0, c3 = 0, f2 = 0, d = e5[t3++], p2 = new Int32Array(4096), m = null; ; ) {
    for (; h2 < 16 && 0 !== d; ) c3 |= e5[t3++] << h2, h2 += 8, 1 === d ? d = e5[t3++] : --d;
    if (h2 < l2) break;
    var _2 = c3 & u2;
    if (c3 >>= l2, h2 -= l2, _2 !== a2) {
      if (_2 === o3) break;
      for (var g = _2 < s4 ? _2 : m, b2 = 0, y2 = g; y2 > a2; ) y2 = p2[y2] >> 8, ++b2;
      var w = y2;
      if (f2 + b2 + (g !== _2 ? 1 : 0) > r4) return void console.log("Warning, gif stream longer than expected.");
      i2[f2++] = w;
      var v2 = f2 += b2;
      for (g !== _2 && (i2[f2++] = w), y2 = g; b2--; ) y2 = p2[y2], i2[--v2] = 255 & y2, y2 >>= 8;
      null !== m && s4 < 4096 && (p2[s4++] = m << 8 | w, s4 >= u2 + 1 && l2 < 12 && (++l2, u2 = u2 << 1 | 1)), m = _2;
    } else s4 = o3 + 1, u2 = (1 << (l2 = n3 + 1)) - 1, m = null;
  }
  return f2 !== r4 && console.log("Warning, gif stream shorter than expected."), i2;
}
function correctGamma$1(e5) {
  return e5 > 0.04045 ? ((e5 + 0.055) / 1.055) ** 2.4 : e5 / 12.92;
}
function rgb2xyz$1(e5, t3, i2) {
  return { x: 0.4124 * (e5 = correctGamma$1(e5 / 255)) + 0.3576 * (t3 = correctGamma$1(t3 / 255)) + 0.1805 * (i2 = correctGamma$1(i2 / 255)), y: 0.2126 * e5 + 0.7152 * t3 + 0.0722 * i2, z: 0.0193 * e5 + 0.1192 * t3 + 0.9505 * i2 };
}
function degrees2radians$1(e5) {
  return e5 * (Math.PI / 180);
}
function max3$1(e5, t3, i2) {
  let r4 = e5;
  return r4 < t3 && (r4 = t3), r4 < i2 && (r4 = i2), r4;
}
function min3$1(e5, t3, i2) {
  let r4 = e5;
  return r4 > t3 && (r4 = t3), r4 > i2 && (r4 = i2), r4;
}
function intInRange$1(e5, t3, i2) {
  return e5 > i2 && (e5 = i2), e5 < t3 && (e5 = t3), 0 | e5;
}
function inRange0to255Rounded$1(e5) {
  return (e5 = Math.round(e5)) > 255 ? e5 = 255 : e5 < 0 && (e5 = 0), e5;
}
function inRange0to255$1(e5) {
  return e5 > 255 ? e5 = 255 : e5 < 0 && (e5 = 0), e5;
}
function stableSort$1(e5, t3) {
  const i2 = typeof e5[0];
  let r4;
  if ("number" === i2 || "string" === i2) {
    const i3 = /* @__PURE__ */ Object.create(null);
    for (let t4 = 0, r5 = e5.length; t4 < r5; t4++) {
      const r6 = e5[t4];
      i3[r6] || 0 === i3[r6] || (i3[r6] = t4);
    }
    r4 = e5.sort((e6, r5) => t3(e6, r5) || i3[e6] - i3[r5]);
  } else {
    const i3 = e5.slice(0);
    r4 = e5.sort((e6, r5) => t3(e6, r5) || i3.indexOf(e6) - i3.indexOf(r5));
  }
  return r4;
}
function rgb2hsl$1(e5, t3, i2) {
  const r4 = min3$1(e5, t3, i2), n3 = max3$1(e5, t3, i2), a2 = n3 - r4, o3 = (r4 + n3) / 510;
  let s4 = 0;
  o3 > 0 && o3 < 1 && (s4 = a2 / (o3 < 0.5 ? n3 + r4 : 510 - n3 - r4));
  let l2 = 0;
  return a2 > 0 && (l2 = n3 === e5 ? (t3 - i2) / a2 : n3 === t3 ? 2 + (i2 - e5) / a2 : 4 + (e5 - t3) / a2, l2 *= 60, l2 < 0 && (l2 += 360)), { h: l2, s: s4, l: o3 };
}
function pivot$1(e5) {
  return e5 > 8856e-6 ? e5 ** (1 / 3) : 7.787 * e5 + 16 / 116;
}
function xyz2lab$1(e5, t3, i2) {
  if (e5 = pivot$1(e5 / refX$1), t3 = pivot$1(t3 / refY$1), i2 = pivot$1(i2 / refZ$1), 116 * t3 - 16 < 0) throw new Error("xxx");
  return { L: Math.max(0, 116 * t3 - 16), a: 500 * (e5 - t3), b: 200 * (t3 - i2) };
}
function rgb2lab$1(e5, t3, i2) {
  const r4 = rgb2xyz$1(e5, t3, i2);
  return xyz2lab$1(r4.x, r4.y, r4.z);
}
function pivot2$1(e5) {
  return e5 > 0.206893034 ? e5 ** 3 : (e5 - 16 / 116) / 7.787;
}
function lab2xyz$1(e5, t3, i2) {
  const r4 = (e5 + 16) / 116, n3 = r4 - i2 / 200;
  return { x: refX2$1 * pivot2$1(t3 / 500 + r4), y: refY2$1 * pivot2$1(r4), z: refZ2$1 * pivot2$1(n3) };
}
function correctGamma2$1(e5) {
  return e5 > 31308e-7 ? 1.055 * e5 ** (1 / 2.4) - 0.055 : 12.92 * e5;
}
function xyz2rgb$1(e5, t3, i2) {
  const r4 = correctGamma2$1(3.2406 * e5 + -1.5372 * t3 + -0.4986 * i2), n3 = correctGamma2$1(-0.9689 * e5 + 1.8758 * t3 + 0.0415 * i2), a2 = correctGamma2$1(0.0557 * e5 + -0.204 * t3 + 1.057 * i2);
  return { r: inRange0to255Rounded$1(255 * r4), g: inRange0to255Rounded$1(255 * n3), b: inRange0to255Rounded$1(255 * a2) };
}
function lab2rgb$1(e5, t3, i2) {
  const r4 = lab2xyz$1(e5, t3, i2);
  return xyz2rgb$1(r4.x, r4.y, r4.z);
}
function hueGroup$1(e5, t3) {
  const i2 = 360 / t3;
  for (let r4 = 1, n3 = i2 - i2 / 2; r4 < t3; r4++, n3 += i2) if (e5 >= n3 && e5 < n3 + i2) return r4;
  return 0;
}
function createArray1D$1(e5) {
  const t3 = [];
  for (let i2 = 0; i2 < e5; i2++) t3[i2] = 0;
  return t3;
}
function createArray4D$1(e5, t3, i2, r4) {
  const n3 = new Array(e5);
  for (let a2 = 0; a2 < e5; a2++) {
    n3[a2] = new Array(t3);
    for (let e6 = 0; e6 < t3; e6++) {
      n3[a2][e6] = new Array(i2);
      for (let t4 = 0; t4 < i2; t4++) {
        n3[a2][e6][t4] = new Array(r4);
        for (let i3 = 0; i3 < r4; i3++) n3[a2][e6][t4][i3] = 0;
      }
    }
  }
  return n3;
}
function createArray3D$1(e5, t3, i2) {
  const r4 = new Array(e5);
  for (let n3 = 0; n3 < e5; n3++) {
    r4[n3] = new Array(t3);
    for (let e6 = 0; e6 < t3; e6++) {
      r4[n3][e6] = new Array(i2);
      for (let t4 = 0; t4 < i2; t4++) r4[n3][e6][t4] = 0;
    }
  }
  return r4;
}
function fillArray3D$1(e5, t3, i2, r4, n3) {
  for (let a2 = 0; a2 < t3; a2++) {
    e5[a2] = [];
    for (let t4 = 0; t4 < i2; t4++) {
      e5[a2][t4] = [];
      for (let i3 = 0; i3 < r4; i3++) e5[a2][t4][i3] = n3;
    }
  }
}
function fillArray1D$1(e5, t3, i2) {
  for (let r4 = 0; r4 < t3; r4++) e5[r4] = i2;
}
function* hilbertCurve$1(e5, t3, i2) {
  const r4 = Math.max(e5, t3), n3 = { width: e5, height: t3, level: Math.floor(Math.log(r4) / Math.log(2) + 1), callback: i2, tracker: new ProgressTracker$1(e5 * t3, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert$1(n3, 1), visit$1(n3, 0);
}
function* walkHilbert$1(e5, t3) {
  if (!(e5.level < 1)) {
    switch (e5.tracker.shouldNotify(e5.index) && (yield { progress: e5.tracker.progress }), e5.level--, t3) {
      case 2:
        yield* walkHilbert$1(e5, 1), visit$1(e5, 3), yield* walkHilbert$1(e5, 2), visit$1(e5, 4), yield* walkHilbert$1(e5, 2), visit$1(e5, 2), yield* walkHilbert$1(e5, 4);
        break;
      case 3:
        yield* walkHilbert$1(e5, 4), visit$1(e5, 2), yield* walkHilbert$1(e5, 3), visit$1(e5, 1), yield* walkHilbert$1(e5, 3), visit$1(e5, 3), yield* walkHilbert$1(e5, 1);
        break;
      case 1:
        yield* walkHilbert$1(e5, 2), visit$1(e5, 4), yield* walkHilbert$1(e5, 1), visit$1(e5, 3), yield* walkHilbert$1(e5, 1), visit$1(e5, 1), yield* walkHilbert$1(e5, 3);
        break;
      case 4:
        yield* walkHilbert$1(e5, 3), visit$1(e5, 1), yield* walkHilbert$1(e5, 4), visit$1(e5, 2), yield* walkHilbert$1(e5, 4), visit$1(e5, 4), yield* walkHilbert$1(e5, 2);
    }
    e5.level++;
  }
}
function visit$1(e5, t3) {
  switch (e5.x >= 0 && e5.x < e5.width && e5.y >= 0 && e5.y < e5.height && (e5.callback(e5.x, e5.y), e5.index++), t3) {
    case 2:
      e5.x--;
      break;
    case 3:
      e5.x++;
      break;
    case 1:
      e5.y--;
      break;
    case 4:
      e5.y++;
  }
}
function ssim$1(e5, t3) {
  if (e5.getHeight() !== t3.getHeight() || e5.getWidth() !== t3.getWidth()) throw new Error("Images have different sizes!");
  const i2 = (255 * K1$1) ** 2, r4 = (255 * K2$1) ** 2;
  let n3 = 0, a2 = 0;
  return iterate$1(e5, t3, (e6, t4, o3, s4) => {
    let l2 = 0, u2 = 0, h2 = 0;
    for (let i3 = 0; i3 < e6.length; i3++) u2 += (e6[i3] - o3) ** 2, h2 += (t4[i3] - s4) ** 2, l2 += (e6[i3] - o3) * (t4[i3] - s4);
    const c3 = e6.length - 1;
    u2 /= c3, h2 /= c3, l2 /= c3;
    a2 += (2 * o3 * s4 + i2) * (2 * l2 + r4) / ((o3 ** 2 + s4 ** 2 + i2) * (u2 + h2 + r4)), n3++;
  }), a2 / n3;
}
function iterate$1(e5, t3, i2) {
  const r4 = e5.getWidth(), n3 = e5.getHeight();
  for (let a2 = 0; a2 < n3; a2 += 8) for (let o3 = 0; o3 < r4; o3 += 8) {
    const s4 = Math.min(8, r4 - o3), l2 = Math.min(8, n3 - a2), u2 = calculateLumaValuesForWindow$1(e5, o3, a2, s4, l2), h2 = calculateLumaValuesForWindow$1(t3, o3, a2, s4, l2);
    i2(u2, h2, calculateAverageLuma$1(u2), calculateAverageLuma$1(h2));
  }
}
function calculateLumaValuesForWindow$1(e5, t3, i2, r4, n3) {
  const a2 = e5.getPointArray(), o3 = [];
  let s4 = 0;
  for (let l2 = i2; l2 < i2 + n3; l2++) {
    const i3 = l2 * e5.getWidth();
    for (let e6 = t3; e6 < t3 + r4; e6++) {
      const t4 = a2[i3 + e6];
      o3[s4] = 0.2126 * t4.r + 0.7152 * t4.g + 0.0722 * t4.b, s4++;
    }
  }
  return o3;
}
function calculateAverageLuma$1(e5) {
  let t3 = 0;
  for (const i2 of e5) t3 += i2;
  return t3 / e5.length;
}
function buildPaletteSync$1(e5, { colorDistanceFormula: t3, paletteQuantization: i2, colors: r4 } = {}) {
  const n3 = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(t3), i2, r4);
  return e5.forEach((e6) => n3.sample(e6)), n3.quantizeSync();
}
async function buildPalette(e5, { colorDistanceFormula: t3, paletteQuantization: i2, colors: r4, onProgress: n3 } = {}) {
  return new Promise((a2, o3) => {
    const s4 = paletteQuantizationToPaletteQuantizer$1(colorDistanceFormulaToColorDistance$1(t3), i2, r4);
    let l2;
    e5.forEach((e6) => s4.sample(e6));
    const u2 = s4.quantize(), h2 = /* @__PURE__ */ __name(() => {
      try {
        const e6 = u2.next();
        e6.done ? a2(l2) : (e6.value.palette && (l2 = e6.value.palette), n3 && n3(e6.value.progress), setImmediateImpl(h2));
      } catch (e6) {
        o3(e6);
      }
    }, "h");
    setImmediateImpl(h2);
  });
}
function applyPaletteSync$1(e5, t3, { colorDistanceFormula: i2, imageQuantization: r4 } = {}) {
  return imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(i2), r4).quantizeSync(e5, t3);
}
async function applyPalette(e5, t3, { colorDistanceFormula: i2, imageQuantization: r4, onProgress: n3 } = {}) {
  return new Promise((a2, o3) => {
    let s4;
    const l2 = imageQuantizationToImageQuantizer$1(colorDistanceFormulaToColorDistance$1(i2), r4).quantize(e5, t3), u2 = /* @__PURE__ */ __name(() => {
      try {
        const e6 = l2.next();
        e6.done ? a2(s4) : (e6.value.pointContainer && (s4 = e6.value.pointContainer), n3 && n3(e6.value.progress), setImmediateImpl(u2));
      } catch (e6) {
        o3(e6);
      }
    }, "u");
    setImmediateImpl(u2);
  });
}
function colorDistanceFormulaToColorDistance$1(e5 = "euclidean-bt709") {
  switch (e5) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts$1();
    case "cie94-textiles":
      return new CIE94Textiles$1();
    case "ciede2000":
      return new CIEDE2000$1();
    case "color-metric":
      return new CMetric$1();
    case "euclidean":
      return new Euclidean$1();
    case "euclidean-bt709":
      return new EuclideanBT709$1();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha$1();
    case "manhattan":
      return new Manhattan$1();
    case "manhattan-bt709":
      return new ManhattanBT709$1();
    case "manhattan-nommyde":
      return new ManhattanNommyde$1();
    case "pngquant":
      return new PNGQuant$1();
    default:
      throw new Error(`Unknown colorDistanceFormula ${e5}`);
  }
}
function imageQuantizationToImageQuantizer$1(e5, t3 = "floyd-steinberg") {
  switch (t3) {
    case "nearest":
      return new NearestColor$1(e5);
    case "riemersma":
      return new ErrorDiffusionRiemersma$1(e5);
    case "floyd-steinberg":
      return new ErrorDiffusionArray$1(e5, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray$1(e5, 1);
    case "stucki":
      return new ErrorDiffusionArray$1(e5, 2);
    case "atkinson":
      return new ErrorDiffusionArray$1(e5, 3);
    case "jarvis":
      return new ErrorDiffusionArray$1(e5, 4);
    case "burkes":
      return new ErrorDiffusionArray$1(e5, 5);
    case "sierra":
      return new ErrorDiffusionArray$1(e5, 6);
    case "two-sierra":
      return new ErrorDiffusionArray$1(e5, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray$1(e5, 8);
    default:
      throw new Error(`Unknown imageQuantization ${t3}`);
  }
}
function paletteQuantizationToPaletteQuantizer$1(e5, t3 = "wuquant", i2 = 256) {
  switch (t3) {
    case "neuquant":
      return new NeuQuant$1(e5, i2);
    case "rgbquant":
      return new RGBQuant$1(e5, i2);
    case "wuquant":
      return new WuQuant$1(e5, i2);
    case "neuquant-float":
      return new NeuQuantFloat$1(e5, i2);
    default:
      throw new Error(`Unknown paletteQuantization ${t3}`);
  }
}
function requireGifutil() {
  return hasRequiredGifutil || (hasRequiredGifutil = 1, function(e5) {
    const t3 = require$$0, i2 = imageQ, r4 = bitmapimage, { GifFrame: n3 } = gifframe, { GifError: a2 } = gif$1, { GifCodec: o3 } = requireGifcodec(), s4 = [".jpg", ".jpeg", ".png", ".bmp"], l2 = new o3();
    function u2(e6, t4, r5, n4, a3) {
      const o4 = Array.isArray(e6) ? e6 : [e6];
      if (a3) {
        if (["FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite"].indexOf(a3.ditherAlgorithm) < 0) throw new Error(`Invalid ditherAlgorithm '${a3.ditherAlgorithm}'`);
        void 0 === a3.serpentine && (a3.serpentine = true), void 0 === a3.minimumColorDistanceToDither && (a3.minimumColorDistanceToDither = 0), void 0 === a3.calculateErrorLikeGIMP && (a3.calculateErrorLikeGIMP = false);
      }
      const s5 = new i2.distance.Euclidean(), l3 = new i2.palette[t4](s5, r5, n4);
      let u3;
      u3 = a3 ? new i2.image.ErrorDiffusionArray(s5, i2.image.ErrorDiffusionArrayKernel[a3.ditherAlgorithm], a3.serpentine, a3.minimumColorDistanceToDither, a3.calculateErrorLikeGIMP) : new i2.image.NearestColor(s5);
      const h2 = [];
      o4.forEach((e7) => {
        const t5 = e7.bitmap.data, r6 = new ArrayBuffer(t5.length), n5 = new Uint32Array(r6);
        for (let e8 = 0, i3 = 0; e8 < t5.length; e8 += 4, ++i3) n5[i3] = t5.readUInt32LE(e8, true);
        const a4 = i2.utils.PointContainer.fromUint32Array(n5, e7.bitmap.width, e7.bitmap.height);
        l3.sample(a4), h2.push(a4);
      });
      const c3 = l3.quantizeSync();
      for (let e7 = 0; e7 < o4.length; ++e7) {
        const t5 = o4[e7].bitmap.data, i3 = u3.quantizeSync(h2[e7], c3).toUint32Array();
        for (let e8 = 0, r6 = 0; e8 < t5.length; e8 += 4, ++r6) t5.writeUInt32LE(i3[r6], e8);
      }
    }
    __name(u2, "u");
    e5.cloneFrames = function(e6) {
      let t4 = [];
      return e6.forEach((e7) => {
        t4.push(new n3(e7));
      }), t4;
    }, e5.getColorInfo = function(e6, t4) {
      let i3 = false;
      const r5 = [];
      for (let t5 = 0; t5 < e6.length; ++t5) {
        let n5 = e6[t5].getPalette();
        if (n5.usesTransparency && (i3 = true), n5.indexCount > 256) throw new a2(`Frame ${t5} uses more than 256 color indexes`);
        r5.push(n5);
      }
      if (0 === t4) return { usesTransparency: i3, palettes: r5 };
      const n4 = /* @__PURE__ */ new Set();
      r5.forEach((e7) => {
        e7.colors.forEach((e8) => {
          n4.add(e8);
        });
      });
      let o4 = n4.size;
      if (i3 && ++o4, t4 && o4 > t4) return { usesTransparency: i3, palettes: r5 };
      const s5 = new Array(n4.size), l3 = n4.values();
      for (let e7 = 0; e7 < s5.length; ++e7) s5[e7] = l3.next().value;
      return s5.sort((e7, t5) => e7 - t5), { colors: s5, indexCount: o4, usesTransparency: i3, palettes: r5 };
    }, e5.copyAsJimp = function(t4, i3) {
      return e5.shareAsJimp(t4, new r4(i3));
    }, e5.getMaxDimensions = function(e6) {
      let t4 = 0, i3 = 0;
      return e6.forEach((e7) => {
        const r5 = e7.xOffset + e7.bitmap.width;
        r5 > t4 && (t4 = r5);
        const n4 = e7.yOffset + e7.bitmap.height;
        n4 > i3 && (i3 = n4);
      }), { maxWidth: t4, maxHeight: i3 };
    }, e5.quantizeDekker = function(e6, t4, i3) {
      u2(e6, "NeuQuantFloat", t4 = t4 || 256, 0, i3);
    }, e5.quantizeSorokin = function(e6, t4, i3, r5) {
      let n4;
      switch (t4 = t4 || 256, i3 = i3 || "min-pop") {
        case "min-pop":
          n4 = 2;
          break;
        case "top-pop":
          n4 = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${i3}'`);
      }
      u2(e6, "RGBQuant", t4, n4, r5);
    }, e5.quantizeWu = function(e6, t4, i3, r5) {
      if (t4 = t4 || 256, (i3 = i3 || 5) < 1 || i3 > 8) throw new Error("Invalid quantization quality");
      u2(e6, "WuQuant", t4, i3, r5);
    }, e5.read = function(e6, i3) {
      return i3 = i3 || l2, Buffer2.isBuffer(e6) ? i3.decodeGif(e6) : function(e7) {
        return new Promise((i4, r5) => {
          t3.readFile(e7, (e8, t4) => e8 ? r5(e8) : i4(t4));
        });
      }(e6).then((e7) => i3.decodeGif(e7));
    }, e5.shareAsJimp = function(e6, t4) {
      const i3 = new e6(t4.bitmap.width, t4.bitmap.height, 0);
      return i3.bitmap.data = t4.bitmap.data, i3;
    }, e5.write = function(e6, i3, r5, n4) {
      n4 = n4 || l2;
      const a3 = e6.match(/\.[a-zA-Z]+$/);
      if (null !== a3 && s4.includes(a3[0].toLowerCase())) throw new Error(`GIF '${e6}' has an unexpected suffix`);
      return n4.encodeGif(i3, r5).then((i4) => function(e7, i5) {
        return new Promise((r6, n5) => {
          t3.writeFile(e7, i5, (e8) => e8 ? n5(e8) : r6());
        });
      }(e6, i4.buffer).then(() => i4));
    };
  }(gifutil)), gifutil;
}
function requireGifcodec() {
  if (hasRequiredGifcodec) return gifcodec;
  hasRequiredGifcodec = 1;
  const e5 = omggif, { Gif: t3, GifError: i2 } = gif$1;
  function r4() {
    const e6 = requireGifutil();
    return r4 = /* @__PURE__ */ __name(function() {
      return e6;
    }, "r"), e6;
  }
  __name(r4, "r");
  const { GifFrame: n3 } = gifframe;
  function a2(e6, t4) {
    const i3 = e6.indexOf(t4);
    return -1 === i3 ? null : i3;
  }
  __name(a2, "a");
  function o3(e6, t4) {
    for (var i3, r5 = 0, n4 = e6.length - 1; r5 <= n4; ) if (e6[i3 = Math.floor((r5 + n4) / 2)] > t4) n4 = i3 - 1;
    else {
      if (!(e6[i3] < t4)) return i3;
      r5 = i3 + 1;
    }
    return null;
  }
  __name(o3, "o");
  function s4(e6) {
    const t4 = e6.colors;
    e6.usesTransparency && t4.push(0);
    const i3 = t4.length;
    let r5 = 2;
    for (; i3 > r5; ) r5 <<= 1;
    t4.length = r5, t4.fill(0, i3);
  }
  __name(s4, "s");
  function l2(e6, t4) {
    let i3 = e6.bitmap.width * e6.bitmap.height;
    return i3 = Math.ceil(i3 * t4 / 8), i3 += Math.ceil(i3 / 255), 100 + i3 + 768;
  }
  __name(l2, "l");
  function u2(e6) {
    let t4 = e6.indexCount, i3 = 0;
    for (--t4; t4; ) ++i3, t4 >>= 1;
    return i3 > 0 ? i3 : 1;
  }
  __name(u2, "u");
  function h2(e6, t4, r5, n4, l3) {
    if (r5.interlaced) throw new i2("writing interlaced GIFs is not supported");
    const u3 = function(e7, t5, r6) {
      const n5 = r6.colors, s5 = n5.length <= 8 ? a2 : o3, l4 = t5.bitmap.data, u4 = new Buffer2(l4.length / 4);
      let h4 = n5.length, c3 = 0, f2 = 0;
      for (; c3 < l4.length; ) {
        if (0 !== l4[c3 + 3]) {
          const e8 = l4.readUInt32BE(c3, true) >> 8 & 16777215;
          u4[f2] = s5(n5, e8);
        } else u4[f2] = h4;
        c3 += 4, ++f2;
      }
      if (r6.usesTransparency) {
        if (256 === h4) throw new i2(`Frame ${e7} already has 256 colorsand so can't use transparency`);
      } else h4 = null;
      return { buffer: u4, transparentIndex: h4 };
    }(t4, r5, n4), h3 = { delay: r5.delayCentisecs, disposal: r5.disposalMethod, transparent: u3.transparentIndex };
    l3 && (s4(n4), h3.palette = n4.colors);
    try {
      let t5, i3 = e6.getOutputBuffer(), n5 = e6.getOutputBufferPosition(), a3 = true;
      for (; a3; ) if (t5 = e6.addFrame(r5.xOffset, r5.yOffset, r5.bitmap.width, r5.bitmap.height, u3.buffer, h3), a3 = false, t5 >= i3.length - 1) {
        const t6 = new Buffer2(1.5 * i3.length);
        i3.copy(t6), e6.setOutputBuffer(t6), e6.setOutputBufferPosition(n5), i3 = t6, a3 = true;
      }
      return i3;
    } catch (e7) {
      throw new i2(e7);
    }
  }
  __name(h2, "h");
  return gifcodec.GifCodec = class {
    constructor(e6 = {}) {
      this._transparentRGB = null, "number" == typeof e6.transparentRGB && 0 !== e6.transparentRGB && (this._transparentRGBA = 256 * e6.transparentRGB), this._testInitialBufferSize = 0;
    }
    decodeGif(r5) {
      try {
        let n4;
        try {
          n4 = new e5.GifReader(r5);
        } catch (e6) {
          throw new i2(e6);
        }
        const a3 = n4.numFrames(), o4 = [], s5 = { width: n4.width, height: n4.height, loops: n4.loopCount(), usesTransparency: false };
        for (let e6 = 0; e6 < a3; ++e6) {
          const t4 = this._decodeFrame(n4, e6, s5.usesTransparency);
          o4.push(t4.frame), t4.usesTransparency && (s5.usesTransparency = true);
        }
        return Promise.resolve(new t3(r5, o4, s5));
      } catch (e6) {
        return Promise.reject(e6);
      }
    }
    encodeGif(e6, n4 = {}) {
      try {
        if (null === e6 || 0 === e6.length) throw new i2("there are no frames");
        const a3 = r4().getMaxDimensions(e6);
        return (n4 = Object.assign({}, n4)).width = a3.maxWidth, n4.height = a3.maxHeight, void 0 === n4.loops && (n4.loops = 0), n4.colorScope = n4.colorScope || t3.GlobalColorsPreferred, Promise.resolve(this._encodeGif(e6, n4));
      } catch (e7) {
        return Promise.reject(e7);
      }
    }
    _decodeFrame(e6, t4, r5) {
      let a3, o4;
      try {
        if (a3 = e6.frameInfo(t4), o4 = new Buffer2(e6.width * e6.height * 4), e6.decodeAndBlitFrameRGBA(t4, o4), a3.width !== e6.width || a3.height !== e6.height) {
          if (a3.y && (o4 = o4.slice(a3.y * e6.width * 4)), e6.width > a3.width) for (let t5 = 0; t5 < a3.height; ++t5) o4.copy(o4, t5 * a3.width * 4, 4 * (a3.x + t5 * e6.width), 4 * (a3.x + t5 * e6.width) + 4 * a3.width);
          o4 = o4.slice(0, a3.width * a3.height * 4);
        }
      } catch (e7) {
        throw new i2(e7);
      }
      let s5 = false;
      if (null === this._transparentRGBA) {
        if (!r5) for (let e7 = 3; e7 < o4.length; e7 += 4) 0 === o4[e7] && (s5 = true, e7 = o4.length);
      } else for (let e7 = 3; e7 < o4.length; e7 += 4) 0 === o4[e7] && (o4.writeUInt32BE(this._transparentRGBA, e7 - 3), s5 = true);
      return { frame: new n3(a3.width, a3.height, o4, { xOffset: a3.x, yOffset: a3.y, disposalMethod: a3.disposal, interlaced: a3.interlaced, delayCentisecs: a3.delay }), usesTransparency: s5 };
    }
    _encodeGif(n4, a3) {
      let o4;
      if (a3.colorScope === t3.LocalColorsOnly) o4 = r4().getColorInfo(n4, 0);
      else if (o4 = r4().getColorInfo(n4, 256), !o4.colors) {
        if (a3.colorScope === t3.GlobalColorsOnly) throw new i2("Too many color indexes for global color table");
        a3.colorScope = t3.LocalColorsOnly;
      }
      a3.usesTransparency = o4.usesTransparency;
      const l3 = o4.palettes;
      if (a3.colorScope === t3.LocalColorsOnly) {
        return function(r5, n5, a4, o5) {
          const s5 = { loop: n5.loops };
          let l4, u3 = new Buffer2(a4);
          try {
            l4 = new e5.GifWriter(u3, n5.width, n5.height, s5);
          } catch (e6) {
            throw new i2(e6);
          }
          for (let e6 = 0; e6 < r5.length; ++e6) u3 = h2(l4, e6, r5[e6], o5[e6], true);
          return new t3(u3.slice(0, l4.end()), r5, n5);
        }(n4, a3, 2e3, l3);
      }
      return function(r5, n5, a4, o5) {
        const l4 = { colors: o5.colors.slice(), usesTransparency: o5.usesTransparency };
        s4(l4);
        const u3 = { palette: l4.colors, loop: n5.loops };
        let c3, f2 = new Buffer2(a4);
        try {
          c3 = new e5.GifWriter(f2, n5.width, n5.height, u3);
        } catch (e6) {
          throw new i2(e6);
        }
        for (let e6 = 0; e6 < r5.length; ++e6) f2 = h2(c3, e6, r5[e6], o5, false);
        return new t3(f2.slice(0, c3.end()), r5, n5);
      }(n4, a3, 2e3, o4);
    }
    _getSizeEstimateGlobal(e6, t4) {
      if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
      let i3 = 968;
      const r5 = u2(e6);
      return t4.forEach((e7) => {
        i3 += l2(e7, r5);
      }), i3;
    }
    _getSizeEstimateLocal(e6, t4) {
      if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
      let i3 = 200;
      for (let r5 = 0; r5 < t4.length; ++r5) {
        const n4 = u2(e6[r5]);
        i3 += l2(t4[r5], n4);
      }
      return i3;
    }
  }, gifcodec;
}
function gif() {
  return { mime: "image/gif", encode: /* @__PURE__ */ __name(async (e5) => {
    const t3 = new src.BitmapImage(e5);
    src.GifUtil.quantizeDekker(t3, 256);
    const i2 = new src.GifFrame(e5), r4 = new src.GifCodec();
    return (await r4.encodeGif([i2], {})).buffer;
  }, "encode"), decode: /* @__PURE__ */ __name((e5) => {
    const t3 = new omggif.GifReader(e5), i2 = Buffer2.alloc(t3.width * t3.height * 4);
    return t3.decodeAndBlitFrameRGBA(0, i2), { data: i2, width: t3.width, height: t3.height };
  }, "decode") };
}
function jpeg$2() {
  return { mime: "image/jpeg", encode: /* @__PURE__ */ __name((e5, { quality: t3 = 100 } = {}) => JPEG.encode(e5, t3).data, "encode"), decode: /* @__PURE__ */ __name((e5, t3) => JPEG.decode(e5, t3), "decode") };
}
function commonjsRequire(e5) {
  throw new Error('Could not dynamically require "' + e5 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function png() {
  return { mime: "image/png", hasAlpha: true, encode: /* @__PURE__ */ __name((e5, { deflateLevel: t3 = 9, deflateStrategy: i2 = 3, filterType: r4 = PNGFilterType.AUTO, colorType: n3, inputHasAlpha: a2 = true, ...o3 } = {}) => {
    const s4 = new browserExports.PNG({ width: e5.width, height: e5.height });
    return s4.data = e5.data, browserExports.PNG.sync.write(s4, { ...o3, deflateLevel: t3, deflateStrategy: i2, filterType: r4, colorType: void 0 !== n3 ? n3 : a2 ? PNGColorType.COLOR_ALPHA : PNGColorType.COLOR, inputHasAlpha: a2 });
  }, "encode"), decode: /* @__PURE__ */ __name((e5, t3) => {
    const i2 = browserExports.PNG.sync.read(e5, t3);
    return { data: i2.data, width: i2.width, height: i2.height };
  }, "decode") };
}
function requireCommon() {
  return hasRequiredCommon || (hasRequiredCommon = 1, function(e5) {
    var t3 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
    function i2(e6, t4) {
      return Object.prototype.hasOwnProperty.call(e6, t4);
    }
    __name(i2, "i");
    e5.assign = function(e6) {
      for (var t4 = Array.prototype.slice.call(arguments, 1); t4.length; ) {
        var r5 = t4.shift();
        if (r5) {
          if ("object" != typeof r5) throw new TypeError(r5 + "must be non-object");
          for (var n4 in r5) i2(r5, n4) && (e6[n4] = r5[n4]);
        }
      }
      return e6;
    }, e5.shrinkBuf = function(e6, t4) {
      return e6.length === t4 ? e6 : e6.subarray ? e6.subarray(0, t4) : (e6.length = t4, e6);
    };
    var r4 = { arraySet: /* @__PURE__ */ __name(function(e6, t4, i3, r5, n4) {
      if (t4.subarray && e6.subarray) e6.set(t4.subarray(i3, i3 + r5), n4);
      else for (var a2 = 0; a2 < r5; a2++) e6[n4 + a2] = t4[i3 + a2];
    }, "arraySet"), flattenChunks: /* @__PURE__ */ __name(function(e6) {
      var t4, i3, r5, n4, a2, o3;
      for (r5 = 0, t4 = 0, i3 = e6.length; t4 < i3; t4++) r5 += e6[t4].length;
      for (o3 = new Uint8Array(r5), n4 = 0, t4 = 0, i3 = e6.length; t4 < i3; t4++) a2 = e6[t4], o3.set(a2, n4), n4 += a2.length;
      return o3;
    }, "flattenChunks") }, n3 = { arraySet: /* @__PURE__ */ __name(function(e6, t4, i3, r5, n4) {
      for (var a2 = 0; a2 < r5; a2++) e6[n4 + a2] = t4[i3 + a2];
    }, "arraySet"), flattenChunks: /* @__PURE__ */ __name(function(e6) {
      return [].concat.apply([], e6);
    }, "flattenChunks") };
    e5.setTyped = function(t4) {
      t4 ? (e5.Buf8 = Uint8Array, e5.Buf16 = Uint16Array, e5.Buf32 = Int32Array, e5.assign(e5, r4)) : (e5.Buf8 = Array, e5.Buf16 = Array, e5.Buf32 = Array, e5.assign(e5, n3));
    }, e5.setTyped(t3);
  }(common)), common;
}
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var e5 = requireCommon(), t3 = 0, i2 = 1;
  function r4(e6) {
    for (var t4 = e6.length; --t4 >= 0; ) e6[t4] = 0;
  }
  __name(r4, "r");
  var n3 = 0, a2 = 29, o3 = 256, s4 = o3 + 1 + a2, l2 = 30, u2 = 19, h2 = 2 * s4 + 1, c3 = 15, f2 = 16, d = 7, p2 = 256, m = 16, _2 = 17, g = 18, b2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], y2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], v2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], x2 = new Array(2 * (s4 + 2));
  r4(x2);
  var E2 = new Array(2 * l2);
  r4(E2);
  var k2 = new Array(512);
  r4(k2);
  var S2 = new Array(256);
  r4(S2);
  var A2 = new Array(a2);
  r4(A2);
  var I, M2, T2, P = new Array(l2);
  function B2(e6, t4, i3, r5, n4) {
    this.static_tree = e6, this.extra_bits = t4, this.extra_base = i3, this.elems = r5, this.max_length = n4, this.has_stree = e6 && e6.length;
  }
  __name(B2, "B");
  function C2(e6, t4) {
    this.dyn_tree = e6, this.max_code = 0, this.stat_desc = t4;
  }
  __name(C2, "C");
  function R2(e6) {
    return e6 < 256 ? k2[e6] : k2[256 + (e6 >>> 7)];
  }
  __name(R2, "R");
  function z2(e6, t4) {
    e6.pending_buf[e6.pending++] = 255 & t4, e6.pending_buf[e6.pending++] = t4 >>> 8 & 255;
  }
  __name(z2, "z");
  function F(e6, t4, i3) {
    e6.bi_valid > f2 - i3 ? (e6.bi_buf |= t4 << e6.bi_valid & 65535, z2(e6, e6.bi_buf), e6.bi_buf = t4 >> f2 - e6.bi_valid, e6.bi_valid += i3 - f2) : (e6.bi_buf |= t4 << e6.bi_valid & 65535, e6.bi_valid += i3);
  }
  __name(F, "F");
  function N2(e6, t4, i3) {
    F(e6, i3[2 * t4], i3[2 * t4 + 1]);
  }
  __name(N2, "N");
  function O2(e6, t4) {
    var i3 = 0;
    do {
      i3 |= 1 & e6, e6 >>>= 1, i3 <<= 1;
    } while (--t4 > 0);
    return i3 >>> 1;
  }
  __name(O2, "O");
  function D(e6, t4, i3) {
    var r5, n4, a3 = new Array(c3 + 1), o4 = 0;
    for (r5 = 1; r5 <= c3; r5++) a3[r5] = o4 = o4 + i3[r5 - 1] << 1;
    for (n4 = 0; n4 <= t4; n4++) {
      var s5 = e6[2 * n4 + 1];
      0 !== s5 && (e6[2 * n4] = O2(a3[s5]++, s5));
    }
  }
  __name(D, "D");
  function $(e6) {
    var t4;
    for (t4 = 0; t4 < s4; t4++) e6.dyn_ltree[2 * t4] = 0;
    for (t4 = 0; t4 < l2; t4++) e6.dyn_dtree[2 * t4] = 0;
    for (t4 = 0; t4 < u2; t4++) e6.bl_tree[2 * t4] = 0;
    e6.dyn_ltree[2 * p2] = 1, e6.opt_len = e6.static_len = 0, e6.last_lit = e6.matches = 0;
  }
  __name($, "$");
  function L2(e6) {
    e6.bi_valid > 8 ? z2(e6, e6.bi_buf) : e6.bi_valid > 0 && (e6.pending_buf[e6.pending++] = e6.bi_buf), e6.bi_buf = 0, e6.bi_valid = 0;
  }
  __name(L2, "L");
  function U(e6, t4, i3, r5) {
    var n4 = 2 * t4, a3 = 2 * i3;
    return e6[n4] < e6[a3] || e6[n4] === e6[a3] && r5[t4] <= r5[i3];
  }
  __name(U, "U");
  function Z(e6, t4, i3) {
    for (var r5 = e6.heap[i3], n4 = i3 << 1; n4 <= e6.heap_len && (n4 < e6.heap_len && U(t4, e6.heap[n4 + 1], e6.heap[n4], e6.depth) && n4++, !U(t4, r5, e6.heap[n4], e6.depth)); ) e6.heap[i3] = e6.heap[n4], i3 = n4, n4 <<= 1;
    e6.heap[i3] = r5;
  }
  __name(Z, "Z");
  function j(e6, t4, i3) {
    var r5, n4, a3, s5, l3 = 0;
    if (0 !== e6.last_lit) do {
      r5 = e6.pending_buf[e6.d_buf + 2 * l3] << 8 | e6.pending_buf[e6.d_buf + 2 * l3 + 1], n4 = e6.pending_buf[e6.l_buf + l3], l3++, 0 === r5 ? N2(e6, n4, t4) : (N2(e6, (a3 = S2[n4]) + o3 + 1, t4), 0 !== (s5 = b2[a3]) && F(e6, n4 -= A2[a3], s5), N2(e6, a3 = R2(--r5), i3), 0 !== (s5 = y2[a3]) && F(e6, r5 -= P[a3], s5));
    } while (l3 < e6.last_lit);
    N2(e6, p2, t4);
  }
  __name(j, "j");
  function G(e6, t4) {
    var i3, r5, n4, a3 = t4.dyn_tree, o4 = t4.stat_desc.static_tree, s5 = t4.stat_desc.has_stree, l3 = t4.stat_desc.elems, u3 = -1;
    for (e6.heap_len = 0, e6.heap_max = h2, i3 = 0; i3 < l3; i3++) 0 !== a3[2 * i3] ? (e6.heap[++e6.heap_len] = u3 = i3, e6.depth[i3] = 0) : a3[2 * i3 + 1] = 0;
    for (; e6.heap_len < 2; ) a3[2 * (n4 = e6.heap[++e6.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e6.depth[n4] = 0, e6.opt_len--, s5 && (e6.static_len -= o4[2 * n4 + 1]);
    for (t4.max_code = u3, i3 = e6.heap_len >> 1; i3 >= 1; i3--) Z(e6, a3, i3);
    n4 = l3;
    do {
      i3 = e6.heap[1], e6.heap[1] = e6.heap[e6.heap_len--], Z(e6, a3, 1), r5 = e6.heap[1], e6.heap[--e6.heap_max] = i3, e6.heap[--e6.heap_max] = r5, a3[2 * n4] = a3[2 * i3] + a3[2 * r5], e6.depth[n4] = (e6.depth[i3] >= e6.depth[r5] ? e6.depth[i3] : e6.depth[r5]) + 1, a3[2 * i3 + 1] = a3[2 * r5 + 1] = n4, e6.heap[1] = n4++, Z(e6, a3, 1);
    } while (e6.heap_len >= 2);
    e6.heap[--e6.heap_max] = e6.heap[1], function(e7, t5) {
      var i4, r6, n5, a4, o5, s6, l4 = t5.dyn_tree, u4 = t5.max_code, f3 = t5.stat_desc.static_tree, d2 = t5.stat_desc.has_stree, p3 = t5.stat_desc.extra_bits, m2 = t5.stat_desc.extra_base, _3 = t5.stat_desc.max_length, g2 = 0;
      for (a4 = 0; a4 <= c3; a4++) e7.bl_count[a4] = 0;
      for (l4[2 * e7.heap[e7.heap_max] + 1] = 0, i4 = e7.heap_max + 1; i4 < h2; i4++) (a4 = l4[2 * l4[2 * (r6 = e7.heap[i4]) + 1] + 1] + 1) > _3 && (a4 = _3, g2++), l4[2 * r6 + 1] = a4, r6 > u4 || (e7.bl_count[a4]++, o5 = 0, r6 >= m2 && (o5 = p3[r6 - m2]), s6 = l4[2 * r6], e7.opt_len += s6 * (a4 + o5), d2 && (e7.static_len += s6 * (f3[2 * r6 + 1] + o5)));
      if (0 !== g2) {
        do {
          for (a4 = _3 - 1; 0 === e7.bl_count[a4]; ) a4--;
          e7.bl_count[a4]--, e7.bl_count[a4 + 1] += 2, e7.bl_count[_3]--, g2 -= 2;
        } while (g2 > 0);
        for (a4 = _3; 0 !== a4; a4--) for (r6 = e7.bl_count[a4]; 0 !== r6; ) (n5 = e7.heap[--i4]) > u4 || (l4[2 * n5 + 1] !== a4 && (e7.opt_len += (a4 - l4[2 * n5 + 1]) * l4[2 * n5], l4[2 * n5 + 1] = a4), r6--);
      }
    }(e6, t4), D(a3, u3, e6.bl_count);
  }
  __name(G, "G");
  function H(e6, t4, i3) {
    var r5, n4, a3 = -1, o4 = t4[1], s5 = 0, l3 = 7, u3 = 4;
    for (0 === o4 && (l3 = 138, u3 = 3), t4[2 * (i3 + 1) + 1] = 65535, r5 = 0; r5 <= i3; r5++) n4 = o4, o4 = t4[2 * (r5 + 1) + 1], ++s5 < l3 && n4 === o4 || (s5 < u3 ? e6.bl_tree[2 * n4] += s5 : 0 !== n4 ? (n4 !== a3 && e6.bl_tree[2 * n4]++, e6.bl_tree[2 * m]++) : s5 <= 10 ? e6.bl_tree[2 * _2]++ : e6.bl_tree[2 * g]++, s5 = 0, a3 = n4, 0 === o4 ? (l3 = 138, u3 = 3) : n4 === o4 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4));
  }
  __name(H, "H");
  function Q(e6, t4, i3) {
    var r5, n4, a3 = -1, o4 = t4[1], s5 = 0, l3 = 7, u3 = 4;
    for (0 === o4 && (l3 = 138, u3 = 3), r5 = 0; r5 <= i3; r5++) if (n4 = o4, o4 = t4[2 * (r5 + 1) + 1], !(++s5 < l3 && n4 === o4)) {
      if (s5 < u3) do {
        N2(e6, n4, e6.bl_tree);
      } while (0 != --s5);
      else 0 !== n4 ? (n4 !== a3 && (N2(e6, n4, e6.bl_tree), s5--), N2(e6, m, e6.bl_tree), F(e6, s5 - 3, 2)) : s5 <= 10 ? (N2(e6, _2, e6.bl_tree), F(e6, s5 - 3, 3)) : (N2(e6, g, e6.bl_tree), F(e6, s5 - 11, 7));
      s5 = 0, a3 = n4, 0 === o4 ? (l3 = 138, u3 = 3) : n4 === o4 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4);
    }
  }
  __name(Q, "Q");
  r4(P);
  var W = false;
  function q(t4, i3, r5, a3) {
    F(t4, (n3 << 1) + (a3 ? 1 : 0), 3), function(t5, i4, r6, n4) {
      L2(t5), z2(t5, r6), z2(t5, ~r6), e5.arraySet(t5.pending_buf, t5.window, i4, r6, t5.pending), t5.pending += r6;
    }(t4, i3, r5);
  }
  __name(q, "q");
  return trees._tr_init = function(e6) {
    W || (!function() {
      var e7, t4, i3, r5, n4, h3 = new Array(c3 + 1);
      for (i3 = 0, r5 = 0; r5 < a2 - 1; r5++) for (A2[r5] = i3, e7 = 0; e7 < 1 << b2[r5]; e7++) S2[i3++] = r5;
      for (S2[i3 - 1] = r5, n4 = 0, r5 = 0; r5 < 16; r5++) for (P[r5] = n4, e7 = 0; e7 < 1 << y2[r5]; e7++) k2[n4++] = r5;
      for (n4 >>= 7; r5 < l2; r5++) for (P[r5] = n4 << 7, e7 = 0; e7 < 1 << y2[r5] - 7; e7++) k2[256 + n4++] = r5;
      for (t4 = 0; t4 <= c3; t4++) h3[t4] = 0;
      for (e7 = 0; e7 <= 143; ) x2[2 * e7 + 1] = 8, e7++, h3[8]++;
      for (; e7 <= 255; ) x2[2 * e7 + 1] = 9, e7++, h3[9]++;
      for (; e7 <= 279; ) x2[2 * e7 + 1] = 7, e7++, h3[7]++;
      for (; e7 <= 287; ) x2[2 * e7 + 1] = 8, e7++, h3[8]++;
      for (D(x2, s4 + 1, h3), e7 = 0; e7 < l2; e7++) E2[2 * e7 + 1] = 5, E2[2 * e7] = O2(e7, 5);
      I = new B2(x2, b2, o3 + 1, s4, c3), M2 = new B2(E2, y2, 0, l2, c3), T2 = new B2(new Array(0), w, 0, u2, d);
    }(), W = true), e6.l_desc = new C2(e6.dyn_ltree, I), e6.d_desc = new C2(e6.dyn_dtree, M2), e6.bl_desc = new C2(e6.bl_tree, T2), e6.bi_buf = 0, e6.bi_valid = 0, $(e6);
  }, trees._tr_stored_block = q, trees._tr_flush_block = function(e6, r5, n4, a3) {
    var s5, l3, h3 = 0;
    e6.level > 0 ? (2 === e6.strm.data_type && (e6.strm.data_type = function(e7) {
      var r6, n5 = 4093624447;
      for (r6 = 0; r6 <= 31; r6++, n5 >>>= 1) if (1 & n5 && 0 !== e7.dyn_ltree[2 * r6]) return t3;
      if (0 !== e7.dyn_ltree[18] || 0 !== e7.dyn_ltree[20] || 0 !== e7.dyn_ltree[26]) return i2;
      for (r6 = 32; r6 < o3; r6++) if (0 !== e7.dyn_ltree[2 * r6]) return i2;
      return t3;
    }(e6)), G(e6, e6.l_desc), G(e6, e6.d_desc), h3 = function(e7) {
      var t4;
      for (H(e7, e7.dyn_ltree, e7.l_desc.max_code), H(e7, e7.dyn_dtree, e7.d_desc.max_code), G(e7, e7.bl_desc), t4 = u2 - 1; t4 >= 3 && 0 === e7.bl_tree[2 * v2[t4] + 1]; t4--) ;
      return e7.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
    }(e6), s5 = e6.opt_len + 3 + 7 >>> 3, (l3 = e6.static_len + 3 + 7 >>> 3) <= s5 && (s5 = l3)) : s5 = l3 = n4 + 5, n4 + 4 <= s5 && -1 !== r5 ? q(e6, r5, n4, a3) : 4 === e6.strategy || l3 === s5 ? (F(e6, 2 + (a3 ? 1 : 0), 3), j(e6, x2, E2)) : (F(e6, 4 + (a3 ? 1 : 0), 3), function(e7, t4, i3, r6) {
      var n5;
      for (F(e7, t4 - 257, 5), F(e7, i3 - 1, 5), F(e7, r6 - 4, 4), n5 = 0; n5 < r6; n5++) F(e7, e7.bl_tree[2 * v2[n5] + 1], 3);
      Q(e7, e7.dyn_ltree, t4 - 1), Q(e7, e7.dyn_dtree, i3 - 1);
    }(e6, e6.l_desc.max_code + 1, e6.d_desc.max_code + 1, h3 + 1), j(e6, e6.dyn_ltree, e6.dyn_dtree)), $(e6), a3 && L2(e6);
  }, trees._tr_tally = function(e6, t4, i3) {
    return e6.pending_buf[e6.d_buf + 2 * e6.last_lit] = t4 >>> 8 & 255, e6.pending_buf[e6.d_buf + 2 * e6.last_lit + 1] = 255 & t4, e6.pending_buf[e6.l_buf + e6.last_lit] = 255 & i3, e6.last_lit++, 0 === t4 ? e6.dyn_ltree[2 * i3]++ : (e6.matches++, t4--, e6.dyn_ltree[2 * (S2[i3] + o3 + 1)]++, e6.dyn_dtree[2 * R2(t4)]++), e6.last_lit === e6.lit_bufsize - 1;
  }, trees._tr_align = function(e6) {
    F(e6, 2, 3), N2(e6, p2, x2), function(e7) {
      16 === e7.bi_valid ? (z2(e7, e7.bi_buf), e7.bi_buf = 0, e7.bi_valid = 0) : e7.bi_valid >= 8 && (e7.pending_buf[e7.pending++] = 255 & e7.bi_buf, e7.bi_buf >>= 8, e7.bi_valid -= 8);
    }(e6);
  }, trees;
}
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  return hasRequiredAdler32 = 1, adler32_1 = /* @__PURE__ */ __name(function(e5, t3, i2, r4) {
    for (var n3 = 65535 & e5, a2 = e5 >>> 16 & 65535, o3 = 0; 0 !== i2; ) {
      i2 -= o3 = i2 > 2e3 ? 2e3 : i2;
      do {
        a2 = a2 + (n3 = n3 + t3[r4++] | 0) | 0;
      } while (--o3);
      n3 %= 65521, a2 %= 65521;
    }
    return n3 | a2 << 16;
  }, "adler32_1"), adler32_1;
}
function requireCrc32() {
  if (hasRequiredCrc32) return crc32_1;
  hasRequiredCrc32 = 1;
  var e5 = function() {
    for (var e6, t3 = [], i2 = 0; i2 < 256; i2++) {
      e6 = i2;
      for (var r4 = 0; r4 < 8; r4++) e6 = 1 & e6 ? 3988292384 ^ e6 >>> 1 : e6 >>> 1;
      t3[i2] = e6;
    }
    return t3;
  }();
  return crc32_1 = /* @__PURE__ */ __name(function(t3, i2, r4, n3) {
    var a2 = e5, o3 = n3 + r4;
    t3 ^= -1;
    for (var s4 = n3; s4 < o3; s4++) t3 = t3 >>> 8 ^ a2[255 & (t3 ^ i2[s4])];
    return ~t3;
  }, "crc32_1"), crc32_1;
}
function requireMessages() {
  return hasRequiredMessages ? messages : (hasRequiredMessages = 1, messages = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" });
}
function requireDeflate$1() {
  if (hasRequiredDeflate$1) return deflate;
  hasRequiredDeflate$1 = 1;
  var e5, t3 = requireCommon(), i2 = requireTrees(), r4 = requireAdler32(), n3 = requireCrc32(), a2 = requireMessages(), o3 = 0, s4 = 4, l2 = 0, u2 = -2, h2 = -1, c3 = 4, f2 = 2, d = 8, p2 = 9, m = 286, _2 = 30, g = 19, b2 = 2 * m + 1, y2 = 15, w = 3, v2 = 258, x2 = v2 + w + 1, E2 = 42, k2 = 103, S2 = 113, A2 = 666, I = 1, M2 = 2, T2 = 3, P = 4;
  function B2(e6, t4) {
    return e6.msg = a2[t4], t4;
  }
  __name(B2, "B");
  function C2(e6) {
    return (e6 << 1) - (e6 > 4 ? 9 : 0);
  }
  __name(C2, "C");
  function R2(e6) {
    for (var t4 = e6.length; --t4 >= 0; ) e6[t4] = 0;
  }
  __name(R2, "R");
  function z2(e6) {
    var i3 = e6.state, r5 = i3.pending;
    r5 > e6.avail_out && (r5 = e6.avail_out), 0 !== r5 && (t3.arraySet(e6.output, i3.pending_buf, i3.pending_out, r5, e6.next_out), e6.next_out += r5, i3.pending_out += r5, e6.total_out += r5, e6.avail_out -= r5, i3.pending -= r5, 0 === i3.pending && (i3.pending_out = 0));
  }
  __name(z2, "z");
  function F(e6, t4) {
    i2._tr_flush_block(e6, e6.block_start >= 0 ? e6.block_start : -1, e6.strstart - e6.block_start, t4), e6.block_start = e6.strstart, z2(e6.strm);
  }
  __name(F, "F");
  function N2(e6, t4) {
    e6.pending_buf[e6.pending++] = t4;
  }
  __name(N2, "N");
  function O2(e6, t4) {
    e6.pending_buf[e6.pending++] = t4 >>> 8 & 255, e6.pending_buf[e6.pending++] = 255 & t4;
  }
  __name(O2, "O");
  function D(e6, t4) {
    var i3, r5, n4 = e6.max_chain_length, a3 = e6.strstart, o4 = e6.prev_length, s5 = e6.nice_match, l3 = e6.strstart > e6.w_size - x2 ? e6.strstart - (e6.w_size - x2) : 0, u3 = e6.window, h3 = e6.w_mask, c4 = e6.prev, f3 = e6.strstart + v2, d2 = u3[a3 + o4 - 1], p3 = u3[a3 + o4];
    e6.prev_length >= e6.good_match && (n4 >>= 2), s5 > e6.lookahead && (s5 = e6.lookahead);
    do {
      if (u3[(i3 = t4) + o4] === p3 && u3[i3 + o4 - 1] === d2 && u3[i3] === u3[a3] && u3[++i3] === u3[a3 + 1]) {
        a3 += 2, i3++;
        do {
        } while (u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && a3 < f3);
        if (r5 = v2 - (f3 - a3), a3 = f3 - v2, r5 > o4) {
          if (e6.match_start = t4, o4 = r5, r5 >= s5) break;
          d2 = u3[a3 + o4 - 1], p3 = u3[a3 + o4];
        }
      }
    } while ((t4 = c4[t4 & h3]) > l3 && 0 != --n4);
    return o4 <= e6.lookahead ? o4 : e6.lookahead;
  }
  __name(D, "D");
  function $(e6) {
    var i3, a3, o4, s5, l3, u3, h3, c4, f3, d2, p3 = e6.w_size;
    do {
      if (s5 = e6.window_size - e6.lookahead - e6.strstart, e6.strstart >= p3 + (p3 - x2)) {
        t3.arraySet(e6.window, e6.window, p3, p3, 0), e6.match_start -= p3, e6.strstart -= p3, e6.block_start -= p3, i3 = a3 = e6.hash_size;
        do {
          o4 = e6.head[--i3], e6.head[i3] = o4 >= p3 ? o4 - p3 : 0;
        } while (--a3);
        i3 = a3 = p3;
        do {
          o4 = e6.prev[--i3], e6.prev[i3] = o4 >= p3 ? o4 - p3 : 0;
        } while (--a3);
        s5 += p3;
      }
      if (0 === e6.strm.avail_in) break;
      if (u3 = e6.strm, h3 = e6.window, c4 = e6.strstart + e6.lookahead, f3 = s5, d2 = void 0, (d2 = u3.avail_in) > f3 && (d2 = f3), a3 = 0 === d2 ? 0 : (u3.avail_in -= d2, t3.arraySet(h3, u3.input, u3.next_in, d2, c4), 1 === u3.state.wrap ? u3.adler = r4(u3.adler, h3, d2, c4) : 2 === u3.state.wrap && (u3.adler = n3(u3.adler, h3, d2, c4)), u3.next_in += d2, u3.total_in += d2, d2), e6.lookahead += a3, e6.lookahead + e6.insert >= w) for (l3 = e6.strstart - e6.insert, e6.ins_h = e6.window[l3], e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[l3 + 1]) & e6.hash_mask; e6.insert && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[l3 + w - 1]) & e6.hash_mask, e6.prev[l3 & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = l3, l3++, e6.insert--, !(e6.lookahead + e6.insert < w)); ) ;
    } while (e6.lookahead < x2 && 0 !== e6.strm.avail_in);
  }
  __name($, "$");
  function L2(e6, t4) {
    for (var r5, n4; ; ) {
      if (e6.lookahead < x2) {
        if ($(e6), e6.lookahead < x2 && t4 === o3) return I;
        if (0 === e6.lookahead) break;
      }
      if (r5 = 0, e6.lookahead >= w && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + w - 1]) & e6.hash_mask, r5 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart), 0 !== r5 && e6.strstart - r5 <= e6.w_size - x2 && (e6.match_length = D(e6, r5)), e6.match_length >= w) if (n4 = i2._tr_tally(e6, e6.strstart - e6.match_start, e6.match_length - w), e6.lookahead -= e6.match_length, e6.match_length <= e6.max_lazy_match && e6.lookahead >= w) {
        e6.match_length--;
        do {
          e6.strstart++, e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + w - 1]) & e6.hash_mask, r5 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart;
        } while (0 != --e6.match_length);
        e6.strstart++;
      } else e6.strstart += e6.match_length, e6.match_length = 0, e6.ins_h = e6.window[e6.strstart], e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + 1]) & e6.hash_mask;
      else n4 = i2._tr_tally(e6, 0, e6.window[e6.strstart]), e6.lookahead--, e6.strstart++;
      if (n4 && (F(e6, false), 0 === e6.strm.avail_out)) return I;
    }
    return e6.insert = e6.strstart < w - 1 ? e6.strstart : w - 1, t4 === s4 ? (F(e6, true), 0 === e6.strm.avail_out ? T2 : P) : e6.last_lit && (F(e6, false), 0 === e6.strm.avail_out) ? I : M2;
  }
  __name(L2, "L");
  function U(e6, t4) {
    for (var r5, n4, a3; ; ) {
      if (e6.lookahead < x2) {
        if ($(e6), e6.lookahead < x2 && t4 === o3) return I;
        if (0 === e6.lookahead) break;
      }
      if (r5 = 0, e6.lookahead >= w && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + w - 1]) & e6.hash_mask, r5 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart), e6.prev_length = e6.match_length, e6.prev_match = e6.match_start, e6.match_length = w - 1, 0 !== r5 && e6.prev_length < e6.max_lazy_match && e6.strstart - r5 <= e6.w_size - x2 && (e6.match_length = D(e6, r5), e6.match_length <= 5 && (1 === e6.strategy || e6.match_length === w && e6.strstart - e6.match_start > 4096) && (e6.match_length = w - 1)), e6.prev_length >= w && e6.match_length <= e6.prev_length) {
        a3 = e6.strstart + e6.lookahead - w, n4 = i2._tr_tally(e6, e6.strstart - 1 - e6.prev_match, e6.prev_length - w), e6.lookahead -= e6.prev_length - 1, e6.prev_length -= 2;
        do {
          ++e6.strstart <= a3 && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + w - 1]) & e6.hash_mask, r5 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart);
        } while (0 != --e6.prev_length);
        if (e6.match_available = 0, e6.match_length = w - 1, e6.strstart++, n4 && (F(e6, false), 0 === e6.strm.avail_out)) return I;
      } else if (e6.match_available) {
        if ((n4 = i2._tr_tally(e6, 0, e6.window[e6.strstart - 1])) && F(e6, false), e6.strstart++, e6.lookahead--, 0 === e6.strm.avail_out) return I;
      } else e6.match_available = 1, e6.strstart++, e6.lookahead--;
    }
    return e6.match_available && (n4 = i2._tr_tally(e6, 0, e6.window[e6.strstart - 1]), e6.match_available = 0), e6.insert = e6.strstart < w - 1 ? e6.strstart : w - 1, t4 === s4 ? (F(e6, true), 0 === e6.strm.avail_out ? T2 : P) : e6.last_lit && (F(e6, false), 0 === e6.strm.avail_out) ? I : M2;
  }
  __name(U, "U");
  function Z(e6, t4, i3, r5, n4) {
    this.good_length = e6, this.max_lazy = t4, this.nice_length = i3, this.max_chain = r5, this.func = n4;
  }
  __name(Z, "Z");
  function j() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = d, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new t3.Buf16(2 * b2), this.dyn_dtree = new t3.Buf16(2 * (2 * _2 + 1)), this.bl_tree = new t3.Buf16(2 * (2 * g + 1)), R2(this.dyn_ltree), R2(this.dyn_dtree), R2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new t3.Buf16(y2 + 1), this.heap = new t3.Buf16(2 * m + 1), R2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new t3.Buf16(2 * m + 1), R2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
  }
  __name(j, "j");
  function G(e6) {
    var t4;
    return e6 && e6.state ? (e6.total_in = e6.total_out = 0, e6.data_type = f2, (t4 = e6.state).pending = 0, t4.pending_out = 0, t4.wrap < 0 && (t4.wrap = -t4.wrap), t4.status = t4.wrap ? E2 : S2, e6.adler = 2 === t4.wrap ? 0 : 1, t4.last_flush = o3, i2._tr_init(t4), l2) : B2(e6, u2);
  }
  __name(G, "G");
  function H(t4) {
    var i3 = G(t4);
    return i3 === l2 && function(t5) {
      t5.window_size = 2 * t5.w_size, R2(t5.head), t5.max_lazy_match = e5[t5.level].max_lazy, t5.good_match = e5[t5.level].good_length, t5.nice_match = e5[t5.level].nice_length, t5.max_chain_length = e5[t5.level].max_chain, t5.strstart = 0, t5.block_start = 0, t5.lookahead = 0, t5.insert = 0, t5.match_length = t5.prev_length = w - 1, t5.match_available = 0, t5.ins_h = 0;
    }(t4.state), i3;
  }
  __name(H, "H");
  function Q(e6, i3, r5, n4, a3, o4) {
    if (!e6) return u2;
    var s5 = 1;
    if (i3 === h2 && (i3 = 6), n4 < 0 ? (s5 = 0, n4 = -n4) : n4 > 15 && (s5 = 2, n4 -= 16), a3 < 1 || a3 > p2 || r5 !== d || n4 < 8 || n4 > 15 || i3 < 0 || i3 > 9 || o4 < 0 || o4 > c3) return B2(e6, u2);
    8 === n4 && (n4 = 9);
    var l3 = new j();
    return e6.state = l3, l3.strm = e6, l3.wrap = s5, l3.gzhead = null, l3.w_bits = n4, l3.w_size = 1 << l3.w_bits, l3.w_mask = l3.w_size - 1, l3.hash_bits = a3 + 7, l3.hash_size = 1 << l3.hash_bits, l3.hash_mask = l3.hash_size - 1, l3.hash_shift = ~~((l3.hash_bits + w - 1) / w), l3.window = new t3.Buf8(2 * l3.w_size), l3.head = new t3.Buf16(l3.hash_size), l3.prev = new t3.Buf16(l3.w_size), l3.lit_bufsize = 1 << a3 + 6, l3.pending_buf_size = 4 * l3.lit_bufsize, l3.pending_buf = new t3.Buf8(l3.pending_buf_size), l3.d_buf = 1 * l3.lit_bufsize, l3.l_buf = 3 * l3.lit_bufsize, l3.level = i3, l3.strategy = o4, l3.method = r5, H(e6);
  }
  __name(Q, "Q");
  return e5 = [new Z(0, 0, 0, 0, function(e6, t4) {
    var i3 = 65535;
    for (i3 > e6.pending_buf_size - 5 && (i3 = e6.pending_buf_size - 5); ; ) {
      if (e6.lookahead <= 1) {
        if ($(e6), 0 === e6.lookahead && t4 === o3) return I;
        if (0 === e6.lookahead) break;
      }
      e6.strstart += e6.lookahead, e6.lookahead = 0;
      var r5 = e6.block_start + i3;
      if ((0 === e6.strstart || e6.strstart >= r5) && (e6.lookahead = e6.strstart - r5, e6.strstart = r5, F(e6, false), 0 === e6.strm.avail_out)) return I;
      if (e6.strstart - e6.block_start >= e6.w_size - x2 && (F(e6, false), 0 === e6.strm.avail_out)) return I;
    }
    return e6.insert = 0, t4 === s4 ? (F(e6, true), 0 === e6.strm.avail_out ? T2 : P) : (e6.strstart > e6.block_start && (F(e6, false), e6.strm.avail_out), I);
  }), new Z(4, 4, 8, 4, L2), new Z(4, 5, 16, 8, L2), new Z(4, 6, 32, 32, L2), new Z(4, 4, 16, 16, U), new Z(8, 16, 32, 32, U), new Z(8, 16, 128, 128, U), new Z(8, 32, 128, 256, U), new Z(32, 128, 258, 1024, U), new Z(32, 258, 258, 4096, U)], deflate.deflateInit = function(e6, t4) {
    return Q(e6, t4, d, 15, 8, 0);
  }, deflate.deflateInit2 = Q, deflate.deflateReset = H, deflate.deflateResetKeep = G, deflate.deflateSetHeader = function(e6, t4) {
    return e6 && e6.state ? 2 !== e6.state.wrap ? u2 : (e6.state.gzhead = t4, l2) : u2;
  }, deflate.deflate = function(t4, r5) {
    var a3, h3, c4, f3;
    if (!t4 || !t4.state || r5 > 5 || r5 < 0) return t4 ? B2(t4, u2) : u2;
    if (h3 = t4.state, !t4.output || !t4.input && 0 !== t4.avail_in || h3.status === A2 && r5 !== s4) return B2(t4, 0 === t4.avail_out ? -5 : u2);
    if (h3.strm = t4, a3 = h3.last_flush, h3.last_flush = r5, h3.status === E2) if (2 === h3.wrap) t4.adler = 0, N2(h3, 31), N2(h3, 139), N2(h3, 8), h3.gzhead ? (N2(h3, (h3.gzhead.text ? 1 : 0) + (h3.gzhead.hcrc ? 2 : 0) + (h3.gzhead.extra ? 4 : 0) + (h3.gzhead.name ? 8 : 0) + (h3.gzhead.comment ? 16 : 0)), N2(h3, 255 & h3.gzhead.time), N2(h3, h3.gzhead.time >> 8 & 255), N2(h3, h3.gzhead.time >> 16 & 255), N2(h3, h3.gzhead.time >> 24 & 255), N2(h3, 9 === h3.level ? 2 : h3.strategy >= 2 || h3.level < 2 ? 4 : 0), N2(h3, 255 & h3.gzhead.os), h3.gzhead.extra && h3.gzhead.extra.length && (N2(h3, 255 & h3.gzhead.extra.length), N2(h3, h3.gzhead.extra.length >> 8 & 255)), h3.gzhead.hcrc && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending, 0)), h3.gzindex = 0, h3.status = 69) : (N2(h3, 0), N2(h3, 0), N2(h3, 0), N2(h3, 0), N2(h3, 0), N2(h3, 9 === h3.level ? 2 : h3.strategy >= 2 || h3.level < 2 ? 4 : 0), N2(h3, 3), h3.status = S2);
    else {
      var p3 = d + (h3.w_bits - 8 << 4) << 8;
      p3 |= (h3.strategy >= 2 || h3.level < 2 ? 0 : h3.level < 6 ? 1 : 6 === h3.level ? 2 : 3) << 6, 0 !== h3.strstart && (p3 |= 32), p3 += 31 - p3 % 31, h3.status = S2, O2(h3, p3), 0 !== h3.strstart && (O2(h3, t4.adler >>> 16), O2(h3, 65535 & t4.adler)), t4.adler = 1;
    }
    if (69 === h3.status) if (h3.gzhead.extra) {
      for (c4 = h3.pending; h3.gzindex < (65535 & h3.gzhead.extra.length) && (h3.pending !== h3.pending_buf_size || (h3.gzhead.hcrc && h3.pending > c4 && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending - c4, c4)), z2(t4), c4 = h3.pending, h3.pending !== h3.pending_buf_size)); ) N2(h3, 255 & h3.gzhead.extra[h3.gzindex]), h3.gzindex++;
      h3.gzhead.hcrc && h3.pending > c4 && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending - c4, c4)), h3.gzindex === h3.gzhead.extra.length && (h3.gzindex = 0, h3.status = 73);
    } else h3.status = 73;
    if (73 === h3.status) if (h3.gzhead.name) {
      c4 = h3.pending;
      do {
        if (h3.pending === h3.pending_buf_size && (h3.gzhead.hcrc && h3.pending > c4 && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending - c4, c4)), z2(t4), c4 = h3.pending, h3.pending === h3.pending_buf_size)) {
          f3 = 1;
          break;
        }
        f3 = h3.gzindex < h3.gzhead.name.length ? 255 & h3.gzhead.name.charCodeAt(h3.gzindex++) : 0, N2(h3, f3);
      } while (0 !== f3);
      h3.gzhead.hcrc && h3.pending > c4 && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending - c4, c4)), 0 === f3 && (h3.gzindex = 0, h3.status = 91);
    } else h3.status = 91;
    if (91 === h3.status) if (h3.gzhead.comment) {
      c4 = h3.pending;
      do {
        if (h3.pending === h3.pending_buf_size && (h3.gzhead.hcrc && h3.pending > c4 && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending - c4, c4)), z2(t4), c4 = h3.pending, h3.pending === h3.pending_buf_size)) {
          f3 = 1;
          break;
        }
        f3 = h3.gzindex < h3.gzhead.comment.length ? 255 & h3.gzhead.comment.charCodeAt(h3.gzindex++) : 0, N2(h3, f3);
      } while (0 !== f3);
      h3.gzhead.hcrc && h3.pending > c4 && (t4.adler = n3(t4.adler, h3.pending_buf, h3.pending - c4, c4)), 0 === f3 && (h3.status = k2);
    } else h3.status = k2;
    if (h3.status === k2 && (h3.gzhead.hcrc ? (h3.pending + 2 > h3.pending_buf_size && z2(t4), h3.pending + 2 <= h3.pending_buf_size && (N2(h3, 255 & t4.adler), N2(h3, t4.adler >> 8 & 255), t4.adler = 0, h3.status = S2)) : h3.status = S2), 0 !== h3.pending) {
      if (z2(t4), 0 === t4.avail_out) return h3.last_flush = -1, l2;
    } else if (0 === t4.avail_in && C2(r5) <= C2(a3) && r5 !== s4) return B2(t4, -5);
    if (h3.status === A2 && 0 !== t4.avail_in) return B2(t4, -5);
    if (0 !== t4.avail_in || 0 !== h3.lookahead || r5 !== o3 && h3.status !== A2) {
      var m2 = 2 === h3.strategy ? function(e6, t5) {
        for (var r6; ; ) {
          if (0 === e6.lookahead && ($(e6), 0 === e6.lookahead)) {
            if (t5 === o3) return I;
            break;
          }
          if (e6.match_length = 0, r6 = i2._tr_tally(e6, 0, e6.window[e6.strstart]), e6.lookahead--, e6.strstart++, r6 && (F(e6, false), 0 === e6.strm.avail_out)) return I;
        }
        return e6.insert = 0, t5 === s4 ? (F(e6, true), 0 === e6.strm.avail_out ? T2 : P) : e6.last_lit && (F(e6, false), 0 === e6.strm.avail_out) ? I : M2;
      }(h3, r5) : 3 === h3.strategy ? function(e6, t5) {
        for (var r6, n4, a4, l3, u3 = e6.window; ; ) {
          if (e6.lookahead <= v2) {
            if ($(e6), e6.lookahead <= v2 && t5 === o3) return I;
            if (0 === e6.lookahead) break;
          }
          if (e6.match_length = 0, e6.lookahead >= w && e6.strstart > 0 && (n4 = u3[a4 = e6.strstart - 1]) === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4]) {
            l3 = e6.strstart + v2;
            do {
            } while (n4 === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4] && n4 === u3[++a4] && a4 < l3);
            e6.match_length = v2 - (l3 - a4), e6.match_length > e6.lookahead && (e6.match_length = e6.lookahead);
          }
          if (e6.match_length >= w ? (r6 = i2._tr_tally(e6, 1, e6.match_length - w), e6.lookahead -= e6.match_length, e6.strstart += e6.match_length, e6.match_length = 0) : (r6 = i2._tr_tally(e6, 0, e6.window[e6.strstart]), e6.lookahead--, e6.strstart++), r6 && (F(e6, false), 0 === e6.strm.avail_out)) return I;
        }
        return e6.insert = 0, t5 === s4 ? (F(e6, true), 0 === e6.strm.avail_out ? T2 : P) : e6.last_lit && (F(e6, false), 0 === e6.strm.avail_out) ? I : M2;
      }(h3, r5) : e5[h3.level].func(h3, r5);
      if (m2 !== T2 && m2 !== P || (h3.status = A2), m2 === I || m2 === T2) return 0 === t4.avail_out && (h3.last_flush = -1), l2;
      if (m2 === M2 && (1 === r5 ? i2._tr_align(h3) : 5 !== r5 && (i2._tr_stored_block(h3, 0, 0, false), 3 === r5 && (R2(h3.head), 0 === h3.lookahead && (h3.strstart = 0, h3.block_start = 0, h3.insert = 0))), z2(t4), 0 === t4.avail_out)) return h3.last_flush = -1, l2;
    }
    return r5 !== s4 ? l2 : h3.wrap <= 0 ? 1 : (2 === h3.wrap ? (N2(h3, 255 & t4.adler), N2(h3, t4.adler >> 8 & 255), N2(h3, t4.adler >> 16 & 255), N2(h3, t4.adler >> 24 & 255), N2(h3, 255 & t4.total_in), N2(h3, t4.total_in >> 8 & 255), N2(h3, t4.total_in >> 16 & 255), N2(h3, t4.total_in >> 24 & 255)) : (O2(h3, t4.adler >>> 16), O2(h3, 65535 & t4.adler)), z2(t4), h3.wrap > 0 && (h3.wrap = -h3.wrap), 0 !== h3.pending ? l2 : 1);
  }, deflate.deflateEnd = function(e6) {
    var t4;
    return e6 && e6.state ? (t4 = e6.state.status) !== E2 && 69 !== t4 && 73 !== t4 && 91 !== t4 && t4 !== k2 && t4 !== S2 && t4 !== A2 ? B2(e6, u2) : (e6.state = null, t4 === S2 ? B2(e6, -3) : l2) : u2;
  }, deflate.deflateSetDictionary = function(e6, i3) {
    var n4, a3, o4, s5, h3, c4, f3, d2, p3 = i3.length;
    if (!e6 || !e6.state) return u2;
    if (2 === (s5 = (n4 = e6.state).wrap) || 1 === s5 && n4.status !== E2 || n4.lookahead) return u2;
    for (1 === s5 && (e6.adler = r4(e6.adler, i3, p3, 0)), n4.wrap = 0, p3 >= n4.w_size && (0 === s5 && (R2(n4.head), n4.strstart = 0, n4.block_start = 0, n4.insert = 0), d2 = new t3.Buf8(n4.w_size), t3.arraySet(d2, i3, p3 - n4.w_size, n4.w_size, 0), i3 = d2, p3 = n4.w_size), h3 = e6.avail_in, c4 = e6.next_in, f3 = e6.input, e6.avail_in = p3, e6.next_in = 0, e6.input = i3, $(n4); n4.lookahead >= w; ) {
      a3 = n4.strstart, o4 = n4.lookahead - (w - 1);
      do {
        n4.ins_h = (n4.ins_h << n4.hash_shift ^ n4.window[a3 + w - 1]) & n4.hash_mask, n4.prev[a3 & n4.w_mask] = n4.head[n4.ins_h], n4.head[n4.ins_h] = a3, a3++;
      } while (--o4);
      n4.strstart = a3, n4.lookahead = w - 1, $(n4);
    }
    return n4.strstart += n4.lookahead, n4.block_start = n4.strstart, n4.insert = n4.lookahead, n4.lookahead = 0, n4.match_length = n4.prev_length = w - 1, n4.match_available = 0, e6.next_in = c4, e6.input = f3, e6.avail_in = h3, n4.wrap = s5, l2;
  }, deflate.deflateInfo = "pako deflate (from Nodeca project)", deflate;
}
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  var e5 = requireCommon(), t3 = true, i2 = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (e6) {
    t3 = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (e6) {
    i2 = false;
  }
  for (var r4 = new e5.Buf8(256), n3 = 0; n3 < 256; n3++) r4[n3] = n3 >= 252 ? 6 : n3 >= 248 ? 5 : n3 >= 240 ? 4 : n3 >= 224 ? 3 : n3 >= 192 ? 2 : 1;
  function a2(r5, n4) {
    if (n4 < 65534 && (r5.subarray && i2 || !r5.subarray && t3)) return String.fromCharCode.apply(null, e5.shrinkBuf(r5, n4));
    for (var a3 = "", o3 = 0; o3 < n4; o3++) a3 += String.fromCharCode(r5[o3]);
    return a3;
  }
  __name(a2, "a");
  return r4[254] = r4[254] = 1, strings.string2buf = function(t4) {
    var i3, r5, n4, a3, o3, s4 = t4.length, l2 = 0;
    for (a3 = 0; a3 < s4; a3++) 55296 == (64512 & (r5 = t4.charCodeAt(a3))) && a3 + 1 < s4 && 56320 == (64512 & (n4 = t4.charCodeAt(a3 + 1))) && (r5 = 65536 + (r5 - 55296 << 10) + (n4 - 56320), a3++), l2 += r5 < 128 ? 1 : r5 < 2048 ? 2 : r5 < 65536 ? 3 : 4;
    for (i3 = new e5.Buf8(l2), o3 = 0, a3 = 0; o3 < l2; a3++) 55296 == (64512 & (r5 = t4.charCodeAt(a3))) && a3 + 1 < s4 && 56320 == (64512 & (n4 = t4.charCodeAt(a3 + 1))) && (r5 = 65536 + (r5 - 55296 << 10) + (n4 - 56320), a3++), r5 < 128 ? i3[o3++] = r5 : r5 < 2048 ? (i3[o3++] = 192 | r5 >>> 6, i3[o3++] = 128 | 63 & r5) : r5 < 65536 ? (i3[o3++] = 224 | r5 >>> 12, i3[o3++] = 128 | r5 >>> 6 & 63, i3[o3++] = 128 | 63 & r5) : (i3[o3++] = 240 | r5 >>> 18, i3[o3++] = 128 | r5 >>> 12 & 63, i3[o3++] = 128 | r5 >>> 6 & 63, i3[o3++] = 128 | 63 & r5);
    return i3;
  }, strings.buf2binstring = function(e6) {
    return a2(e6, e6.length);
  }, strings.binstring2buf = function(t4) {
    for (var i3 = new e5.Buf8(t4.length), r5 = 0, n4 = i3.length; r5 < n4; r5++) i3[r5] = t4.charCodeAt(r5);
    return i3;
  }, strings.buf2string = function(e6, t4) {
    var i3, n4, o3, s4, l2 = t4 || e6.length, u2 = new Array(2 * l2);
    for (n4 = 0, i3 = 0; i3 < l2; ) if ((o3 = e6[i3++]) < 128) u2[n4++] = o3;
    else if ((s4 = r4[o3]) > 4) u2[n4++] = 65533, i3 += s4 - 1;
    else {
      for (o3 &= 2 === s4 ? 31 : 3 === s4 ? 15 : 7; s4 > 1 && i3 < l2; ) o3 = o3 << 6 | 63 & e6[i3++], s4--;
      s4 > 1 ? u2[n4++] = 65533 : o3 < 65536 ? u2[n4++] = o3 : (o3 -= 65536, u2[n4++] = 55296 | o3 >> 10 & 1023, u2[n4++] = 56320 | 1023 & o3);
    }
    return a2(u2, n4);
  }, strings.utf8border = function(e6, t4) {
    var i3;
    for ((t4 = t4 || e6.length) > e6.length && (t4 = e6.length), i3 = t4 - 1; i3 >= 0 && 128 == (192 & e6[i3]); ) i3--;
    return i3 < 0 || 0 === i3 ? t4 : i3 + r4[e6[i3]] > t4 ? i3 : t4;
  }, strings;
}
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  return hasRequiredZstream = 1, zstream = /* @__PURE__ */ __name(function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
  }, "zstream");
}
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$1;
  hasRequiredDeflate = 1;
  var e5 = requireDeflate$1(), t3 = requireCommon(), i2 = requireStrings(), r4 = requireMessages(), n3 = requireZstream(), a2 = Object.prototype.toString, o3 = 0, s4 = -1, l2 = 0, u2 = 8;
  function h2(c4) {
    if (!(this instanceof h2)) return new h2(c4);
    this.options = t3.assign({ level: s4, method: u2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: l2, to: "" }, c4 || {});
    var f2 = this.options;
    f2.raw && f2.windowBits > 0 ? f2.windowBits = -f2.windowBits : f2.gzip && f2.windowBits > 0 && f2.windowBits < 16 && (f2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n3(), this.strm.avail_out = 0;
    var d = e5.deflateInit2(this.strm, f2.level, f2.method, f2.windowBits, f2.memLevel, f2.strategy);
    if (d !== o3) throw new Error(r4[d]);
    if (f2.header && e5.deflateSetHeader(this.strm, f2.header), f2.dictionary) {
      var p2;
      if (p2 = "string" == typeof f2.dictionary ? i2.string2buf(f2.dictionary) : "[object ArrayBuffer]" === a2.call(f2.dictionary) ? new Uint8Array(f2.dictionary) : f2.dictionary, (d = e5.deflateSetDictionary(this.strm, p2)) !== o3) throw new Error(r4[d]);
      this._dict_set = true;
    }
  }
  __name(h2, "h");
  function c3(e6, t4) {
    var i3 = new h2(t4);
    if (i3.push(e6, true), i3.err) throw i3.msg || r4[i3.err];
    return i3.result;
  }
  __name(c3, "c");
  return h2.prototype.push = function(r5, n4) {
    var s5, l3, u3 = this.strm, h3 = this.options.chunkSize;
    if (this.ended) return false;
    l3 = n4 === ~~n4 ? n4 : true === n4 ? 4 : 0, "string" == typeof r5 ? u3.input = i2.string2buf(r5) : "[object ArrayBuffer]" === a2.call(r5) ? u3.input = new Uint8Array(r5) : u3.input = r5, u3.next_in = 0, u3.avail_in = u3.input.length;
    do {
      if (0 === u3.avail_out && (u3.output = new t3.Buf8(h3), u3.next_out = 0, u3.avail_out = h3), 1 !== (s5 = e5.deflate(u3, l3)) && s5 !== o3) return this.onEnd(s5), this.ended = true, false;
      0 !== u3.avail_out && (0 !== u3.avail_in || 4 !== l3 && 2 !== l3) || ("string" === this.options.to ? this.onData(i2.buf2binstring(t3.shrinkBuf(u3.output, u3.next_out))) : this.onData(t3.shrinkBuf(u3.output, u3.next_out)));
    } while ((u3.avail_in > 0 || 0 === u3.avail_out) && 1 !== s5);
    return 4 === l3 ? (s5 = e5.deflateEnd(this.strm), this.onEnd(s5), this.ended = true, s5 === o3) : 2 !== l3 || (this.onEnd(o3), u3.avail_out = 0, true);
  }, h2.prototype.onData = function(e6) {
    this.chunks.push(e6);
  }, h2.prototype.onEnd = function(e6) {
    e6 === o3 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = t3.flattenChunks(this.chunks)), this.chunks = [], this.err = e6, this.msg = this.strm.msg;
  }, deflate$1.Deflate = h2, deflate$1.deflate = c3, deflate$1.deflateRaw = function(e6, t4) {
    return (t4 = t4 || {}).raw = true, c3(e6, t4);
  }, deflate$1.gzip = function(e6, t4) {
    return (t4 = t4 || {}).gzip = true, c3(e6, t4);
  }, deflate$1;
}
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  return inffast = /* @__PURE__ */ __name(function(e5, t3) {
    var i2, r4, n3, a2, o3, s4, l2, u2, h2, c3, f2, d, p2, m, _2, g, b2, y2, w, v2, x2, E2, k2, S2, A2;
    i2 = e5.state, r4 = e5.next_in, S2 = e5.input, n3 = r4 + (e5.avail_in - 5), a2 = e5.next_out, A2 = e5.output, o3 = a2 - (t3 - e5.avail_out), s4 = a2 + (e5.avail_out - 257), l2 = i2.dmax, u2 = i2.wsize, h2 = i2.whave, c3 = i2.wnext, f2 = i2.window, d = i2.hold, p2 = i2.bits, m = i2.lencode, _2 = i2.distcode, g = (1 << i2.lenbits) - 1, b2 = (1 << i2.distbits) - 1;
    e: do {
      p2 < 15 && (d += S2[r4++] << p2, p2 += 8, d += S2[r4++] << p2, p2 += 8), y2 = m[d & g];
      t: for (; ; ) {
        if (d >>>= w = y2 >>> 24, p2 -= w, 0 === (w = y2 >>> 16 & 255)) A2[a2++] = 65535 & y2;
        else {
          if (!(16 & w)) {
            if (64 & w) {
              if (32 & w) {
                i2.mode = 12;
                break e;
              }
              e5.msg = "invalid literal/length code", i2.mode = 30;
              break e;
            }
            y2 = m[(65535 & y2) + (d & (1 << w) - 1)];
            continue t;
          }
          for (v2 = 65535 & y2, (w &= 15) && (p2 < w && (d += S2[r4++] << p2, p2 += 8), v2 += d & (1 << w) - 1, d >>>= w, p2 -= w), p2 < 15 && (d += S2[r4++] << p2, p2 += 8, d += S2[r4++] << p2, p2 += 8), y2 = _2[d & b2]; ; ) {
            if (d >>>= w = y2 >>> 24, p2 -= w, 16 & (w = y2 >>> 16 & 255)) {
              if (x2 = 65535 & y2, p2 < (w &= 15) && (d += S2[r4++] << p2, (p2 += 8) < w && (d += S2[r4++] << p2, p2 += 8)), (x2 += d & (1 << w) - 1) > l2) {
                e5.msg = "invalid distance too far back", i2.mode = 30;
                break e;
              }
              if (d >>>= w, p2 -= w, x2 > (w = a2 - o3)) {
                if ((w = x2 - w) > h2 && i2.sane) {
                  e5.msg = "invalid distance too far back", i2.mode = 30;
                  break e;
                }
                if (E2 = 0, k2 = f2, 0 === c3) {
                  if (E2 += u2 - w, w < v2) {
                    v2 -= w;
                    do {
                      A2[a2++] = f2[E2++];
                    } while (--w);
                    E2 = a2 - x2, k2 = A2;
                  }
                } else if (c3 < w) {
                  if (E2 += u2 + c3 - w, (w -= c3) < v2) {
                    v2 -= w;
                    do {
                      A2[a2++] = f2[E2++];
                    } while (--w);
                    if (E2 = 0, c3 < v2) {
                      v2 -= w = c3;
                      do {
                        A2[a2++] = f2[E2++];
                      } while (--w);
                      E2 = a2 - x2, k2 = A2;
                    }
                  }
                } else if (E2 += c3 - w, w < v2) {
                  v2 -= w;
                  do {
                    A2[a2++] = f2[E2++];
                  } while (--w);
                  E2 = a2 - x2, k2 = A2;
                }
                for (; v2 > 2; ) A2[a2++] = k2[E2++], A2[a2++] = k2[E2++], A2[a2++] = k2[E2++], v2 -= 3;
                v2 && (A2[a2++] = k2[E2++], v2 > 1 && (A2[a2++] = k2[E2++]));
              } else {
                E2 = a2 - x2;
                do {
                  A2[a2++] = A2[E2++], A2[a2++] = A2[E2++], A2[a2++] = A2[E2++], v2 -= 3;
                } while (v2 > 2);
                v2 && (A2[a2++] = A2[E2++], v2 > 1 && (A2[a2++] = A2[E2++]));
              }
              break;
            }
            if (64 & w) {
              e5.msg = "invalid distance code", i2.mode = 30;
              break e;
            }
            y2 = _2[(65535 & y2) + (d & (1 << w) - 1)];
          }
        }
        break;
      }
    } while (r4 < n3 && a2 < s4);
    r4 -= v2 = p2 >> 3, d &= (1 << (p2 -= v2 << 3)) - 1, e5.next_in = r4, e5.next_out = a2, e5.avail_in = r4 < n3 ? n3 - r4 + 5 : 5 - (r4 - n3), e5.avail_out = a2 < s4 ? s4 - a2 + 257 : 257 - (a2 - s4), i2.hold = d, i2.bits = p2;
  }, "inffast"), inffast;
}
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var e5 = requireCommon(), t3 = 15, i2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], r4 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], n3 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], a2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
  return inftrees = /* @__PURE__ */ __name(function(o3, s4, l2, u2, h2, c3, f2, d) {
    var p2, m, _2, g, b2, y2, w, v2, x2, E2 = d.bits, k2 = 0, S2 = 0, A2 = 0, I = 0, M2 = 0, T2 = 0, P = 0, B2 = 0, C2 = 0, R2 = 0, z2 = null, F = 0, N2 = new e5.Buf16(16), O2 = new e5.Buf16(16), D = null, $ = 0;
    for (k2 = 0; k2 <= t3; k2++) N2[k2] = 0;
    for (S2 = 0; S2 < u2; S2++) N2[s4[l2 + S2]]++;
    for (M2 = E2, I = t3; I >= 1 && 0 === N2[I]; I--) ;
    if (M2 > I && (M2 = I), 0 === I) return h2[c3++] = 20971520, h2[c3++] = 20971520, d.bits = 1, 0;
    for (A2 = 1; A2 < I && 0 === N2[A2]; A2++) ;
    for (M2 < A2 && (M2 = A2), B2 = 1, k2 = 1; k2 <= t3; k2++) if (B2 <<= 1, (B2 -= N2[k2]) < 0) return -1;
    if (B2 > 0 && (0 === o3 || 1 !== I)) return -1;
    for (O2[1] = 0, k2 = 1; k2 < t3; k2++) O2[k2 + 1] = O2[k2] + N2[k2];
    for (S2 = 0; S2 < u2; S2++) 0 !== s4[l2 + S2] && (f2[O2[s4[l2 + S2]]++] = S2);
    if (0 === o3 ? (z2 = D = f2, y2 = 19) : 1 === o3 ? (z2 = i2, F -= 257, D = r4, $ -= 257, y2 = 256) : (z2 = n3, D = a2, y2 = -1), R2 = 0, S2 = 0, k2 = A2, b2 = c3, T2 = M2, P = 0, _2 = -1, g = (C2 = 1 << M2) - 1, 1 === o3 && C2 > 852 || 2 === o3 && C2 > 592) return 1;
    for (; ; ) {
      w = k2 - P, f2[S2] < y2 ? (v2 = 0, x2 = f2[S2]) : f2[S2] > y2 ? (v2 = D[$ + f2[S2]], x2 = z2[F + f2[S2]]) : (v2 = 96, x2 = 0), p2 = 1 << k2 - P, A2 = m = 1 << T2;
      do {
        h2[b2 + (R2 >> P) + (m -= p2)] = w << 24 | v2 << 16 | x2;
      } while (0 !== m);
      for (p2 = 1 << k2 - 1; R2 & p2; ) p2 >>= 1;
      if (0 !== p2 ? (R2 &= p2 - 1, R2 += p2) : R2 = 0, S2++, 0 == --N2[k2]) {
        if (k2 === I) break;
        k2 = s4[l2 + f2[S2]];
      }
      if (k2 > M2 && (R2 & g) !== _2) {
        for (0 === P && (P = M2), b2 += A2, B2 = 1 << (T2 = k2 - P); T2 + P < I && !((B2 -= N2[T2 + P]) <= 0); ) T2++, B2 <<= 1;
        if (C2 += 1 << T2, 1 === o3 && C2 > 852 || 2 === o3 && C2 > 592) return 1;
        h2[_2 = R2 & g] = M2 << 24 | T2 << 16 | b2 - c3;
      }
    }
    return 0 !== R2 && (h2[b2 + R2] = k2 - P << 24 | 64 << 16), d.bits = M2, 0;
  }, "inftrees");
}
function requireInflate$1() {
  if (hasRequiredInflate$1) return inflate;
  hasRequiredInflate$1 = 1;
  var e5 = requireCommon(), t3 = requireAdler32(), i2 = requireCrc32(), r4 = requireInffast(), n3 = requireInftrees(), a2 = 1, o3 = 2, s4 = 0, l2 = -2, u2 = 1, h2 = 12, c3 = 30, f2 = 852, d = 592;
  function p2(e6) {
    return (e6 >>> 24 & 255) + (e6 >>> 8 & 65280) + ((65280 & e6) << 8) + ((255 & e6) << 24);
  }
  __name(p2, "p");
  function m() {
    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e5.Buf16(320), this.work = new e5.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
  }
  __name(m, "m");
  function _2(t4) {
    var i3;
    return t4 && t4.state ? (i3 = t4.state, t4.total_in = t4.total_out = i3.total = 0, t4.msg = "", i3.wrap && (t4.adler = 1 & i3.wrap), i3.mode = u2, i3.last = 0, i3.havedict = 0, i3.dmax = 32768, i3.head = null, i3.hold = 0, i3.bits = 0, i3.lencode = i3.lendyn = new e5.Buf32(f2), i3.distcode = i3.distdyn = new e5.Buf32(d), i3.sane = 1, i3.back = -1, s4) : l2;
  }
  __name(_2, "_");
  function g(e6) {
    var t4;
    return e6 && e6.state ? ((t4 = e6.state).wsize = 0, t4.whave = 0, t4.wnext = 0, _2(e6)) : l2;
  }
  __name(g, "g");
  function b2(e6, t4) {
    var i3, r5;
    return e6 && e6.state ? (r5 = e6.state, t4 < 0 ? (i3 = 0, t4 = -t4) : (i3 = 1 + (t4 >> 4), t4 < 48 && (t4 &= 15)), t4 && (t4 < 8 || t4 > 15) ? l2 : (null !== r5.window && r5.wbits !== t4 && (r5.window = null), r5.wrap = i3, r5.wbits = t4, g(e6))) : l2;
  }
  __name(b2, "b");
  function y2(e6, t4) {
    var i3, r5;
    return e6 ? (r5 = new m(), e6.state = r5, r5.window = null, (i3 = b2(e6, t4)) !== s4 && (e6.state = null), i3) : l2;
  }
  __name(y2, "y");
  var w, v2, x2 = true;
  function E2(t4) {
    if (x2) {
      var i3;
      for (w = new e5.Buf32(512), v2 = new e5.Buf32(32), i3 = 0; i3 < 144; ) t4.lens[i3++] = 8;
      for (; i3 < 256; ) t4.lens[i3++] = 9;
      for (; i3 < 280; ) t4.lens[i3++] = 7;
      for (; i3 < 288; ) t4.lens[i3++] = 8;
      for (n3(a2, t4.lens, 0, 288, w, 0, t4.work, { bits: 9 }), i3 = 0; i3 < 32; ) t4.lens[i3++] = 5;
      n3(o3, t4.lens, 0, 32, v2, 0, t4.work, { bits: 5 }), x2 = false;
    }
    t4.lencode = w, t4.lenbits = 9, t4.distcode = v2, t4.distbits = 5;
  }
  __name(E2, "E");
  function k2(t4, i3, r5, n4) {
    var a3, o4 = t4.state;
    return null === o4.window && (o4.wsize = 1 << o4.wbits, o4.wnext = 0, o4.whave = 0, o4.window = new e5.Buf8(o4.wsize)), n4 >= o4.wsize ? (e5.arraySet(o4.window, i3, r5 - o4.wsize, o4.wsize, 0), o4.wnext = 0, o4.whave = o4.wsize) : ((a3 = o4.wsize - o4.wnext) > n4 && (a3 = n4), e5.arraySet(o4.window, i3, r5 - n4, a3, o4.wnext), (n4 -= a3) ? (e5.arraySet(o4.window, i3, r5 - n4, n4, 0), o4.wnext = n4, o4.whave = o4.wsize) : (o4.wnext += a3, o4.wnext === o4.wsize && (o4.wnext = 0), o4.whave < o4.wsize && (o4.whave += a3))), 0;
  }
  __name(k2, "k");
  return inflate.inflateReset = g, inflate.inflateReset2 = b2, inflate.inflateResetKeep = _2, inflate.inflateInit = function(e6) {
    return y2(e6, 15);
  }, inflate.inflateInit2 = y2, inflate.inflate = function(f3, d2) {
    var m2, _3, g2, b3, y3, w2, v3, x3, S2, A2, I, M2, T2, P, B2, C2, R2, z2, F, N2, O2, D, $, L2, U = 0, Z = new e5.Buf8(4), j = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    if (!f3 || !f3.state || !f3.output || !f3.input && 0 !== f3.avail_in) return l2;
    (m2 = f3.state).mode === h2 && (m2.mode = 13), y3 = f3.next_out, g2 = f3.output, v3 = f3.avail_out, b3 = f3.next_in, _3 = f3.input, w2 = f3.avail_in, x3 = m2.hold, S2 = m2.bits, A2 = w2, I = v3, D = s4;
    e: for (; ; ) switch (m2.mode) {
      case u2:
        if (0 === m2.wrap) {
          m2.mode = 13;
          break;
        }
        for (; S2 < 16; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        if (2 & m2.wrap && 35615 === x3) {
          m2.check = 0, Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0), x3 = 0, S2 = 0, m2.mode = 2;
          break;
        }
        if (m2.flags = 0, m2.head && (m2.head.done = false), !(1 & m2.wrap) || (((255 & x3) << 8) + (x3 >> 8)) % 31) {
          f3.msg = "incorrect header check", m2.mode = c3;
          break;
        }
        if (8 != (15 & x3)) {
          f3.msg = "unknown compression method", m2.mode = c3;
          break;
        }
        if (S2 -= 4, O2 = 8 + (15 & (x3 >>>= 4)), 0 === m2.wbits) m2.wbits = O2;
        else if (O2 > m2.wbits) {
          f3.msg = "invalid window size", m2.mode = c3;
          break;
        }
        m2.dmax = 1 << O2, f3.adler = m2.check = 1, m2.mode = 512 & x3 ? 10 : h2, x3 = 0, S2 = 0;
        break;
      case 2:
        for (; S2 < 16; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        if (m2.flags = x3, 8 != (255 & m2.flags)) {
          f3.msg = "unknown compression method", m2.mode = c3;
          break;
        }
        if (57344 & m2.flags) {
          f3.msg = "unknown header flags set", m2.mode = c3;
          break;
        }
        m2.head && (m2.head.text = x3 >> 8 & 1), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0)), x3 = 0, S2 = 0, m2.mode = 3;
      case 3:
        for (; S2 < 32; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        m2.head && (m2.head.time = x3), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, Z[2] = x3 >>> 16 & 255, Z[3] = x3 >>> 24 & 255, m2.check = i2(m2.check, Z, 4, 0)), x3 = 0, S2 = 0, m2.mode = 4;
      case 4:
        for (; S2 < 16; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        m2.head && (m2.head.xflags = 255 & x3, m2.head.os = x3 >> 8), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0)), x3 = 0, S2 = 0, m2.mode = 5;
      case 5:
        if (1024 & m2.flags) {
          for (; S2 < 16; ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          m2.length = x3, m2.head && (m2.head.extra_len = x3), 512 & m2.flags && (Z[0] = 255 & x3, Z[1] = x3 >>> 8 & 255, m2.check = i2(m2.check, Z, 2, 0)), x3 = 0, S2 = 0;
        } else m2.head && (m2.head.extra = null);
        m2.mode = 6;
      case 6:
        if (1024 & m2.flags && ((M2 = m2.length) > w2 && (M2 = w2), M2 && (m2.head && (O2 = m2.head.extra_len - m2.length, m2.head.extra || (m2.head.extra = new Array(m2.head.extra_len)), e5.arraySet(m2.head.extra, _3, b3, M2, O2)), 512 & m2.flags && (m2.check = i2(m2.check, _3, M2, b3)), w2 -= M2, b3 += M2, m2.length -= M2), m2.length)) break e;
        m2.length = 0, m2.mode = 7;
      case 7:
        if (2048 & m2.flags) {
          if (0 === w2) break e;
          M2 = 0;
          do {
            O2 = _3[b3 + M2++], m2.head && O2 && m2.length < 65536 && (m2.head.name += String.fromCharCode(O2));
          } while (O2 && M2 < w2);
          if (512 & m2.flags && (m2.check = i2(m2.check, _3, M2, b3)), w2 -= M2, b3 += M2, O2) break e;
        } else m2.head && (m2.head.name = null);
        m2.length = 0, m2.mode = 8;
      case 8:
        if (4096 & m2.flags) {
          if (0 === w2) break e;
          M2 = 0;
          do {
            O2 = _3[b3 + M2++], m2.head && O2 && m2.length < 65536 && (m2.head.comment += String.fromCharCode(O2));
          } while (O2 && M2 < w2);
          if (512 & m2.flags && (m2.check = i2(m2.check, _3, M2, b3)), w2 -= M2, b3 += M2, O2) break e;
        } else m2.head && (m2.head.comment = null);
        m2.mode = 9;
      case 9:
        if (512 & m2.flags) {
          for (; S2 < 16; ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          if (x3 !== (65535 & m2.check)) {
            f3.msg = "header crc mismatch", m2.mode = c3;
            break;
          }
          x3 = 0, S2 = 0;
        }
        m2.head && (m2.head.hcrc = m2.flags >> 9 & 1, m2.head.done = true), f3.adler = m2.check = 0, m2.mode = h2;
        break;
      case 10:
        for (; S2 < 32; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        f3.adler = m2.check = p2(x3), x3 = 0, S2 = 0, m2.mode = 11;
      case 11:
        if (0 === m2.havedict) return f3.next_out = y3, f3.avail_out = v3, f3.next_in = b3, f3.avail_in = w2, m2.hold = x3, m2.bits = S2, 2;
        f3.adler = m2.check = 1, m2.mode = h2;
      case h2:
        if (5 === d2 || 6 === d2) break e;
      case 13:
        if (m2.last) {
          x3 >>>= 7 & S2, S2 -= 7 & S2, m2.mode = 27;
          break;
        }
        for (; S2 < 3; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        switch (m2.last = 1 & x3, S2 -= 1, 3 & (x3 >>>= 1)) {
          case 0:
            m2.mode = 14;
            break;
          case 1:
            if (E2(m2), m2.mode = 20, 6 === d2) {
              x3 >>>= 2, S2 -= 2;
              break e;
            }
            break;
          case 2:
            m2.mode = 17;
            break;
          case 3:
            f3.msg = "invalid block type", m2.mode = c3;
        }
        x3 >>>= 2, S2 -= 2;
        break;
      case 14:
        for (x3 >>>= 7 & S2, S2 -= 7 & S2; S2 < 32; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        if ((65535 & x3) != (x3 >>> 16 ^ 65535)) {
          f3.msg = "invalid stored block lengths", m2.mode = c3;
          break;
        }
        if (m2.length = 65535 & x3, x3 = 0, S2 = 0, m2.mode = 15, 6 === d2) break e;
      case 15:
        m2.mode = 16;
      case 16:
        if (M2 = m2.length) {
          if (M2 > w2 && (M2 = w2), M2 > v3 && (M2 = v3), 0 === M2) break e;
          e5.arraySet(g2, _3, b3, M2, y3), w2 -= M2, b3 += M2, v3 -= M2, y3 += M2, m2.length -= M2;
          break;
        }
        m2.mode = h2;
        break;
      case 17:
        for (; S2 < 14; ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        if (m2.nlen = 257 + (31 & x3), x3 >>>= 5, S2 -= 5, m2.ndist = 1 + (31 & x3), x3 >>>= 5, S2 -= 5, m2.ncode = 4 + (15 & x3), x3 >>>= 4, S2 -= 4, m2.nlen > 286 || m2.ndist > 30) {
          f3.msg = "too many length or distance symbols", m2.mode = c3;
          break;
        }
        m2.have = 0, m2.mode = 18;
      case 18:
        for (; m2.have < m2.ncode; ) {
          for (; S2 < 3; ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          m2.lens[j[m2.have++]] = 7 & x3, x3 >>>= 3, S2 -= 3;
        }
        for (; m2.have < 19; ) m2.lens[j[m2.have++]] = 0;
        if (m2.lencode = m2.lendyn, m2.lenbits = 7, $ = { bits: m2.lenbits }, D = n3(0, m2.lens, 0, 19, m2.lencode, 0, m2.work, $), m2.lenbits = $.bits, D) {
          f3.msg = "invalid code lengths set", m2.mode = c3;
          break;
        }
        m2.have = 0, m2.mode = 19;
      case 19:
        for (; m2.have < m2.nlen + m2.ndist; ) {
          for (; C2 = (U = m2.lencode[x3 & (1 << m2.lenbits) - 1]) >>> 16 & 255, R2 = 65535 & U, !((B2 = U >>> 24) <= S2); ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          if (R2 < 16) x3 >>>= B2, S2 -= B2, m2.lens[m2.have++] = R2;
          else {
            if (16 === R2) {
              for (L2 = B2 + 2; S2 < L2; ) {
                if (0 === w2) break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              if (x3 >>>= B2, S2 -= B2, 0 === m2.have) {
                f3.msg = "invalid bit length repeat", m2.mode = c3;
                break;
              }
              O2 = m2.lens[m2.have - 1], M2 = 3 + (3 & x3), x3 >>>= 2, S2 -= 2;
            } else if (17 === R2) {
              for (L2 = B2 + 3; S2 < L2; ) {
                if (0 === w2) break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              S2 -= B2, O2 = 0, M2 = 3 + (7 & (x3 >>>= B2)), x3 >>>= 3, S2 -= 3;
            } else {
              for (L2 = B2 + 7; S2 < L2; ) {
                if (0 === w2) break e;
                w2--, x3 += _3[b3++] << S2, S2 += 8;
              }
              S2 -= B2, O2 = 0, M2 = 11 + (127 & (x3 >>>= B2)), x3 >>>= 7, S2 -= 7;
            }
            if (m2.have + M2 > m2.nlen + m2.ndist) {
              f3.msg = "invalid bit length repeat", m2.mode = c3;
              break;
            }
            for (; M2--; ) m2.lens[m2.have++] = O2;
          }
        }
        if (m2.mode === c3) break;
        if (0 === m2.lens[256]) {
          f3.msg = "invalid code -- missing end-of-block", m2.mode = c3;
          break;
        }
        if (m2.lenbits = 9, $ = { bits: m2.lenbits }, D = n3(a2, m2.lens, 0, m2.nlen, m2.lencode, 0, m2.work, $), m2.lenbits = $.bits, D) {
          f3.msg = "invalid literal/lengths set", m2.mode = c3;
          break;
        }
        if (m2.distbits = 6, m2.distcode = m2.distdyn, $ = { bits: m2.distbits }, D = n3(o3, m2.lens, m2.nlen, m2.ndist, m2.distcode, 0, m2.work, $), m2.distbits = $.bits, D) {
          f3.msg = "invalid distances set", m2.mode = c3;
          break;
        }
        if (m2.mode = 20, 6 === d2) break e;
      case 20:
        m2.mode = 21;
      case 21:
        if (w2 >= 6 && v3 >= 258) {
          f3.next_out = y3, f3.avail_out = v3, f3.next_in = b3, f3.avail_in = w2, m2.hold = x3, m2.bits = S2, r4(f3, I), y3 = f3.next_out, g2 = f3.output, v3 = f3.avail_out, b3 = f3.next_in, _3 = f3.input, w2 = f3.avail_in, x3 = m2.hold, S2 = m2.bits, m2.mode === h2 && (m2.back = -1);
          break;
        }
        for (m2.back = 0; C2 = (U = m2.lencode[x3 & (1 << m2.lenbits) - 1]) >>> 16 & 255, R2 = 65535 & U, !((B2 = U >>> 24) <= S2); ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        if (C2 && !(240 & C2)) {
          for (z2 = B2, F = C2, N2 = R2; C2 = (U = m2.lencode[N2 + ((x3 & (1 << z2 + F) - 1) >> z2)]) >>> 16 & 255, R2 = 65535 & U, !(z2 + (B2 = U >>> 24) <= S2); ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          x3 >>>= z2, S2 -= z2, m2.back += z2;
        }
        if (x3 >>>= B2, S2 -= B2, m2.back += B2, m2.length = R2, 0 === C2) {
          m2.mode = 26;
          break;
        }
        if (32 & C2) {
          m2.back = -1, m2.mode = h2;
          break;
        }
        if (64 & C2) {
          f3.msg = "invalid literal/length code", m2.mode = c3;
          break;
        }
        m2.extra = 15 & C2, m2.mode = 22;
      case 22:
        if (m2.extra) {
          for (L2 = m2.extra; S2 < L2; ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          m2.length += x3 & (1 << m2.extra) - 1, x3 >>>= m2.extra, S2 -= m2.extra, m2.back += m2.extra;
        }
        m2.was = m2.length, m2.mode = 23;
      case 23:
        for (; C2 = (U = m2.distcode[x3 & (1 << m2.distbits) - 1]) >>> 16 & 255, R2 = 65535 & U, !((B2 = U >>> 24) <= S2); ) {
          if (0 === w2) break e;
          w2--, x3 += _3[b3++] << S2, S2 += 8;
        }
        if (!(240 & C2)) {
          for (z2 = B2, F = C2, N2 = R2; C2 = (U = m2.distcode[N2 + ((x3 & (1 << z2 + F) - 1) >> z2)]) >>> 16 & 255, R2 = 65535 & U, !(z2 + (B2 = U >>> 24) <= S2); ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          x3 >>>= z2, S2 -= z2, m2.back += z2;
        }
        if (x3 >>>= B2, S2 -= B2, m2.back += B2, 64 & C2) {
          f3.msg = "invalid distance code", m2.mode = c3;
          break;
        }
        m2.offset = R2, m2.extra = 15 & C2, m2.mode = 24;
      case 24:
        if (m2.extra) {
          for (L2 = m2.extra; S2 < L2; ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          m2.offset += x3 & (1 << m2.extra) - 1, x3 >>>= m2.extra, S2 -= m2.extra, m2.back += m2.extra;
        }
        if (m2.offset > m2.dmax) {
          f3.msg = "invalid distance too far back", m2.mode = c3;
          break;
        }
        m2.mode = 25;
      case 25:
        if (0 === v3) break e;
        if (M2 = I - v3, m2.offset > M2) {
          if ((M2 = m2.offset - M2) > m2.whave && m2.sane) {
            f3.msg = "invalid distance too far back", m2.mode = c3;
            break;
          }
          M2 > m2.wnext ? (M2 -= m2.wnext, T2 = m2.wsize - M2) : T2 = m2.wnext - M2, M2 > m2.length && (M2 = m2.length), P = m2.window;
        } else P = g2, T2 = y3 - m2.offset, M2 = m2.length;
        M2 > v3 && (M2 = v3), v3 -= M2, m2.length -= M2;
        do {
          g2[y3++] = P[T2++];
        } while (--M2);
        0 === m2.length && (m2.mode = 21);
        break;
      case 26:
        if (0 === v3) break e;
        g2[y3++] = m2.length, v3--, m2.mode = 21;
        break;
      case 27:
        if (m2.wrap) {
          for (; S2 < 32; ) {
            if (0 === w2) break e;
            w2--, x3 |= _3[b3++] << S2, S2 += 8;
          }
          if (I -= v3, f3.total_out += I, m2.total += I, I && (f3.adler = m2.check = m2.flags ? i2(m2.check, g2, I, y3 - I) : t3(m2.check, g2, I, y3 - I)), I = v3, (m2.flags ? x3 : p2(x3)) !== m2.check) {
            f3.msg = "incorrect data check", m2.mode = c3;
            break;
          }
          x3 = 0, S2 = 0;
        }
        m2.mode = 28;
      case 28:
        if (m2.wrap && m2.flags) {
          for (; S2 < 32; ) {
            if (0 === w2) break e;
            w2--, x3 += _3[b3++] << S2, S2 += 8;
          }
          if (x3 !== (4294967295 & m2.total)) {
            f3.msg = "incorrect length check", m2.mode = c3;
            break;
          }
          x3 = 0, S2 = 0;
        }
        m2.mode = 29;
      case 29:
        D = 1;
        break e;
      case c3:
        D = -3;
        break e;
      case 31:
        return -4;
      default:
        return l2;
    }
    return f3.next_out = y3, f3.avail_out = v3, f3.next_in = b3, f3.avail_in = w2, m2.hold = x3, m2.bits = S2, (m2.wsize || I !== f3.avail_out && m2.mode < c3 && (m2.mode < 27 || 4 !== d2)) && k2(f3, f3.output, f3.next_out, I - f3.avail_out), A2 -= f3.avail_in, I -= f3.avail_out, f3.total_in += A2, f3.total_out += I, m2.total += I, m2.wrap && I && (f3.adler = m2.check = m2.flags ? i2(m2.check, g2, I, f3.next_out - I) : t3(m2.check, g2, I, f3.next_out - I)), f3.data_type = m2.bits + (m2.last ? 64 : 0) + (m2.mode === h2 ? 128 : 0) + (20 === m2.mode || 15 === m2.mode ? 256 : 0), (0 === A2 && 0 === I || 4 === d2) && D === s4 && (D = -5), D;
  }, inflate.inflateEnd = function(e6) {
    if (!e6 || !e6.state) return l2;
    var t4 = e6.state;
    return t4.window && (t4.window = null), e6.state = null, s4;
  }, inflate.inflateGetHeader = function(e6, t4) {
    var i3;
    return e6 && e6.state && 2 & (i3 = e6.state).wrap ? (i3.head = t4, t4.done = false, s4) : l2;
  }, inflate.inflateSetDictionary = function(e6, i3) {
    var r5, n4 = i3.length;
    return e6 && e6.state ? 0 !== (r5 = e6.state).wrap && 11 !== r5.mode ? l2 : 11 === r5.mode && t3(1, i3, n4, 0) !== r5.check ? -3 : k2(e6, i3, n4, n4) ? (r5.mode = 31, -4) : (r5.havedict = 1, s4) : l2;
  }, inflate.inflateInfo = "pako inflate (from Nodeca project)", inflate;
}
function requireConstants() {
  return hasRequiredConstants ? constants : (hasRequiredConstants = 1, constants = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 });
}
function requireGzheader() {
  if (hasRequiredGzheader) return gzheader;
  return hasRequiredGzheader = 1, gzheader = /* @__PURE__ */ __name(function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
  }, "gzheader");
}
function requireInflate() {
  if (hasRequiredInflate) return inflate$1;
  hasRequiredInflate = 1;
  var e5 = requireInflate$1(), t3 = requireCommon(), i2 = requireStrings(), r4 = requireConstants(), n3 = requireMessages(), a2 = requireZstream(), o3 = requireGzheader(), s4 = Object.prototype.toString;
  function l2(u3) {
    if (!(this instanceof l2)) return new l2(u3);
    this.options = t3.assign({ chunkSize: 16384, windowBits: 0, to: "" }, u3 || {});
    var h2 = this.options;
    h2.raw && h2.windowBits >= 0 && h2.windowBits < 16 && (h2.windowBits = -h2.windowBits, 0 === h2.windowBits && (h2.windowBits = -15)), !(h2.windowBits >= 0 && h2.windowBits < 16) || u3 && u3.windowBits || (h2.windowBits += 32), h2.windowBits > 15 && h2.windowBits < 48 && (15 & h2.windowBits || (h2.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new a2(), this.strm.avail_out = 0;
    var c3 = e5.inflateInit2(this.strm, h2.windowBits);
    if (c3 !== r4.Z_OK) throw new Error(n3[c3]);
    if (this.header = new o3(), e5.inflateGetHeader(this.strm, this.header), h2.dictionary && ("string" == typeof h2.dictionary ? h2.dictionary = i2.string2buf(h2.dictionary) : "[object ArrayBuffer]" === s4.call(h2.dictionary) && (h2.dictionary = new Uint8Array(h2.dictionary)), h2.raw && (c3 = e5.inflateSetDictionary(this.strm, h2.dictionary)) !== r4.Z_OK)) throw new Error(n3[c3]);
  }
  __name(l2, "l");
  function u2(e6, t4) {
    var i3 = new l2(t4);
    if (i3.push(e6, true), i3.err) throw i3.msg || n3[i3.err];
    return i3.result;
  }
  __name(u2, "u");
  return l2.prototype.push = function(n4, a3) {
    var o4, l3, u3, h2, c3, f2 = this.strm, d = this.options.chunkSize, p2 = this.options.dictionary, m = false;
    if (this.ended) return false;
    l3 = a3 === ~~a3 ? a3 : true === a3 ? r4.Z_FINISH : r4.Z_NO_FLUSH, "string" == typeof n4 ? f2.input = i2.binstring2buf(n4) : "[object ArrayBuffer]" === s4.call(n4) ? f2.input = new Uint8Array(n4) : f2.input = n4, f2.next_in = 0, f2.avail_in = f2.input.length;
    do {
      if (0 === f2.avail_out && (f2.output = new t3.Buf8(d), f2.next_out = 0, f2.avail_out = d), (o4 = e5.inflate(f2, r4.Z_NO_FLUSH)) === r4.Z_NEED_DICT && p2 && (o4 = e5.inflateSetDictionary(this.strm, p2)), o4 === r4.Z_BUF_ERROR && true === m && (o4 = r4.Z_OK, m = false), o4 !== r4.Z_STREAM_END && o4 !== r4.Z_OK) return this.onEnd(o4), this.ended = true, false;
      f2.next_out && (0 !== f2.avail_out && o4 !== r4.Z_STREAM_END && (0 !== f2.avail_in || l3 !== r4.Z_FINISH && l3 !== r4.Z_SYNC_FLUSH) || ("string" === this.options.to ? (u3 = i2.utf8border(f2.output, f2.next_out), h2 = f2.next_out - u3, c3 = i2.buf2string(f2.output, u3), f2.next_out = h2, f2.avail_out = d - h2, h2 && t3.arraySet(f2.output, f2.output, u3, h2, 0), this.onData(c3)) : this.onData(t3.shrinkBuf(f2.output, f2.next_out)))), 0 === f2.avail_in && 0 === f2.avail_out && (m = true);
    } while ((f2.avail_in > 0 || 0 === f2.avail_out) && o4 !== r4.Z_STREAM_END);
    return o4 === r4.Z_STREAM_END && (l3 = r4.Z_FINISH), l3 === r4.Z_FINISH ? (o4 = e5.inflateEnd(this.strm), this.onEnd(o4), this.ended = true, o4 === r4.Z_OK) : l3 !== r4.Z_SYNC_FLUSH || (this.onEnd(r4.Z_OK), f2.avail_out = 0, true);
  }, l2.prototype.onData = function(e6) {
    this.chunks.push(e6);
  }, l2.prototype.onEnd = function(e6) {
    e6 === r4.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = t3.flattenChunks(this.chunks)), this.chunks = [], this.err = e6, this.msg = this.strm.msg;
  }, inflate$1.Inflate = l2, inflate$1.inflate = u2, inflate$1.inflateRaw = function(e6, t4) {
    return (t4 = t4 || {}).raw = true, u2(e6, t4);
  }, inflate$1.ungzip = u2, inflate$1;
}
function requirePako() {
  if (hasRequiredPako) return pako_1;
  hasRequiredPako = 1;
  var e5 = {};
  return (0, requireCommon().assign)(e5, requireDeflate(), requireInflate(), requireConstants()), pako_1 = e5;
}
function getDimensionValue(e5) {
  return "number" == typeof e5 ? e5 : e5 instanceof Uint8Array ? e5[0] : "string" == typeof e5[0] ? parseInt(e5[0]) : e5[0];
}
function tiff() {
  return { mime: "image/tiff", encode: /* @__PURE__ */ __name((e5) => {
    const t3 = utif.encodeImage(e5.data, e5.width, e5.height);
    return Buffer2.from(t3);
  }, "encode"), decode: /* @__PURE__ */ __name((e5) => {
    const t3 = utif.decode(e5), i2 = t3[0];
    if (!i2) throw new Error("No page found in TIFF");
    if (!i2.t256) throw new Error("No image width found in TIFF");
    if (!i2.t257) throw new Error("No image height found in TIFF");
    t3.forEach((t4) => {
      utif.decodeImage(e5, t4);
    });
    const r4 = utif.toRGBA8(i2);
    return { data: Buffer2.from(r4), width: getDimensionValue(i2.t256), height: getDimensionValue(i2.t257) };
  }, "decode") };
}
function setErrorMap(e5) {
  overrideErrorMap = e5;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(e5, t3) {
  const i2 = getErrorMap(), r4 = makeIssue({ issueData: t3, data: e5.data, path: e5.path, errorMaps: [e5.common.contextualErrorMap, e5.schemaErrorMap, i2, i2 === errorMap ? void 0 : errorMap].filter((e6) => !!e6) });
  e5.common.issues.push(r4);
}
function __classPrivateFieldGet(e5, t3, i2, r4) {
  if ("function" == typeof t3 ? e5 !== t3 || !r4 : !t3.has(e5)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t3.get(e5);
}
function __classPrivateFieldSet(e5, t3, i2, r4, n3) {
  if ("function" == typeof t3 ? e5 !== t3 || !n3 : !t3.has(e5)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t3.set(e5, i2), i2;
}
function processCreateParams(e5) {
  if (!e5) return {};
  const { errorMap: t3, invalid_type_error: i2, required_error: r4, description: n3 } = e5;
  if (t3 && (i2 || r4)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (t3) return { errorMap: t3, description: n3 };
  return { errorMap: /* @__PURE__ */ __name((t4, n4) => {
    var a2, o3;
    const { message: s4 } = e5;
    return "invalid_enum_value" === t4.code ? { message: null != s4 ? s4 : n4.defaultError } : void 0 === n4.data ? { message: null !== (a2 = null != s4 ? s4 : r4) && void 0 !== a2 ? a2 : n4.defaultError } : "invalid_type" !== t4.code ? { message: n4.defaultError } : { message: null !== (o3 = null != s4 ? s4 : i2) && void 0 !== o3 ? o3 : n4.defaultError };
  }, "errorMap"), description: n3 };
}
function timeRegexSource(e5) {
  let t3 = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e5.precision ? t3 = `${t3}\\.\\d{${e5.precision}}` : null == e5.precision && (t3 = `${t3}(\\.\\d+)?`), t3;
}
function timeRegex(e5) {
  return new RegExp(`^${timeRegexSource(e5)}$`);
}
function datetimeRegex(e5) {
  let t3 = `${dateRegexSource}T${timeRegexSource(e5)}`;
  const i2 = [];
  return i2.push(e5.local ? "Z?" : "Z"), e5.offset && i2.push("([+-]\\d{2}:?\\d{2})"), t3 = `${t3}(${i2.join("|")})`, new RegExp(`^${t3}$`);
}
function isValidIP(e5, t3) {
  return !("v4" !== t3 && t3 || !ipv4Regex.test(e5)) || !("v6" !== t3 && t3 || !ipv6Regex.test(e5));
}
function floatSafeRemainder(e5, t3) {
  const i2 = (e5.toString().split(".")[1] || "").length, r4 = (t3.toString().split(".")[1] || "").length, n3 = i2 > r4 ? i2 : r4;
  return parseInt(e5.toFixed(n3).replace(".", "")) % parseInt(t3.toFixed(n3).replace(".", "")) / Math.pow(10, n3);
}
function deepPartialify(e5) {
  if (e5 instanceof ZodObject) {
    const t3 = {};
    for (const i2 in e5.shape) {
      const r4 = e5.shape[i2];
      t3[i2] = ZodOptional.create(deepPartialify(r4));
    }
    return new ZodObject({ ...e5._def, shape: /* @__PURE__ */ __name(() => t3, "shape") });
  }
  return e5 instanceof ZodArray ? new ZodArray({ ...e5._def, type: deepPartialify(e5.element) }) : e5 instanceof ZodOptional ? ZodOptional.create(deepPartialify(e5.unwrap())) : e5 instanceof ZodNullable ? ZodNullable.create(deepPartialify(e5.unwrap())) : e5 instanceof ZodTuple ? ZodTuple.create(e5.items.map((e6) => deepPartialify(e6))) : e5;
}
function mergeValues(e5, t3) {
  const i2 = getParsedType(e5), r4 = getParsedType(t3);
  if (e5 === t3) return { valid: true, data: e5 };
  if (i2 === ZodParsedType.object && r4 === ZodParsedType.object) {
    const i3 = util$1.objectKeys(t3), r5 = util$1.objectKeys(e5).filter((e6) => -1 !== i3.indexOf(e6)), n3 = { ...e5, ...t3 };
    for (const i4 of r5) {
      const r6 = mergeValues(e5[i4], t3[i4]);
      if (!r6.valid) return { valid: false };
      n3[i4] = r6.data;
    }
    return { valid: true, data: n3 };
  }
  if (i2 === ZodParsedType.array && r4 === ZodParsedType.array) {
    if (e5.length !== t3.length) return { valid: false };
    const i3 = [];
    for (let r5 = 0; r5 < e5.length; r5++) {
      const n3 = mergeValues(e5[r5], t3[r5]);
      if (!n3.valid) return { valid: false };
      i3.push(n3.data);
    }
    return { valid: true, data: i3 };
  }
  return i2 === ZodParsedType.date && r4 === ZodParsedType.date && +e5 == +t3 ? { valid: true, data: e5 } : { valid: false };
}
function createZodEnum(e5, t3) {
  return new ZodEnum({ values: e5, typeName: ZodFirstPartyTypeKind.ZodEnum, ...processCreateParams(t3) });
}
function custom(e5, t3 = {}, i2) {
  return e5 ? ZodAny.create().superRefine((r4, n3) => {
    var a2, o3;
    if (!e5(r4)) {
      const e6 = "function" == typeof t3 ? t3(r4) : "string" == typeof t3 ? { message: t3 } : t3, s4 = null === (o3 = null !== (a2 = e6.fatal) && void 0 !== a2 ? a2 : i2) || void 0 === o3 || o3, l2 = "string" == typeof e6 ? { message: e6 } : e6;
      n3.addIssue({ code: "custom", ...l2, fatal: s4 });
    }
  }) : ZodAny.create();
}
function applyKernel(e5, t3, i2, r4) {
  const n3 = [0, 0, 0, 0], a2 = (t3.length - 1) / 2;
  for (let o3 = 0; o3 < t3.length; o3 += 1) for (let s4 = 0; s4 < t3[o3].length; s4 += 1) {
    const l2 = e5.getPixelIndex(i2 + o3 - a2, r4 + s4 - a2);
    n3[0] += e5.bitmap.data[l2] * t3[o3][s4], n3[1] += e5.bitmap.data[l2 + 1] * t3[o3][s4], n3[2] += e5.bitmap.data[l2 + 2] * t3[o3][s4], n3[3] += e5.bitmap.data[l2 + 3] * t3[o3][s4];
  }
  return n3;
}
function mix(e5, t3, i2 = 50) {
  return { r: (t3.r - e5.r) * (i2 / 100) + e5.r, g: (t3.g - e5.g) * (i2 / 100) + e5.g, b: (t3.b - e5.b) * (i2 / 100) + e5.b };
}
function histogram(e5) {
  const t3 = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
  return e5.scan((i2, r4, n3) => {
    t3.r[e5.bitmap.data[n3 + 0]]++, t3.g[e5.bitmap.data[n3 + 1]]++, t3.b[e5.bitmap.data[n3 + 2]]++;
  }), t3;
}
async function fromStream(e5) {
  const t3 = await strtok3.fromStream(e5);
  try {
    return await fromTokenizer(t3);
  } finally {
    await t3.close();
  }
}
async function fromBuffer(e5) {
  if (!(e5 instanceof Uint8Array || e5 instanceof ArrayBuffer || Buffer2.isBuffer(e5))) throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof e5}\``);
  const t3 = e5 instanceof Buffer2 ? e5 : Buffer2.from(e5);
  if (!(t3 && t3.length > 1)) return;
  return fromTokenizer(strtok3.fromBuffer(t3));
}
function _check(e5, t3, i2) {
  i2 = { offset: 0, ...i2 };
  for (const [r4, n3] of t3.entries()) if (i2.mask) {
    if (n3 !== (i2.mask[r4] & e5[r4 + i2.offset])) return false;
  } else if (n3 !== e5[r4 + i2.offset]) return false;
  return true;
}
async function fromTokenizer(e5) {
  try {
    return _fromTokenizer(e5);
  } catch (e6) {
    if (!(e6 instanceof strtok3.EndOfStreamError)) throw e6;
  }
}
async function _fromTokenizer(e5) {
  let t3 = Buffer2.alloc(minimumBytes);
  const i2 = /* @__PURE__ */ __name((e6, i3) => _check(t3, e6, i3), "i"), r4 = /* @__PURE__ */ __name((e6, t4) => i2(stringToBytes(e6), t4), "r");
  if (e5.fileInfo.size || (e5.fileInfo.size = Number.MAX_SAFE_INTEGER), await e5.peekBuffer(t3, { length: 12, mayBeLess: true }), i2([66, 77])) return { ext: "bmp", mime: "image/bmp" };
  if (i2([11, 119])) return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
  if (i2([120, 1])) return { ext: "dmg", mime: "application/x-apple-diskimage" };
  if (i2([77, 90])) return { ext: "exe", mime: "application/x-msdownload" };
  if (i2([37, 33])) return await e5.peekBuffer(t3, { length: 24, mayBeLess: true }), r4("PS-Adobe-", { offset: 2 }) && r4(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
  if (i2([31, 160]) || i2([31, 157])) return { ext: "Z", mime: "application/x-compress" };
  if (i2([255, 216, 255])) return { ext: "jpg", mime: "image/jpeg" };
  if (i2([73, 73, 188])) return { ext: "jxr", mime: "image/vnd.ms-photo" };
  if (i2([31, 139, 8])) return { ext: "gz", mime: "application/gzip" };
  if (i2([66, 90, 104])) return { ext: "bz2", mime: "application/x-bzip2" };
  if (r4("ID3")) {
    await e5.ignore(6);
    const n3 = await e5.readToken(uint32SyncSafeToken);
    return e5.position + n3 > e5.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await e5.ignore(n3), fromTokenizer(e5));
  }
  if (r4("MP+")) return { ext: "mpc", mime: "audio/x-musepack" };
  if ((67 === t3[0] || 70 === t3[0]) && i2([87, 83], { offset: 1 })) return { ext: "swf", mime: "application/x-shockwave-flash" };
  if (i2([71, 73, 70])) return { ext: "gif", mime: "image/gif" };
  if (r4("FLIF")) return { ext: "flif", mime: "image/flif" };
  if (r4("8BPS")) return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
  if (r4("WEBP", { offset: 8 })) return { ext: "webp", mime: "image/webp" };
  if (r4("MPCK")) return { ext: "mpc", mime: "audio/x-musepack" };
  if (r4("FORM")) return { ext: "aif", mime: "audio/aiff" };
  if (r4("icns", { offset: 0 })) return { ext: "icns", mime: "image/icns" };
  if (i2([80, 75, 3, 4])) {
    try {
      for (; e5.position + 30 < e5.fileInfo.size; ) {
        await e5.readBuffer(t3, { length: 30 });
        const a2 = { compressedSize: t3.readUInt32LE(18), uncompressedSize: t3.readUInt32LE(22), filenameLength: t3.readUInt16LE(26), extraFieldLength: t3.readUInt16LE(28) };
        if (a2.filename = await e5.readToken(new Token.StringType(a2.filenameLength, "utf-8")), await e5.ignore(a2.extraFieldLength), "META-INF/mozilla.rsa" === a2.filename) return { ext: "xpi", mime: "application/x-xpinstall" };
        if (a2.filename.endsWith(".rels") || a2.filename.endsWith(".xml")) {
          switch (a2.filename.split("/")[0]) {
            case "_rels":
            default:
              break;
            case "word":
              return { ext: "docx", mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" };
            case "ppt":
              return { ext: "pptx", mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation" };
            case "xl":
              return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
          }
        }
        if (a2.filename.startsWith("xl/")) return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
        if (a2.filename.startsWith("3D/") && a2.filename.endsWith(".model")) return { ext: "3mf", mime: "model/3mf" };
        if ("mimetype" === a2.filename && a2.compressedSize === a2.uncompressedSize) {
          switch (await e5.readToken(new Token.StringType(a2.compressedSize, "utf-8"))) {
            case "application/epub+zip":
              return { ext: "epub", mime: "application/epub+zip" };
            case "application/vnd.oasis.opendocument.text":
              return { ext: "odt", mime: "application/vnd.oasis.opendocument.text" };
            case "application/vnd.oasis.opendocument.spreadsheet":
              return { ext: "ods", mime: "application/vnd.oasis.opendocument.spreadsheet" };
            case "application/vnd.oasis.opendocument.presentation":
              return { ext: "odp", mime: "application/vnd.oasis.opendocument.presentation" };
          }
        }
        if (0 === a2.compressedSize) {
          let o3 = -1;
          for (; o3 < 0 && e5.position < e5.fileInfo.size; ) await e5.peekBuffer(t3, { mayBeLess: true }), o3 = t3.indexOf("504B0304", 0, "hex"), await e5.ignore(o3 >= 0 ? o3 : t3.length);
        } else await e5.ignore(a2.compressedSize);
      }
    } catch (s4) {
      if (!(s4 instanceof strtok3.EndOfStreamError)) throw s4;
    }
    return { ext: "zip", mime: "application/zip" };
  }
  if (r4("OggS")) {
    await e5.ignore(28);
    const l2 = Buffer2.alloc(8);
    return await e5.readBuffer(l2), _check(l2, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/opus" } : _check(l2, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : _check(l2, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : _check(l2, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : _check(l2, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : _check(l2, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
  }
  if (i2([80, 75]) && (3 === t3[2] || 5 === t3[2] || 7 === t3[2]) && (4 === t3[3] || 6 === t3[3] || 8 === t3[3])) return { ext: "zip", mime: "application/zip" };
  if (r4("ftyp", { offset: 4 }) && 96 & t3[8]) {
    const u2 = t3.toString("binary", 8, 12).replace("\0", " ").trim();
    switch (u2) {
      case "avif":
        return { ext: "avif", mime: "image/avif" };
      case "mif1":
        return { ext: "heic", mime: "image/heif" };
      case "msf1":
        return { ext: "heic", mime: "image/heif-sequence" };
      case "heic":
      case "heix":
        return { ext: "heic", mime: "image/heic" };
      case "hevc":
      case "hevx":
        return { ext: "heic", mime: "image/heic-sequence" };
      case "qt":
        return { ext: "mov", mime: "video/quicktime" };
      case "M4V":
      case "M4VH":
      case "M4VP":
        return { ext: "m4v", mime: "video/x-m4v" };
      case "M4P":
        return { ext: "m4p", mime: "video/mp4" };
      case "M4B":
        return { ext: "m4b", mime: "audio/mp4" };
      case "M4A":
        return { ext: "m4a", mime: "audio/x-m4a" };
      case "F4V":
        return { ext: "f4v", mime: "video/mp4" };
      case "F4P":
        return { ext: "f4p", mime: "video/mp4" };
      case "F4A":
        return { ext: "f4a", mime: "audio/mp4" };
      case "F4B":
        return { ext: "f4b", mime: "audio/mp4" };
      case "crx":
        return { ext: "cr3", mime: "image/x-canon-cr3" };
      default:
        return u2.startsWith("3g") ? u2.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
    }
  }
  if (r4("MThd")) return { ext: "mid", mime: "audio/midi" };
  if (r4("wOFF") && (i2([0, 1, 0, 0], { offset: 4 }) || r4("OTTO", { offset: 4 }))) return { ext: "woff", mime: "font/woff" };
  if (r4("wOF2") && (i2([0, 1, 0, 0], { offset: 4 }) || r4("OTTO", { offset: 4 }))) return { ext: "woff2", mime: "font/woff2" };
  if (i2([212, 195, 178, 161]) || i2([161, 178, 195, 212])) return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
  if (r4("DSD ")) return { ext: "dsf", mime: "audio/x-dsf" };
  if (r4("LZIP")) return { ext: "lz", mime: "application/x-lzip" };
  if (r4("fLaC")) return { ext: "flac", mime: "audio/x-flac" };
  if (i2([66, 80, 71, 251])) return { ext: "bpg", mime: "image/bpg" };
  if (r4("wvpk")) return { ext: "wv", mime: "audio/wavpack" };
  if (r4("%PDF")) {
    await e5.ignore(1350);
    const h2 = 10485760, c3 = Buffer2.alloc(Math.min(h2, e5.fileInfo.size));
    return await e5.readBuffer(c3, { mayBeLess: true }), c3.includes(Buffer2.from("AIPrivateData")) ? { ext: "ai", mime: "application/postscript" } : { ext: "pdf", mime: "application/pdf" };
  }
  if (i2([0, 97, 115, 109])) return { ext: "wasm", mime: "application/wasm" };
  if (i2([73, 73, 42, 0])) return r4("CR", { offset: 8 }) ? { ext: "cr2", mime: "image/x-canon-cr2" } : i2([28, 0, 254, 0], { offset: 8 }) || i2([31, 0, 11, 0], { offset: 8 }) ? { ext: "nef", mime: "image/x-nikon-nef" } : i2([8, 0, 0, 0], { offset: 4 }) && (i2([45, 0, 254, 0], { offset: 8 }) || i2([39, 0, 254, 0], { offset: 8 })) ? { ext: "dng", mime: "image/x-adobe-dng" } : (t3 = Buffer2.alloc(24), await e5.peekBuffer(t3), (i2([16, 251, 134, 1], { offset: 4 }) || i2([8, 0, 0, 0], { offset: 4 })) && i2([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? { ext: "arw", mime: "image/x-sony-arw" } : { ext: "tif", mime: "image/tiff" });
  if (i2([77, 77, 0, 42])) return { ext: "tif", mime: "image/tiff" };
  if (r4("MAC ")) return { ext: "ape", mime: "audio/ape" };
  if (i2([26, 69, 223, 163])) {
    async function f2() {
      const t4 = await e5.peekNumber(Token.UINT8);
      let i3 = 128, r5 = 0;
      for (; !(t4 & i3) && 0 !== i3; ) ++r5, i3 >>= 1;
      const n3 = Buffer2.alloc(r5 + 1);
      return await e5.readBuffer(n3), n3;
    }
    __name(f2, "f");
    async function d() {
      const e6 = await f2(), t4 = await f2();
      t4[0] ^= 128 >> t4.length - 1;
      const i3 = Math.min(6, t4.length);
      return { id: e6.readUIntBE(0, e6.length), len: t4.readUIntBE(t4.length - i3, i3) };
    }
    __name(d, "d");
    async function p2(t4, i3) {
      for (; i3 > 0; ) {
        const t5 = await d();
        if (17026 === t5.id) return e5.readToken(new Token.StringType(t5.len, "utf-8"));
        await e5.ignore(t5.len), --i3;
      }
    }
    __name(p2, "p");
    const m = await d();
    switch (await p2(0, m.len)) {
      case "webm":
        return { ext: "webm", mime: "video/webm" };
      case "matroska":
        return { ext: "mkv", mime: "video/x-matroska" };
      default:
        return;
    }
  }
  if (i2([82, 73, 70, 70])) {
    if (i2([65, 86, 73], { offset: 8 })) return { ext: "avi", mime: "video/vnd.avi" };
    if (i2([87, 65, 86, 69], { offset: 8 })) return { ext: "wav", mime: "audio/vnd.wave" };
    if (i2([81, 76, 67, 77], { offset: 8 })) return { ext: "qcp", mime: "audio/qcelp" };
  }
  if (r4("SQLi")) return { ext: "sqlite", mime: "application/x-sqlite3" };
  if (i2([78, 69, 83, 26])) return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
  if (r4("Cr24")) return { ext: "crx", mime: "application/x-google-chrome-extension" };
  if (r4("MSCF") || r4("ISc(")) return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
  if (i2([237, 171, 238, 219])) return { ext: "rpm", mime: "application/x-rpm" };
  if (i2([197, 208, 211, 198])) return { ext: "eps", mime: "application/eps" };
  if (i2([40, 181, 47, 253])) return { ext: "zst", mime: "application/zstd" };
  if (i2([79, 84, 84, 79, 0])) return { ext: "otf", mime: "font/otf" };
  if (r4("#!AMR")) return { ext: "amr", mime: "audio/amr" };
  if (r4("{\\rtf")) return { ext: "rtf", mime: "application/rtf" };
  if (i2([70, 76, 86, 1])) return { ext: "flv", mime: "video/x-flv" };
  if (r4("IMPM")) return { ext: "it", mime: "audio/x-it" };
  if (r4("-lh0-", { offset: 2 }) || r4("-lh1-", { offset: 2 }) || r4("-lh2-", { offset: 2 }) || r4("-lh3-", { offset: 2 }) || r4("-lh4-", { offset: 2 }) || r4("-lh5-", { offset: 2 }) || r4("-lh6-", { offset: 2 }) || r4("-lh7-", { offset: 2 }) || r4("-lzs-", { offset: 2 }) || r4("-lz4-", { offset: 2 }) || r4("-lz5-", { offset: 2 }) || r4("-lhd-", { offset: 2 })) return { ext: "lzh", mime: "application/x-lzh-compressed" };
  if (i2([0, 0, 1, 186])) {
    if (i2([33], { offset: 4, mask: [241] })) return { ext: "mpg", mime: "video/MP1S" };
    if (i2([68], { offset: 4, mask: [196] })) return { ext: "mpg", mime: "video/MP2P" };
  }
  if (r4("ITSF")) return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
  if (i2([253, 55, 122, 88, 90, 0])) return { ext: "xz", mime: "application/x-xz" };
  if (r4("<?xml ")) return { ext: "xml", mime: "application/xml" };
  if (i2([55, 122, 188, 175, 39, 28])) return { ext: "7z", mime: "application/x-7z-compressed" };
  if (i2([82, 97, 114, 33, 26, 7]) && (0 === t3[6] || 1 === t3[6])) return { ext: "rar", mime: "application/x-rar-compressed" };
  if (r4("solid ")) return { ext: "stl", mime: "model/stl" };
  if (r4("BLENDER")) return { ext: "blend", mime: "application/x-blender" };
  if (r4("!<arch>")) {
    await e5.ignore(8);
    return "debian-binary" === await e5.readToken(new Token.StringType(13, "ascii")) ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
  }
  if (i2([137, 80, 78, 71, 13, 10, 26, 10])) {
    async function _2() {
      return { length: await e5.readToken(Token.INT32_BE), type: await e5.readToken(new Token.StringType(4, "binary")) };
    }
    __name(_2, "_");
    await e5.ignore(8);
    do {
      const g = await _2();
      if (g.length < 0) return;
      switch (g.type) {
        case "IDAT":
          return { ext: "png", mime: "image/png" };
        case "acTL":
          return { ext: "apng", mime: "image/apng" };
        default:
          await e5.ignore(g.length + 4);
      }
    } while (e5.position + 8 < e5.fileInfo.size);
    return { ext: "png", mime: "image/png" };
  }
  if (i2([65, 82, 82, 79, 87, 49, 0, 0])) return { ext: "arrow", mime: "application/x-apache-arrow" };
  if (i2([103, 108, 84, 70, 2, 0, 0, 0])) return { ext: "glb", mime: "model/gltf-binary" };
  if (i2([102, 114, 101, 101], { offset: 4 }) || i2([109, 100, 97, 116], { offset: 4 }) || i2([109, 111, 111, 118], { offset: 4 }) || i2([119, 105, 100, 101], { offset: 4 })) return { ext: "mov", mime: "video/quicktime" };
  if (i2([73, 73, 82, 79, 8, 0, 0, 0, 24])) return { ext: "orf", mime: "image/x-olympus-orf" };
  if (r4("gimp xcf ")) return { ext: "xcf", mime: "image/x-xcf" };
  if (i2([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) return { ext: "rw2", mime: "image/x-panasonic-rw2" };
  if (i2([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function b2() {
      const t4 = Buffer2.alloc(16);
      return await e5.readBuffer(t4), { id: t4, size: Number(await e5.readToken(Token.UINT64_LE)) };
    }
    __name(b2, "b");
    for (await e5.ignore(30); e5.position + 24 < e5.fileInfo.size; ) {
      const y2 = await b2();
      let w = y2.size - 24;
      if (_check(y2.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
        const v2 = Buffer2.alloc(16);
        if (w -= await e5.readBuffer(v2), _check(v2, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "audio/x-ms-asf" };
        if (_check(v2, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "video/x-ms-asf" };
        break;
      }
      await e5.ignore(w);
    }
    return { ext: "asf", mime: "application/vnd.ms-asf" };
  }
  if (i2([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) return { ext: "ktx", mime: "image/ktx" };
  if ((i2([126, 16, 4]) || i2([126, 24, 4])) && i2([48, 77, 73, 69], { offset: 4 })) return { ext: "mie", mime: "application/x-mie" };
  if (i2([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) return { ext: "shp", mime: "application/x-esri-shape" };
  if (i2([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
    await e5.ignore(20);
    switch (await e5.readToken(new Token.StringType(4, "ascii"))) {
      case "jp2 ":
        return { ext: "jp2", mime: "image/jp2" };
      case "jpx ":
        return { ext: "jpx", mime: "image/jpx" };
      case "jpm ":
        return { ext: "jpm", mime: "image/jpm" };
      case "mjp2":
        return { ext: "mj2", mime: "image/mj2" };
      default:
        return;
    }
  }
  if (i2([255, 10]) || i2([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) return { ext: "jxl", mime: "image/jxl" };
  if (i2([0, 0, 1, 186]) || i2([0, 0, 1, 179])) return { ext: "mpg", mime: "video/mpeg" };
  if (i2([0, 1, 0, 0, 0])) return { ext: "ttf", mime: "font/ttf" };
  if (i2([0, 0, 1, 0])) return { ext: "ico", mime: "image/x-icon" };
  if (i2([0, 0, 2, 0])) return { ext: "cur", mime: "image/x-icon" };
  if (i2([208, 207, 17, 224, 161, 177, 26, 225])) return { ext: "cfb", mime: "application/x-cfb" };
  if (await e5.peekBuffer(t3, { length: Math.min(256, e5.fileInfo.size), mayBeLess: true }), r4("BEGIN:")) {
    if (r4("VCARD", { offset: 6 })) return { ext: "vcf", mime: "text/vcard" };
    if (r4("VCALENDAR", { offset: 6 })) return { ext: "ics", mime: "text/calendar" };
  }
  if (r4("FUJIFILMCCD-RAW")) return { ext: "raf", mime: "image/x-fujifilm-raf" };
  if (r4("Extended Module:")) return { ext: "xm", mime: "audio/x-xm" };
  if (r4("Creative Voice File")) return { ext: "voc", mime: "audio/x-voc" };
  if (i2([4, 0, 0, 0]) && t3.length >= 16) {
    const x2 = t3.readUInt32LE(12);
    if (x2 > 12 && t3.length >= x2 + 16) try {
      const E2 = t3.slice(16, x2 + 16).toString();
      if (JSON.parse(E2).files) return { ext: "asar", mime: "application/x-asar" };
    } catch (k2) {
    }
  }
  if (i2([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) return { ext: "mxf", mime: "application/mxf" };
  if (r4("SCRM", { offset: 44 })) return { ext: "s3m", mime: "audio/x-s3m" };
  if (i2([71], { offset: 4 }) && (i2([71], { offset: 192 }) || i2([71], { offset: 196 }))) return { ext: "mts", mime: "video/mp2t" };
  if (i2([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
  if (i2([68, 73, 67, 77], { offset: 128 })) return { ext: "dcm", mime: "application/dicom" };
  if (i2([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) return { ext: "lnk", mime: "application/x.ms.shortcut" };
  if (i2([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) return { ext: "alias", mime: "application/x.apple.alias" };
  if (i2([76, 80], { offset: 34 }) && (i2([0, 0, 1], { offset: 8 }) || i2([1, 0, 2], { offset: 8 }) || i2([2, 0, 2], { offset: 8 }))) return { ext: "eot", mime: "application/vnd.ms-fontobject" };
  if (i2([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) return { ext: "indd", mime: "application/x-indesign" };
  if (await e5.peekBuffer(t3, { length: Math.min(512, e5.fileInfo.size), mayBeLess: true }), tarHeaderChecksumMatches(t3)) return { ext: "tar", mime: "application/x-tar" };
  if (i2([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0])) return { ext: "skp", mime: "application/vnd.sketchup.skp" };
  if (r4("-----BEGIN PGP MESSAGE-----")) return { ext: "pgp", mime: "application/pgp-encrypted" };
  if (t3.length >= 2 && i2([255, 224], { offset: 0, mask: [255, 224] })) {
    if (i2([16], { offset: 1, mask: [22] })) return i2([8], { offset: 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
    if (i2([2], { offset: 1, mask: [6] })) return { ext: "mp3", mime: "audio/mpeg" };
    if (i2([4], { offset: 1, mask: [6] })) return { ext: "mp2", mime: "audio/mpeg" };
    if (i2([6], { offset: 1, mask: [6] })) return { ext: "mp1", mime: "audio/mpeg" };
  }
}
function to(e5, t3) {
  return e5.then(function(e6) {
    return [null, e6];
  }).catch(function(e6) {
    return [e6, void 0];
  });
}
function Mime$1() {
  this._types = /* @__PURE__ */ Object.create(null), this._extensions = /* @__PURE__ */ Object.create(null);
  for (let e5 = 0; e5 < arguments.length; e5++) this.define(arguments[e5]);
  this.define = this.define.bind(this), this.getType = this.getType.bind(this), this.getExtension = this.getExtension.bind(this);
}
function srcOver(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a;
  return { r: (e5.r * e5.a + t3.r * t3.a * (1 - e5.a)) / r4, g: (e5.g * e5.a + t3.g * t3.a * (1 - e5.a)) / r4, b: (e5.b * e5.a + t3.b * t3.a * (1 - e5.a)) / r4, a: r4 };
}
function dstOver(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a;
  return { r: (t3.r * t3.a + e5.r * e5.a * (1 - t3.a)) / r4, g: (t3.g * t3.a + e5.g * e5.a * (1 - t3.a)) / r4, b: (t3.b * t3.a + e5.b * e5.a * (1 - t3.a)) / r4, a: r4 };
}
function multiply(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (n3 * s4 + n3 * (1 - t3.a) + s4 * (1 - e5.a)) / r4, g: (a2 * l2 + a2 * (1 - t3.a) + l2 * (1 - e5.a)) / r4, b: (o3 * u2 + o3 * (1 - t3.a) + u2 * (1 - e5.a)) / r4, a: r4 };
}
function add(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a;
  return { r: (n3 + t3.r * t3.a) / r4, g: (a2 + t3.g * t3.a) / r4, b: (o3 + t3.b * t3.a) / r4, a: r4 };
}
function screen(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (n3 * t3.a + s4 * e5.a - n3 * s4 + n3 * (1 - t3.a) + s4 * (1 - e5.a)) / r4, g: (a2 * t3.a + l2 * e5.a - a2 * l2 + a2 * (1 - t3.a) + l2 * (1 - e5.a)) / r4, b: (o3 * t3.a + u2 * e5.a - o3 * u2 + o3 * (1 - t3.a) + u2 * (1 - e5.a)) / r4, a: r4 };
}
function overlay(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (2 * s4 <= t3.a ? 2 * n3 * s4 + n3 * (1 - t3.a) + s4 * (1 - e5.a) : n3 * (1 + t3.a) + s4 * (1 + e5.a) - 2 * s4 * n3 - t3.a * e5.a) / r4, g: (2 * l2 <= t3.a ? 2 * a2 * l2 + a2 * (1 - t3.a) + l2 * (1 - e5.a) : a2 * (1 + t3.a) + l2 * (1 + e5.a) - 2 * l2 * a2 - t3.a * e5.a) / r4, b: (2 * u2 <= t3.a ? 2 * o3 * u2 + o3 * (1 - t3.a) + u2 * (1 - e5.a) : o3 * (1 + t3.a) + u2 * (1 + e5.a) - 2 * u2 * o3 - t3.a * e5.a) / r4, a: r4 };
}
function darken(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (Math.min(n3 * t3.a, s4 * e5.a) + n3 * (1 - t3.a) + s4 * (1 - e5.a)) / r4, g: (Math.min(a2 * t3.a, l2 * e5.a) + a2 * (1 - t3.a) + l2 * (1 - e5.a)) / r4, b: (Math.min(o3 * t3.a, u2 * e5.a) + o3 * (1 - t3.a) + u2 * (1 - e5.a)) / r4, a: r4 };
}
function lighten(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (Math.max(n3 * t3.a, s4 * e5.a) + n3 * (1 - t3.a) + s4 * (1 - e5.a)) / r4, g: (Math.max(a2 * t3.a, l2 * e5.a) + a2 * (1 - t3.a) + l2 * (1 - e5.a)) / r4, b: (Math.max(o3 * t3.a, u2 * e5.a) + o3 * (1 - t3.a) + u2 * (1 - e5.a)) / r4, a: r4 };
}
function hardLight(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (2 * n3 <= e5.a ? 2 * n3 * s4 + n3 * (1 - t3.a) + s4 * (1 - e5.a) : n3 * (1 + t3.a) + s4 * (1 + e5.a) - 2 * s4 * n3 - t3.a * e5.a) / r4, g: (2 * a2 <= e5.a ? 2 * a2 * l2 + a2 * (1 - t3.a) + l2 * (1 - e5.a) : a2 * (1 + t3.a) + l2 * (1 + e5.a) - 2 * l2 * a2 - t3.a * e5.a) / r4, b: (2 * o3 <= e5.a ? 2 * o3 * u2 + o3 * (1 - t3.a) + u2 * (1 - e5.a) : o3 * (1 + t3.a) + u2 * (1 + e5.a) - 2 * u2 * o3 - t3.a * e5.a) / r4, a: r4 };
}
function difference(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (n3 + s4 - 2 * Math.min(n3 * t3.a, s4 * e5.a)) / r4, g: (a2 + l2 - 2 * Math.min(a2 * t3.a, l2 * e5.a)) / r4, b: (o3 + u2 - 2 * Math.min(o3 * t3.a, u2 * e5.a)) / r4, a: r4 };
}
function exclusion(e5, t3, i2 = 1) {
  e5.a *= i2;
  const r4 = t3.a + e5.a - t3.a * e5.a, n3 = e5.r * e5.a, a2 = e5.g * e5.a, o3 = e5.b * e5.a, s4 = t3.r * t3.a, l2 = t3.g * t3.a, u2 = t3.b * t3.a;
  return { r: (n3 * t3.a + s4 * e5.a - 2 * n3 * s4 + n3 * (1 - t3.a) + s4 * (1 - e5.a)) / r4, g: (a2 * t3.a + l2 * e5.a - 2 * a2 * l2 + a2 * (1 - t3.a) + l2 * (1 - e5.a)) / r4, b: (o3 * t3.a + u2 * e5.a - 2 * o3 * u2 + o3 * (1 - t3.a) + u2 * (1 - e5.a)) / r4, a: r4 };
}
function composite(e5, t3, i2 = 0, r4 = 0, n3 = {}) {
  if (!(t3 instanceof e5.constructor)) throw new Error("The source must be a Jimp image");
  if ("number" != typeof i2 || "number" != typeof r4) throw new Error("x and y must be numbers");
  const { mode: a2 = BlendMode.SRC_OVER } = n3;
  let { opacitySource: o3 = 1, opacityDest: s4 = 1 } = n3;
  ("number" != typeof o3 || o3 < 0 || o3 > 1) && (o3 = 1), ("number" != typeof s4 || s4 < 0 || s4 > 1) && (s4 = 1);
  const l2 = compositeModes[a2];
  return i2 = Math.round(i2), r4 = Math.round(r4), 1 !== s4 && e5.scan((t4, i3, r5) => {
    const n4 = e5.bitmap.data[r5 + 3] * s4;
    e5.bitmap.data[r5 + 3] = n4;
  }), t3.scan((n4, a3, s5) => {
    const u2 = e5.getPixelIndex(i2 + n4, r4 + a3, Edge.CROP);
    if (-1 === u2) return;
    const h2 = l2({ r: t3.bitmap.data[s5 + 0] / 255, g: t3.bitmap.data[s5 + 1] / 255, b: t3.bitmap.data[s5 + 2] / 255, a: t3.bitmap.data[s5 + 3] / 255 }, { r: e5.bitmap.data[u2 + 0] / 255, g: e5.bitmap.data[u2 + 1] / 255, b: e5.bitmap.data[u2 + 2] / 255, a: e5.bitmap.data[u2 + 3] / 255 }, o3);
    e5.bitmap.data[u2 + 0] = limit255(255 * h2.r), e5.bitmap.data[u2 + 1] = limit255(255 * h2.g), e5.bitmap.data[u2 + 2] = limit255(255 * h2.b), e5.bitmap.data[u2 + 3] = limit255(255 * h2.a);
  }), e5;
}
function readExifValue(e5, t3) {
  switch (e5) {
    case 1:
      return t3.nextUInt8();
    case 3:
    case 8:
      return t3.nextUInt16();
    case 4:
    case 9:
      return t3.nextUInt32();
    case 5:
      return [t3.nextUInt32(), t3.nextUInt32()];
    case 6:
      return t3.nextInt8();
    case 10:
      return [t3.nextInt32(), t3.nextInt32()];
    case 11:
      return t3.nextFloat();
    case 12:
      return t3.nextDouble();
    default:
      throw new Error("Invalid format while decoding: " + e5);
  }
}
function getBytesPerComponent(e5) {
  switch (e5) {
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
      return 4;
    case 5:
    case 10:
    case 12:
      return 8;
    default:
      return 0;
  }
}
function readExifTag(e5, t3) {
  var i2, r4, n3 = t3.nextUInt16(), a2 = t3.nextUInt16(), o3 = getBytesPerComponent(a2), s4 = t3.nextUInt32(), l2 = o3 * s4;
  if (l2 > 4 && (t3 = e5.openWithOffset(t3.nextUInt32())), 2 === a2) {
    var u2 = (i2 = t3.nextString(s4)).indexOf("\0");
    -1 !== u2 && (i2 = i2.substr(0, u2));
  } else if (7 === a2) i2 = t3.nextBuffer(s4);
  else if (0 !== a2) for (i2 = [], r4 = 0; r4 < s4; ++r4) i2.push(readExifValue(a2, t3));
  return l2 < 4 && t3.skip(4 - l2), [n3, i2, a2];
}
function readIFDSection(e5, t3, i2) {
  var r4, n3, a2 = t3.nextUInt16();
  for (n3 = 0; n3 < a2; ++n3) i2((r4 = readExifTag(e5, t3))[0], r4[1], r4[2]);
}
function readHeader(e5) {
  if ("Exif\0\0" !== e5.nextString(6)) throw new Error("Invalid EXIF header");
  var t3 = e5.mark(), i2 = e5.nextUInt16();
  if (18761 === i2) e5.setBigEndian(false);
  else {
    if (19789 !== i2) throw new Error("Invalid TIFF header");
    e5.setBigEndian(true);
  }
  if (42 !== e5.nextUInt16()) throw new Error("Invalid TIFF data");
  return t3;
}
function parseNumber(e5) {
  return parseInt(e5, 10);
}
function parseDateTimeParts(e5, t3) {
  e5 = e5.map(parseNumber), t3 = t3.map(parseNumber);
  var i2 = e5[0], r4 = e5[1] - 1, n3 = e5[2], a2 = t3[0], o3 = t3[1], s4 = t3[2];
  return Date.UTC(i2, r4, n3, a2, o3, s4, 0) / 1e3;
}
function parseDateWithTimezoneFormat(e5) {
  var t3 = e5.substr(0, 10).split("-"), i2 = e5.substr(11, 8).split(":"), r4 = e5.substr(19, 6).split(":").map(parseNumber), n3 = r4[0] * hours + r4[1] * minutes, a2 = parseDateTimeParts(t3, i2);
  if ("number" == typeof (a2 -= n3) && !isNaN(a2)) return a2;
}
function parseDateWithSpecFormat(e5) {
  var t3 = e5.split(" "), i2 = parseDateTimeParts(t3[0].split(":"), t3[1].split(":"));
  if ("number" == typeof i2 && !isNaN(i2)) return i2;
}
function parseExifDate(e5) {
  var t3 = 19 === e5.length && ":" === e5.charAt(4);
  return 25 === e5.length && "T" === e5.charAt(10) ? parseDateWithTimezoneFormat(e5) : t3 ? parseDateWithSpecFormat(e5) : void 0;
}
function requireExifTags() {
  return hasRequiredExifTags ? exifTags : (hasRequiredExifTags = 1, exifTags = { exif: { 1: "InteropIndex", 2: "InteropVersion", 11: "ProcessingSoftware", 254: "SubfileType", 255: "OldSubfileType", 256: "ImageWidth", 257: "ImageHeight", 258: "BitsPerSample", 259: "Compression", 262: "PhotometricInterpretation", 263: "Thresholding", 264: "CellWidth", 265: "CellLength", 266: "FillOrder", 269: "DocumentName", 270: "ImageDescription", 271: "Make", 272: "Model", 273: "StripOffsets", 274: "Orientation", 277: "SamplesPerPixel", 278: "RowsPerStrip", 279: "StripByteCounts", 280: "MinSampleValue", 281: "MaxSampleValue", 282: "XResolution", 283: "YResolution", 284: "PlanarConfiguration", 285: "PageName", 286: "XPosition", 287: "YPosition", 288: "FreeOffsets", 289: "FreeByteCounts", 290: "GrayResponseUnit", 291: "GrayResponseCurve", 292: "T4Options", 293: "T6Options", 296: "ResolutionUnit", 297: "PageNumber", 300: "ColorResponseUnit", 301: "TransferFunction", 305: "Software", 306: "ModifyDate", 315: "Artist", 316: "HostComputer", 317: "Predictor", 318: "WhitePoint", 319: "PrimaryChromaticities", 320: "ColorMap", 321: "HalftoneHints", 322: "TileWidth", 323: "TileLength", 324: "TileOffsets", 325: "TileByteCounts", 326: "BadFaxLines", 327: "CleanFaxData", 328: "ConsecutiveBadFaxLines", 330: "SubIFD", 332: "InkSet", 333: "InkNames", 334: "NumberofInks", 336: "DotRange", 337: "TargetPrinter", 338: "ExtraSamples", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 342: "TransferRange", 343: "ClipPath", 344: "XClipPathUnits", 345: "YClipPathUnits", 346: "Indexed", 347: "JPEGTables", 351: "OPIProxy", 400: "GlobalParametersIFD", 401: "ProfileType", 402: "FaxProfile", 403: "CodingMethods", 404: "VersionYear", 405: "ModeNumber", 433: "Decode", 434: "DefaultImageColor", 435: "T82Options", 437: "JPEGTables", 512: "JPEGProc", 513: "ThumbnailOffset", 514: "ThumbnailLength", 515: "JPEGRestartInterval", 517: "JPEGLosslessPredictors", 518: "JPEGPointTransforms", 519: "JPEGQTables", 520: "JPEGDCTables", 521: "JPEGACTables", 529: "YCbCrCoefficients", 530: "YCbCrSubSampling", 531: "YCbCrPositioning", 532: "ReferenceBlackWhite", 559: "StripRowCounts", 700: "ApplicationNotes", 999: "USPTOMiscellaneous", 4096: "RelatedImageFileFormat", 4097: "RelatedImageWidth", 4098: "RelatedImageHeight", 18246: "Rating", 18247: "XP_DIP_XML", 18248: "StitchInfo", 18249: "RatingPercent", 32781: "ImageID", 32931: "WangTag1", 32932: "WangAnnotation", 32933: "WangTag3", 32934: "WangTag4", 32995: "Matteing", 32996: "DataType", 32997: "ImageDepth", 32998: "TileDepth", 33405: "Model2", 33421: "CFARepeatPatternDim", 33422: "CFAPattern2", 33423: "BatteryLevel", 33424: "KodakIFD", 33432: "Copyright", 33434: "ExposureTime", 33437: "FNumber", 33445: "MDFileTag", 33446: "MDScalePixel", 33447: "MDColorTable", 33448: "MDLabName", 33449: "MDSampleInfo", 33450: "MDPrepDate", 33451: "MDPrepTime", 33452: "MDFileUnits", 33550: "PixelScale", 33589: "AdventScale", 33590: "AdventRevision", 33628: "UIC1Tag", 33629: "UIC2Tag", 33630: "UIC3Tag", 33631: "UIC4Tag", 33723: "IPTC-NAA", 33918: "IntergraphPacketData", 33919: "IntergraphFlagRegisters", 33920: "IntergraphMatrix", 33921: "INGRReserved", 33922: "ModelTiePoint", 34016: "Site", 34017: "ColorSequence", 34018: "IT8Header", 34019: "RasterPadding", 34020: "BitsPerRunLength", 34021: "BitsPerExtendedRunLength", 34022: "ColorTable", 34023: "ImageColorIndicator", 34024: "BackgroundColorIndicator", 34025: "ImageColorValue", 34026: "BackgroundColorValue", 34027: "PixelIntensityRange", 34028: "TransparencyIndicator", 34029: "ColorCharacterization", 34030: "HCUsage", 34031: "TrapIndicator", 34032: "CMYKEquivalent", 34118: "SEMInfo", 34152: "AFCP_IPTC", 34232: "PixelMagicJBIGOptions", 34264: "ModelTransform", 34306: "WB_GRGBLevels", 34310: "LeafData", 34377: "PhotoshopSettings", 34665: "ExifOffset", 34675: "ICC_Profile", 34687: "TIFF_FXExtensions", 34688: "MultiProfiles", 34689: "SharedData", 34690: "T88Options", 34732: "ImageLayer", 34735: "GeoTiffDirectory", 34736: "GeoTiffDoubleParams", 34737: "GeoTiffAsciiParams", 34850: "ExposureProgram", 34852: "SpectralSensitivity", 34853: "GPSInfo", 34855: "ISO", 34856: "Opto-ElectricConvFactor", 34857: "Interlace", 34858: "TimeZoneOffset", 34859: "SelfTimerMode", 34864: "SensitivityType", 34865: "StandardOutputSensitivity", 34866: "RecommendedExposureIndex", 34867: "ISOSpeed", 34868: "ISOSpeedLatitudeyyy", 34869: "ISOSpeedLatitudezzz", 34908: "FaxRecvParams", 34909: "FaxSubAddress", 34910: "FaxRecvTime", 34954: "LeafSubIFD", 36864: "ExifVersion", 36867: "DateTimeOriginal", 36868: "CreateDate", 37121: "ComponentsConfiguration", 37122: "CompressedBitsPerPixel", 37377: "ShutterSpeedValue", 37378: "ApertureValue", 37379: "BrightnessValue", 37380: "ExposureCompensation", 37381: "MaxApertureValue", 37382: "SubjectDistance", 37383: "MeteringMode", 37384: "LightSource", 37385: "Flash", 37386: "FocalLength", 37387: "FlashEnergy", 37388: "SpatialFrequencyResponse", 37389: "Noise", 37390: "FocalPlaneXResolution", 37391: "FocalPlaneYResolution", 37392: "FocalPlaneResolutionUnit", 37393: "ImageNumber", 37394: "SecurityClassification", 37395: "ImageHistory", 37396: "SubjectArea", 37397: "ExposureIndex", 37398: "TIFF-EPStandardID", 37399: "SensingMethod", 37434: "CIP3DataFile", 37435: "CIP3Sheet", 37436: "CIP3Side", 37439: "StoNits", 37500: "MakerNote", 37510: "UserComment", 37520: "SubSecTime", 37521: "SubSecTimeOriginal", 37522: "SubSecTimeDigitized", 37679: "MSDocumentText", 37680: "MSPropertySetStorage", 37681: "MSDocumentTextPosition", 37724: "ImageSourceData", 40091: "XPTitle", 40092: "XPComment", 40093: "XPAuthor", 40094: "XPKeywords", 40095: "XPSubject", 40960: "FlashpixVersion", 40961: "ColorSpace", 40962: "ExifImageWidth", 40963: "ExifImageHeight", 40964: "RelatedSoundFile", 40965: "InteropOffset", 41483: "FlashEnergy", 41484: "SpatialFrequencyResponse", 41485: "Noise", 41486: "FocalPlaneXResolution", 41487: "FocalPlaneYResolution", 41488: "FocalPlaneResolutionUnit", 41489: "ImageNumber", 41490: "SecurityClassification", 41491: "ImageHistory", 41492: "SubjectLocation", 41493: "ExposureIndex", 41494: "TIFF-EPStandardID", 41495: "SensingMethod", 41728: "FileSource", 41729: "SceneType", 41730: "CFAPattern", 41985: "CustomRendered", 41986: "ExposureMode", 41987: "WhiteBalance", 41988: "DigitalZoomRatio", 41989: "FocalLengthIn35mmFormat", 41990: "SceneCaptureType", 41991: "GainControl", 41992: "Contrast", 41993: "Saturation", 41994: "Sharpness", 41995: "DeviceSettingDescription", 41996: "SubjectDistanceRange", 42016: "ImageUniqueID", 42032: "OwnerName", 42033: "SerialNumber", 42034: "LensInfo", 42035: "LensMake", 42036: "LensModel", 42037: "LensSerialNumber", 42112: "GDALMetadata", 42113: "GDALNoData", 42240: "Gamma", 44992: "ExpandSoftware", 44993: "ExpandLens", 44994: "ExpandFilm", 44995: "ExpandFilterLens", 44996: "ExpandScanner", 44997: "ExpandFlashLamp", 48129: "PixelFormat", 48130: "Transformation", 48131: "Uncompressed", 48132: "ImageType", 48256: "ImageWidth", 48257: "ImageHeight", 48258: "WidthResolution", 48259: "HeightResolution", 48320: "ImageOffset", 48321: "ImageByteCount", 48322: "AlphaOffset", 48323: "AlphaByteCount", 48324: "ImageDataDiscard", 48325: "AlphaDataDiscard", 50215: "OceScanjobDesc", 50216: "OceApplicationSelector", 50217: "OceIDNumber", 50218: "OceImageLogic", 50255: "Annotations", 50341: "PrintIM", 50560: "USPTOOriginalContentType", 50706: "DNGVersion", 50707: "DNGBackwardVersion", 50708: "UniqueCameraModel", 50709: "LocalizedCameraModel", 50710: "CFAPlaneColor", 50711: "CFALayout", 50712: "LinearizationTable", 50713: "BlackLevelRepeatDim", 50714: "BlackLevel", 50715: "BlackLevelDeltaH", 50716: "BlackLevelDeltaV", 50717: "WhiteLevel", 50718: "DefaultScale", 50719: "DefaultCropOrigin", 50720: "DefaultCropSize", 50721: "ColorMatrix1", 50722: "ColorMatrix2", 50723: "CameraCalibration1", 50724: "CameraCalibration2", 50725: "ReductionMatrix1", 50726: "ReductionMatrix2", 50727: "AnalogBalance", 50728: "AsShotNeutral", 50729: "AsShotWhiteXY", 50730: "BaselineExposure", 50731: "BaselineNoise", 50732: "BaselineSharpness", 50733: "BayerGreenSplit", 50734: "LinearResponseLimit", 50735: "CameraSerialNumber", 50736: "DNGLensInfo", 50737: "ChromaBlurRadius", 50738: "AntiAliasStrength", 50739: "ShadowScale", 50740: "DNGPrivateData", 50741: "MakerNoteSafety", 50752: "RawImageSegmentation", 50778: "CalibrationIlluminant1", 50779: "CalibrationIlluminant2", 50780: "BestQualityScale", 50781: "RawDataUniqueID", 50784: "AliasLayerMetadata", 50827: "OriginalRawFileName", 50828: "OriginalRawFileData", 50829: "ActiveArea", 50830: "MaskedAreas", 50831: "AsShotICCProfile", 50832: "AsShotPreProfileMatrix", 50833: "CurrentICCProfile", 50834: "CurrentPreProfileMatrix", 50879: "ColorimetricReference", 50898: "PanasonicTitle", 50899: "PanasonicTitle2", 50931: "CameraCalibrationSig", 50932: "ProfileCalibrationSig", 50933: "ProfileIFD", 50934: "AsShotProfileName", 50935: "NoiseReductionApplied", 50936: "ProfileName", 50937: "ProfileHueSatMapDims", 50938: "ProfileHueSatMapData1", 50939: "ProfileHueSatMapData2", 50940: "ProfileToneCurve", 50941: "ProfileEmbedPolicy", 50942: "ProfileCopyright", 50964: "ForwardMatrix1", 50965: "ForwardMatrix2", 50966: "PreviewApplicationName", 50967: "PreviewApplicationVersion", 50968: "PreviewSettingsName", 50969: "PreviewSettingsDigest", 50970: "PreviewColorSpace", 50971: "PreviewDateTime", 50972: "RawImageDigest", 50973: "OriginalRawFileDigest", 50974: "SubTileBlockSize", 50975: "RowInterleaveFactor", 50981: "ProfileLookTableDims", 50982: "ProfileLookTableData", 51008: "OpcodeList1", 51009: "OpcodeList2", 51022: "OpcodeList3", 51041: "NoiseProfile", 51043: "TimeCodes", 51044: "FrameRate", 51058: "TStop", 51081: "ReelName", 51089: "OriginalDefaultFinalSize", 51090: "OriginalBestQualitySize", 51091: "OriginalDefaultCropSize", 51105: "CameraLabel", 51107: "ProfileHueSatMapEncoding", 51108: "ProfileLookTableEncoding", 51109: "BaselineExposureOffset", 51110: "DefaultBlackRender", 51111: "NewRawImageDigest", 51112: "RawToPreviewGain", 51125: "DefaultUserCrop", 59932: "Padding", 59933: "OffsetSchema", 65e3: "OwnerName", 65001: "SerialNumber", 65002: "Lens", 65024: "KDC_IFD", 65100: "RawFile", 65101: "Converter", 65102: "WhiteBalance", 65105: "Exposure", 65106: "Shadows", 65107: "Brightness", 65108: "Contrast", 65109: "Saturation", 65110: "Sharpness", 65111: "Smoothness", 65112: "MoireFilter" }, gps: { 0: "GPSVersionID", 1: "GPSLatitudeRef", 2: "GPSLatitude", 3: "GPSLongitudeRef", 4: "GPSLongitude", 5: "GPSAltitudeRef", 6: "GPSAltitude", 7: "GPSTimeStamp", 8: "GPSSatellites", 9: "GPSStatus", 10: "GPSMeasureMode", 11: "GPSDOP", 12: "GPSSpeedRef", 13: "GPSSpeed", 14: "GPSTrackRef", 15: "GPSTrack", 16: "GPSImgDirectionRef", 17: "GPSImgDirection", 18: "GPSMapDatum", 19: "GPSDestLatitudeRef", 20: "GPSDestLatitude", 21: "GPSDestLongitudeRef", 22: "GPSDestLongitude", 23: "GPSDestBearingRef", 24: "GPSDestBearing", 25: "GPSDestDistanceRef", 26: "GPSDestDistance", 27: "GPSProcessingMethod", 28: "GPSAreaInformation", 29: "GPSDateStamp", 30: "GPSDifferential", 31: "GPSHPositioningError" } });
}
function ExifResult(e5, t3, i2, r4, n3, a2, o3) {
  this.startMarker = e5, this.tags = t3, this.imageSize = i2, this.thumbnailOffset = r4, this.thumbnailLength = n3, this.thumbnailType = a2, this.app1Offset = o3;
}
function Parser$1(e5) {
  this.stream = e5, this.flags = { readBinaryTags: false, resolveTagNames: true, simplifyValues: true, imageSize: true, hidePointers: true, returnTags: true };
}
function requireDomBufferstream() {
  if (hasRequiredDomBufferstream) return domBufferstream;
  function e5(e6, t3, i2, r4, n3, a2) {
    this.global = n3, t3 = t3 || 0, i2 = i2 || e6.byteLength - t3, this.arrayBuffer = e6.slice(t3, t3 + i2), this.view = new n3.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(r4), this.offset = 0, this.parentOffset = (a2 || 0) + t3;
  }
  __name(e5, "e");
  return hasRequiredDomBufferstream = 1, e5.prototype = { setBigEndian: /* @__PURE__ */ __name(function(e6) {
    this.littleEndian = !e6;
  }, "setBigEndian"), nextUInt8: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getUint8(this.offset);
    return this.offset += 1, e6;
  }, "nextUInt8"), nextInt8: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getInt8(this.offset);
    return this.offset += 1, e6;
  }, "nextInt8"), nextUInt16: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getUint16(this.offset, this.littleEndian);
    return this.offset += 2, e6;
  }, "nextUInt16"), nextUInt32: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getUint32(this.offset, this.littleEndian);
    return this.offset += 4, e6;
  }, "nextUInt32"), nextInt16: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getInt16(this.offset, this.littleEndian);
    return this.offset += 2, e6;
  }, "nextInt16"), nextInt32: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getInt32(this.offset, this.littleEndian);
    return this.offset += 4, e6;
  }, "nextInt32"), nextFloat: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getFloat32(this.offset, this.littleEndian);
    return this.offset += 4, e6;
  }, "nextFloat"), nextDouble: /* @__PURE__ */ __name(function() {
    var e6 = this.view.getFloat64(this.offset, this.littleEndian);
    return this.offset += 8, e6;
  }, "nextDouble"), nextBuffer: /* @__PURE__ */ __name(function(e6) {
    var t3 = this.arrayBuffer.slice(this.offset, this.offset + e6);
    return this.offset += e6, t3;
  }, "nextBuffer"), remainingLength: /* @__PURE__ */ __name(function() {
    return this.arrayBuffer.byteLength - this.offset;
  }, "remainingLength"), nextString: /* @__PURE__ */ __name(function(e6) {
    var t3 = this.arrayBuffer.slice(this.offset, this.offset + e6);
    return t3 = String.fromCharCode.apply(null, new this.global.Uint8Array(t3)), this.offset += e6, t3;
  }, "nextString"), mark: /* @__PURE__ */ __name(function() {
    var t3 = this;
    return { openWithOffset: /* @__PURE__ */ __name(function(i2) {
      return i2 = (i2 || 0) + this.offset, new e5(t3.arrayBuffer, i2, t3.arrayBuffer.byteLength - i2, !t3.littleEndian, t3.global, t3.parentOffset);
    }, "openWithOffset"), offset: this.offset, getParentOffset: /* @__PURE__ */ __name(function() {
      return t3.parentOffset;
    }, "getParentOffset") };
  }, "mark"), offsetFrom: /* @__PURE__ */ __name(function(e6) {
    return this.parentOffset + this.offset - (e6.offset + e6.getParentOffset());
  }, "offsetFrom"), skip: /* @__PURE__ */ __name(function(e6) {
    this.offset += e6;
  }, "skip"), branch: /* @__PURE__ */ __name(function(t3, i2) {
    return i2 = "number" == typeof i2 ? i2 : this.arrayBuffer.byteLength - (this.offset + t3), new e5(this.arrayBuffer, this.offset + t3, i2, !this.littleEndian, this.global, this.parentOffset);
  }, "branch") }, domBufferstream = e5;
}
function requireBufferstream() {
  if (hasRequiredBufferstream) return bufferstream;
  function e5(e6, t3, i2, r4) {
    this.buffer = e6, this.offset = t3 || 0, i2 = "number" == typeof i2 ? i2 : e6.length, this.endPosition = this.offset + i2, this.setBigEndian(r4);
  }
  __name(e5, "e");
  return hasRequiredBufferstream = 1, e5.prototype = { setBigEndian: /* @__PURE__ */ __name(function(e6) {
    this.bigEndian = !!e6;
  }, "setBigEndian"), nextUInt8: /* @__PURE__ */ __name(function() {
    var e6 = this.buffer.readUInt8(this.offset);
    return this.offset += 1, e6;
  }, "nextUInt8"), nextInt8: /* @__PURE__ */ __name(function() {
    var e6 = this.buffer.readInt8(this.offset);
    return this.offset += 1, e6;
  }, "nextInt8"), nextUInt16: /* @__PURE__ */ __name(function() {
    var e6 = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
    return this.offset += 2, e6;
  }, "nextUInt16"), nextUInt32: /* @__PURE__ */ __name(function() {
    var e6 = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, e6;
  }, "nextUInt32"), nextInt16: /* @__PURE__ */ __name(function() {
    var e6 = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
    return this.offset += 2, e6;
  }, "nextInt16"), nextInt32: /* @__PURE__ */ __name(function() {
    var e6 = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
    return this.offset += 4, e6;
  }, "nextInt32"), nextFloat: /* @__PURE__ */ __name(function() {
    var e6 = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
    return this.offset += 4, e6;
  }, "nextFloat"), nextDouble: /* @__PURE__ */ __name(function() {
    var e6 = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
    return this.offset += 8, e6;
  }, "nextDouble"), nextBuffer: /* @__PURE__ */ __name(function(e6) {
    var t3 = this.buffer.slice(this.offset, this.offset + e6);
    return this.offset += e6, t3;
  }, "nextBuffer"), remainingLength: /* @__PURE__ */ __name(function() {
    return this.endPosition - this.offset;
  }, "remainingLength"), nextString: /* @__PURE__ */ __name(function(e6) {
    var t3 = this.buffer.toString("utf8", this.offset, this.offset + e6);
    return this.offset += e6, t3;
  }, "nextString"), mark: /* @__PURE__ */ __name(function() {
    var t3 = this;
    return { openWithOffset: /* @__PURE__ */ __name(function(i2) {
      return i2 = (i2 || 0) + this.offset, new e5(t3.buffer, i2, t3.endPosition - i2, t3.bigEndian);
    }, "openWithOffset"), offset: this.offset };
  }, "mark"), offsetFrom: /* @__PURE__ */ __name(function(e6) {
    return this.offset - e6.offset;
  }, "offsetFrom"), skip: /* @__PURE__ */ __name(function(e6) {
    this.offset += e6;
  }, "skip"), branch: /* @__PURE__ */ __name(function(t3, i2) {
    return i2 = "number" == typeof i2 ? i2 : this.endPosition - (this.offset + t3), new e5(this.buffer, this.offset + t3, i2, this.bigEndian);
  }, "branch") }, bufferstream = e5;
}
function getGlobal() {
  return (0, eval)("this");
}
function getExifOrientation(e5) {
  const t3 = e5._exif;
  return t3 && t3.tags && t3.tags.Orientation || 1;
}
function getExifOrientationTransformation(e5) {
  const t3 = e5.bitmap.width, i2 = e5.bitmap.height;
  switch (getExifOrientation(e5)) {
    case 1:
    default:
      return null;
    case 2:
      return function(e6, i3) {
        return [t3 - e6 - 1, i3];
      };
    case 3:
      return function(e6, r4) {
        return [t3 - e6 - 1, i2 - r4 - 1];
      };
    case 4:
      return function(e6, t4) {
        return [e6, i2 - t4 - 1];
      };
    case 5:
      return function(e6, t4) {
        return [t4, e6];
      };
    case 6:
      return function(e6, t4) {
        return [t4, i2 - e6 - 1];
      };
    case 7:
      return function(e6, r4) {
        return [t3 - r4 - 1, i2 - e6 - 1];
      };
    case 8:
      return function(e6, i3) {
        return [t3 - i3 - 1, e6];
      };
  }
}
function transformBitmap(e5, t3, i2, r4) {
  const n3 = e5.bitmap.data, a2 = e5.bitmap.width, o3 = Buffer2.alloc(n3.length);
  for (let e6 = 0; e6 < t3; e6++) for (let s4 = 0; s4 < i2; s4++) {
    const [i3, l2] = r4(e6, s4), u2 = t3 * s4 + e6 << 2, h2 = a2 * l2 + i3 << 2, c3 = n3.readUInt32BE(h2);
    o3.writeUInt32BE(c3, u2);
  }
  e5.bitmap.data = o3, e5.bitmap.width = t3, e5.bitmap.height = i2, e5._exif.tags.Orientation = 1;
}
function exifRotate(e5) {
  if (getExifOrientation(e5) < 2) return;
  const t3 = getExifOrientationTransformation(e5), i2 = getExifOrientation(e5) > 4, r4 = i2 ? e5.bitmap.height : e5.bitmap.width, n3 = i2 ? e5.bitmap.width : e5.bitmap.height;
  t3 && transformBitmap(e5, r4, n3, t3);
}
async function attemptExifRotate(e5, t3) {
  try {
    e5._exif = EXIFParser.create(t3).parse(), exifRotate(e5);
  } catch {
  }
}
function bufferFromArrayBuffer(e5) {
  const t3 = Buffer2.alloc(e5.byteLength), i2 = new Uint8Array(e5);
  for (let e6 = 0; e6 < t3.length; ++e6) t3[e6] = i2[e6];
  return t3;
}
function createJimp({ plugins: e5, formats: t3 } = {}) {
  const i2 = e5 || [], r4 = (t3 || []).map((e6) => e6()), n3 = class {
    static {
      __name(this, "n");
    }
    constructor(e6 = emptyBitmap) {
      if (__publicField$2(this, "bitmap", emptyBitmap), __publicField$2(this, "background", 0), __publicField$2(this, "formats", []), __publicField$2(this, "mime"), this.formats = r4, "data" in e6) this.bitmap = e6;
      else if (this.bitmap = { data: Buffer2.alloc(e6.width * e6.height * 4), width: e6.width, height: e6.height }, e6.color) {
        this.background = "string" == typeof e6.color ? cssColorToHex(e6.color) : e6.color;
        for (let e7 = 0; e7 < this.bitmap.data.length; e7 += 4) this.bitmap.data.writeUInt32BE(this.background, e7);
      }
      for (const e7 of i2) for (const t4 in e7) this[t4] = (...i3) => {
        const r5 = e7[t4]?.(this, ...i3);
        return "object" == typeof r5 && "bitmap" in r5 ? (this.bitmap = r5.bitmap, this) : r5;
      };
    }
    static async read(e6, t4) {
      if (Buffer2.isBuffer(e6) || e6 instanceof ArrayBuffer) return this.fromBuffer(e6);
      const [i3, r5] = await to(fetch(e6));
      if (i3) throw new Error(`Could not load Buffer from URL: ${e6}`);
      if (!r5.ok) throw new Error(`HTTP Status ${r5.status} for url ${e6}`);
      const [n4, a2] = await to(r5.arrayBuffer());
      if (n4) throw new Error(`Could not load Buffer from ${e6}`);
      const o3 = bufferFromArrayBuffer(a2);
      return this.fromBuffer(o3, t4);
    }
    static fromBitmap(e6) {
      let t4;
      if (e6.data instanceof Buffer2 && (t4 = Buffer2.from(e6.data)), (e6.data instanceof Uint8Array || e6.data instanceof Uint8ClampedArray) && (t4 = Buffer2.from(e6.data.buffer)), Array.isArray(e6.data) && (t4 = Buffer2.concat(e6.data.map((e7) => Buffer2.from(e7.toString(16).padStart(8, "0"), "hex")))), !t4) throw new Error("data must be a Buffer");
      if ("number" != typeof e6.height || "number" != typeof e6.width) throw new Error("bitmap must have width and height");
      return new n3({ height: e6.height, width: e6.width, data: t4 });
    }
    static async fromBuffer(e6, t4) {
      const i3 = e6 instanceof ArrayBuffer ? bufferFromArrayBuffer(e6) : e6, a2 = await fileType$1.fromBuffer(i3);
      if (!a2 || !a2.mime) throw new Error("Could not find MIME for Buffer");
      const o3 = r4.find((e7) => e7.mime === a2.mime);
      if (!o3 || !o3.decode) throw new Error(`Mime type ${a2.mime} does not support decoding`);
      const s4 = new n3(await o3.decode(i3, t4?.[o3.mime]));
      return s4.mime = a2.mime, attemptExifRotate(s4, i3), s4;
    }
    inspect() {
      return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
    }
    toString() {
      return "[object Jimp]";
    }
    get width() {
      return this.bitmap.width;
    }
    get height() {
      return this.bitmap.height;
    }
    async getBuffer(e6, t4) {
      const i3 = this.formats.find((t5) => t5.mime === e6);
      if (!i3 || !i3.encode) throw new Error(`Unsupported MIME type: ${e6}`);
      let r5;
      return i3.hasAlpha ? r5 = this : (r5 = new n3({ width: this.bitmap.width, height: this.bitmap.height, color: this.background }), composite(r5, this)), i3.encode(r5.bitmap, t4);
    }
    async getBase64(e6, t4) {
      return "data:" + e6 + ";base64," + (await this.getBuffer(e6, t4)).toString("base64");
    }
    async write(e6, t4) {
      const i3 = mime.getType(e6);
      await writeFile(e6, await this.getBuffer(i3, t4));
    }
    clone() {
      return new n3({ ...this.bitmap, data: Buffer2.from(this.bitmap.data) });
    }
    getPixelIndex(e6, t4, i3) {
      let r5, n4;
      if (i3 || (i3 = Edge.EXTEND), "number" != typeof e6 || "number" != typeof t4) throw new Error("x and y must be numbers");
      r5 = e6 = Math.round(e6), n4 = t4 = Math.round(t4), i3 === Edge.EXTEND && (e6 < 0 && (r5 = 0), e6 >= this.bitmap.width && (r5 = this.bitmap.width - 1), t4 < 0 && (n4 = 0), t4 >= this.bitmap.height && (n4 = this.bitmap.height - 1)), i3 === Edge.WRAP && (e6 < 0 && (r5 = this.bitmap.width + e6), e6 >= this.bitmap.width && (r5 = e6 % this.bitmap.width), t4 < 0 && (n4 = this.bitmap.height + t4), t4 >= this.bitmap.height && (n4 = t4 % this.bitmap.height));
      let a2 = this.bitmap.width * n4 + r5 << 2;
      return (r5 < 0 || r5 >= this.bitmap.width) && (a2 = -1), (n4 < 0 || n4 >= this.bitmap.height) && (a2 = -1), a2;
    }
    getPixelColor(e6, t4) {
      if ("number" != typeof e6 || "number" != typeof t4) throw new Error("x and y must be numbers");
      const i3 = this.getPixelIndex(e6, t4);
      return this.bitmap.data.readUInt32BE(i3);
    }
    setPixelColor(e6, t4, i3) {
      if ("number" != typeof e6 || "number" != typeof t4 || "number" != typeof i3) throw new Error("hex, x and y must be numbers");
      const r5 = this.getPixelIndex(t4, i3);
      return this.bitmap.data.writeUInt32BE(e6, r5), this;
    }
    hasAlpha() {
      const { width: e6, height: t4, data: i3 } = this.bitmap, r5 = e6 * t4 << 2;
      for (let e7 = 3; e7 < r5; e7 += 4) if (255 !== i3[e7]) return true;
      return false;
    }
    composite(e6, t4 = 0, i3 = 0, r5 = {}) {
      return composite(this, e6, t4, i3, r5);
    }
    scan(e6, t4, i3, r5, n4) {
      return scan(this, e6, t4, i3, r5, n4);
    }
    scanIterator(e6 = 0, t4 = 0, i3 = this.bitmap.width, r5 = this.bitmap.height) {
      if ("number" != typeof e6 || "number" != typeof t4) throw new Error("x and y must be numbers");
      if ("number" != typeof i3 || "number" != typeof r5) throw new Error("w and h must be numbers");
      return scanIterator(this, e6, t4, i3, r5);
    }
  };
  return n3;
}
function Resize(e5, t3, i2, r4, n3, a2, o3) {
  this.widthOriginal = Math.abs(Math.floor(e5) || 0), this.heightOriginal = Math.abs(Math.floor(t3) || 0), this.targetWidth = Math.abs(Math.floor(i2) || 0), this.targetHeight = Math.abs(Math.floor(r4) || 0), this.colorChannels = n3 ? 4 : 3, this.interpolationPass = Boolean(a2), this.resizeCallback = "function" == typeof o3 ? o3 : function() {
  }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
}
function Converter$1(e5, t3) {
  if (!(e5 && t3 && e5.length && t3.length)) throw new Error("Bad alphabet");
  this.srcAlphabet = e5, this.dstAlphabet = t3;
}
function anyBase(e5, t3) {
  var i2 = new Converter(e5, t3);
  return function(e6) {
    return i2.convert(e6);
  };
}
function intToRGBA(e5) {
  const t3 = 255 & e5, i2 = 255 & (e5 >>>= 8), r4 = 255 & (e5 >>>= 8);
  return { r: 255 & (e5 >>>= 8), g: r4, b: i2, a: t3 };
}
function initCoefficients(e5) {
  for (let t3 = 1; t3 < e5; t3++) c$1[t3] = 1;
  c$1[0] = 1 / Math.sqrt(2);
}
function applyDCT(e5, t3) {
  const i2 = t3, r4 = [];
  for (let t4 = 0; t4 < i2; t4++) {
    const n3 = [];
    for (let a2 = 0; a2 < i2; a2++) {
      let o3 = 0;
      for (let r5 = 0; r5 < i2; r5++) for (let n4 = 0; n4 < i2; n4++) o3 += Math.cos((2 * r5 + 1) / (2 * i2) * t4 * Math.PI) * Math.cos((2 * n4 + 1) / (2 * i2) * a2 * Math.PI) * e5[r5][n4];
      o3 *= c$1[t4] * c$1[a2] / 4, n3[a2] = o3, r4[t4] = n3;
    }
  }
  return r4;
}
function distance(e5, t3) {
  const i2 = new ImagePHash(), r4 = i2.getHash(e5), n3 = i2.getHash(t3);
  return i2.distance(r4, n3);
}
function compareHashes(e5, t3) {
  return new ImagePHash().distance(e5, t3);
}
function measureText(e5, t3) {
  let i2 = 0;
  for (let r4 = 0; r4 < t3.length; r4++) {
    const n3 = t3[r4], a2 = e5.chars[n3];
    if (a2) {
      const o3 = e5.kernings[n3], s4 = t3[r4 + 1], l2 = o3 && s4 && o3[s4] && o3[s4] || 0;
      i2 += (a2.xadvance || 0) + l2;
    }
  }
  return i2;
}
function splitLines(e5, t3, i2) {
  const r4 = t3.replace(/[\r\n]+/g, " \n").split(" "), n3 = [];
  let a2 = [], o3 = 0;
  return r4.forEach((t4) => {
    if (measureText(e5, t4 + (r4.length > 1 ? " " : "")) > i2) {
      const r5 = t4[Symbol.iterator]();
      let o4 = "";
      for (const t5 of r5) {
        const r6 = [...a2, o4 + t5].join(" "), s5 = measureText(e5, r6);
        s5 < i2 ? o4 += t5 : s5 > i2 ? (n3.push([...a2, o4]), a2 = [], o4 = t5) : (n3.push([...a2, o4 + t5]), a2 = [], o4 = "");
      }
      return;
    }
    const s4 = [...a2, t4].join(" "), l2 = measureText(e5, s4);
    l2 <= i2 && !t4.includes("\n") ? (l2 > o3 && (o3 = l2), a2.push(t4)) : (n3.push(a2), a2 = [t4.replace("\n", "")]);
  }), n3.push(a2), { lines: n3, longestLine: o3 };
}
function measureTextHeight(e5, t3, i2) {
  const { lines: r4 } = splitLines(e5, t3, i2);
  return r4.length * e5.common.lineHeight;
}
function xOffsetBasedOnAlignment(e5, t3, i2, r4) {
  return r4 === HorizontalAlign.LEFT ? 0 : r4 === HorizontalAlign.CENTER ? (i2 - measureText(e5, t3)) / 2 : i2 - measureText(e5, t3);
}
function drawCharacter(e5, t3, i2, r4, n3) {
  if (n3.width > 0 && n3.height > 0) {
    const a2 = t3.pages[n3.page];
    a2 && (e5 = methods$h.blit(e5, { src: a2, x: i2 + n3.xoffset, y: r4 + n3.yoffset, srcX: n3.x, srcY: n3.y, srcW: n3.width, srcH: n3.height }));
  }
  return e5;
}
function printText(e5, t3, i2, r4, n3, a2) {
  for (let o3 = 0; o3 < n3.length; o3++) {
    const s4 = n3[o3];
    let l2;
    l2 = t3.chars[s4] ? s4 : /\s/.test(s4) ? "" : "?";
    const u2 = t3.chars[l2] || { xadvance: void 0 }, h2 = t3.kernings[l2];
    u2 && drawCharacter(e5, t3, i2, r4, u2);
    const c3 = n3[o3 + 1];
    i2 += (h2 && c3 && h2[c3] && h2[c3] || 0) + (u2.xadvance || a2);
  }
}
function createIdxTranslationFunction(e5) {
  return function(t3, i2) {
    return i2 * e5 + t3 << 2;
  };
}
function matrixRotate(e5, t3) {
  if (Math.abs(t3) % 90 != 0) throw new Error("Unsupported matrix rotation degree");
  const i2 = e5.bitmap.width, r4 = e5.bitmap.height;
  let n3;
  switch (t3) {
    case 90:
    case -270:
      n3 = 90;
      break;
    case 180:
    case -180:
      n3 = 180;
      break;
    case 270:
    case -90:
      n3 = -90;
      break;
    default:
      throw new Error("Unsupported matrix rotation degree");
  }
  const a2 = 180 === n3 ? i2 : r4, o3 = 180 === n3 ? r4 : i2, s4 = Buffer2.alloc(e5.bitmap.data.length), l2 = createIdxTranslationFunction(i2), u2 = createIdxTranslationFunction(a2);
  for (let t4 = 0; t4 < i2; t4++) for (let a3 = 0; a3 < r4; a3++) {
    const o4 = l2(t4, a3), h2 = e5.bitmap.data.readUInt32BE(o4);
    let c3;
    switch (n3) {
      case 90:
        c3 = u2(a3, i2 - t4 - 1);
        break;
      case -90:
        c3 = u2(r4 - a3 - 1, t4);
        break;
      case 180:
        c3 = u2(i2 - t4 - 1, r4 - a3 - 1);
        break;
      default:
        throw new Error("Unsupported matrix rotation angle");
    }
    s4.writeUInt32BE(h2, c3);
  }
  e5.bitmap.data = s4, e5.bitmap.width = a2, e5.bitmap.height = o3;
}
function createTranslationFunction(e5, t3) {
  return function(i2, r4) {
    return { x: i2 + e5, y: r4 + t3 };
  };
}
function advancedRotate(e5, t3, i2) {
  const r4 = t3 * Math.PI / 180, n3 = Math.cos(r4), a2 = Math.sin(r4);
  let o3 = e5.bitmap.width, s4 = e5.bitmap.height;
  if (true === i2 || "string" == typeof i2) {
    o3 = Math.ceil(Math.abs(e5.bitmap.width * n3) + Math.abs(e5.bitmap.height * a2)) + 1, s4 = Math.ceil(Math.abs(e5.bitmap.width * a2) + Math.abs(e5.bitmap.height * n3)) + 1, o3 % 2 != 0 && o3++, s4 % 2 != 0 && s4++;
    const t4 = clone(e5);
    e5.scan((t5, i3, r6) => {
      e5.bitmap.data.writeUInt32BE(e5.background, r6);
    });
    const r5 = Math.max(o3, s4, e5.bitmap.width, e5.bitmap.height);
    e5 = composite(e5 = methods$d.resize(e5, { h: r5, w: r5, mode: true === i2 ? void 0 : i2 }), t4, e5.bitmap.width / 2 - t4.bitmap.width / 2, e5.bitmap.height / 2 - t4.bitmap.height / 2);
  }
  const l2 = e5.bitmap.width, u2 = e5.bitmap.height, h2 = Buffer2.alloc(e5.bitmap.data.length), c3 = createTranslationFunction(-l2 / 2, -u2 / 2), f2 = createTranslationFunction(l2 / 2 + 0.5, u2 / 2 + 0.5);
  for (let t4 = 1; t4 <= u2; t4++) for (let i3 = 1; i3 <= l2; i3++) {
    const r5 = c3(i3, t4), o4 = f2(n3 * r5.x - a2 * r5.y, n3 * r5.y + a2 * r5.x), s5 = l2 * (t4 - 1) + i3 - 1 << 2;
    if (o4.x >= 0 && o4.x < l2 && o4.y >= 0 && o4.y < u2) {
      const t5 = l2 * (0 | o4.y) + o4.x << 2, i4 = e5.bitmap.data.readUInt32BE(t5);
      h2.writeUInt32BE(i4, s5);
    } else h2.writeUInt32BE(e5.background, s5);
  }
  if (e5.bitmap.data = h2, true === i2 || "string" == typeof i2) {
    const t4 = Math.max(l2 / 2 - o3 / 2, 0), i3 = Math.max(u2 / 2 - s4 / 2, 0);
    e5 = methods$b.crop(e5, { x: t4, y: i3, w: o3, h: s4 });
  }
}
function correctGamma(e5) {
  return e5 > 0.04045 ? ((e5 + 0.055) / 1.055) ** 2.4 : e5 / 12.92;
}
function rgb2xyz(e5, t3, i2) {
  return { x: 0.4124 * (e5 = correctGamma(e5 / 255)) + 0.3576 * (t3 = correctGamma(t3 / 255)) + 0.1805 * (i2 = correctGamma(i2 / 255)), y: 0.2126 * e5 + 0.7152 * t3 + 0.0722 * i2, z: 0.0193 * e5 + 0.1192 * t3 + 0.9505 * i2 };
}
function degrees2radians(e5) {
  return e5 * (Math.PI / 180);
}
function max3(e5, t3, i2) {
  let r4 = e5;
  return r4 < t3 && (r4 = t3), r4 < i2 && (r4 = i2), r4;
}
function min3(e5, t3, i2) {
  let r4 = e5;
  return r4 > t3 && (r4 = t3), r4 > i2 && (r4 = i2), r4;
}
function intInRange(e5, t3, i2) {
  return e5 > i2 && (e5 = i2), e5 < t3 && (e5 = t3), 0 | e5;
}
function inRange0to255Rounded(e5) {
  return (e5 = Math.round(e5)) > 255 ? e5 = 255 : e5 < 0 && (e5 = 0), e5;
}
function inRange0to255(e5) {
  return e5 > 255 ? e5 = 255 : e5 < 0 && (e5 = 0), e5;
}
function stableSort(e5, t3) {
  const i2 = typeof e5[0];
  let r4;
  if ("number" === i2 || "string" === i2) {
    const i3 = /* @__PURE__ */ Object.create(null);
    for (let t4 = 0, r5 = e5.length; t4 < r5; t4++) {
      const r6 = e5[t4];
      i3[r6] || 0 === i3[r6] || (i3[r6] = t4);
    }
    r4 = e5.sort((e6, r5) => t3(e6, r5) || i3[e6] - i3[r5]);
  } else {
    const i3 = e5.slice(0);
    r4 = e5.sort((e6, r5) => t3(e6, r5) || i3.indexOf(e6) - i3.indexOf(r5));
  }
  return r4;
}
function rgb2hsl(e5, t3, i2) {
  const r4 = min3(e5, t3, i2), n3 = max3(e5, t3, i2), a2 = n3 - r4, o3 = (r4 + n3) / 510;
  let s4 = 0;
  o3 > 0 && o3 < 1 && (s4 = a2 / (o3 < 0.5 ? n3 + r4 : 510 - n3 - r4));
  let l2 = 0;
  return a2 > 0 && (l2 = n3 === e5 ? (t3 - i2) / a2 : n3 === t3 ? 2 + (i2 - e5) / a2 : 4 + (e5 - t3) / a2, l2 *= 60, l2 < 0 && (l2 += 360)), { h: l2, s: s4, l: o3 };
}
function pivot(e5) {
  return e5 > 8856e-6 ? e5 ** (1 / 3) : 7.787 * e5 + 16 / 116;
}
function xyz2lab(e5, t3, i2) {
  if (e5 = pivot(e5 / refX), t3 = pivot(t3 / refY), i2 = pivot(i2 / refZ), 116 * t3 - 16 < 0) throw new Error("xxx");
  return { L: Math.max(0, 116 * t3 - 16), a: 500 * (e5 - t3), b: 200 * (t3 - i2) };
}
function rgb2lab(e5, t3, i2) {
  const r4 = rgb2xyz(e5, t3, i2);
  return xyz2lab(r4.x, r4.y, r4.z);
}
function pivot2(e5) {
  return e5 > 0.206893034 ? e5 ** 3 : (e5 - 16 / 116) / 7.787;
}
function lab2xyz(e5, t3, i2) {
  const r4 = (e5 + 16) / 116, n3 = r4 - i2 / 200;
  return { x: refX2 * pivot2(t3 / 500 + r4), y: refY2 * pivot2(r4), z: refZ2 * pivot2(n3) };
}
function correctGamma2(e5) {
  return e5 > 31308e-7 ? 1.055 * e5 ** (1 / 2.4) - 0.055 : 12.92 * e5;
}
function xyz2rgb(e5, t3, i2) {
  const r4 = correctGamma2(3.2406 * e5 + -1.5372 * t3 + -0.4986 * i2), n3 = correctGamma2(-0.9689 * e5 + 1.8758 * t3 + 0.0415 * i2), a2 = correctGamma2(0.0557 * e5 + -0.204 * t3 + 1.057 * i2);
  return { r: inRange0to255Rounded(255 * r4), g: inRange0to255Rounded(255 * n3), b: inRange0to255Rounded(255 * a2) };
}
function lab2rgb(e5, t3, i2) {
  const r4 = lab2xyz(e5, t3, i2);
  return xyz2rgb(r4.x, r4.y, r4.z);
}
function hueGroup(e5, t3) {
  const i2 = 360 / t3;
  for (let r4 = 1, n3 = i2 - i2 / 2; r4 < t3; r4++, n3 += i2) if (e5 >= n3 && e5 < n3 + i2) return r4;
  return 0;
}
function createArray1D(e5) {
  const t3 = [];
  for (let i2 = 0; i2 < e5; i2++) t3[i2] = 0;
  return t3;
}
function createArray4D(e5, t3, i2, r4) {
  const n3 = new Array(e5);
  for (let a2 = 0; a2 < e5; a2++) {
    n3[a2] = new Array(t3);
    for (let e6 = 0; e6 < t3; e6++) {
      n3[a2][e6] = new Array(i2);
      for (let t4 = 0; t4 < i2; t4++) {
        n3[a2][e6][t4] = new Array(r4);
        for (let i3 = 0; i3 < r4; i3++) n3[a2][e6][t4][i3] = 0;
      }
    }
  }
  return n3;
}
function createArray3D(e5, t3, i2) {
  const r4 = new Array(e5);
  for (let n3 = 0; n3 < e5; n3++) {
    r4[n3] = new Array(t3);
    for (let e6 = 0; e6 < t3; e6++) {
      r4[n3][e6] = new Array(i2);
      for (let t4 = 0; t4 < i2; t4++) r4[n3][e6][t4] = 0;
    }
  }
  return r4;
}
function fillArray3D(e5, t3, i2, r4, n3) {
  for (let a2 = 0; a2 < t3; a2++) {
    e5[a2] = [];
    for (let t4 = 0; t4 < i2; t4++) {
      e5[a2][t4] = [];
      for (let i3 = 0; i3 < r4; i3++) e5[a2][t4][i3] = n3;
    }
  }
}
function fillArray1D(e5, t3, i2) {
  for (let r4 = 0; r4 < t3; r4++) e5[r4] = i2;
}
function* hilbertCurve(e5, t3, i2) {
  const r4 = Math.max(e5, t3), n3 = { width: e5, height: t3, level: Math.floor(Math.log(r4) / Math.log(2) + 1), callback: i2, tracker: new ProgressTracker(e5 * t3, 99), index: 0, x: 0, y: 0 };
  yield* walkHilbert(n3, 1), visit(n3, 0);
}
function* walkHilbert(e5, t3) {
  if (!(e5.level < 1)) {
    switch (e5.tracker.shouldNotify(e5.index) && (yield { progress: e5.tracker.progress }), e5.level--, t3) {
      case 2:
        yield* walkHilbert(e5, 1), visit(e5, 3), yield* walkHilbert(e5, 2), visit(e5, 4), yield* walkHilbert(e5, 2), visit(e5, 2), yield* walkHilbert(e5, 4);
        break;
      case 3:
        yield* walkHilbert(e5, 4), visit(e5, 2), yield* walkHilbert(e5, 3), visit(e5, 1), yield* walkHilbert(e5, 3), visit(e5, 3), yield* walkHilbert(e5, 1);
        break;
      case 1:
        yield* walkHilbert(e5, 2), visit(e5, 4), yield* walkHilbert(e5, 1), visit(e5, 3), yield* walkHilbert(e5, 1), visit(e5, 1), yield* walkHilbert(e5, 3);
        break;
      case 4:
        yield* walkHilbert(e5, 3), visit(e5, 1), yield* walkHilbert(e5, 4), visit(e5, 2), yield* walkHilbert(e5, 4), visit(e5, 4), yield* walkHilbert(e5, 2);
    }
    e5.level++;
  }
}
function visit(e5, t3) {
  switch (e5.x >= 0 && e5.x < e5.width && e5.y >= 0 && e5.y < e5.height && (e5.callback(e5.x, e5.y), e5.index++), t3) {
    case 2:
      e5.x--;
      break;
    case 3:
      e5.x++;
      break;
    case 1:
      e5.y--;
      break;
    case 4:
      e5.y++;
  }
}
function ssim(e5, t3) {
  if (e5.getHeight() !== t3.getHeight() || e5.getWidth() !== t3.getWidth()) throw new Error("Images have different sizes!");
  const i2 = (255 * K1) ** 2, r4 = (255 * K2) ** 2;
  let n3 = 0, a2 = 0;
  return iterate(e5, t3, (e6, t4, o3, s4) => {
    let l2 = 0, u2 = 0, h2 = 0;
    for (let i3 = 0; i3 < e6.length; i3++) u2 += (e6[i3] - o3) ** 2, h2 += (t4[i3] - s4) ** 2, l2 += (e6[i3] - o3) * (t4[i3] - s4);
    const c3 = e6.length - 1;
    u2 /= c3, h2 /= c3, l2 /= c3;
    a2 += (2 * o3 * s4 + i2) * (2 * l2 + r4) / ((o3 ** 2 + s4 ** 2 + i2) * (u2 + h2 + r4)), n3++;
  }), a2 / n3;
}
function iterate(e5, t3, i2) {
  const r4 = e5.getWidth(), n3 = e5.getHeight();
  for (let a2 = 0; a2 < n3; a2 += 8) for (let o3 = 0; o3 < r4; o3 += 8) {
    const s4 = Math.min(8, r4 - o3), l2 = Math.min(8, n3 - a2), u2 = calculateLumaValuesForWindow(e5, o3, a2, s4, l2), h2 = calculateLumaValuesForWindow(t3, o3, a2, s4, l2);
    i2(u2, h2, calculateAverageLuma(u2), calculateAverageLuma(h2));
  }
}
function calculateLumaValuesForWindow(e5, t3, i2, r4, n3) {
  const a2 = e5.getPointArray(), o3 = [];
  let s4 = 0;
  for (let l2 = i2; l2 < i2 + n3; l2++) {
    const i3 = l2 * e5.getWidth();
    for (let e6 = t3; e6 < t3 + r4; e6++) {
      const t4 = a2[i3 + e6];
      o3[s4] = 0.2126 * t4.r + 0.7152 * t4.g + 0.0722 * t4.b, s4++;
    }
  }
  return o3;
}
function calculateAverageLuma(e5) {
  let t3 = 0;
  for (const i2 of e5) t3 += i2;
  return t3 / e5.length;
}
function buildPaletteSync(e5, { colorDistanceFormula: t3, paletteQuantization: i2, colors: r4 } = {}) {
  const n3 = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(t3), i2, r4);
  return e5.forEach((e6) => n3.sample(e6)), n3.quantizeSync();
}
function applyPaletteSync(e5, t3, { colorDistanceFormula: i2, imageQuantization: r4 } = {}) {
  return imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(i2), r4).quantizeSync(e5, t3);
}
function colorDistanceFormulaToColorDistance(e5 = "euclidean-bt709") {
  switch (e5) {
    case "cie94-graphic-arts":
      return new CIE94GraphicArts();
    case "cie94-textiles":
      return new CIE94Textiles();
    case "ciede2000":
      return new CIEDE2000();
    case "color-metric":
      return new CMetric();
    case "euclidean":
      return new Euclidean();
    case "euclidean-bt709":
      return new EuclideanBT709();
    case "euclidean-bt709-noalpha":
      return new EuclideanBT709NoAlpha();
    case "manhattan":
      return new Manhattan();
    case "manhattan-bt709":
      return new ManhattanBT709();
    case "manhattan-nommyde":
      return new ManhattanNommyde();
    case "pngquant":
      return new PNGQuant();
    default:
      throw new Error(`Unknown colorDistanceFormula ${e5}`);
  }
}
function imageQuantizationToImageQuantizer(e5, t3 = "floyd-steinberg") {
  switch (t3) {
    case "nearest":
      return new NearestColor(e5);
    case "riemersma":
      return new ErrorDiffusionRiemersma(e5);
    case "floyd-steinberg":
      return new ErrorDiffusionArray(e5, 0);
    case "false-floyd-steinberg":
      return new ErrorDiffusionArray(e5, 1);
    case "stucki":
      return new ErrorDiffusionArray(e5, 2);
    case "atkinson":
      return new ErrorDiffusionArray(e5, 3);
    case "jarvis":
      return new ErrorDiffusionArray(e5, 4);
    case "burkes":
      return new ErrorDiffusionArray(e5, 5);
    case "sierra":
      return new ErrorDiffusionArray(e5, 6);
    case "two-sierra":
      return new ErrorDiffusionArray(e5, 7);
    case "sierra-lite":
      return new ErrorDiffusionArray(e5, 8);
    default:
      throw new Error(`Unknown imageQuantization ${t3}`);
  }
}
function paletteQuantizationToPaletteQuantizer(e5, t3 = "wuquant", i2 = 256) {
  switch (t3) {
    case "neuquant":
      return new NeuQuant(e5, i2);
    case "rgbquant":
      return new RGBQuant(e5, i2);
    case "wuquant":
      return new WuQuant(e5, i2);
    case "neuquant-float":
      return new NeuQuantFloat(e5, i2);
    default:
      throw new Error(`Unknown paletteQuantization ${t3}`);
  }
}
function splitLine(e5, t3) {
  if (!(e5 = e5.replace(/\t+/g, " ").trim())) return null;
  var i2 = e5.indexOf(" ");
  if (-1 === i2) throw new Error("no named row at line " + t3);
  var r4 = e5.substring(0, i2);
  e5 = (e5 = (e5 = (e5 = e5.substring(i2 + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map(function(e6) {
    return e6.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
  });
  for (var n3 = [], a2 = 0; a2 < e5.length; a2++) {
    var o3 = e5[a2];
    0 === a2 ? n3.push({ key: o3[0], data: "" }) : a2 === e5.length - 1 ? n3[n3.length - 1].data = parseData(o3[0]) : (n3[n3.length - 1].data = parseData(o3[0]), n3.push({ key: o3[1], data: "" }));
  }
  var s4 = { key: r4, data: {} };
  return n3.forEach(function(e6) {
    s4.data[e6.key] = e6.data;
  }), s4;
}
function parseData(e5) {
  return e5 && 0 !== e5.length ? 0 === e5.indexOf('"') || 0 === e5.indexOf("'") ? e5.substring(1, e5.length - 1) : -1 !== e5.indexOf(",") ? parseIntList$1(e5) : parseInt(e5, 10) : "";
}
function parseIntList$1(e5) {
  return e5.split(",").map(function(e6) {
    return parseInt(e6, 10);
  });
}
function parseIntList(e5) {
  return e5.split(",").map(function(e6) {
    return parseInt(e6, 10);
  });
}
function getAttribs(e5) {
  return getAttribList(e5).reduce(function(e6, t3) {
    return e6[mapName(t3.nodeName)] = t3.nodeValue, e6;
  }, {});
}
function getAttribList(e5) {
  for (var t3 = [], i2 = 0; i2 < e5.attributes.length; i2++) t3.push(e5.attributes[i2]);
  return t3;
}
function mapName(e5) {
  return NAME_MAP[e5.toLowerCase()] || e5;
}
function readBlock(e5, t3, i2) {
  if (i2 > t3.length - 1) return 0;
  var r4 = t3.readUInt8(i2++), n3 = t3.readInt32LE(i2);
  switch (i2 += 4, r4) {
    case 1:
      e5.info = readInfo(t3, i2);
      break;
    case 2:
      e5.common = readCommon(t3, i2);
      break;
    case 3:
      e5.pages = readPages(t3, i2, n3);
      break;
    case 4:
      e5.chars = readChars(t3, i2, n3);
      break;
    case 5:
      e5.kernings = readKernings(t3, i2, n3);
  }
  return 5 + n3;
}
function readInfo(e5, t3) {
  var i2 = {};
  i2.size = e5.readInt16LE(t3);
  var r4 = e5.readUInt8(t3 + 2);
  return i2.smooth = r4 >> 7 & 1, i2.unicode = r4 >> 6 & 1, i2.italic = r4 >> 5 & 1, i2.bold = r4 >> 4 & 1, r4 >> 3 & 1 && (i2.fixedHeight = 1), i2.charset = e5.readUInt8(t3 + 3) || "", i2.stretchH = e5.readUInt16LE(t3 + 4), i2.aa = e5.readUInt8(t3 + 6), i2.padding = [e5.readInt8(t3 + 7), e5.readInt8(t3 + 8), e5.readInt8(t3 + 9), e5.readInt8(t3 + 10)], i2.spacing = [e5.readInt8(t3 + 11), e5.readInt8(t3 + 12)], i2.outline = e5.readUInt8(t3 + 13), i2.face = readStringNT(e5, t3 + 14), i2;
}
function readCommon(e5, t3) {
  var i2 = {};
  return i2.lineHeight = e5.readUInt16LE(t3), i2.base = e5.readUInt16LE(t3 + 2), i2.scaleW = e5.readUInt16LE(t3 + 4), i2.scaleH = e5.readUInt16LE(t3 + 6), i2.pages = e5.readUInt16LE(t3 + 8), e5.readUInt8(t3 + 10), i2.packed = 0, i2.alphaChnl = e5.readUInt8(t3 + 11), i2.redChnl = e5.readUInt8(t3 + 12), i2.greenChnl = e5.readUInt8(t3 + 13), i2.blueChnl = e5.readUInt8(t3 + 14), i2;
}
function readPages(e5, t3, i2) {
  for (var r4 = [], n3 = readNameNT(e5, t3), a2 = n3.length + 1, o3 = i2 / a2, s4 = 0; s4 < o3; s4++) r4[s4] = e5.slice(t3, t3 + n3.length).toString("utf8"), t3 += a2;
  return r4;
}
function readChars(e5, t3, i2) {
  for (var r4 = [], n3 = i2 / 20, a2 = 0; a2 < n3; a2++) {
    var o3 = {}, s4 = 20 * a2;
    o3.id = e5.readUInt32LE(t3 + 0 + s4), o3.x = e5.readUInt16LE(t3 + 4 + s4), o3.y = e5.readUInt16LE(t3 + 6 + s4), o3.width = e5.readUInt16LE(t3 + 8 + s4), o3.height = e5.readUInt16LE(t3 + 10 + s4), o3.xoffset = e5.readInt16LE(t3 + 12 + s4), o3.yoffset = e5.readInt16LE(t3 + 14 + s4), o3.xadvance = e5.readInt16LE(t3 + 16 + s4), o3.page = e5.readUInt8(t3 + 18 + s4), o3.chnl = e5.readUInt8(t3 + 19 + s4), r4[a2] = o3;
  }
  return r4;
}
function readKernings(e5, t3, i2) {
  for (var r4 = [], n3 = i2 / 10, a2 = 0; a2 < n3; a2++) {
    var o3 = {}, s4 = 10 * a2;
    o3.first = e5.readUInt32LE(t3 + 0 + s4), o3.second = e5.readUInt32LE(t3 + 4 + s4), o3.amount = e5.readInt16LE(t3 + 8 + s4), r4[a2] = o3;
  }
  return r4;
}
function readNameNT(e5, t3) {
  for (var i2 = t3; i2 < e5.length && 0 !== e5[i2]; i2++) ;
  return e5.slice(t3, i2);
}
function readStringNT(e5, t3) {
  return readNameNT(e5, t3).toString("utf8");
}
function normalizeArray(e5, t3) {
  for (var i2 = 0, r4 = e5.length - 1; r4 >= 0; r4--) {
    var n3 = e5[r4];
    "." === n3 ? e5.splice(r4, 1) : ".." === n3 ? (e5.splice(r4, 1), i2++) : i2 && (e5.splice(r4, 1), i2--);
  }
  if (t3) for (; i2--; i2) e5.unshift("..");
  return e5;
}
function resolve3() {
  for (var e5 = "", t3 = false, i2 = arguments.length - 1; i2 >= -1 && !t3; i2--) {
    var r4 = i2 >= 0 ? arguments[i2] : "/";
    if ("string" != typeof r4) throw new TypeError("Arguments to path.resolve must be strings");
    r4 && (e5 = r4 + "/" + e5, t3 = "/" === r4.charAt(0));
  }
  return e5 = normalizeArray(filter(e5.split("/"), function(e6) {
    return !!e6;
  }), !t3).join("/"), (t3 ? "/" : "") + e5 || ".";
}
function normalize(e5) {
  var t3 = isAbsolute(e5), i2 = "/" === substr(e5, -1);
  return e5 = normalizeArray(filter(e5.split("/"), function(e6) {
    return !!e6;
  }), !t3).join("/"), e5 || t3 || (e5 = "."), e5 && i2 && (e5 += "/"), (t3 ? "/" : "") + e5;
}
function isAbsolute(e5) {
  return "/" === e5.charAt(0);
}
function join() {
  return normalize(filter(Array.prototype.slice.call(arguments, 0), function(e5, t3) {
    if ("string" != typeof e5) throw new TypeError("Arguments to path.join must be strings");
    return e5;
  }).join("/"));
}
function relative2(e5, t3) {
  function i2(e6) {
    for (var t4 = 0; t4 < e6.length && "" === e6[t4]; t4++) ;
    for (var i3 = e6.length - 1; i3 >= 0 && "" === e6[i3]; i3--) ;
    return t4 > i3 ? [] : e6.slice(t4, i3 - t4 + 1);
  }
  __name(i2, "i");
  e5 = resolve3(e5).substr(1), t3 = resolve3(t3).substr(1);
  for (var r4 = i2(e5.split("/")), n3 = i2(t3.split("/")), a2 = Math.min(r4.length, n3.length), o3 = a2, s4 = 0; s4 < a2; s4++) if (r4[s4] !== n3[s4]) {
    o3 = s4;
    break;
  }
  var l2 = [];
  for (s4 = o3; s4 < r4.length; s4++) l2.push("..");
  return (l2 = l2.concat(n3.slice(o3))).join("/");
}
function dirname(e5) {
  var t3 = splitPath(e5), i2 = t3[0], r4 = t3[1];
  return i2 || r4 ? (r4 && (r4 = r4.substr(0, r4.length - 1)), i2 + r4) : ".";
}
function basename(e5, t3) {
  var i2 = splitPath(e5)[2];
  return t3 && i2.substr(-1 * t3.length) === t3 && (i2 = i2.substr(0, i2.length - t3.length)), i2;
}
function extname(e5) {
  return splitPath(e5)[3];
}
function filter(e5, t3) {
  if (e5.filter) return e5.filter(t3);
  for (var i2 = [], r4 = 0; r4 < e5.length; r4++) t3(e5[r4], r4, e5) && i2.push(e5[r4]);
  return i2;
}
function e3(e5) {
  return e5 && e5.__esModule && Object.prototype.hasOwnProperty.call(e5, "default") ? e5.default : e5;
}
function b(e5) {
  let t3 = [], i2 = "";
  return e5.forEach((e6) => {
    e6.type === O.CONTENT ? i2 += e6.value : (i2.length && (t3.push(L(i2)), i2 = ""), t3.push(e6));
  }), i2.length && t3.push(L(i2)), t3;
}
function isBinary(e5) {
  if ("string" == typeof e5) return "BMF" === e5.substring(0, 3);
  const t3 = e5.slice(0, 4);
  return e5.length > 4 && t3[0] === HEADER[0] && t3[1] === HEADER[1] && t3[2] === HEADER[2];
}
function parseFont(e5, t3) {
  return isBinary(t3) ? ("string" == typeof t3 && (t3 = Buffer2.from(t3, "binary")), readBinary(t3)) : (t3 = t3.toString().trim(), /.json$/.test(e5) || "{" === t3.charAt(0) ? JSON.parse(t3) : /.xml$/.test(e5) || "<" === t3.charAt(0) ? parseXML(t3) : parseASCII(t3));
}
function parseNumbersInObject(e5) {
  for (const t3 in e5) {
    try {
      e5[t3] = parseInt(e5[t3], 10);
    } catch {
    }
    "object" == typeof e5[t3] && parseNumbersInObject(e5[t3]);
  }
  return e5;
}
async function loadBitmapFontData(e5) {
  if (isWebWorker && "string" == typeof e5) {
    const t3 = await fetch(e5), i2 = await t3.text(), r4 = convertXML(i2).font.children.reduce((e6, t4) => ({ ...e6, ...t4 }), {}), n3 = [], a2 = [], o3 = [];
    for (let e6 = 0; e6 < r4.pages.children.length; e6++) {
      const t4 = r4.pages.children[e6].page;
      n3[parseInt(t4.id, 10)] = parseNumbersInObject(t4.file);
    }
    for (let e6 = 0; e6 < r4.chars.children.length; e6++) a2.push(parseNumbersInObject(r4.chars.children[e6].char));
    for (let e6 = 0; e6 < r4.kernings.children.length; e6++) o3.push(parseNumbersInObject(r4.kernings.children[e6].kerning));
    return { info: r4.info, common: r4.common, pages: n3, chars: a2, kernings: o3 };
  }
  if ("string" == typeof e5) {
    const t3 = await fetch(e5);
    return parseFont(e5, await t3.text());
  }
  return parseFont("", e5);
}
async function processBitmapFont(e5, t3) {
  const i2 = {}, r4 = {};
  for (let e6 = 0; e6 < t3.chars.length; e6++) {
    const r5 = t3.chars[e6];
    i2[String.fromCharCode(r5.id)] = r5;
  }
  for (let e6 = 0; e6 < t3.kernings.length; e6++) {
    const i3 = String.fromCharCode(t3.kernings[e6].first);
    r4[i3] = r4[i3] || {}, r4[i3][String.fromCharCode(t3.kernings[e6].second)] = t3.kernings[e6].amount;
  }
  return { ...t3, chars: i2, kernings: r4, pages: await Promise.all(t3.pages.map(async (t4) => CharacterJimp.read(path.join(path.dirname(e5), t4)))) };
}
async function loadFont(e5) {
  let t3 = e5;
  if ("undefined" == typeof window && !isWebWorker) {
    const { existsSync: i2, promises: r4 } = await Promise.resolve().then(function() {
      return _polyfillNode_fs$1;
    });
    i2(e5) && (t3 = await r4.readFile(e5));
  }
  return processBitmapFont(e5, await loadBitmapFontData(t3));
}
function pixelmatch(e5, t3, i2, r4, n3, a2) {
  if (!isPixelData(e5) || !isPixelData(t3) || i2 && !isPixelData(i2)) throw new Error("Image data: Uint8Array, Uint8ClampedArray or Buffer expected.");
  if (e5.length !== t3.length || i2 && i2.length !== e5.length) throw new Error("Image sizes do not match.");
  if (e5.length !== r4 * n3 * 4) throw new Error("Image data size does not match width/height.");
  a2 = Object.assign({}, defaultOptions, a2);
  const o3 = r4 * n3, s4 = new Uint32Array(e5.buffer, e5.byteOffset, o3), l2 = new Uint32Array(t3.buffer, t3.byteOffset, o3);
  let u2 = true;
  for (let e6 = 0; e6 < o3; e6++) if (s4[e6] !== l2[e6]) {
    u2 = false;
    break;
  }
  if (u2) {
    if (i2 && !a2.diffMask) for (let t4 = 0; t4 < o3; t4++) drawGrayPixel(e5, 4 * t4, a2.alpha, i2);
    return 0;
  }
  const h2 = 35215 * a2.threshold * a2.threshold;
  let c3 = 0;
  for (let o4 = 0; o4 < n3; o4++) for (let s5 = 0; s5 < r4; s5++) {
    const l3 = 4 * (o4 * r4 + s5), u3 = colorDelta(e5, t3, l3, l3);
    Math.abs(u3) > h2 ? a2.includeAA || !antialiased(e5, s5, o4, r4, n3, t3) && !antialiased(t3, s5, o4, r4, n3, e5) ? (i2 && drawPixel(i2, l3, ...u3 < 0 && a2.diffColorAlt || a2.diffColor), c3++) : i2 && !a2.diffMask && drawPixel(i2, l3, ...a2.aaColor) : i2 && (a2.diffMask || drawGrayPixel(e5, l3, a2.alpha, i2));
  }
  return c3;
}
function isPixelData(e5) {
  return ArrayBuffer.isView(e5) && 1 === e5.constructor.BYTES_PER_ELEMENT;
}
function antialiased(e5, t3, i2, r4, n3, a2) {
  const o3 = Math.max(t3 - 1, 0), s4 = Math.max(i2 - 1, 0), l2 = Math.min(t3 + 1, r4 - 1), u2 = Math.min(i2 + 1, n3 - 1), h2 = 4 * (i2 * r4 + t3);
  let c3, f2, d, p2, m = t3 === o3 || t3 === l2 || i2 === s4 || i2 === u2 ? 1 : 0, _2 = 0, g = 0;
  for (let n4 = o3; n4 <= l2; n4++) for (let a3 = s4; a3 <= u2; a3++) {
    if (n4 === t3 && a3 === i2) continue;
    const o4 = colorDelta(e5, e5, h2, 4 * (a3 * r4 + n4), true);
    if (0 === o4) {
      if (m++, m > 2) return false;
    } else o4 < _2 ? (_2 = o4, c3 = n4, f2 = a3) : o4 > g && (g = o4, d = n4, p2 = a3);
  }
  return 0 !== _2 && 0 !== g && (hasManySiblings(e5, c3, f2, r4, n3) && hasManySiblings(a2, c3, f2, r4, n3) || hasManySiblings(e5, d, p2, r4, n3) && hasManySiblings(a2, d, p2, r4, n3));
}
function hasManySiblings(e5, t3, i2, r4, n3) {
  const a2 = Math.max(t3 - 1, 0), o3 = Math.max(i2 - 1, 0), s4 = Math.min(t3 + 1, r4 - 1), l2 = Math.min(i2 + 1, n3 - 1), u2 = 4 * (i2 * r4 + t3);
  let h2 = t3 === a2 || t3 === s4 || i2 === o3 || i2 === l2 ? 1 : 0;
  for (let n4 = a2; n4 <= s4; n4++) for (let a3 = o3; a3 <= l2; a3++) {
    if (n4 === t3 && a3 === i2) continue;
    const o4 = 4 * (a3 * r4 + n4);
    if (e5[u2] === e5[o4] && e5[u2 + 1] === e5[o4 + 1] && e5[u2 + 2] === e5[o4 + 2] && e5[u2 + 3] === e5[o4 + 3] && h2++, h2 > 2) return true;
  }
  return false;
}
function colorDelta(e5, t3, i2, r4, n3) {
  let a2 = e5[i2 + 0], o3 = e5[i2 + 1], s4 = e5[i2 + 2], l2 = e5[i2 + 3], u2 = t3[r4 + 0], h2 = t3[r4 + 1], c3 = t3[r4 + 2], f2 = t3[r4 + 3];
  if (l2 === f2 && a2 === u2 && o3 === h2 && s4 === c3) return 0;
  l2 < 255 && (l2 /= 255, a2 = blend(a2, l2), o3 = blend(o3, l2), s4 = blend(s4, l2)), f2 < 255 && (f2 /= 255, u2 = blend(u2, f2), h2 = blend(h2, f2), c3 = blend(c3, f2));
  const d = rgb2y(a2, o3, s4), p2 = rgb2y(u2, h2, c3), m = d - p2;
  if (n3) return m;
  const _2 = rgb2i(a2, o3, s4) - rgb2i(u2, h2, c3), g = rgb2q(a2, o3, s4) - rgb2q(u2, h2, c3), b2 = 0.5053 * m * m + 0.299 * _2 * _2 + 0.1957 * g * g;
  return d > p2 ? -b2 : b2;
}
function rgb2y(e5, t3, i2) {
  return 0.29889531 * e5 + 0.58662247 * t3 + 0.11448223 * i2;
}
function rgb2i(e5, t3, i2) {
  return 0.59597799 * e5 - 0.2741761 * t3 - 0.32180189 * i2;
}
function rgb2q(e5, t3, i2) {
  return 0.21147017 * e5 - 0.52261711 * t3 + 0.31114694 * i2;
}
function blend(e5, t3) {
  return 255 + (e5 - 255) * t3;
}
function drawPixel(e5, t3, i2, r4, n3) {
  e5[t3 + 0] = i2, e5[t3 + 1] = r4, e5[t3 + 2] = n3, e5[t3 + 3] = 255;
}
function drawGrayPixel(e5, t3, i2, r4) {
  const n3 = blend(rgb2y(e5[t3 + 0], e5[t3 + 1], e5[t3 + 2]), i2 * e5[t3 + 3] / 255);
  drawPixel(r4, t3, n3, n3, n3);
}
function diff(e5, t3, i2 = 0.1) {
  let r4 = e5.bitmap, n3 = t3.bitmap;
  if (r4.width === n3.width && r4.height === n3.height || (r4.width * r4.height > n3.width * n3.height ? r4 = methods$d.resize(clone(e5), { w: n3.width, h: n3.height }).bitmap : n3 = methods$d.resize(clone(t3), { w: r4.width, h: r4.height }).bitmap), "number" != typeof i2 || i2 < 0 || i2 > 1) throw new Error("threshold must be a number between 0 and 1");
  const a2 = new e5.constructor({ width: r4.width, height: r4.height, color: 4294967295 });
  return { percent: pixelMatch(r4.data, n3.data, a2.bitmap.data, a2.bitmap.width, a2.bitmap.height, { threshold: i2 }) / (a2.bitmap.width * a2.bitmap.height), image: a2 };
}
var commonjsGlobal, global$1, lookup, revLookup, Arr, inited, toString, isArray, INSPECT_MAX_BYTES, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE, HeaderTypes, HeaderTypes$1, BmpCompression, BmpDecoder, BmpEncoder, trimLeft, trimRight, names$1, hexNames, matchers, CSS_UNIT, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4, omggif, GifReader_1, GifWriter_1, BitmapImage$2, bitmapimage, gif$1, Gif$1, GifError$2, gifcodec, gifutil, _polyfillNode_fs, _polyfillNode_fs$1, require$$0, __defProp$3, __getOwnPropDesc2, __getOwnPropNames2, __hasOwnProp2, __defNormalProp$3, __markAsModule, __export$1, __reExport, __toCommonJS, __publicField$3, src_exports, constants_exports$1, bt709_exports$1, Y$1, x$2, y$2, conversion_exports$1, arithmetic_exports$1, refX$1, refY$1, refZ$1, refX2$1, refY2$1, refZ2$1, distance_exports$1, AbstractDistanceCalculator$1, AbstractCIE94$1, CIE94Textiles$1, CIE94GraphicArts$1, _CIEDE2000$1, CIEDE2000$1, CMetric$1, AbstractEuclidean$1, Euclidean$1, EuclideanBT709$1, EuclideanBT709NoAlpha$1, AbstractManhattan$1, Manhattan$1, ManhattanNommyde$1, ManhattanBT709$1, PNGQuant$1, palette_exports$1, AbstractPaletteQuantizer$1, Point$1, PointContainer$1, hueGroups$1, Palette$1, utils_exports$1, HueGroup$1, HueStatistics$1, _ProgressTracker$1, ProgressTracker$1, networkBiasShift$1, Neuron$1, _NeuQuant$1, NeuQuant$1, networkBiasShift2$1, NeuronFloat$1, _NeuQuantFloat$1, NeuQuantFloat$1, _ColorHistogram$1, ColorHistogram$1, RemovedColor$1, RGBQuant$1, WuColorCube$1, _WuQuant$1, WuQuant$1, image_exports$1, AbstractImageQuantizer$1, NearestColor$1, ErrorDiffusionArrayKernel$1, ErrorDiffusionArray$1, ErrorDiffusionRiemersma$1, quality_exports$1, K1$1, K2$1, setImmediateImpl, imageQ, gifframe, BitmapImage$1, GifFrame$1, hasRequiredGifutil, hasRequiredGifcodec, BitmapImage, Gif, GifError$1, GifCodec, GifFrame, GifUtil, src, encoder, encoderExports, decoder, module, JpegImage, decoderExports, encode2, decode, jpegJs, JPEG, browser$1, browserExports, PNGFilterType, PNGFilterType2, PNGColorType, PNGColorType2, UTIF, common, hasRequiredCommon, deflate$1, deflate, trees, hasRequiredTrees, adler32_1, hasRequiredAdler32, crc32_1, hasRequiredCrc32, messages, hasRequiredMessages, hasRequiredDeflate$1, strings, hasRequiredStrings, zstream, hasRequiredZstream, hasRequiredDeflate, inflate$1, inflate, inffast, hasRequiredInffast, inftrees, hasRequiredInftrees, hasRequiredInflate$1, constants, hasRequiredConstants, gzheader, hasRequiredGzheader, hasRequiredInflate, pako_1, hasRequiredPako, UTIFExports, utif, util$1, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY2, OK, isAborted, isDirty, isValid, isAsync, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv6Regex, base64Regex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z, Edge, Edge2, JimpClassSchema, BlitOptionsSchemaComplex, BlitOptionsSchema, methods$h, mulTable, shgTable, methods$g, CircleOptionsSchema, methods$f, ConvolutionMatrixSchema, ConvolutionComplexOptionsSchema, ConvolutionOptionsSchema, ConvoluteComplexOptionsSchema, ConvoluteOptionsSchema, PixelateSize, PixelateComplexOptionsSchema, PixelateOptionsSchema, HueActionSchema, SpinActionSchema, LightenActionSchema, RGBColorSchema, MixActionSchema, TintActionSchema, ShadeActionSchema, XorActionSchema, RedActionSchema, GreenActionSchema, BlueActionSchema, BrightenActionSchema, DarkenActionSchema, DesaturateActionSchema, SaturateActionSchema, GrayscaleActionSchema, ColorActionNameSchema, normalizeValue, getBounds, methods$e, lib$1, ieee754, core$1, ReadStreamTokenizer$1, AbstractTokenizer$1, lib, EndOfFileStream, StreamReader, Deferred$1, Deferred, peek_readable_1$2, AbstractTokenizer, AbstractTokenizer_1$1, peek_readable_1$1, maxBufferSize, ReadStreamTokenizer, BufferTokenizer$1, peek_readable_1, AbstractTokenizer_1, BufferTokenizer, util, supported$1, Token, strtok3, stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken, supported, minimumBytes, stream2, fileType, core, fileType$1, writeFile, Mime_1, standard, Mime, lite, mime, HorizontalAlign, HorizontalAlign2, VerticalAlign, VerticalAlign2, BlendMode, BlendMode2, names, compositeModes, jpeg$1, exif$2, hours, minutes, date$1, exif$1, date, degreeTags, dateTags, simplify$1, exifTags, hasRequiredExifTags, jpeg, exif, simplify, parser, domBufferstream, hasRequiredDomBufferstream, bufferstream, hasRequiredBufferstream, Parser, exifParser, EXIFParser, __defProp$2, __defNormalProp$2, __publicField$2, emptyBitmap, ResizeStrategy, ResizeStrategy2, operations, ResizeOptionsSchema, ScaleToFitOptionsSchema, ScaleComplexOptionsSchema, methods$d, ContainOptionsSchema, methods$c, CropOptionsSchema, AutocropComplexOptionsSchema, methods$b, CoverOptionsSchema, methods$a, DisplaceOptionsSchema, methods$9, methods$8, FisheyeOptionsSchema, methods$7, FlipOptionsSchema, methods$6, converter, Converter, anyBase_1, anyBase$1, __defProp$1, __defNormalProp$1, __publicField$1, ImagePHash, c$1, alphabet, maxHashLength, methods$5, MaskOptionsObjectSchema, MaskOptionsSchema, methods$4, PrintOptionsSchema, methods$3, RotateOptionsSchema, methods$2, ThresholdOptionsSchema, methods$1, __defProp2, __defNormalProp, __export2, __publicField, constants_exports, bt709_exports, Y, x$1, y$1, conversion_exports, arithmetic_exports, refX, refY, refZ, refX2, refY2, refZ2, distance_exports, AbstractDistanceCalculator, AbstractCIE94, CIE94Textiles, CIE94GraphicArts, _CIEDE2000, CIEDE2000, CMetric, AbstractEuclidean, Euclidean, EuclideanBT709, EuclideanBT709NoAlpha, AbstractManhattan, Manhattan, ManhattanNommyde, ManhattanBT709, PNGQuant, palette_exports, AbstractPaletteQuantizer, Point, PointContainer, hueGroups, Palette, utils_exports, HueGroup, HueStatistics, _ProgressTracker, ProgressTracker, networkBiasShift, Neuron, _NeuQuant, NeuQuant, networkBiasShift2, NeuronFloat, _NeuQuantFloat, NeuQuantFloat, _ColorHistogram, ColorHistogram, RemovedColor, RGBQuant, WuColorCube, _WuQuant, WuQuant, image_exports, AbstractImageQuantizer, NearestColor, ErrorDiffusionArrayKernel, ErrorDiffusionArray, ErrorDiffusionRiemersma, quality_exports, K1, K2, QuantizeOptionsSchema, methods, parseBmfontAscii, parseASCII, GLYPH_DESIGNER_ERROR, parseAttribs, xmlParseFromString, parseAttributes, parseFromString, NAME_MAP, browser, parseXML, HEADER$1, parseBmfontBinary, readBinary, splitPathRe, splitPath, sep, delimiter, path, substr, t, r2, n, E, s2, a, T, u, c, l, o, N, i, p, O, A, f, C, h, _, L, y, v, S, R, B, M, x, k, simpleXmlToJson_min, xmlPackage, convertXML, isWebWorker, CharacterJimp, HEADER, pixelmatch_1, defaultOptions, pixelMatch, defaultPlugins, defaultFormats, JimpMime, Jimp;
var init_browser = __esm({
  "node_modules/jimp/dist/browser/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    __name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
    __name(getAugmentedNamespace, "getAugmentedNamespace");
    "undefined" == typeof self && "object" == typeof commonjsGlobal && (commonjsGlobal.self = commonjsGlobal);
    global$1 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
    lookup = [];
    revLookup = [];
    Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array;
    inited = false;
    __name(init2, "init");
    __name(toByteArray, "toByteArray");
    __name(tripletToBase64, "tripletToBase64");
    __name(encodeChunk, "encodeChunk");
    __name(fromByteArray2, "fromByteArray");
    __name(read, "read");
    __name(write, "write");
    toString = {}.toString;
    isArray = Array.isArray || function(e5) {
      return "[object Array]" == toString.call(e5);
    };
    INSPECT_MAX_BYTES = 50;
    __name(kMaxLength, "kMaxLength");
    __name(createBuffer, "createBuffer");
    __name(Buffer2, "Buffer");
    __name(from, "from");
    __name(assertSize, "assertSize");
    __name(alloc, "alloc");
    __name(allocUnsafe, "allocUnsafe");
    __name(fromString, "fromString");
    __name(fromArrayLike, "fromArrayLike");
    __name(fromArrayBuffer, "fromArrayBuffer");
    __name(fromObject, "fromObject");
    __name(checked, "checked");
    __name(internalIsBuffer, "internalIsBuffer");
    __name(byteLength, "byteLength");
    __name(slowToString, "slowToString");
    __name(swap, "swap");
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    __name(arrayIndexOf, "arrayIndexOf");
    __name(hexWrite, "hexWrite");
    __name(utf8Write, "utf8Write");
    __name(asciiWrite, "asciiWrite");
    __name(latin1Write, "latin1Write");
    __name(base64Write, "base64Write");
    __name(ucs2Write, "ucs2Write");
    __name(base64Slice, "base64Slice");
    __name(utf8Slice, "utf8Slice");
    Buffer2.TYPED_ARRAY_SUPPORT = void 0 === global$1.TYPED_ARRAY_SUPPORT || global$1.TYPED_ARRAY_SUPPORT, kMaxLength(), Buffer2.poolSize = 8192, Buffer2._augment = function(e5) {
      return e5.__proto__ = Buffer2.prototype, e5;
    }, Buffer2.from = function(e5, t3, i2) {
      return from(null, e5, t3, i2);
    }, Buffer2.TYPED_ARRAY_SUPPORT && (Buffer2.prototype.__proto__ = Uint8Array.prototype, Buffer2.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && Buffer2[Symbol.species]), Buffer2.alloc = function(e5, t3, i2) {
      return alloc(null, e5, t3, i2);
    }, Buffer2.allocUnsafe = function(e5) {
      return allocUnsafe(null, e5);
    }, Buffer2.allocUnsafeSlow = function(e5) {
      return allocUnsafe(null, e5);
    }, Buffer2.isBuffer = isBuffer, Buffer2.compare = function(e5, t3) {
      if (!internalIsBuffer(e5) || !internalIsBuffer(t3)) throw new TypeError("Arguments must be Buffers");
      if (e5 === t3) return 0;
      for (var i2 = e5.length, r4 = t3.length, n3 = 0, a2 = Math.min(i2, r4); n3 < a2; ++n3) if (e5[n3] !== t3[n3]) {
        i2 = e5[n3], r4 = t3[n3];
        break;
      }
      return i2 < r4 ? -1 : r4 < i2 ? 1 : 0;
    }, Buffer2.isEncoding = function(e5) {
      switch (String(e5).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, Buffer2.concat = function(e5, t3) {
      if (!isArray(e5)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === e5.length) return Buffer2.alloc(0);
      var i2;
      if (void 0 === t3) for (t3 = 0, i2 = 0; i2 < e5.length; ++i2) t3 += e5[i2].length;
      var r4 = Buffer2.allocUnsafe(t3), n3 = 0;
      for (i2 = 0; i2 < e5.length; ++i2) {
        var a2 = e5[i2];
        if (!internalIsBuffer(a2)) throw new TypeError('"list" argument must be an Array of Buffers');
        a2.copy(r4, n3), n3 += a2.length;
      }
      return r4;
    }, Buffer2.byteLength = byteLength, Buffer2.prototype._isBuffer = true, Buffer2.prototype.swap16 = function() {
      var e5 = this.length;
      if (e5 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var t3 = 0; t3 < e5; t3 += 2) swap(this, t3, t3 + 1);
      return this;
    }, Buffer2.prototype.swap32 = function() {
      var e5 = this.length;
      if (e5 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var t3 = 0; t3 < e5; t3 += 4) swap(this, t3, t3 + 3), swap(this, t3 + 1, t3 + 2);
      return this;
    }, Buffer2.prototype.swap64 = function() {
      var e5 = this.length;
      if (e5 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var t3 = 0; t3 < e5; t3 += 8) swap(this, t3, t3 + 7), swap(this, t3 + 1, t3 + 6), swap(this, t3 + 2, t3 + 5), swap(this, t3 + 3, t3 + 4);
      return this;
    }, Buffer2.prototype.toString = function() {
      var e5 = 0 | this.length;
      return 0 === e5 ? "" : 0 === arguments.length ? utf8Slice(this, 0, e5) : slowToString.apply(this, arguments);
    }, Buffer2.prototype.equals = function(e5) {
      if (!internalIsBuffer(e5)) throw new TypeError("Argument must be a Buffer");
      return this === e5 || 0 === Buffer2.compare(this, e5);
    }, Buffer2.prototype.inspect = function() {
      var e5 = "", t3 = INSPECT_MAX_BYTES;
      return this.length > 0 && (e5 = this.toString("hex", 0, t3).match(/.{2}/g).join(" "), this.length > t3 && (e5 += " ... ")), "<Buffer " + e5 + ">";
    }, Buffer2.prototype.compare = function(e5, t3, i2, r4, n3) {
      if (!internalIsBuffer(e5)) throw new TypeError("Argument must be a Buffer");
      if (void 0 === t3 && (t3 = 0), void 0 === i2 && (i2 = e5 ? e5.length : 0), void 0 === r4 && (r4 = 0), void 0 === n3 && (n3 = this.length), t3 < 0 || i2 > e5.length || r4 < 0 || n3 > this.length) throw new RangeError("out of range index");
      if (r4 >= n3 && t3 >= i2) return 0;
      if (r4 >= n3) return -1;
      if (t3 >= i2) return 1;
      if (this === e5) return 0;
      for (var a2 = (n3 >>>= 0) - (r4 >>>= 0), o3 = (i2 >>>= 0) - (t3 >>>= 0), s4 = Math.min(a2, o3), l2 = this.slice(r4, n3), u2 = e5.slice(t3, i2), h2 = 0; h2 < s4; ++h2) if (l2[h2] !== u2[h2]) {
        a2 = l2[h2], o3 = u2[h2];
        break;
      }
      return a2 < o3 ? -1 : o3 < a2 ? 1 : 0;
    }, Buffer2.prototype.includes = function(e5, t3, i2) {
      return -1 !== this.indexOf(e5, t3, i2);
    }, Buffer2.prototype.indexOf = function(e5, t3, i2) {
      return bidirectionalIndexOf(this, e5, t3, i2, true);
    }, Buffer2.prototype.lastIndexOf = function(e5, t3, i2) {
      return bidirectionalIndexOf(this, e5, t3, i2, false);
    }, Buffer2.prototype.write = function(e5, t3, i2, r4) {
      if (void 0 === t3) r4 = "utf8", i2 = this.length, t3 = 0;
      else if (void 0 === i2 && "string" == typeof t3) r4 = t3, i2 = this.length, t3 = 0;
      else {
        if (!isFinite(t3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t3 |= 0, isFinite(i2) ? (i2 |= 0, void 0 === r4 && (r4 = "utf8")) : (r4 = i2, i2 = void 0);
      }
      var n3 = this.length - t3;
      if ((void 0 === i2 || i2 > n3) && (i2 = n3), e5.length > 0 && (i2 < 0 || t3 < 0) || t3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      r4 || (r4 = "utf8");
      for (var a2 = false; ; ) switch (r4) {
        case "hex":
          return hexWrite(this, e5, t3, i2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, e5, t3, i2);
        case "ascii":
          return asciiWrite(this, e5, t3, i2);
        case "latin1":
        case "binary":
          return latin1Write(this, e5, t3, i2);
        case "base64":
          return base64Write(this, e5, t3, i2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, e5, t3, i2);
        default:
          if (a2) throw new TypeError("Unknown encoding: " + r4);
          r4 = ("" + r4).toLowerCase(), a2 = true;
      }
    }, Buffer2.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    __name(asciiSlice, "asciiSlice");
    __name(latin1Slice, "latin1Slice");
    __name(hexSlice, "hexSlice");
    __name(utf16leSlice, "utf16leSlice");
    __name(checkOffset, "checkOffset");
    __name(checkInt, "checkInt");
    __name(objectWriteUInt16, "objectWriteUInt16");
    __name(objectWriteUInt32, "objectWriteUInt32");
    __name(checkIEEE754, "checkIEEE754");
    __name(writeFloat, "writeFloat");
    __name(writeDouble, "writeDouble");
    Buffer2.prototype.slice = function(e5, t3) {
      var i2, r4 = this.length;
      if ((e5 = ~~e5) < 0 ? (e5 += r4) < 0 && (e5 = 0) : e5 > r4 && (e5 = r4), (t3 = void 0 === t3 ? r4 : ~~t3) < 0 ? (t3 += r4) < 0 && (t3 = 0) : t3 > r4 && (t3 = r4), t3 < e5 && (t3 = e5), Buffer2.TYPED_ARRAY_SUPPORT) (i2 = this.subarray(e5, t3)).__proto__ = Buffer2.prototype;
      else {
        var n3 = t3 - e5;
        i2 = new Buffer2(n3, void 0);
        for (var a2 = 0; a2 < n3; ++a2) i2[a2] = this[a2 + e5];
      }
      return i2;
    }, Buffer2.prototype.readUIntLE = function(e5, t3, i2) {
      e5 |= 0, t3 |= 0, i2 || checkOffset(e5, t3, this.length);
      for (var r4 = this[e5], n3 = 1, a2 = 0; ++a2 < t3 && (n3 *= 256); ) r4 += this[e5 + a2] * n3;
      return r4;
    }, Buffer2.prototype.readUIntBE = function(e5, t3, i2) {
      e5 |= 0, t3 |= 0, i2 || checkOffset(e5, t3, this.length);
      for (var r4 = this[e5 + --t3], n3 = 1; t3 > 0 && (n3 *= 256); ) r4 += this[e5 + --t3] * n3;
      return r4;
    }, Buffer2.prototype.readUInt8 = function(e5, t3) {
      return t3 || checkOffset(e5, 1, this.length), this[e5];
    }, Buffer2.prototype.readUInt16LE = function(e5, t3) {
      return t3 || checkOffset(e5, 2, this.length), this[e5] | this[e5 + 1] << 8;
    }, Buffer2.prototype.readUInt16BE = function(e5, t3) {
      return t3 || checkOffset(e5, 2, this.length), this[e5] << 8 | this[e5 + 1];
    }, Buffer2.prototype.readUInt32LE = function(e5, t3) {
      return t3 || checkOffset(e5, 4, this.length), (this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16) + 16777216 * this[e5 + 3];
    }, Buffer2.prototype.readUInt32BE = function(e5, t3) {
      return t3 || checkOffset(e5, 4, this.length), 16777216 * this[e5] + (this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3]);
    }, Buffer2.prototype.readIntLE = function(e5, t3, i2) {
      e5 |= 0, t3 |= 0, i2 || checkOffset(e5, t3, this.length);
      for (var r4 = this[e5], n3 = 1, a2 = 0; ++a2 < t3 && (n3 *= 256); ) r4 += this[e5 + a2] * n3;
      return r4 >= (n3 *= 128) && (r4 -= Math.pow(2, 8 * t3)), r4;
    }, Buffer2.prototype.readIntBE = function(e5, t3, i2) {
      e5 |= 0, t3 |= 0, i2 || checkOffset(e5, t3, this.length);
      for (var r4 = t3, n3 = 1, a2 = this[e5 + --r4]; r4 > 0 && (n3 *= 256); ) a2 += this[e5 + --r4] * n3;
      return a2 >= (n3 *= 128) && (a2 -= Math.pow(2, 8 * t3)), a2;
    }, Buffer2.prototype.readInt8 = function(e5, t3) {
      return t3 || checkOffset(e5, 1, this.length), 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
    }, Buffer2.prototype.readInt16LE = function(e5, t3) {
      t3 || checkOffset(e5, 2, this.length);
      var i2 = this[e5] | this[e5 + 1] << 8;
      return 32768 & i2 ? 4294901760 | i2 : i2;
    }, Buffer2.prototype.readInt16BE = function(e5, t3) {
      t3 || checkOffset(e5, 2, this.length);
      var i2 = this[e5 + 1] | this[e5] << 8;
      return 32768 & i2 ? 4294901760 | i2 : i2;
    }, Buffer2.prototype.readInt32LE = function(e5, t3) {
      return t3 || checkOffset(e5, 4, this.length), this[e5] | this[e5 + 1] << 8 | this[e5 + 2] << 16 | this[e5 + 3] << 24;
    }, Buffer2.prototype.readInt32BE = function(e5, t3) {
      return t3 || checkOffset(e5, 4, this.length), this[e5] << 24 | this[e5 + 1] << 16 | this[e5 + 2] << 8 | this[e5 + 3];
    }, Buffer2.prototype.readFloatLE = function(e5, t3) {
      return t3 || checkOffset(e5, 4, this.length), read(this, e5, true, 23, 4);
    }, Buffer2.prototype.readFloatBE = function(e5, t3) {
      return t3 || checkOffset(e5, 4, this.length), read(this, e5, false, 23, 4);
    }, Buffer2.prototype.readDoubleLE = function(e5, t3) {
      return t3 || checkOffset(e5, 8, this.length), read(this, e5, true, 52, 8);
    }, Buffer2.prototype.readDoubleBE = function(e5, t3) {
      return t3 || checkOffset(e5, 8, this.length), read(this, e5, false, 52, 8);
    }, Buffer2.prototype.writeUIntLE = function(e5, t3, i2, r4) {
      (e5 = +e5, t3 |= 0, i2 |= 0, r4) || checkInt(this, e5, t3, i2, Math.pow(2, 8 * i2) - 1, 0);
      var n3 = 1, a2 = 0;
      for (this[t3] = 255 & e5; ++a2 < i2 && (n3 *= 256); ) this[t3 + a2] = e5 / n3 & 255;
      return t3 + i2;
    }, Buffer2.prototype.writeUIntBE = function(e5, t3, i2, r4) {
      (e5 = +e5, t3 |= 0, i2 |= 0, r4) || checkInt(this, e5, t3, i2, Math.pow(2, 8 * i2) - 1, 0);
      var n3 = i2 - 1, a2 = 1;
      for (this[t3 + n3] = 255 & e5; --n3 >= 0 && (a2 *= 256); ) this[t3 + n3] = e5 / a2 & 255;
      return t3 + i2;
    }, Buffer2.prototype.writeUInt8 = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 1, 255, 0), Buffer2.TYPED_ARRAY_SUPPORT || (e5 = Math.floor(e5)), this[t3] = 255 & e5, t3 + 1;
    }, Buffer2.prototype.writeUInt16LE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e5, this[t3 + 1] = e5 >>> 8) : objectWriteUInt16(this, e5, t3, true), t3 + 2;
    }, Buffer2.prototype.writeUInt16BE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 2, 65535, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = e5 >>> 8, this[t3 + 1] = 255 & e5) : objectWriteUInt16(this, e5, t3, false), t3 + 2;
    }, Buffer2.prototype.writeUInt32LE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3 + 3] = e5 >>> 24, this[t3 + 2] = e5 >>> 16, this[t3 + 1] = e5 >>> 8, this[t3] = 255 & e5) : objectWriteUInt32(this, e5, t3, true), t3 + 4;
    }, Buffer2.prototype.writeUInt32BE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 4, 4294967295, 0), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = e5 >>> 24, this[t3 + 1] = e5 >>> 16, this[t3 + 2] = e5 >>> 8, this[t3 + 3] = 255 & e5) : objectWriteUInt32(this, e5, t3, false), t3 + 4;
    }, Buffer2.prototype.writeIntLE = function(e5, t3, i2, r4) {
      if (e5 = +e5, t3 |= 0, !r4) {
        var n3 = Math.pow(2, 8 * i2 - 1);
        checkInt(this, e5, t3, i2, n3 - 1, -n3);
      }
      var a2 = 0, o3 = 1, s4 = 0;
      for (this[t3] = 255 & e5; ++a2 < i2 && (o3 *= 256); ) e5 < 0 && 0 === s4 && 0 !== this[t3 + a2 - 1] && (s4 = 1), this[t3 + a2] = (e5 / o3 | 0) - s4 & 255;
      return t3 + i2;
    }, Buffer2.prototype.writeIntBE = function(e5, t3, i2, r4) {
      if (e5 = +e5, t3 |= 0, !r4) {
        var n3 = Math.pow(2, 8 * i2 - 1);
        checkInt(this, e5, t3, i2, n3 - 1, -n3);
      }
      var a2 = i2 - 1, o3 = 1, s4 = 0;
      for (this[t3 + a2] = 255 & e5; --a2 >= 0 && (o3 *= 256); ) e5 < 0 && 0 === s4 && 0 !== this[t3 + a2 + 1] && (s4 = 1), this[t3 + a2] = (e5 / o3 | 0) - s4 & 255;
      return t3 + i2;
    }, Buffer2.prototype.writeInt8 = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 1, 127, -128), Buffer2.TYPED_ARRAY_SUPPORT || (e5 = Math.floor(e5)), e5 < 0 && (e5 = 255 + e5 + 1), this[t3] = 255 & e5, t3 + 1;
    }, Buffer2.prototype.writeInt16LE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e5, this[t3 + 1] = e5 >>> 8) : objectWriteUInt16(this, e5, t3, true), t3 + 2;
    }, Buffer2.prototype.writeInt16BE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 2, 32767, -32768), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = e5 >>> 8, this[t3 + 1] = 255 & e5) : objectWriteUInt16(this, e5, t3, false), t3 + 2;
    }, Buffer2.prototype.writeInt32LE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 4, 2147483647, -2147483648), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = 255 & e5, this[t3 + 1] = e5 >>> 8, this[t3 + 2] = e5 >>> 16, this[t3 + 3] = e5 >>> 24) : objectWriteUInt32(this, e5, t3, true), t3 + 4;
    }, Buffer2.prototype.writeInt32BE = function(e5, t3, i2) {
      return e5 = +e5, t3 |= 0, i2 || checkInt(this, e5, t3, 4, 2147483647, -2147483648), e5 < 0 && (e5 = 4294967295 + e5 + 1), Buffer2.TYPED_ARRAY_SUPPORT ? (this[t3] = e5 >>> 24, this[t3 + 1] = e5 >>> 16, this[t3 + 2] = e5 >>> 8, this[t3 + 3] = 255 & e5) : objectWriteUInt32(this, e5, t3, false), t3 + 4;
    }, Buffer2.prototype.writeFloatLE = function(e5, t3, i2) {
      return writeFloat(this, e5, t3, true, i2);
    }, Buffer2.prototype.writeFloatBE = function(e5, t3, i2) {
      return writeFloat(this, e5, t3, false, i2);
    }, Buffer2.prototype.writeDoubleLE = function(e5, t3, i2) {
      return writeDouble(this, e5, t3, true, i2);
    }, Buffer2.prototype.writeDoubleBE = function(e5, t3, i2) {
      return writeDouble(this, e5, t3, false, i2);
    }, Buffer2.prototype.copy = function(e5, t3, i2, r4) {
      if (i2 || (i2 = 0), r4 || 0 === r4 || (r4 = this.length), t3 >= e5.length && (t3 = e5.length), t3 || (t3 = 0), r4 > 0 && r4 < i2 && (r4 = i2), r4 === i2) return 0;
      if (0 === e5.length || 0 === this.length) return 0;
      if (t3 < 0) throw new RangeError("targetStart out of bounds");
      if (i2 < 0 || i2 >= this.length) throw new RangeError("sourceStart out of bounds");
      if (r4 < 0) throw new RangeError("sourceEnd out of bounds");
      r4 > this.length && (r4 = this.length), e5.length - t3 < r4 - i2 && (r4 = e5.length - t3 + i2);
      var n3, a2 = r4 - i2;
      if (this === e5 && i2 < t3 && t3 < r4) for (n3 = a2 - 1; n3 >= 0; --n3) e5[n3 + t3] = this[n3 + i2];
      else if (a2 < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) for (n3 = 0; n3 < a2; ++n3) e5[n3 + t3] = this[n3 + i2];
      else Uint8Array.prototype.set.call(e5, this.subarray(i2, i2 + a2), t3);
      return a2;
    }, Buffer2.prototype.fill = function(e5, t3, i2, r4) {
      if ("string" == typeof e5) {
        if ("string" == typeof t3 ? (r4 = t3, t3 = 0, i2 = this.length) : "string" == typeof i2 && (r4 = i2, i2 = this.length), 1 === e5.length) {
          var n3 = e5.charCodeAt(0);
          n3 < 256 && (e5 = n3);
        }
        if (void 0 !== r4 && "string" != typeof r4) throw new TypeError("encoding must be a string");
        if ("string" == typeof r4 && !Buffer2.isEncoding(r4)) throw new TypeError("Unknown encoding: " + r4);
      } else "number" == typeof e5 && (e5 &= 255);
      if (t3 < 0 || this.length < t3 || this.length < i2) throw new RangeError("Out of range index");
      if (i2 <= t3) return this;
      var a2;
      if (t3 >>>= 0, i2 = void 0 === i2 ? this.length : i2 >>> 0, e5 || (e5 = 0), "number" == typeof e5) for (a2 = t3; a2 < i2; ++a2) this[a2] = e5;
      else {
        var o3 = internalIsBuffer(e5) ? e5 : utf8ToBytes(new Buffer2(e5, r4).toString()), s4 = o3.length;
        for (a2 = 0; a2 < i2 - t3; ++a2) this[a2 + t3] = o3[a2 % s4];
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    __name(base64clean, "base64clean");
    __name(stringtrim, "stringtrim");
    __name(toHex, "toHex");
    __name(utf8ToBytes, "utf8ToBytes");
    __name(asciiToBytes, "asciiToBytes");
    __name(utf16leToBytes, "utf16leToBytes");
    __name(base64ToBytes, "base64ToBytes");
    __name(blitBuffer, "blitBuffer");
    __name(isnan, "isnan");
    __name(isBuffer, "isBuffer");
    __name(isFastBuffer, "isFastBuffer");
    __name(isSlowBuffer, "isSlowBuffer");
    !function(e5) {
      e5[e5.BITMAP_INFO_HEADER = 40] = "BITMAP_INFO_HEADER", e5[e5.BITMAP_V2_INFO_HEADER = 52] = "BITMAP_V2_INFO_HEADER", e5[e5.BITMAP_V3_INFO_HEADER = 56] = "BITMAP_V3_INFO_HEADER", e5[e5.BITMAP_V4_HEADER = 108] = "BITMAP_V4_HEADER", e5[e5.BITMAP_V5_HEADER = 124] = "BITMAP_V5_HEADER";
    }(HeaderTypes || (HeaderTypes = {}));
    HeaderTypes$1 = HeaderTypes;
    __name(maskColor, "maskColor");
    !function(e5) {
      e5[e5.NONE = 0] = "NONE", e5[e5.BI_RLE8 = 1] = "BI_RLE8", e5[e5.BI_RLE4 = 2] = "BI_RLE4", e5[e5.BI_BIT_FIELDS = 3] = "BI_BIT_FIELDS", e5[e5.BI_ALPHA_BIT_FIELDS = 6] = "BI_ALPHA_BIT_FIELDS";
    }(BmpCompression || (BmpCompression = {}));
    BmpDecoder = class {
      static {
        __name(this, "BmpDecoder");
      }
      flag;
      fileSize;
      reserved1;
      reserved2;
      offset;
      headerSize;
      width;
      height;
      planes;
      bitPP;
      compression;
      rawSize;
      hr;
      vr;
      colors;
      importantColors;
      palette;
      data;
      maskRed;
      maskGreen;
      maskBlue;
      maskAlpha;
      toRGBA;
      pos;
      bottomUp;
      buffer;
      locRed;
      locGreen;
      locBlue;
      locAlpha;
      shiftRed;
      shiftGreen;
      shiftBlue;
      shiftAlpha;
      constructor(e5, { toRGBA: t3 } = { toRGBA: false }) {
        if (this.buffer = e5, this.toRGBA = !!t3, this.pos = 0, this.bottomUp = true, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), "BM" !== this.flag) throw new Error("Invalid BMP File");
        this.locRed = this.toRGBA ? 0 : 3, this.locGreen = this.toRGBA ? 1 : 2, this.locBlue = this.toRGBA ? 2 : 1, this.locAlpha = this.toRGBA ? 3 : 0, this.parseHeader(), this.parseRGBA();
      }
      parseHeader() {
        if (this.fileSize = this.readUInt32LE(), this.reserved1 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.reserved2 = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.offset = this.readUInt32LE(), this.headerSize = this.readUInt32LE(), !(this.headerSize in HeaderTypes$1)) throw new Error(`Unsupported BMP header size ${this.headerSize}`);
        if (this.width = this.readUInt32LE(), this.height = this.readUInt32LE(), this.height = this.height > 2147483647 ? this.height - 4294967296 : this.height, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compression = this.readUInt32LE(), this.rawSize = this.readUInt32LE(), this.hr = this.readUInt32LE(), this.vr = this.readUInt32LE(), this.colors = this.readUInt32LE(), this.importantColors = this.readUInt32LE(), 32 === this.bitPP ? (this.maskAlpha = 0, this.maskRed = 16711680, this.maskGreen = 65280, this.maskBlue = 255) : 16 === this.bitPP && (this.maskAlpha = 0, this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31), (this.headerSize > HeaderTypes$1.BITMAP_INFO_HEADER || this.compression === BmpCompression.BI_BIT_FIELDS || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskRed = this.readUInt32LE(), this.maskGreen = this.readUInt32LE(), this.maskBlue = this.readUInt32LE()), (this.headerSize > HeaderTypes$1.BITMAP_V2_INFO_HEADER || this.compression === BmpCompression.BI_ALPHA_BIT_FIELDS) && (this.maskAlpha = this.readUInt32LE()), this.headerSize > HeaderTypes$1.BITMAP_V3_INFO_HEADER && (this.pos += HeaderTypes$1.BITMAP_V4_HEADER - HeaderTypes$1.BITMAP_V3_INFO_HEADER), this.headerSize > HeaderTypes$1.BITMAP_V4_HEADER && (this.pos += HeaderTypes$1.BITMAP_V5_HEADER - HeaderTypes$1.BITMAP_V4_HEADER), this.bitPP <= 8 || this.colors > 0) {
          const e6 = 0 === this.colors ? 1 << this.bitPP : this.colors;
          this.palette = new Array(e6);
          for (let t3 = 0; t3 < e6; t3++) {
            const e7 = this.buffer.readUInt8(this.pos++), i2 = this.buffer.readUInt8(this.pos++), r4 = this.buffer.readUInt8(this.pos++), n3 = this.buffer.readUInt8(this.pos++);
            this.palette[t3] = { red: r4, green: i2, blue: e7, quad: n3 };
          }
        }
        this.height < 0 && (this.height *= -1, this.bottomUp = false);
        const e5 = maskColor(this.maskRed, this.maskGreen, this.maskBlue, this.maskAlpha);
        this.shiftRed = e5.shiftRed, this.shiftGreen = e5.shiftGreen, this.shiftBlue = e5.shiftBlue, this.shiftAlpha = e5.shiftAlpha;
      }
      parseRGBA() {
        switch (this.data = Buffer2.alloc(this.width * this.height * 4), this.bitPP) {
          case 1:
            this.bit1();
            break;
          case 4:
            this.bit4();
            break;
          case 8:
            this.bit8();
            break;
          case 16:
            this.bit16();
            break;
          case 24:
            this.bit24();
            break;
          default:
            this.bit32();
        }
      }
      bit1() {
        const e5 = Math.ceil(this.width / 8), t3 = e5 % 4, i2 = 0 !== t3 ? 4 - t3 : 0;
        this.scanImage(i2, e5, (e6, t4) => {
          const i3 = this.buffer.readUInt8(this.pos++), r4 = t4 * this.width * 4 + 8 * e6 * 4;
          for (let t5 = 0; t5 < 8 && 8 * e6 + t5 < this.width; t5++) {
            const e7 = this.palette[i3 >> 7 - t5 & 1];
            this.data[r4 + t5 * this.locAlpha] = 0, this.data[r4 + 4 * t5 + this.locBlue] = e7.blue, this.data[r4 + 4 * t5 + this.locGreen] = e7.green, this.data[r4 + 4 * t5 + this.locRed] = e7.red;
          }
        });
      }
      bit4() {
        if (this.compression === BmpCompression.BI_RLE4) {
          this.data.fill(0);
          let e5 = false, t3 = this.bottomUp ? this.height - 1 : 0, i2 = 0;
          for (; i2 < this.data.length; ) {
            const r4 = this.buffer.readUInt8(this.pos++), n3 = this.buffer.readUInt8(this.pos++);
            if (0 === r4) {
              if (0 === n3) {
                t3 += this.bottomUp ? -1 : 1, i2 = t3 * this.width * 4, e5 = false;
                continue;
              }
              if (1 === n3) break;
              if (2 === n3) {
                const e6 = this.buffer.readUInt8(this.pos++), r5 = this.buffer.readUInt8(this.pos++);
                t3 += this.bottomUp ? -r5 : r5, i2 += r5 * this.width * 4 + 4 * e6;
              } else {
                let t4 = this.buffer.readUInt8(this.pos++);
                for (let r5 = 0; r5 < n3; r5++) i2 = this.setPixelData(i2, e5 ? 15 & t4 : (240 & t4) >> 4), 1 & r5 && r5 + 1 < n3 && (t4 = this.buffer.readUInt8(this.pos++)), e5 = !e5;
                1 == (n3 + 1 >> 1 & 1) && this.pos++;
              }
            } else for (let t4 = 0; t4 < r4; t4++) i2 = this.setPixelData(i2, e5 ? 15 & n3 : (240 & n3) >> 4), e5 = !e5;
          }
        } else {
          const e5 = Math.ceil(this.width / 2), t3 = e5 % 4, i2 = 0 !== t3 ? 4 - t3 : 0;
          this.scanImage(i2, e5, (e6, t4) => {
            const i3 = this.buffer.readUInt8(this.pos++), r4 = t4 * this.width * 4 + 2 * e6 * 4, n3 = i3 >> 4;
            let a2 = this.palette[n3];
            if (this.data[r4] = 0, this.data[r4 + 1] = a2.blue, this.data[r4 + 2] = a2.green, this.data[r4 + 3] = a2.red, 2 * e6 + 1 >= this.width) return false;
            const o3 = 15 & i3;
            a2 = this.palette[o3], this.data[r4 + 4] = 0, this.data[r4 + 4 + 1] = a2.blue, this.data[r4 + 4 + 2] = a2.green, this.data[r4 + 4 + 3] = a2.red;
          });
        }
      }
      bit8() {
        if (this.compression === BmpCompression.BI_RLE8) {
          this.data.fill(0);
          let e5 = this.bottomUp ? this.height - 1 : 0, t3 = 0;
          for (; t3 < this.data.length; ) {
            const i2 = this.buffer.readUInt8(this.pos++), r4 = this.buffer.readUInt8(this.pos++);
            if (0 === i2) {
              if (0 === r4) {
                e5 += this.bottomUp ? -1 : 1, t3 = e5 * this.width * 4;
                continue;
              }
              if (1 === r4) break;
              if (2 === r4) {
                const i3 = this.buffer.readUInt8(this.pos++), r5 = this.buffer.readUInt8(this.pos++);
                e5 += this.bottomUp ? -r5 : r5, t3 += r5 * this.width * 4 + 4 * i3;
              } else {
                for (let e6 = 0; e6 < r4; e6++) {
                  const e7 = this.buffer.readUInt8(this.pos++);
                  t3 = this.setPixelData(t3, e7);
                }
                true & r4 && this.pos++;
              }
            } else for (let e6 = 0; e6 < i2; e6++) t3 = this.setPixelData(t3, r4);
          }
        } else {
          const e5 = this.width % 4, t3 = 0 !== e5 ? 4 - e5 : 0;
          this.scanImage(t3, this.width, (e6, t4) => {
            const i2 = this.buffer.readUInt8(this.pos++), r4 = t4 * this.width * 4 + 4 * e6;
            if (i2 < this.palette.length) {
              const e7 = this.palette[i2];
              this.data[r4] = 0, this.data[r4 + 1] = e7.blue, this.data[r4 + 2] = e7.green, this.data[r4 + 3] = e7.red;
            } else this.data[r4] = 0, this.data[r4 + 1] = 255, this.data[r4 + 2] = 255, this.data[r4 + 3] = 255;
          });
        }
      }
      bit16() {
        const e5 = this.width % 2 * 2;
        this.scanImage(e5, this.width, (e6, t3) => {
          const i2 = t3 * this.width * 4 + 4 * e6, r4 = this.buffer.readUInt16LE(this.pos);
          this.pos += 2, this.data[i2 + this.locRed] = this.shiftRed(r4), this.data[i2 + this.locGreen] = this.shiftGreen(r4), this.data[i2 + this.locBlue] = this.shiftBlue(r4), this.data[i2 + this.locAlpha] = this.shiftAlpha(r4);
        });
      }
      bit24() {
        const e5 = this.width % 4;
        this.scanImage(e5, this.width, (e6, t3) => {
          const i2 = t3 * this.width * 4 + 4 * e6, r4 = this.buffer.readUInt8(this.pos++), n3 = this.buffer.readUInt8(this.pos++), a2 = this.buffer.readUInt8(this.pos++);
          this.data[i2 + this.locRed] = a2, this.data[i2 + this.locGreen] = n3, this.data[i2 + this.locBlue] = r4, this.data[i2 + this.locAlpha] = 0;
        });
      }
      bit32() {
        this.scanImage(0, this.width, (e5, t3) => {
          const i2 = t3 * this.width * 4 + 4 * e5, r4 = this.readUInt32LE();
          this.data[i2 + this.locRed] = this.shiftRed(r4), this.data[i2 + this.locGreen] = this.shiftGreen(r4), this.data[i2 + this.locBlue] = this.shiftBlue(r4), this.data[i2 + this.locAlpha] = this.shiftAlpha(r4);
        });
      }
      scanImage(e5 = 0, t3 = this.width, i2) {
        for (let r4 = this.height - 1; r4 >= 0; r4--) {
          const n3 = this.bottomUp ? r4 : this.height - 1 - r4;
          for (let e6 = 0; e6 < t3; e6++) {
            if (false === i2.call(this, e6, n3)) return;
          }
          this.pos += e5;
        }
      }
      readUInt32LE() {
        const e5 = this.buffer.readUInt32LE(this.pos);
        return this.pos += 4, e5;
      }
      setPixelData(e5, t3) {
        const { blue: i2, green: r4, red: n3 } = this.palette[t3];
        return this.data[e5 + this.locAlpha] = 0, this.data[e5 + 1 + this.locBlue] = i2, this.data[e5 + 2 + this.locGreen] = r4, this.data[e5 + 3 + this.locRed] = n3, e5 + 4;
      }
    };
    __name(createInteger, "createInteger");
    __name(createColor, "createColor");
    BmpEncoder = class {
      static {
        __name(this, "BmpEncoder");
      }
      fileSize;
      reserved1;
      reserved2;
      offset;
      width;
      flag;
      height;
      planes;
      bitPP;
      compress;
      hr;
      vr;
      colors;
      importantColors;
      rawSize;
      headerSize;
      data;
      palette;
      extraBytes;
      buffer;
      bytesInColor;
      pos;
      constructor(e5) {
        switch (this.buffer = e5.data, this.width = e5.width, this.height = e5.height, this.headerSize = HeaderTypes$1.BITMAP_INFO_HEADER, this.flag = "BM", this.bitPP = e5.bitPP || 24, this.offset = 54, this.reserved1 = e5.reserved1 || 0, this.reserved2 = e5.reserved2 || 0, this.planes = 1, this.compress = 0, this.hr = e5.hr || 0, this.vr = e5.vr || 0, this.importantColors = e5.importantColors || 0, this.colors = Math.min(2 ** (this.bitPP - 1 || 1), e5.colors || 1 / 0), this.palette = e5.palette || [], this.colors && this.bitPP < 16 ? this.offset += 4 * this.colors : this.colors = 0, this.bitPP) {
          case 32:
            this.bytesInColor = 4;
            break;
          case 16:
            this.bytesInColor = 2;
            break;
          case 8:
            this.bytesInColor = 1;
            break;
          case 4:
            this.bytesInColor = 0.5;
            break;
          case 1:
            this.bytesInColor = 1 / 8;
            break;
          default:
            this.bytesInColor = 3, this.bitPP = 24;
        }
        const t3 = this.width * this.bitPP / 32, i2 = Math.ceil(t3);
        this.extraBytes = 4 * (i2 - t3), this.rawSize = this.height * i2 * 4 + 2, this.fileSize = this.rawSize + this.offset, this.data = Buffer2.alloc(this.fileSize, 1), this.pos = 0, this.encode();
      }
      encode() {
        switch (this.pos = 0, this.writeHeader(), this.bitPP) {
          case 32:
            this.bit32();
            break;
          case 16:
            this.bit16();
            break;
          case 8:
            this.bit8();
            break;
          case 4:
            this.bit4();
            break;
          case 1:
            this.bit1();
            break;
          default:
            this.bit24();
        }
      }
      writeHeader() {
        this.data.write(this.flag, this.pos, 2), this.pos += 2, this.writeUInt32LE(this.fileSize), this.writeUInt32LE(this.reserved1 << 16 | this.reserved2), this.writeUInt32LE(this.offset), this.writeUInt32LE(this.headerSize), this.writeUInt32LE(this.width), this.writeUInt32LE(this.height), this.data.writeUInt16LE(this.planes, this.pos), this.pos += 2, this.data.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, this.writeUInt32LE(this.compress), this.writeUInt32LE(this.rawSize), this.writeUInt32LE(this.hr), this.writeUInt32LE(this.vr), this.writeUInt32LE(this.colors), this.writeUInt32LE(this.importantColors);
      }
      bit1() {
        this.palette.length && 2 === this.colors ? this.initColors(1) : (this.writeUInt32LE(16777215), this.writeUInt32LE(0)), this.pos += 1;
        let e5 = [];
        this.writeImage((t3, i2, r4) => {
          let n3 = i2;
          n3++;
          const a2 = this.buffer[n3++], o3 = this.buffer[n3++], s4 = 0.2126 * this.buffer[n3++] + 0.7152 * o3 + 0.0722 * a2;
          return e5.push(s4 > 127 ? 0 : 1), (r4 + 1) % 8 == 0 ? (this.data[t3 - 1] = createInteger(e5), e5 = []) : r4 === this.width - 1 && e5.length > 0 && (this.data[t3 - 1] = createInteger(e5) << 4, e5 = []), n3;
        });
      }
      bit4() {
        const e5 = this.initColors(4);
        let t3 = [];
        this.writeImage((i2, r4, n3) => {
          let a2 = r4;
          const o3 = createColor({ quad: this.buffer[a2++], blue: this.buffer[a2++], green: this.buffer[a2++], red: this.buffer[a2++] }), s4 = e5.findIndex((e6) => e6 === o3);
          return -1 !== s4 ? t3.push(s4) : t3.push(0), (n3 + 1) % 2 == 0 && (this.data[i2] = t3[0] << 4 | t3[1], t3 = []), a2;
        });
      }
      bit8() {
        const e5 = this.initColors(8);
        this.writeImage((t3, i2) => {
          let r4 = i2;
          const n3 = createColor({ quad: this.buffer[r4++], blue: this.buffer[r4++], green: this.buffer[r4++], red: this.buffer[r4++] }), a2 = e5.findIndex((e6) => e6 === n3);
          return this.data[t3] = -1 !== a2 ? a2 : 0, r4;
        });
      }
      bit16() {
        this.writeImage((e5, t3) => {
          let i2 = t3 + 1;
          const r4 = this.buffer[i2++] / 8, n3 = this.buffer[i2++] / 8, a2 = this.buffer[i2++] / 8 << 10 | n3 << 5 | r4;
          return this.data[e5] = 255 & a2, this.data[e5 + 1] = (65280 & a2) >> 8, i2;
        });
      }
      bit24() {
        this.writeImage((e5, t3) => {
          let i2 = t3 + 1;
          return this.data[e5] = this.buffer[i2++], this.data[e5 + 1] = this.buffer[i2++], this.data[e5 + 2] = this.buffer[i2++], i2;
        });
      }
      bit32() {
        this.writeImage((e5, t3) => {
          let i2 = t3;
          return this.data[e5 + 3] = this.buffer[i2++], this.data[e5] = this.buffer[i2++], this.data[e5 + 1] = this.buffer[i2++], this.data[e5 + 2] = this.buffer[i2++], i2;
        });
      }
      writeImage(e5) {
        const t3 = this.extraBytes + this.width * this.bytesInColor;
        let i2 = 0;
        for (let r4 = 0; r4 < this.height; r4++) for (let n3 = 0; n3 < this.width; n3++) {
          const a2 = Math.floor(this.pos + (this.height - 1 - r4) * t3 + n3 * this.bytesInColor);
          i2 = e5.call(this, a2, i2, n3, r4);
        }
      }
      initColors(e5) {
        const t3 = [];
        if (!this.palette.length) throw new Error(`To encode ${e5}-bit BMPs a pallette is needed. Please choose up to ${this.colors} colors. Colors must be 32-bit integers.`);
        for (let e6 = 0; e6 < this.colors; e6++) {
          const i2 = createColor(this.palette[e6]);
          this.writeUInt32LE(i2), t3.push(i2);
        }
        return t3;
      }
      writeUInt32LE(e5) {
        this.data.writeUInt32LE(e5, this.pos), this.pos += 4;
      }
    };
    __name(decode$2, "decode$2");
    __name(encode$2, "encode$2");
    __name(_typeof, "_typeof");
    trimLeft = /^\s+/;
    trimRight = /\s+$/;
    __name(tinycolor, "tinycolor");
    __name(inputToRGB, "inputToRGB");
    __name(rgbToRgb, "rgbToRgb");
    __name(rgbToHsl, "rgbToHsl");
    __name(hslToRgb, "hslToRgb");
    __name(rgbToHsv, "rgbToHsv");
    __name(hsvToRgb, "hsvToRgb");
    __name(rgbToHex, "rgbToHex");
    __name(rgbaToHex, "rgbaToHex");
    __name(rgbaToArgbHex, "rgbaToArgbHex");
    __name(_desaturate, "_desaturate");
    __name(_saturate, "_saturate");
    __name(_greyscale, "_greyscale");
    __name(_lighten, "_lighten");
    __name(_brighten, "_brighten");
    __name(_darken, "_darken");
    __name(_spin, "_spin");
    __name(_complement, "_complement");
    __name(polyad, "polyad");
    __name(_splitcomplement, "_splitcomplement");
    __name(_analogous, "_analogous");
    __name(_monochromatic, "_monochromatic");
    tinycolor.prototype = { isDark: /* @__PURE__ */ __name(function() {
      return this.getBrightness() < 128;
    }, "isDark"), isLight: /* @__PURE__ */ __name(function() {
      return !this.isDark();
    }, "isLight"), isValid: /* @__PURE__ */ __name(function() {
      return this._ok;
    }, "isValid"), getOriginalInput: /* @__PURE__ */ __name(function() {
      return this._originalInput;
    }, "getOriginalInput"), getFormat: /* @__PURE__ */ __name(function() {
      return this._format;
    }, "getFormat"), getAlpha: /* @__PURE__ */ __name(function() {
      return this._a;
    }, "getAlpha"), getBrightness: /* @__PURE__ */ __name(function() {
      var e5 = this.toRgb();
      return (299 * e5.r + 587 * e5.g + 114 * e5.b) / 1e3;
    }, "getBrightness"), getLuminance: /* @__PURE__ */ __name(function() {
      var e5, t3, i2, r4 = this.toRgb();
      return e5 = r4.r / 255, t3 = r4.g / 255, i2 = r4.b / 255, 0.2126 * (e5 <= 0.03928 ? e5 / 12.92 : Math.pow((e5 + 0.055) / 1.055, 2.4)) + 0.7152 * (t3 <= 0.03928 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4)) + 0.0722 * (i2 <= 0.03928 ? i2 / 12.92 : Math.pow((i2 + 0.055) / 1.055, 2.4));
    }, "getLuminance"), setAlpha: /* @__PURE__ */ __name(function(e5) {
      return this._a = boundAlpha(e5), this._roundA = Math.round(100 * this._a) / 100, this;
    }, "setAlpha"), toHsv: /* @__PURE__ */ __name(function() {
      var e5 = rgbToHsv(this._r, this._g, this._b);
      return { h: 360 * e5.h, s: e5.s, v: e5.v, a: this._a };
    }, "toHsv"), toHsvString: /* @__PURE__ */ __name(function() {
      var e5 = rgbToHsv(this._r, this._g, this._b), t3 = Math.round(360 * e5.h), i2 = Math.round(100 * e5.s), r4 = Math.round(100 * e5.v);
      return 1 == this._a ? "hsv(" + t3 + ", " + i2 + "%, " + r4 + "%)" : "hsva(" + t3 + ", " + i2 + "%, " + r4 + "%, " + this._roundA + ")";
    }, "toHsvString"), toHsl: /* @__PURE__ */ __name(function() {
      var e5 = rgbToHsl(this._r, this._g, this._b);
      return { h: 360 * e5.h, s: e5.s, l: e5.l, a: this._a };
    }, "toHsl"), toHslString: /* @__PURE__ */ __name(function() {
      var e5 = rgbToHsl(this._r, this._g, this._b), t3 = Math.round(360 * e5.h), i2 = Math.round(100 * e5.s), r4 = Math.round(100 * e5.l);
      return 1 == this._a ? "hsl(" + t3 + ", " + i2 + "%, " + r4 + "%)" : "hsla(" + t3 + ", " + i2 + "%, " + r4 + "%, " + this._roundA + ")";
    }, "toHslString"), toHex: /* @__PURE__ */ __name(function(e5) {
      return rgbToHex(this._r, this._g, this._b, e5);
    }, "toHex"), toHexString: /* @__PURE__ */ __name(function(e5) {
      return "#" + this.toHex(e5);
    }, "toHexString"), toHex8: /* @__PURE__ */ __name(function(e5) {
      return rgbaToHex(this._r, this._g, this._b, this._a, e5);
    }, "toHex8"), toHex8String: /* @__PURE__ */ __name(function(e5) {
      return "#" + this.toHex8(e5);
    }, "toHex8String"), toRgb: /* @__PURE__ */ __name(function() {
      return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
    }, "toRgb"), toRgbString: /* @__PURE__ */ __name(function() {
      return 1 == this._a ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
    }, "toRgbString"), toPercentageRgb: /* @__PURE__ */ __name(function() {
      return { r: Math.round(100 * bound01(this._r, 255)) + "%", g: Math.round(100 * bound01(this._g, 255)) + "%", b: Math.round(100 * bound01(this._b, 255)) + "%", a: this._a };
    }, "toPercentageRgb"), toPercentageRgbString: /* @__PURE__ */ __name(function() {
      return 1 == this._a ? "rgb(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * bound01(this._r, 255)) + "%, " + Math.round(100 * bound01(this._g, 255)) + "%, " + Math.round(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
    }, "toPercentageRgbString"), toName: /* @__PURE__ */ __name(function() {
      return 0 === this._a ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, true)] || false);
    }, "toName"), toFilter: /* @__PURE__ */ __name(function(e5) {
      var t3 = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), i2 = t3, r4 = this._gradientType ? "GradientType = 1, " : "";
      if (e5) {
        var n3 = tinycolor(e5);
        i2 = "#" + rgbaToArgbHex(n3._r, n3._g, n3._b, n3._a);
      }
      return "progid:DXImageTransform.Microsoft.gradient(" + r4 + "startColorstr=" + t3 + ",endColorstr=" + i2 + ")";
    }, "toFilter"), toString: /* @__PURE__ */ __name(function(e5) {
      var t3 = !!e5;
      e5 = e5 || this._format;
      var i2 = false, r4 = this._a < 1 && this._a >= 0;
      return t3 || !r4 || "hex" !== e5 && "hex6" !== e5 && "hex3" !== e5 && "hex4" !== e5 && "hex8" !== e5 && "name" !== e5 ? ("rgb" === e5 && (i2 = this.toRgbString()), "prgb" === e5 && (i2 = this.toPercentageRgbString()), "hex" !== e5 && "hex6" !== e5 || (i2 = this.toHexString()), "hex3" === e5 && (i2 = this.toHexString(true)), "hex4" === e5 && (i2 = this.toHex8String(true)), "hex8" === e5 && (i2 = this.toHex8String()), "name" === e5 && (i2 = this.toName()), "hsl" === e5 && (i2 = this.toHslString()), "hsv" === e5 && (i2 = this.toHsvString()), i2 || this.toHexString()) : "name" === e5 && 0 === this._a ? this.toName() : this.toRgbString();
    }, "toString"), clone: /* @__PURE__ */ __name(function() {
      return tinycolor(this.toString());
    }, "clone"), _applyModification: /* @__PURE__ */ __name(function(e5, t3) {
      var i2 = e5.apply(null, [this].concat([].slice.call(t3)));
      return this._r = i2._r, this._g = i2._g, this._b = i2._b, this.setAlpha(i2._a), this;
    }, "_applyModification"), lighten: /* @__PURE__ */ __name(function() {
      return this._applyModification(_lighten, arguments);
    }, "lighten"), brighten: /* @__PURE__ */ __name(function() {
      return this._applyModification(_brighten, arguments);
    }, "brighten"), darken: /* @__PURE__ */ __name(function() {
      return this._applyModification(_darken, arguments);
    }, "darken"), desaturate: /* @__PURE__ */ __name(function() {
      return this._applyModification(_desaturate, arguments);
    }, "desaturate"), saturate: /* @__PURE__ */ __name(function() {
      return this._applyModification(_saturate, arguments);
    }, "saturate"), greyscale: /* @__PURE__ */ __name(function() {
      return this._applyModification(_greyscale, arguments);
    }, "greyscale"), spin: /* @__PURE__ */ __name(function() {
      return this._applyModification(_spin, arguments);
    }, "spin"), _applyCombination: /* @__PURE__ */ __name(function(e5, t3) {
      return e5.apply(null, [this].concat([].slice.call(t3)));
    }, "_applyCombination"), analogous: /* @__PURE__ */ __name(function() {
      return this._applyCombination(_analogous, arguments);
    }, "analogous"), complement: /* @__PURE__ */ __name(function() {
      return this._applyCombination(_complement, arguments);
    }, "complement"), monochromatic: /* @__PURE__ */ __name(function() {
      return this._applyCombination(_monochromatic, arguments);
    }, "monochromatic"), splitcomplement: /* @__PURE__ */ __name(function() {
      return this._applyCombination(_splitcomplement, arguments);
    }, "splitcomplement"), triad: /* @__PURE__ */ __name(function() {
      return this._applyCombination(polyad, [3]);
    }, "triad"), tetrad: /* @__PURE__ */ __name(function() {
      return this._applyCombination(polyad, [4]);
    }, "tetrad") }, tinycolor.fromRatio = function(e5, t3) {
      if ("object" == _typeof(e5)) {
        var i2 = {};
        for (var r4 in e5) e5.hasOwnProperty(r4) && (i2[r4] = "a" === r4 ? e5[r4] : convertToPercentage(e5[r4]));
        e5 = i2;
      }
      return tinycolor(e5, t3);
    }, tinycolor.equals = function(e5, t3) {
      return !(!e5 || !t3) && tinycolor(e5).toRgbString() == tinycolor(t3).toRgbString();
    }, tinycolor.random = function() {
      return tinycolor.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
    }, tinycolor.mix = function(e5, t3, i2) {
      i2 = 0 === i2 ? 0 : i2 || 50;
      var r4 = tinycolor(e5).toRgb(), n3 = tinycolor(t3).toRgb(), a2 = i2 / 100;
      return tinycolor({ r: (n3.r - r4.r) * a2 + r4.r, g: (n3.g - r4.g) * a2 + r4.g, b: (n3.b - r4.b) * a2 + r4.b, a: (n3.a - r4.a) * a2 + r4.a });
    }, tinycolor.readability = function(e5, t3) {
      var i2 = tinycolor(e5), r4 = tinycolor(t3);
      return (Math.max(i2.getLuminance(), r4.getLuminance()) + 0.05) / (Math.min(i2.getLuminance(), r4.getLuminance()) + 0.05);
    }, tinycolor.isReadable = function(e5, t3, i2) {
      var r4, n3, a2 = tinycolor.readability(e5, t3);
      switch (n3 = false, (r4 = validateWCAG2Parms(i2)).level + r4.size) {
        case "AAsmall":
        case "AAAlarge":
          n3 = a2 >= 4.5;
          break;
        case "AAlarge":
          n3 = a2 >= 3;
          break;
        case "AAAsmall":
          n3 = a2 >= 7;
      }
      return n3;
    }, tinycolor.mostReadable = function(e5, t3, i2) {
      var r4, n3, a2, o3, s4 = null, l2 = 0;
      n3 = (i2 = i2 || {}).includeFallbackColors, a2 = i2.level, o3 = i2.size;
      for (var u2 = 0; u2 < t3.length; u2++) (r4 = tinycolor.readability(e5, t3[u2])) > l2 && (l2 = r4, s4 = tinycolor(t3[u2]));
      return tinycolor.isReadable(e5, s4, { level: a2, size: o3 }) || !n3 ? s4 : (i2.includeFallbackColors = false, tinycolor.mostReadable(e5, ["#fff", "#000"], i2));
    };
    names$1 = tinycolor.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" };
    hexNames = tinycolor.hexNames = flip(names$1);
    __name(flip, "flip");
    __name(boundAlpha, "boundAlpha");
    __name(bound01, "bound01");
    __name(clamp01, "clamp01");
    __name(parseIntFromHex, "parseIntFromHex");
    __name(isOnePointZero, "isOnePointZero");
    __name(isPercentage, "isPercentage");
    __name(pad2, "pad2");
    __name(convertToPercentage, "convertToPercentage");
    __name(convertDecimalToHex, "convertDecimalToHex");
    __name(convertHexToDecimal, "convertHexToDecimal");
    matchers = (CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)", PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", { CSS_UNIT: new RegExp(CSS_UNIT), rgb: new RegExp("rgb" + PERMISSIVE_MATCH3), rgba: new RegExp("rgba" + PERMISSIVE_MATCH4), hsl: new RegExp("hsl" + PERMISSIVE_MATCH3), hsla: new RegExp("hsla" + PERMISSIVE_MATCH4), hsv: new RegExp("hsv" + PERMISSIVE_MATCH3), hsva: new RegExp("hsva" + PERMISSIVE_MATCH4), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ });
    __name(isValidCSSUnit, "isValidCSSUnit");
    __name(stringInputToObject, "stringInputToObject");
    __name(validateWCAG2Parms, "validateWCAG2Parms");
    __name(clone, "clone");
    __name(scan, "scan");
    __name(scanIterator, "scanIterator");
    __name(intToRGBA$1, "intToRGBA$1");
    __name(rgbaToInt, "rgbaToInt");
    __name(colorDiff, "colorDiff");
    __name(limit255, "limit255");
    __name(cssColorToHex, "cssColorToHex");
    __name(encode$1, "encode$1");
    __name(decode$1, "decode$1");
    __name(msBmp, "msBmp");
    __name(bmp, "bmp");
    omggif = {};
    __name(GifWriter, "GifWriter");
    __name(GifWriterOutputLZWCodeStream, "GifWriterOutputLZWCodeStream");
    __name(GifReader, "GifReader");
    __name(GifReaderLZWOutputIndexStream, "GifReaderLZWOutputIndexStream");
    try {
      GifWriter_1 = omggif.GifWriter = GifWriter, GifReader_1 = omggif.GifReader = GifReader;
    } catch (e5) {
    }
    BitmapImage$2 = class e {
      static {
        __name(this, "e");
      }
      constructor(...t3) {
        if (0 === t3.length) throw new Error("constructor requires parameters");
        const i2 = t3[0];
        if (null !== i2 && "object" == typeof i2) if (i2 instanceof e) {
          const e5 = i2.bitmap;
          this.bitmap = { width: e5.width, height: e5.height, data: new Buffer2(e5.width * e5.height * 4) }, e5.data.copy(this.bitmap.data);
        } else {
          if (!(i2.width && i2.height && i2.data)) throw new Error("unrecognized constructor parameters");
          this.bitmap = i2;
        }
        else {
          if ("number" != typeof i2 || "number" != typeof t3[1]) throw new Error("unrecognized constructor parameters");
          {
            const e5 = i2, r4 = t3[1], n3 = t3[2];
            this.bitmap = { width: e5, height: r4 }, Buffer2.isBuffer(n3) ? this.bitmap.data = n3 : (this.bitmap.data = new Buffer2(e5 * r4 * 4), "number" == typeof n3 && this.fillRGBA(n3));
          }
        }
      }
      blit(e5, t3, i2, r4, n3, a2, o3) {
        if (r4 + a2 > this.bitmap.width) throw new Error("copy exceeds width of source bitmap");
        if (t3 + a2 > e5.bitmap.width) throw new Error("copy exceeds width of target bitmap");
        if (n3 + o3 > this.bitmap.height) throw new Error("copy exceeds height of source bitmap");
        if (i2 + o3 > e5.bitmap.height) throw new Erro("copy exceeds height of target bitmap");
        const s4 = this.bitmap.data, l2 = e5.bitmap.data, u2 = 4 * this.bitmap.width, h2 = 4 * e5.bitmap.width, c3 = 4 * a2;
        let f2 = n3 * u2 + 4 * r4, d = i2 * h2 + 4 * t3;
        for (; --o3 >= 0; ) s4.copy(l2, d, f2, f2 + c3), f2 += u2, d += h2;
        return this;
      }
      fillRGBA(e5) {
        const t3 = this.bitmap.data, i2 = 4 * this.bitmap.height;
        let r4 = 0;
        for (; r4 < i2; ) t3.writeUInt32BE(e5, r4), r4 += 4;
        for (; r4 < t3.length; ) t3.copy(t3, r4, 0, i2), r4 += i2;
        return this;
      }
      getRGBA(e5, t3) {
        const i2 = 4 * (t3 * this.bitmap.width + e5);
        return this.bitmap.data.readUInt32BE(i2);
      }
      getRGBASet() {
        const e5 = /* @__PURE__ */ new Set(), t3 = this.bitmap.data;
        for (let i2 = 0; i2 < t3.length; i2 += 4) e5.add(t3.readUInt32BE(i2, true));
        return e5;
      }
      greyscale() {
        const e5 = this.bitmap.data;
        return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (t3, i2, r4) => {
          const n3 = Math.round(0.299 * e5[r4] + 0.587 * e5[r4 + 1] + 0.114 * e5[r4 + 2]);
          e5[r4] = n3, e5[r4 + 1] = n3, e5[r4 + 2] = n3;
        }), this;
      }
      reframe(t3, i2, r4, n3, a2) {
        const o3 = t3 < 0 ? 0 : t3, s4 = i2 < 0 ? 0 : i2, l2 = r4 + o3 > this.bitmap.width ? this.bitmap.width - o3 : r4, u2 = n3 + s4 > this.bitmap.height ? this.bitmap.height - s4 : n3, h2 = t3 < 0 ? -t3 : 0, c3 = i2 < 0 ? -i2 : 0;
        let f2;
        if (void 0 === a2) {
          if (o3 !== t3 || s4 != i2 || l2 !== r4 || u2 !== n3) throw new GifError("fillRGBA required for this reframing");
          f2 = new e(r4, n3);
        } else f2 = new e(r4, n3, a2);
        return this.blit(f2, h2, c3, o3, s4, l2, u2), this.bitmap = f2.bitmap, this;
      }
      scale(e5) {
        if (1 === e5) return;
        if (!Number.isInteger(e5) || e5 < 1) throw new Error("the scale must be an integer >= 1");
        const t3 = this.bitmap.width, i2 = this.bitmap.height, r4 = t3 * e5 * 4, n3 = this.bitmap.data, a2 = new Buffer2(i2 * r4 * e5);
        let o3, s4 = 0, l2 = 0;
        for (let u2 = 0; u2 < i2; ++u2) {
          o3 = l2;
          for (let i3 = 0; i3 < t3; ++i3) {
            const t4 = n3.readUInt32BE(s4, true);
            for (let i4 = 0; i4 < e5; ++i4) a2.writeUInt32BE(t4, l2), l2 += 4;
            s4 += 4;
          }
          for (let t4 = 1; t4 < e5; ++t4) a2.copy(a2, l2, o3, l2), l2 += r4, o3 += r4;
        }
        return this.bitmap = { width: t3 * e5, height: i2 * e5, data: a2 }, this;
      }
      scanAllCoords(e5) {
        const t3 = this.bitmap.width, i2 = this.bitmap.data.length;
        let r4 = 0, n3 = 0;
        for (let a2 = 0; a2 < i2; a2 += 4) e5(r4, n3, a2), ++r4 === t3 && (r4 = 0, ++n3);
      }
      scanAllIndexes(e5) {
        const t3 = this.bitmap.data.length;
        for (let i2 = 0; i2 < t3; i2 += 4) e5(i2);
      }
    };
    bitmapimage = BitmapImage$2;
    gif$1 = {};
    Gif$1 = class {
      static {
        __name(this, "Gif$1");
      }
      constructor(e5, t3, i2) {
        this.width = i2.width, this.height = i2.height, this.loops = i2.loops, this.usesTransparency = i2.usesTransparency, this.colorScope = i2.colorScope, this.frames = t3, this.buffer = e5;
      }
    };
    Gif$1.GlobalColorsPreferred = 0, Gif$1.GlobalColorsOnly = 1, Gif$1.LocalColorsOnly = 2;
    GifError$2 = class extends Error {
      static {
        __name(this, "GifError$2");
      }
      constructor(e5) {
        super(e5), e5 instanceof Error && (this.stack = "Gif" + e5.stack);
      }
    };
    gif$1.Gif = Gif$1, gif$1.GifError = GifError$2;
    gifcodec = {};
    gifutil = {};
    _polyfillNode_fs = {};
    _polyfillNode_fs$1 = Object.freeze({ __proto__: null, default: _polyfillNode_fs });
    require$$0 = getAugmentedNamespace(_polyfillNode_fs$1);
    __defProp$3 = Object.defineProperty;
    __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    __getOwnPropNames2 = Object.getOwnPropertyNames;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __defNormalProp$3 = /* @__PURE__ */ __name((e5, t3, i2) => t3 in e5 ? __defProp$3(e5, t3, { enumerable: true, configurable: true, writable: true, value: i2 }) : e5[t3] = i2, "__defNormalProp$3");
    __markAsModule = /* @__PURE__ */ __name((e5) => __defProp$3(e5, "__esModule", { value: true }), "__markAsModule");
    __export$1 = /* @__PURE__ */ __name((e5, t3) => {
      for (var i2 in t3) __defProp$3(e5, i2, { get: t3[i2], enumerable: true });
    }, "__export$1");
    __reExport = /* @__PURE__ */ __name((e5, t3, i2, r4) => {
      if (t3 && "object" == typeof t3 || "function" == typeof t3) for (let n3 of __getOwnPropNames2(t3)) !__hasOwnProp2.call(e5, n3) && i2 && __defProp$3(e5, n3, { get: /* @__PURE__ */ __name(() => t3[n3], "get"), enumerable: !(r4 = __getOwnPropDesc2(t3, n3)) || r4.enumerable });
      return e5;
    }, "__reExport");
    __toCommonJS = /* @__PURE__ */ ((e5) => (t3, i2) => e5 && e5.get(t3) || (i2 = __reExport(__markAsModule({}), t3, 1), e5 && e5.set(t3, i2), i2))("undefined" != typeof WeakMap ? /* @__PURE__ */ new WeakMap() : 0);
    __publicField$3 = /* @__PURE__ */ __name((e5, t3, i2) => (__defNormalProp$3(e5, "symbol" != typeof t3 ? t3 + "" : t3, i2), i2), "__publicField$3");
    src_exports = {};
    __export$1(src_exports, { applyPalette: /* @__PURE__ */ __name(() => applyPalette, "applyPalette"), applyPaletteSync: /* @__PURE__ */ __name(() => applyPaletteSync$1, "applyPaletteSync"), buildPalette: /* @__PURE__ */ __name(() => buildPalette, "buildPalette"), buildPaletteSync: /* @__PURE__ */ __name(() => buildPaletteSync$1, "buildPaletteSync"), constants: /* @__PURE__ */ __name(() => constants_exports$1, "constants"), conversion: /* @__PURE__ */ __name(() => conversion_exports$1, "conversion"), distance: /* @__PURE__ */ __name(() => distance_exports$1, "distance"), image: /* @__PURE__ */ __name(() => image_exports$1, "image"), palette: /* @__PURE__ */ __name(() => palette_exports$1, "palette"), quality: /* @__PURE__ */ __name(() => quality_exports$1, "quality"), utils: /* @__PURE__ */ __name(() => utils_exports$1, "utils") });
    constants_exports$1 = {};
    __export$1(constants_exports$1, { bt709: /* @__PURE__ */ __name(() => bt709_exports$1, "bt709") });
    bt709_exports$1 = {};
    __export$1(bt709_exports$1, { Y: /* @__PURE__ */ __name(() => Y$1, "Y"), x: /* @__PURE__ */ __name(() => x$2, "x"), y: /* @__PURE__ */ __name(() => y$2, "y") });
    Y$1 = ((e5) => (e5[e5.RED = 0.2126] = "RED", e5[e5.GREEN = 0.7152] = "GREEN", e5[e5.BLUE = 0.0722] = "BLUE", e5[e5.WHITE = 1] = "WHITE", e5))(Y$1 || {});
    x$2 = ((e5) => (e5[e5.RED = 0.64] = "RED", e5[e5.GREEN = 0.3] = "GREEN", e5[e5.BLUE = 0.15] = "BLUE", e5[e5.WHITE = 0.3127] = "WHITE", e5))(x$2 || {});
    y$2 = ((e5) => (e5[e5.RED = 0.33] = "RED", e5[e5.GREEN = 0.6] = "GREEN", e5[e5.BLUE = 0.06] = "BLUE", e5[e5.WHITE = 0.329] = "WHITE", e5))(y$2 || {});
    conversion_exports$1 = {};
    __name(correctGamma$1, "correctGamma$1");
    __name(rgb2xyz$1, "rgb2xyz$1");
    __export$1(conversion_exports$1, { lab2rgb: /* @__PURE__ */ __name(() => lab2rgb$1, "lab2rgb"), lab2xyz: /* @__PURE__ */ __name(() => lab2xyz$1, "lab2xyz"), rgb2hsl: /* @__PURE__ */ __name(() => rgb2hsl$1, "rgb2hsl"), rgb2lab: /* @__PURE__ */ __name(() => rgb2lab$1, "rgb2lab"), rgb2xyz: /* @__PURE__ */ __name(() => rgb2xyz$1, "rgb2xyz"), xyz2lab: /* @__PURE__ */ __name(() => xyz2lab$1, "xyz2lab"), xyz2rgb: /* @__PURE__ */ __name(() => xyz2rgb$1, "xyz2rgb") });
    arithmetic_exports$1 = {};
    __name(degrees2radians$1, "degrees2radians$1");
    __name(max3$1, "max3$1");
    __name(min3$1, "min3$1");
    __name(intInRange$1, "intInRange$1");
    __name(inRange0to255Rounded$1, "inRange0to255Rounded$1");
    __name(inRange0to255$1, "inRange0to255$1");
    __name(stableSort$1, "stableSort$1");
    __name(rgb2hsl$1, "rgb2hsl$1");
    __export$1(arithmetic_exports$1, { degrees2radians: /* @__PURE__ */ __name(() => degrees2radians$1, "degrees2radians"), inRange0to255: /* @__PURE__ */ __name(() => inRange0to255$1, "inRange0to255"), inRange0to255Rounded: /* @__PURE__ */ __name(() => inRange0to255Rounded$1, "inRange0to255Rounded"), intInRange: /* @__PURE__ */ __name(() => intInRange$1, "intInRange"), max3: /* @__PURE__ */ __name(() => max3$1, "max3"), min3: /* @__PURE__ */ __name(() => min3$1, "min3"), stableSort: /* @__PURE__ */ __name(() => stableSort$1, "stableSort") });
    refX$1 = 0.95047;
    refY$1 = 1;
    refZ$1 = 1.08883;
    __name(pivot$1, "pivot$1");
    __name(xyz2lab$1, "xyz2lab$1");
    __name(rgb2lab$1, "rgb2lab$1");
    refX2$1 = 0.95047;
    refY2$1 = 1;
    refZ2$1 = 1.08883;
    __name(pivot2$1, "pivot2$1");
    __name(lab2xyz$1, "lab2xyz$1");
    __name(correctGamma2$1, "correctGamma2$1");
    __name(xyz2rgb$1, "xyz2rgb$1");
    __name(lab2rgb$1, "lab2rgb$1");
    distance_exports$1 = {};
    __export$1(distance_exports$1, { AbstractDistanceCalculator: /* @__PURE__ */ __name(() => AbstractDistanceCalculator$1, "AbstractDistanceCalculator"), AbstractEuclidean: /* @__PURE__ */ __name(() => AbstractEuclidean$1, "AbstractEuclidean"), AbstractManhattan: /* @__PURE__ */ __name(() => AbstractManhattan$1, "AbstractManhattan"), CIE94GraphicArts: /* @__PURE__ */ __name(() => CIE94GraphicArts$1, "CIE94GraphicArts"), CIE94Textiles: /* @__PURE__ */ __name(() => CIE94Textiles$1, "CIE94Textiles"), CIEDE2000: /* @__PURE__ */ __name(() => CIEDE2000$1, "CIEDE2000"), CMetric: /* @__PURE__ */ __name(() => CMetric$1, "CMetric"), Euclidean: /* @__PURE__ */ __name(() => Euclidean$1, "Euclidean"), EuclideanBT709: /* @__PURE__ */ __name(() => EuclideanBT709$1, "EuclideanBT709"), EuclideanBT709NoAlpha: /* @__PURE__ */ __name(() => EuclideanBT709NoAlpha$1, "EuclideanBT709NoAlpha"), Manhattan: /* @__PURE__ */ __name(() => Manhattan$1, "Manhattan"), ManhattanBT709: /* @__PURE__ */ __name(() => ManhattanBT709$1, "ManhattanBT709"), ManhattanNommyde: /* @__PURE__ */ __name(() => ManhattanNommyde$1, "ManhattanNommyde"), PNGQuant: /* @__PURE__ */ __name(() => PNGQuant$1, "PNGQuant") });
    AbstractDistanceCalculator$1 = class {
      static {
        __name(this, "AbstractDistanceCalculator$1");
      }
      constructor() {
        __publicField$3(this, "_maxDistance"), __publicField$3(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
      }
      setWhitePoint(e5, t3, i2, r4) {
        this._whitePoint = { r: e5 > 0 ? 255 / e5 : 0, g: t3 > 0 ? 255 / t3 : 0, b: i2 > 0 ? 255 / i2 : 0, a: r4 > 0 ? 255 / r4 : 0 }, this._maxDistance = this.calculateRaw(e5, t3, i2, r4, 0, 0, 0, 0);
      }
      calculateNormalized(e5, t3) {
        return this.calculateRaw(e5.r, e5.g, e5.b, e5.a, t3.r, t3.g, t3.b, t3.a) / this._maxDistance;
      }
    };
    AbstractCIE94$1 = class extends AbstractDistanceCalculator$1 {
      static {
        __name(this, "AbstractCIE94$1");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = rgb2lab$1(inRange0to255$1(e5 * this._whitePoint.r), inRange0to255$1(t3 * this._whitePoint.g), inRange0to255$1(i2 * this._whitePoint.b)), u2 = rgb2lab$1(inRange0to255$1(n3 * this._whitePoint.r), inRange0to255$1(a2 * this._whitePoint.g), inRange0to255$1(o3 * this._whitePoint.b)), h2 = l2.L - u2.L, c3 = l2.a - u2.a, f2 = l2.b - u2.b, d = Math.sqrt(l2.a * l2.a + l2.b * l2.b), p2 = d - Math.sqrt(u2.a * u2.a + u2.b * u2.b);
        let m = c3 * c3 + f2 * f2 - p2 * p2;
        m = m < 0 ? 0 : Math.sqrt(m);
        const _2 = (s4 - r4) * this._whitePoint.a * this._kA;
        return Math.sqrt((h2 / this._Kl) ** 2 + (p2 / (1 + this._K1 * d)) ** 2 + (m / (1 + this._K2 * d)) ** 2 + _2 ** 2);
      }
    };
    CIE94Textiles$1 = class extends AbstractCIE94$1 {
      static {
        __name(this, "CIE94Textiles$1");
      }
      _setDefaults() {
        this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
      }
    };
    CIE94GraphicArts$1 = class extends AbstractCIE94$1 {
      static {
        __name(this, "CIE94GraphicArts$1");
      }
      _setDefaults() {
        this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
      }
    };
    _CIEDE2000$1 = class extends AbstractDistanceCalculator$1 {
      static {
        __name(this, "_CIEDE2000$1");
      }
      _setDefaults() {
      }
      static _calculatehp(e5, t3) {
        const i2 = Math.atan2(e5, t3);
        return i2 >= 0 ? i2 : i2 + _CIEDE2000$1._deg360InRad;
      }
      static _calculateRT(e5, t3) {
        const i2 = t3 ** 7, r4 = 2 * Math.sqrt(i2 / (i2 + _CIEDE2000$1._pow25to7)), n3 = _CIEDE2000$1._deg30InRad * Math.exp(-(((e5 - _CIEDE2000$1._deg275InRad) / _CIEDE2000$1._deg25InRad) ** 2));
        return -Math.sin(2 * n3) * r4;
      }
      static _calculateT(e5) {
        return 1 - 0.17 * Math.cos(e5 - _CIEDE2000$1._deg30InRad) + 0.24 * Math.cos(2 * e5) + 0.32 * Math.cos(3 * e5 + _CIEDE2000$1._deg6InRad) - 0.2 * Math.cos(4 * e5 - _CIEDE2000$1._deg63InRad);
      }
      static _calculate_ahp(e5, t3, i2, r4) {
        const n3 = i2 + r4;
        return 0 === e5 ? n3 : t3 <= _CIEDE2000$1._deg180InRad ? n3 / 2 : n3 < _CIEDE2000$1._deg360InRad ? (n3 + _CIEDE2000$1._deg360InRad) / 2 : (n3 - _CIEDE2000$1._deg360InRad) / 2;
      }
      static _calculate_dHp(e5, t3, i2, r4) {
        let n3;
        return n3 = 0 === e5 ? 0 : t3 <= _CIEDE2000$1._deg180InRad ? i2 - r4 : i2 <= r4 ? i2 - r4 + _CIEDE2000$1._deg360InRad : i2 - r4 - _CIEDE2000$1._deg360InRad, 2 * Math.sqrt(e5) * Math.sin(n3 / 2);
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = rgb2lab$1(inRange0to255$1(e5 * this._whitePoint.r), inRange0to255$1(t3 * this._whitePoint.g), inRange0to255$1(i2 * this._whitePoint.b)), u2 = rgb2lab$1(inRange0to255$1(n3 * this._whitePoint.r), inRange0to255$1(a2 * this._whitePoint.g), inRange0to255$1(o3 * this._whitePoint.b)), h2 = (s4 - r4) * this._whitePoint.a * _CIEDE2000$1._kA, c3 = this.calculateRawInLab(l2, u2);
        return Math.sqrt(c3 + h2 * h2);
      }
      calculateRawInLab(e5, t3) {
        const i2 = e5.L, r4 = e5.a, n3 = e5.b, a2 = t3.L, o3 = t3.a, s4 = t3.b, l2 = ((Math.sqrt(r4 * r4 + n3 * n3) + Math.sqrt(o3 * o3 + s4 * s4)) / 2) ** 7, u2 = 0.5 * (1 - Math.sqrt(l2 / (l2 + _CIEDE2000$1._pow25to7))), h2 = (1 + u2) * r4, c3 = (1 + u2) * o3, f2 = Math.sqrt(h2 * h2 + n3 * n3), d = Math.sqrt(c3 * c3 + s4 * s4), p2 = f2 * d, m = _CIEDE2000$1._calculatehp(n3, h2), _2 = _CIEDE2000$1._calculatehp(s4, c3), g = Math.abs(m - _2), b2 = a2 - i2, y2 = d - f2, w = _CIEDE2000$1._calculate_dHp(p2, g, _2, m), v2 = _CIEDE2000$1._calculate_ahp(p2, g, m, _2), x2 = (f2 + d) / 2, E2 = ((i2 + a2) / 2 - 50) ** 2, k2 = y2 / (1 + 0.045 * x2), S2 = w / (1 + 0.015 * _CIEDE2000$1._calculateT(v2) * x2);
        return (b2 / (1 + 0.015 * E2 / Math.sqrt(20 + E2))) ** 2 + k2 ** 2 + S2 ** 2 + _CIEDE2000$1._calculateRT(v2, x2) * k2 * S2;
      }
    };
    CIEDE2000$1 = _CIEDE2000$1;
    __publicField$3(CIEDE2000$1, "_kA", 25 / 255), __publicField$3(CIEDE2000$1, "_pow25to7", 25 ** 7), __publicField$3(CIEDE2000$1, "_deg360InRad", degrees2radians$1(360)), __publicField$3(CIEDE2000$1, "_deg180InRad", degrees2radians$1(180)), __publicField$3(CIEDE2000$1, "_deg30InRad", degrees2radians$1(30)), __publicField$3(CIEDE2000$1, "_deg6InRad", degrees2radians$1(6)), __publicField$3(CIEDE2000$1, "_deg63InRad", degrees2radians$1(63)), __publicField$3(CIEDE2000$1, "_deg275InRad", degrees2radians$1(275)), __publicField$3(CIEDE2000$1, "_deg25InRad", degrees2radians$1(25));
    CMetric$1 = class extends AbstractDistanceCalculator$1 {
      static {
        __name(this, "CMetric$1");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = (e5 + n3) / 2 * this._whitePoint.r, u2 = (e5 - n3) * this._whitePoint.r, h2 = (t3 - a2) * this._whitePoint.g, c3 = (i2 - o3) * this._whitePoint.b, f2 = ((512 + l2) * u2 * u2 >> 8) + 4 * h2 * h2 + ((767 - l2) * c3 * c3 >> 8), d = (s4 - r4) * this._whitePoint.a;
        return Math.sqrt(f2 + d * d);
      }
      _setDefaults() {
      }
    };
    AbstractEuclidean$1 = class extends AbstractDistanceCalculator$1 {
      static {
        __name(this, "AbstractEuclidean$1");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = n3 - e5, u2 = a2 - t3, h2 = o3 - i2, c3 = s4 - r4;
        return Math.sqrt(this._kR * l2 * l2 + this._kG * u2 * u2 + this._kB * h2 * h2 + this._kA * c3 * c3);
      }
    };
    Euclidean$1 = class extends AbstractEuclidean$1 {
      static {
        __name(this, "Euclidean$1");
      }
      _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
      }
    };
    EuclideanBT709$1 = class extends AbstractEuclidean$1 {
      static {
        __name(this, "EuclideanBT709$1");
      }
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
      }
    };
    EuclideanBT709NoAlpha$1 = class extends AbstractEuclidean$1 {
      static {
        __name(this, "EuclideanBT709NoAlpha$1");
      }
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
      }
    };
    AbstractManhattan$1 = class extends AbstractDistanceCalculator$1 {
      static {
        __name(this, "AbstractManhattan$1");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        let l2 = n3 - e5, u2 = a2 - t3, h2 = o3 - i2, c3 = s4 - r4;
        return l2 < 0 && (l2 = 0 - l2), u2 < 0 && (u2 = 0 - u2), h2 < 0 && (h2 = 0 - h2), c3 < 0 && (c3 = 0 - c3), this._kR * l2 + this._kG * u2 + this._kB * h2 + this._kA * c3;
      }
    };
    Manhattan$1 = class extends AbstractManhattan$1 {
      static {
        __name(this, "Manhattan$1");
      }
      _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
      }
    };
    ManhattanNommyde$1 = class extends AbstractManhattan$1 {
      static {
        __name(this, "ManhattanNommyde$1");
      }
      _setDefaults() {
        this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
      }
    };
    ManhattanBT709$1 = class extends AbstractManhattan$1 {
      static {
        __name(this, "ManhattanBT709$1");
      }
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
      }
    };
    PNGQuant$1 = class extends AbstractDistanceCalculator$1 {
      static {
        __name(this, "PNGQuant$1");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = (s4 - r4) * this._whitePoint.a;
        return this._colordifferenceCh(e5 * this._whitePoint.r, n3 * this._whitePoint.r, l2) + this._colordifferenceCh(t3 * this._whitePoint.g, a2 * this._whitePoint.g, l2) + this._colordifferenceCh(i2 * this._whitePoint.b, o3 * this._whitePoint.b, l2);
      }
      _colordifferenceCh(e5, t3, i2) {
        const r4 = e5 - t3, n3 = r4 + i2;
        return r4 * r4 + n3 * n3;
      }
      _setDefaults() {
      }
    };
    palette_exports$1 = {};
    __export$1(palette_exports$1, { AbstractPaletteQuantizer: /* @__PURE__ */ __name(() => AbstractPaletteQuantizer$1, "AbstractPaletteQuantizer"), ColorHistogram: /* @__PURE__ */ __name(() => ColorHistogram$1, "ColorHistogram"), NeuQuant: /* @__PURE__ */ __name(() => NeuQuant$1, "NeuQuant"), NeuQuantFloat: /* @__PURE__ */ __name(() => NeuQuantFloat$1, "NeuQuantFloat"), RGBQuant: /* @__PURE__ */ __name(() => RGBQuant$1, "RGBQuant"), WuColorCube: /* @__PURE__ */ __name(() => WuColorCube$1, "WuColorCube"), WuQuant: /* @__PURE__ */ __name(() => WuQuant$1, "WuQuant") });
    AbstractPaletteQuantizer$1 = class {
      static {
        __name(this, "AbstractPaletteQuantizer$1");
      }
      quantizeSync() {
        for (const e5 of this.quantize()) if (e5.palette) return e5.palette;
        throw new Error("unreachable");
      }
    };
    Point$1 = class {
      static {
        __name(this, "Point$1");
      }
      constructor() {
        __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), __publicField$3(this, "uint32"), __publicField$3(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
      }
      static createByQuadruplet(e5) {
        const t3 = new Point$1();
        return t3.r = 0 | e5[0], t3.g = 0 | e5[1], t3.b = 0 | e5[2], t3.a = 0 | e5[3], t3._loadUINT32(), t3._loadQuadruplet(), t3;
      }
      static createByRGBA(e5, t3, i2, r4) {
        const n3 = new Point$1();
        return n3.r = 0 | e5, n3.g = 0 | t3, n3.b = 0 | i2, n3.a = 0 | r4, n3._loadUINT32(), n3._loadQuadruplet(), n3;
      }
      static createByUint32(e5) {
        const t3 = new Point$1();
        return t3.uint32 = e5 >>> 0, t3._loadRGBA(), t3._loadQuadruplet(), t3;
      }
      from(e5) {
        this.r = e5.r, this.g = e5.g, this.b = e5.b, this.a = e5.a, this.uint32 = e5.uint32, this.rgba[0] = e5.r, this.rgba[1] = e5.g, this.rgba[2] = e5.b, this.rgba[3] = e5.a;
      }
      getLuminosity(e5) {
        let t3 = this.r, i2 = this.g, r4 = this.b;
        return e5 && (t3 = Math.min(255, 255 - this.a + this.a * t3 / 255), i2 = Math.min(255, 255 - this.a + this.a * i2 / 255), r4 = Math.min(255, 255 - this.a + this.a * r4 / 255)), 0.2126 * t3 + 0.7152 * i2 + 0.0722 * r4;
      }
      _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
      }
      _loadRGBA() {
        this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
      }
      _loadQuadruplet() {
        this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
      }
    };
    PointContainer$1 = class {
      static {
        __name(this, "PointContainer$1");
      }
      constructor() {
        __publicField$3(this, "_pointArray"), __publicField$3(this, "_width"), __publicField$3(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
      }
      getWidth() {
        return this._width;
      }
      getHeight() {
        return this._height;
      }
      setWidth(e5) {
        this._width = e5;
      }
      setHeight(e5) {
        this._height = e5;
      }
      getPointArray() {
        return this._pointArray;
      }
      clone() {
        const e5 = new PointContainer$1();
        e5._width = this._width, e5._height = this._height;
        for (let t3 = 0, i2 = this._pointArray.length; t3 < i2; t3++) e5._pointArray[t3] = Point$1.createByUint32(0 | this._pointArray[t3].uint32);
        return e5;
      }
      toUint32Array() {
        const e5 = this._pointArray.length, t3 = new Uint32Array(e5);
        for (let i2 = 0; i2 < e5; i2++) t3[i2] = this._pointArray[i2].uint32;
        return t3;
      }
      toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
      }
      static fromHTMLImageElement(e5) {
        const t3 = e5.naturalWidth, i2 = e5.naturalHeight, r4 = document.createElement("canvas");
        r4.width = t3, r4.height = i2;
        return r4.getContext("2d").drawImage(e5, 0, 0, t3, i2, 0, 0, t3, i2), PointContainer$1.fromHTMLCanvasElement(r4);
      }
      static fromHTMLCanvasElement(e5) {
        const t3 = e5.width, i2 = e5.height, r4 = e5.getContext("2d").getImageData(0, 0, t3, i2);
        return PointContainer$1.fromImageData(r4);
      }
      static fromImageData(e5) {
        const t3 = e5.width, i2 = e5.height;
        return PointContainer$1.fromUint8Array(e5.data, t3, i2);
      }
      static fromUint8Array(e5, t3, i2) {
        switch (Object.prototype.toString.call(e5)) {
          case "[object Uint8ClampedArray]":
          case "[object Uint8Array]":
            break;
          default:
            e5 = new Uint8Array(e5);
        }
        const r4 = new Uint32Array(e5.buffer);
        return PointContainer$1.fromUint32Array(r4, t3, i2);
      }
      static fromUint32Array(e5, t3, i2) {
        const r4 = new PointContainer$1();
        r4._width = t3, r4._height = i2;
        for (let t4 = 0, i3 = e5.length; t4 < i3; t4++) r4._pointArray[t4] = Point$1.createByUint32(0 | e5[t4]);
        return r4;
      }
      static fromBuffer(e5, t3, i2) {
        const r4 = new Uint32Array(e5.buffer, e5.byteOffset, e5.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return PointContainer$1.fromUint32Array(r4, t3, i2);
      }
    };
    hueGroups$1 = 10;
    __name(hueGroup$1, "hueGroup$1");
    Palette$1 = class {
      static {
        __name(this, "Palette$1");
      }
      constructor() {
        __publicField$3(this, "_pointContainer"), __publicField$3(this, "_pointArray", []), __publicField$3(this, "_i32idx", {}), this._pointContainer = new PointContainer$1(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
      }
      add(e5) {
        this._pointArray.push(e5), this._pointContainer.setWidth(this._pointArray.length);
      }
      has(e5) {
        for (let t3 = this._pointArray.length - 1; t3 >= 0; t3--) if (e5.uint32 === this._pointArray[t3].uint32) return true;
        return false;
      }
      getNearestColor(e5, t3) {
        return this._pointArray[0 | this._getNearestIndex(e5, t3)];
      }
      getPointContainer() {
        return this._pointContainer;
      }
      _nearestPointFromCache(e5) {
        return "number" == typeof this._i32idx[e5] ? this._i32idx[e5] : -1;
      }
      _getNearestIndex(e5, t3) {
        let i2 = this._nearestPointFromCache("" + t3.uint32);
        if (i2 >= 0) return i2;
        let r4 = Number.MAX_VALUE;
        i2 = 0;
        for (let n3 = 0, a2 = this._pointArray.length; n3 < a2; n3++) {
          const a3 = this._pointArray[n3], o3 = e5.calculateRaw(t3.r, t3.g, t3.b, t3.a, a3.r, a3.g, a3.b, a3.a);
          o3 < r4 && (r4 = o3, i2 = n3);
        }
        return this._i32idx[t3.uint32] = i2, i2;
      }
      sort() {
        this._i32idx = {}, this._pointArray.sort((e5, t3) => {
          const i2 = rgb2hsl$1(e5.r, e5.g, e5.b), r4 = rgb2hsl$1(t3.r, t3.g, t3.b), n3 = e5.r === e5.g && e5.g === e5.b ? 0 : 1 + hueGroup$1(i2.h, hueGroups$1), a2 = (t3.r === t3.g && t3.g === t3.b ? 0 : 1 + hueGroup$1(r4.h, hueGroups$1)) - n3;
          if (a2) return -a2;
          const o3 = e5.getLuminosity(true), s4 = t3.getLuminosity(true);
          if (s4 - o3 != 0) return s4 - o3;
          const l2 = (100 * r4.s | 0) - (100 * i2.s | 0);
          return l2 ? -l2 : 0;
        });
      }
    };
    utils_exports$1 = {};
    __export$1(utils_exports$1, { HueStatistics: /* @__PURE__ */ __name(() => HueStatistics$1, "HueStatistics"), Palette: /* @__PURE__ */ __name(() => Palette$1, "Palette"), Point: /* @__PURE__ */ __name(() => Point$1, "Point"), PointContainer: /* @__PURE__ */ __name(() => PointContainer$1, "PointContainer"), ProgressTracker: /* @__PURE__ */ __name(() => ProgressTracker$1, "ProgressTracker"), arithmetic: /* @__PURE__ */ __name(() => arithmetic_exports$1, "arithmetic") });
    HueGroup$1 = class {
      static {
        __name(this, "HueGroup$1");
      }
      constructor() {
        __publicField$3(this, "num", 0), __publicField$3(this, "cols", []);
      }
    };
    HueStatistics$1 = class {
      static {
        __name(this, "HueStatistics$1");
      }
      constructor(e5, t3) {
        __publicField$3(this, "_numGroups"), __publicField$3(this, "_minCols"), __publicField$3(this, "_stats"), __publicField$3(this, "_groupsFull"), this._numGroups = e5, this._minCols = t3, this._stats = [];
        for (let t4 = 0; t4 <= e5; t4++) this._stats[t4] = new HueGroup$1();
        this._groupsFull = 0;
      }
      check(e5) {
        this._groupsFull === this._numGroups + 1 && (this.check = () => {
        });
        const t3 = 255 & e5, i2 = e5 >>> 8 & 255, r4 = e5 >>> 16 & 255, n3 = t3 === i2 && i2 === r4 ? 0 : 1 + hueGroup$1(rgb2hsl$1(t3, i2, r4).h, this._numGroups), a2 = this._stats[n3], o3 = this._minCols;
        a2.num++, a2.num > o3 || (a2.num === o3 && this._groupsFull++, a2.num <= o3 && this._stats[n3].cols.push(e5));
      }
      injectIntoDictionary(e5) {
        for (let t3 = 0; t3 <= this._numGroups; t3++) this._stats[t3].num <= this._minCols && this._stats[t3].cols.forEach((t4) => {
          e5[t4] ? e5[t4]++ : e5[t4] = 1;
        });
      }
      injectIntoArray(e5) {
        for (let t3 = 0; t3 <= this._numGroups; t3++) this._stats[t3].num <= this._minCols && this._stats[t3].cols.forEach((t4) => {
          -1 === e5.indexOf(t4) && e5.push(t4);
        });
      }
    };
    _ProgressTracker$1 = class {
      static {
        __name(this, "_ProgressTracker$1");
      }
      constructor(e5, t3) {
        __publicField$3(this, "progress"), __publicField$3(this, "_step"), __publicField$3(this, "_range"), __publicField$3(this, "_last"), __publicField$3(this, "_progressRange"), this._range = e5, this._progressRange = t3, this._step = Math.max(1, this._range / (_ProgressTracker$1.steps + 1) | 0), this._last = -this._step, this.progress = 0;
      }
      shouldNotify(e5) {
        return e5 - this._last >= this._step && (this._last = e5, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), true);
      }
    };
    ProgressTracker$1 = _ProgressTracker$1;
    __publicField$3(ProgressTracker$1, "steps", 100);
    networkBiasShift$1 = 3;
    Neuron$1 = class {
      static {
        __name(this, "Neuron$1");
      }
      constructor(e5) {
        __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = e5;
      }
      toPoint() {
        return Point$1.createByRGBA(this.r >> networkBiasShift$1, this.g >> networkBiasShift$1, this.b >> networkBiasShift$1, this.a >> networkBiasShift$1);
      }
      subtract(e5, t3, i2, r4) {
        this.r -= 0 | e5, this.g -= 0 | t3, this.b -= 0 | i2, this.a -= 0 | r4;
      }
    };
    _NeuQuant$1 = class extends AbstractPaletteQuantizer$1 {
      static {
        __name(this, "_NeuQuant$1");
      }
      constructor(e5, t3 = 256) {
        super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = e5, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t3, this._distance.setWhitePoint(255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1, 255 << networkBiasShift$1);
      }
      sample(e5) {
        this._pointArray = this._pointArray.concat(e5.getPointArray());
      }
      *quantize() {
        this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
      }
      _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let e5 = 0; e5 < this._networkSize; e5++) this._network[e5] = new Neuron$1((e5 << networkBiasShift$1 + 8) / this._networkSize | 0), this._freq[e5] = _NeuQuant$1._initialBias / this._networkSize | 0, this._bias[e5] = 0;
      }
      *_learn() {
        let e5 = this._sampleFactor;
        const t3 = this._pointArray.length;
        t3 < _NeuQuant$1._minpicturebytes && (e5 = 1);
        const i2 = 30 + (e5 - 1) / 3 | 0, r4 = t3 / e5 | 0;
        let n3, a2 = r4 / _NeuQuant$1._nCycles | 0, o3 = _NeuQuant$1._initAlpha, s4 = (this._networkSize >> 3) * _NeuQuant$1._radiusBias, l2 = s4 >> _NeuQuant$1._radiusBiasShift;
        l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++) this._radPower[e6] = o3 * ((l2 * l2 - e6 * e6) * _NeuQuant$1._radBias / (l2 * l2)) >>> 0;
        n3 = t3 < _NeuQuant$1._minpicturebytes ? 1 : t3 % _NeuQuant$1._prime1 != 0 ? _NeuQuant$1._prime1 : t3 % _NeuQuant$1._prime2 != 0 ? _NeuQuant$1._prime2 : t3 % _NeuQuant$1._prime3 != 0 ? _NeuQuant$1._prime3 : _NeuQuant$1._prime4;
        const u2 = new ProgressTracker$1(r4, 99);
        for (let e6 = 0, h2 = 0; e6 < r4; ) {
          u2.shouldNotify(e6) && (yield { progress: u2.progress });
          const r5 = this._pointArray[h2], c3 = r5.b << networkBiasShift$1, f2 = r5.g << networkBiasShift$1, d = r5.r << networkBiasShift$1, p2 = r5.a << networkBiasShift$1, m = this._contest(c3, f2, d, p2);
          if (this._alterSingle(o3, m, c3, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c3, f2, d, p2), h2 += n3, h2 >= t3 && (h2 -= t3), e6++, 0 === a2 && (a2 = 1), e6 % a2 == 0) {
            o3 -= o3 / i2 | 0, s4 -= s4 / _NeuQuant$1._radiusDecrease | 0, l2 = s4 >> _NeuQuant$1._radiusBiasShift, l2 <= 1 && (l2 = 0);
            for (let e7 = 0; e7 < l2; e7++) this._radPower[e7] = o3 * ((l2 * l2 - e7 * e7) * _NeuQuant$1._radBias / (l2 * l2)) >>> 0;
          }
        }
      }
      _buildPalette() {
        const e5 = new Palette$1();
        return this._network.forEach((t3) => {
          e5.add(t3.toPoint());
        }), e5.sort(), e5;
      }
      _alterNeighbour(e5, t3, i2, r4, n3, a2) {
        let o3 = t3 - e5;
        o3 < -1 && (o3 = -1);
        let s4 = t3 + e5;
        s4 > this._networkSize && (s4 = this._networkSize);
        let l2 = t3 + 1, u2 = t3 - 1, h2 = 1;
        for (; l2 < s4 || u2 > o3; ) {
          const e6 = this._radPower[h2++] / _NeuQuant$1._alphaRadBias;
          if (l2 < s4) {
            const t4 = this._network[l2++];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
          if (u2 > o3) {
            const t4 = this._network[u2--];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
        }
      }
      _alterSingle(e5, t3, i2, r4, n3, a2) {
        e5 /= _NeuQuant$1._initAlpha;
        const o3 = this._network[t3];
        o3.subtract(e5 * (o3.r - n3), e5 * (o3.g - r4), e5 * (o3.b - i2), e5 * (o3.a - a2));
      }
      _contest(e5, t3, i2, r4) {
        const n3 = 1020 << networkBiasShift$1;
        let a2 = ~(1 << 31), o3 = a2, s4 = -1, l2 = s4;
        for (let u2 = 0; u2 < this._networkSize; u2++) {
          const h2 = this._network[u2], c3 = this._distance.calculateNormalized(h2, { r: i2, g: t3, b: e5, a: r4 }) * n3 | 0;
          c3 < a2 && (a2 = c3, s4 = u2);
          const f2 = c3 - (this._bias[u2] >> _NeuQuant$1._initialBiasShift - networkBiasShift$1);
          f2 < o3 && (o3 = f2, l2 = u2);
          const d = this._freq[u2] >> _NeuQuant$1._betaShift;
          this._freq[u2] -= d, this._bias[u2] += d << _NeuQuant$1._gammaShift;
        }
        return this._freq[s4] += _NeuQuant$1._beta, this._bias[s4] -= _NeuQuant$1._betaGamma, l2;
      }
    };
    NeuQuant$1 = _NeuQuant$1;
    __publicField$3(NeuQuant$1, "_prime1", 499), __publicField$3(NeuQuant$1, "_prime2", 491), __publicField$3(NeuQuant$1, "_prime3", 487), __publicField$3(NeuQuant$1, "_prime4", 503), __publicField$3(NeuQuant$1, "_minpicturebytes", _NeuQuant$1._prime4), __publicField$3(NeuQuant$1, "_nCycles", 100), __publicField$3(NeuQuant$1, "_initialBiasShift", 16), __publicField$3(NeuQuant$1, "_initialBias", 1 << _NeuQuant$1._initialBiasShift), __publicField$3(NeuQuant$1, "_gammaShift", 10), __publicField$3(NeuQuant$1, "_betaShift", 10), __publicField$3(NeuQuant$1, "_beta", _NeuQuant$1._initialBias >> _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_betaGamma", _NeuQuant$1._initialBias << _NeuQuant$1._gammaShift - _NeuQuant$1._betaShift), __publicField$3(NeuQuant$1, "_radiusBiasShift", 6), __publicField$3(NeuQuant$1, "_radiusBias", 1 << _NeuQuant$1._radiusBiasShift), __publicField$3(NeuQuant$1, "_radiusDecrease", 30), __publicField$3(NeuQuant$1, "_alphaBiasShift", 10), __publicField$3(NeuQuant$1, "_initAlpha", 1 << _NeuQuant$1._alphaBiasShift), __publicField$3(NeuQuant$1, "_radBiasShift", 8), __publicField$3(NeuQuant$1, "_radBias", 1 << _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBiasShift", _NeuQuant$1._alphaBiasShift + _NeuQuant$1._radBiasShift), __publicField$3(NeuQuant$1, "_alphaRadBias", 1 << _NeuQuant$1._alphaRadBiasShift);
    networkBiasShift2$1 = 3;
    NeuronFloat$1 = class {
      static {
        __name(this, "NeuronFloat$1");
      }
      constructor(e5) {
        __publicField$3(this, "r"), __publicField$3(this, "g"), __publicField$3(this, "b"), __publicField$3(this, "a"), this.r = this.g = this.b = this.a = e5;
      }
      toPoint() {
        return Point$1.createByRGBA(this.r >> networkBiasShift2$1, this.g >> networkBiasShift2$1, this.b >> networkBiasShift2$1, this.a >> networkBiasShift2$1);
      }
      subtract(e5, t3, i2, r4) {
        this.r -= e5, this.g -= t3, this.b -= i2, this.a -= r4;
      }
    };
    _NeuQuantFloat$1 = class extends AbstractPaletteQuantizer$1 {
      static {
        __name(this, "_NeuQuantFloat$1");
      }
      constructor(e5, t3 = 256) {
        super(), __publicField$3(this, "_pointArray"), __publicField$3(this, "_networkSize"), __publicField$3(this, "_network"), __publicField$3(this, "_sampleFactor"), __publicField$3(this, "_radPower"), __publicField$3(this, "_freq"), __publicField$3(this, "_bias"), __publicField$3(this, "_distance"), this._distance = e5, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t3, this._distance.setWhitePoint(255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1, 255 << networkBiasShift2$1);
      }
      sample(e5) {
        this._pointArray = this._pointArray.concat(e5.getPointArray());
      }
      *quantize() {
        this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
      }
      _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let e5 = 0; e5 < this._networkSize; e5++) this._network[e5] = new NeuronFloat$1((e5 << networkBiasShift2$1 + 8) / this._networkSize), this._freq[e5] = _NeuQuantFloat$1._initialBias / this._networkSize, this._bias[e5] = 0;
      }
      *_learn() {
        let e5 = this._sampleFactor;
        const t3 = this._pointArray.length;
        t3 < _NeuQuantFloat$1._minpicturebytes && (e5 = 1);
        const i2 = 30 + (e5 - 1) / 3, r4 = t3 / e5;
        let n3, a2 = r4 / _NeuQuantFloat$1._nCycles | 0, o3 = _NeuQuantFloat$1._initAlpha, s4 = (this._networkSize >> 3) * _NeuQuantFloat$1._radiusBias, l2 = s4 >> _NeuQuantFloat$1._radiusBiasShift;
        l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++) this._radPower[e6] = o3 * ((l2 * l2 - e6 * e6) * _NeuQuantFloat$1._radBias / (l2 * l2));
        n3 = t3 < _NeuQuantFloat$1._minpicturebytes ? 1 : t3 % _NeuQuantFloat$1._prime1 != 0 ? _NeuQuantFloat$1._prime1 : t3 % _NeuQuantFloat$1._prime2 != 0 ? _NeuQuantFloat$1._prime2 : t3 % _NeuQuantFloat$1._prime3 != 0 ? _NeuQuantFloat$1._prime3 : _NeuQuantFloat$1._prime4;
        const u2 = new ProgressTracker$1(r4, 99);
        for (let e6 = 0, h2 = 0; e6 < r4; ) {
          u2.shouldNotify(e6) && (yield { progress: u2.progress });
          const r5 = this._pointArray[h2], c3 = r5.b << networkBiasShift2$1, f2 = r5.g << networkBiasShift2$1, d = r5.r << networkBiasShift2$1, p2 = r5.a << networkBiasShift2$1, m = this._contest(c3, f2, d, p2);
          if (this._alterSingle(o3, m, c3, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c3, f2, d, p2), h2 += n3, h2 >= t3 && (h2 -= t3), e6++, 0 === a2 && (a2 = 1), e6 % a2 == 0) {
            o3 -= o3 / i2, s4 -= s4 / _NeuQuantFloat$1._radiusDecrease, l2 = s4 >> _NeuQuantFloat$1._radiusBiasShift, l2 <= 1 && (l2 = 0);
            for (let e7 = 0; e7 < l2; e7++) this._radPower[e7] = o3 * ((l2 * l2 - e7 * e7) * _NeuQuantFloat$1._radBias / (l2 * l2));
          }
        }
      }
      _buildPalette() {
        const e5 = new Palette$1();
        return this._network.forEach((t3) => {
          e5.add(t3.toPoint());
        }), e5.sort(), e5;
      }
      _alterNeighbour(e5, t3, i2, r4, n3, a2) {
        let o3 = t3 - e5;
        o3 < -1 && (o3 = -1);
        let s4 = t3 + e5;
        s4 > this._networkSize && (s4 = this._networkSize);
        let l2 = t3 + 1, u2 = t3 - 1, h2 = 1;
        for (; l2 < s4 || u2 > o3; ) {
          const e6 = this._radPower[h2++] / _NeuQuantFloat$1._alphaRadBias;
          if (l2 < s4) {
            const t4 = this._network[l2++];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
          if (u2 > o3) {
            const t4 = this._network[u2--];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
        }
      }
      _alterSingle(e5, t3, i2, r4, n3, a2) {
        e5 /= _NeuQuantFloat$1._initAlpha;
        const o3 = this._network[t3];
        o3.subtract(e5 * (o3.r - n3), e5 * (o3.g - r4), e5 * (o3.b - i2), e5 * (o3.a - a2));
      }
      _contest(e5, t3, i2, r4) {
        const n3 = 1020 << networkBiasShift2$1;
        let a2 = ~(1 << 31), o3 = a2, s4 = -1, l2 = s4;
        for (let u2 = 0; u2 < this._networkSize; u2++) {
          const h2 = this._network[u2], c3 = this._distance.calculateNormalized(h2, { r: i2, g: t3, b: e5, a: r4 }) * n3;
          c3 < a2 && (a2 = c3, s4 = u2);
          const f2 = c3 - (this._bias[u2] >> _NeuQuantFloat$1._initialBiasShift - networkBiasShift2$1);
          f2 < o3 && (o3 = f2, l2 = u2);
          const d = this._freq[u2] >> _NeuQuantFloat$1._betaShift;
          this._freq[u2] -= d, this._bias[u2] += d << _NeuQuantFloat$1._gammaShift;
        }
        return this._freq[s4] += _NeuQuantFloat$1._beta, this._bias[s4] -= _NeuQuantFloat$1._betaGamma, l2;
      }
    };
    NeuQuantFloat$1 = _NeuQuantFloat$1;
    __publicField$3(NeuQuantFloat$1, "_prime1", 499), __publicField$3(NeuQuantFloat$1, "_prime2", 491), __publicField$3(NeuQuantFloat$1, "_prime3", 487), __publicField$3(NeuQuantFloat$1, "_prime4", 503), __publicField$3(NeuQuantFloat$1, "_minpicturebytes", _NeuQuantFloat$1._prime4), __publicField$3(NeuQuantFloat$1, "_nCycles", 100), __publicField$3(NeuQuantFloat$1, "_initialBiasShift", 16), __publicField$3(NeuQuantFloat$1, "_initialBias", 1 << _NeuQuantFloat$1._initialBiasShift), __publicField$3(NeuQuantFloat$1, "_gammaShift", 10), __publicField$3(NeuQuantFloat$1, "_betaShift", 10), __publicField$3(NeuQuantFloat$1, "_beta", _NeuQuantFloat$1._initialBias >> _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_betaGamma", _NeuQuantFloat$1._initialBias << _NeuQuantFloat$1._gammaShift - _NeuQuantFloat$1._betaShift), __publicField$3(NeuQuantFloat$1, "_radiusBiasShift", 6), __publicField$3(NeuQuantFloat$1, "_radiusBias", 1 << _NeuQuantFloat$1._radiusBiasShift), __publicField$3(NeuQuantFloat$1, "_radiusDecrease", 30), __publicField$3(NeuQuantFloat$1, "_alphaBiasShift", 10), __publicField$3(NeuQuantFloat$1, "_initAlpha", 1 << _NeuQuantFloat$1._alphaBiasShift), __publicField$3(NeuQuantFloat$1, "_radBiasShift", 8), __publicField$3(NeuQuantFloat$1, "_radBias", 1 << _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBiasShift", _NeuQuantFloat$1._alphaBiasShift + _NeuQuantFloat$1._radBiasShift), __publicField$3(NeuQuantFloat$1, "_alphaRadBias", 1 << _NeuQuantFloat$1._alphaRadBiasShift);
    _ColorHistogram$1 = class {
      static {
        __name(this, "_ColorHistogram$1");
      }
      constructor(e5, t3) {
        __publicField$3(this, "_method"), __publicField$3(this, "_hueStats"), __publicField$3(this, "_histogram"), __publicField$3(this, "_initColors"), __publicField$3(this, "_minHueCols"), this._method = e5, this._minHueCols = t3 << 2, this._initColors = t3 << 2, this._hueStats = new HueStatistics$1(_ColorHistogram$1._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
      }
      sample(e5) {
        switch (this._method) {
          case 1:
            this._colorStats1D(e5);
            break;
          case 2:
            this._colorStats2D(e5);
        }
      }
      getImportanceSortedColorsIDXI32() {
        const e5 = stableSort$1(Object.keys(this._histogram), (e6, t4) => this._histogram[t4] - this._histogram[e6]);
        if (0 === e5.length) return [];
        let t3;
        switch (this._method) {
          case 1:
            const i2 = Math.min(e5.length, this._initColors), r4 = e5[i2 - 1], n3 = this._histogram[r4];
            t3 = e5.slice(0, i2);
            let a2 = i2;
            const o3 = e5.length;
            for (; a2 < o3 && this._histogram[e5[a2]] === n3; ) t3.push(e5[a2++]);
            this._hueStats.injectIntoArray(t3);
            break;
          case 2:
            t3 = e5;
            break;
          default:
            throw new Error("Incorrect method");
        }
        return t3.map((e6) => +e6);
      }
      _colorStats1D(e5) {
        const t3 = this._histogram, i2 = e5.getPointArray(), r4 = i2.length;
        for (let e6 = 0; e6 < r4; e6++) {
          const r5 = i2[e6].uint32;
          this._hueStats.check(r5), r5 in t3 ? t3[r5]++ : t3[r5] = 1;
        }
      }
      _colorStats2D(e5) {
        const t3 = e5.getWidth(), i2 = e5.getHeight(), r4 = e5.getPointArray(), n3 = _ColorHistogram$1._boxSize[0], a2 = _ColorHistogram$1._boxSize[1], o3 = n3 * a2, s4 = this._makeBoxes(t3, i2, n3, a2), l2 = this._histogram;
        s4.forEach((e6) => {
          let i3 = Math.round(e6.w * e6.h / o3) * _ColorHistogram$1._boxPixels;
          i3 < 2 && (i3 = 2);
          const n4 = {};
          this._iterateBox(e6, t3, (e7) => {
            const t4 = r4[e7].uint32;
            this._hueStats.check(t4), t4 in l2 ? l2[t4]++ : t4 in n4 ? ++n4[t4] >= i3 && (l2[t4] = n4[t4]) : n4[t4] = 1;
          });
        }), this._hueStats.injectIntoDictionary(l2);
      }
      _iterateBox(e5, t3, i2) {
        const r4 = e5, n3 = r4.y * t3 + r4.x, a2 = (r4.y + r4.h - 1) * t3 + (r4.x + r4.w - 1), o3 = t3 - r4.w + 1;
        let s4 = 0, l2 = n3;
        do {
          i2.call(this, l2), l2 += ++s4 % r4.w == 0 ? o3 : 1;
        } while (l2 <= a2);
      }
      _makeBoxes(e5, t3, i2, r4) {
        const n3 = e5 % i2, a2 = t3 % r4, o3 = e5 - n3, s4 = t3 - a2, l2 = [];
        for (let u2 = 0; u2 < t3; u2 += r4) for (let t4 = 0; t4 < e5; t4 += i2) l2.push({ x: t4, y: u2, w: t4 === o3 ? n3 : i2, h: u2 === s4 ? a2 : r4 });
        return l2;
      }
    };
    ColorHistogram$1 = _ColorHistogram$1;
    __publicField$3(ColorHistogram$1, "_boxSize", [64, 64]), __publicField$3(ColorHistogram$1, "_boxPixels", 2), __publicField$3(ColorHistogram$1, "_hueGroups", 10);
    RemovedColor$1 = class {
      static {
        __name(this, "RemovedColor$1");
      }
      constructor(e5, t3, i2) {
        __publicField$3(this, "index"), __publicField$3(this, "color"), __publicField$3(this, "distance"), this.index = e5, this.color = t3, this.distance = i2;
      }
    };
    RGBQuant$1 = class extends AbstractPaletteQuantizer$1 {
      static {
        __name(this, "RGBQuant$1");
      }
      constructor(e5, t3 = 256, i2 = 2) {
        super(), __publicField$3(this, "_colors"), __publicField$3(this, "_initialDistance"), __publicField$3(this, "_distanceIncrement"), __publicField$3(this, "_histogram"), __publicField$3(this, "_distance"), this._distance = e5, this._colors = t3, this._histogram = new ColorHistogram$1(i2, t3), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
      }
      sample(e5) {
        this._histogram.sample(e5);
      }
      *quantize() {
        const e5 = this._histogram.getImportanceSortedColorsIDXI32();
        if (0 === e5.length) throw new Error("No colors in image");
        yield* this._buildPalette(e5);
      }
      *_buildPalette(e5) {
        const t3 = new Palette$1(), i2 = t3.getPointContainer().getPointArray(), r4 = new Array(e5.length);
        for (let t4 = 0; t4 < e5.length; t4++) i2.push(Point$1.createByUint32(e5[t4])), r4[t4] = 1;
        const n3 = i2.length, a2 = [];
        let o3 = n3, s4 = this._initialDistance;
        const l2 = new ProgressTracker$1(o3 - this._colors, 99);
        for (; o3 > this._colors; ) {
          a2.length = 0;
          for (let e6 = 0; e6 < n3; e6++) {
            if (l2.shouldNotify(n3 - o3) && (yield { progress: l2.progress }), 0 === r4[e6]) continue;
            const t4 = i2[e6];
            for (let l3 = e6 + 1; l3 < n3; l3++) {
              if (0 === r4[l3]) continue;
              const e7 = i2[l3], n4 = this._distance.calculateNormalized(t4, e7);
              n4 < s4 && (a2.push(new RemovedColor$1(l3, e7, n4)), r4[l3] = 0, o3--);
            }
          }
          s4 += o3 > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
        }
        if (o3 < this._colors) {
          stableSort$1(a2, (e7, t4) => t4.distance - e7.distance);
          let e6 = 0;
          for (; o3 < this._colors && e6 < a2.length; ) {
            r4[a2[e6].index] = 1, o3++, e6++;
          }
        }
        let u2 = i2.length;
        for (let e6 = u2 - 1; e6 >= 0; e6--) 0 === r4[e6] && (e6 !== u2 - 1 && (i2[e6] = i2[u2 - 1]), --u2);
        i2.length = u2, t3.sort(), yield { palette: t3, progress: 100 };
      }
    };
    __name(createArray1D$1, "createArray1D$1");
    __name(createArray4D$1, "createArray4D$1");
    __name(createArray3D$1, "createArray3D$1");
    __name(fillArray3D$1, "fillArray3D$1");
    __name(fillArray1D$1, "fillArray1D$1");
    WuColorCube$1 = class {
      static {
        __name(this, "WuColorCube$1");
      }
      constructor() {
        __publicField$3(this, "redMinimum"), __publicField$3(this, "redMaximum"), __publicField$3(this, "greenMinimum"), __publicField$3(this, "greenMaximum"), __publicField$3(this, "blueMinimum"), __publicField$3(this, "blueMaximum"), __publicField$3(this, "volume"), __publicField$3(this, "alphaMinimum"), __publicField$3(this, "alphaMaximum");
      }
    };
    _WuQuant$1 = class extends AbstractPaletteQuantizer$1 {
      static {
        __name(this, "_WuQuant$1");
      }
      constructor(e5, t3 = 256, i2 = 5) {
        super(), __publicField$3(this, "_reds"), __publicField$3(this, "_greens"), __publicField$3(this, "_blues"), __publicField$3(this, "_alphas"), __publicField$3(this, "_sums"), __publicField$3(this, "_weights"), __publicField$3(this, "_momentsRed"), __publicField$3(this, "_momentsGreen"), __publicField$3(this, "_momentsBlue"), __publicField$3(this, "_momentsAlpha"), __publicField$3(this, "_moments"), __publicField$3(this, "_table"), __publicField$3(this, "_pixels"), __publicField$3(this, "_cubes"), __publicField$3(this, "_colors"), __publicField$3(this, "_significantBitsPerChannel"), __publicField$3(this, "_maxSideIndex"), __publicField$3(this, "_alphaMaxSideIndex"), __publicField$3(this, "_sideSize"), __publicField$3(this, "_alphaSideSize"), __publicField$3(this, "_distance"), this._distance = e5, this._setQuality(i2), this._initialize(t3);
      }
      sample(e5) {
        const t3 = e5.getPointArray();
        for (let e6 = 0, i2 = t3.length; e6 < i2; e6++) this._addColor(t3[e6]);
        this._pixels = this._pixels.concat(t3);
      }
      *quantize() {
        yield* this._preparePalette();
        const e5 = new Palette$1();
        for (let t3 = 0; t3 < this._colors; t3++) if (this._sums[t3] > 0) {
          const i2 = this._sums[t3], r4 = this._reds[t3] / i2, n3 = this._greens[t3] / i2, a2 = this._blues[t3] / i2, o3 = this._alphas[t3] / i2, s4 = Point$1.createByRGBA(0 | r4, 0 | n3, 0 | a2, 0 | o3);
          e5.add(s4);
        }
        e5.sort(), yield { palette: e5, progress: 100 };
      }
      *_preparePalette() {
        yield* this._calculateMoments();
        let e5 = 0;
        const t3 = createArray1D$1(this._colors);
        for (let i3 = 1; i3 < this._colors; ++i3) {
          this._cut(this._cubes[e5], this._cubes[i3]) ? (t3[e5] = this._cubes[e5].volume > 1 ? this._calculateVariance(this._cubes[e5]) : 0, t3[i3] = this._cubes[i3].volume > 1 ? this._calculateVariance(this._cubes[i3]) : 0) : (t3[e5] = 0, i3--), e5 = 0;
          let r5 = t3[0];
          for (let n4 = 1; n4 <= i3; ++n4) t3[n4] > r5 && (r5 = t3[n4], e5 = n4);
          if (r5 <= 0) {
            this._colors = i3 + 1;
            break;
          }
        }
        const i2 = [], r4 = [], n3 = [], a2 = [];
        for (let e6 = 0; e6 < this._colors; ++e6) {
          const t4 = _WuQuant$1._volume(this._cubes[e6], this._weights);
          t4 > 0 ? (i2[e6] = _WuQuant$1._volume(this._cubes[e6], this._momentsRed) / t4 | 0, r4[e6] = _WuQuant$1._volume(this._cubes[e6], this._momentsGreen) / t4 | 0, n3[e6] = _WuQuant$1._volume(this._cubes[e6], this._momentsBlue) / t4 | 0, a2[e6] = _WuQuant$1._volume(this._cubes[e6], this._momentsAlpha) / t4 | 0) : (i2[e6] = 0, r4[e6] = 0, n3[e6] = 0, a2[e6] = 0);
        }
        this._reds = createArray1D$1(this._colors + 1), this._greens = createArray1D$1(this._colors + 1), this._blues = createArray1D$1(this._colors + 1), this._alphas = createArray1D$1(this._colors + 1), this._sums = createArray1D$1(this._colors + 1);
        for (let e6 = 0, t4 = this._pixels.length; e6 < t4; e6++) {
          const t5 = this._pixels[e6];
          let o3 = -1, s4 = Number.MAX_VALUE;
          for (let e7 = 0; e7 < this._colors; e7++) {
            const l2 = i2[e7], u2 = r4[e7], h2 = n3[e7], c3 = a2[e7], f2 = this._distance.calculateRaw(l2, u2, h2, c3, t5.r, t5.g, t5.b, t5.a);
            f2 < s4 && (s4 = f2, o3 = e7);
          }
          this._reds[o3] += t5.r, this._greens[o3] += t5.g, this._blues[o3] += t5.b, this._alphas[o3] += t5.a, this._sums[o3]++;
        }
      }
      _addColor(e5) {
        const t3 = 8 - this._significantBitsPerChannel, i2 = 1 + (e5.r >> t3), r4 = 1 + (e5.g >> t3), n3 = 1 + (e5.b >> t3), a2 = 1 + (e5.a >> t3);
        this._weights[a2][i2][r4][n3]++, this._momentsRed[a2][i2][r4][n3] += e5.r, this._momentsGreen[a2][i2][r4][n3] += e5.g, this._momentsBlue[a2][i2][r4][n3] += e5.b, this._momentsAlpha[a2][i2][r4][n3] += e5.a, this._moments[a2][i2][r4][n3] += this._table[e5.r] + this._table[e5.g] + this._table[e5.b] + this._table[e5.a];
      }
      *_calculateMoments() {
        const e5 = [], t3 = [], i2 = [], r4 = [], n3 = [], a2 = [], o3 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), s4 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), l2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), u2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), h2 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize), c3 = createArray3D$1(this._sideSize, this._sideSize, this._sideSize);
        let f2 = 0;
        const d = new ProgressTracker$1(this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let p2 = 1; p2 <= this._alphaMaxSideIndex; ++p2) {
          fillArray3D$1(o3, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(s4, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(l2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(u2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(h2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D$1(c3, this._sideSize, this._sideSize, this._sideSize, 0);
          for (let m = 1; m <= this._maxSideIndex; ++m, ++f2) {
            d.shouldNotify(f2) && (yield { progress: d.progress }), fillArray1D$1(e5, this._sideSize, 0), fillArray1D$1(t3, this._sideSize, 0), fillArray1D$1(i2, this._sideSize, 0), fillArray1D$1(r4, this._sideSize, 0), fillArray1D$1(n3, this._sideSize, 0), fillArray1D$1(a2, this._sideSize, 0);
            for (let f3 = 1; f3 <= this._maxSideIndex; ++f3) {
              let d2 = 0, _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0;
              for (let v2 = 1; v2 <= this._maxSideIndex; ++v2) d2 += this._weights[p2][m][f3][v2], _2 += this._momentsRed[p2][m][f3][v2], g += this._momentsGreen[p2][m][f3][v2], b2 += this._momentsBlue[p2][m][f3][v2], y2 += this._momentsAlpha[p2][m][f3][v2], w += this._moments[p2][m][f3][v2], e5[v2] += d2, t3[v2] += _2, i2[v2] += g, r4[v2] += b2, n3[v2] += y2, a2[v2] += w, o3[m][f3][v2] = o3[m - 1][f3][v2] + e5[v2], s4[m][f3][v2] = s4[m - 1][f3][v2] + t3[v2], l2[m][f3][v2] = l2[m - 1][f3][v2] + i2[v2], u2[m][f3][v2] = u2[m - 1][f3][v2] + r4[v2], h2[m][f3][v2] = h2[m - 1][f3][v2] + n3[v2], c3[m][f3][v2] = c3[m - 1][f3][v2] + a2[v2], this._weights[p2][m][f3][v2] = this._weights[p2 - 1][m][f3][v2] + o3[m][f3][v2], this._momentsRed[p2][m][f3][v2] = this._momentsRed[p2 - 1][m][f3][v2] + s4[m][f3][v2], this._momentsGreen[p2][m][f3][v2] = this._momentsGreen[p2 - 1][m][f3][v2] + l2[m][f3][v2], this._momentsBlue[p2][m][f3][v2] = this._momentsBlue[p2 - 1][m][f3][v2] + u2[m][f3][v2], this._momentsAlpha[p2][m][f3][v2] = this._momentsAlpha[p2 - 1][m][f3][v2] + h2[m][f3][v2], this._moments[p2][m][f3][v2] = this._moments[p2 - 1][m][f3][v2] + c3[m][f3][v2];
            }
          }
        }
      }
      static _volumeFloat(e5, t3) {
        return t3[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] - t3[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] - t3[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] + t3[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - t3[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] + t3[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] + t3[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] - t3[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (t3[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] - t3[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] - t3[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + t3[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] - t3[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + t3[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + t3[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] - t3[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
      }
      static _volume(e5, t3) {
        return 0 | _WuQuant$1._volumeFloat(e5, t3);
      }
      static _top(e5, t3, i2, r4) {
        let n3;
        switch (t3) {
          case _WuQuant$1._alpha:
            n3 = r4[i2][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] - r4[i2][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] - r4[i2][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] + r4[i2][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (r4[i2][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] - r4[i2][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] - r4[i2][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + r4[i2][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
            break;
          case _WuQuant$1._red:
            n3 = r4[e5.alphaMaximum][i2][e5.greenMaximum][e5.blueMaximum] - r4[e5.alphaMaximum][i2][e5.greenMinimum][e5.blueMaximum] - r4[e5.alphaMinimum][i2][e5.greenMaximum][e5.blueMaximum] + r4[e5.alphaMinimum][i2][e5.greenMinimum][e5.blueMaximum] - (r4[e5.alphaMaximum][i2][e5.greenMaximum][e5.blueMinimum] - r4[e5.alphaMaximum][i2][e5.greenMinimum][e5.blueMinimum] - r4[e5.alphaMinimum][i2][e5.greenMaximum][e5.blueMinimum] + r4[e5.alphaMinimum][i2][e5.greenMinimum][e5.blueMinimum]);
            break;
          case _WuQuant$1._green:
            n3 = r4[e5.alphaMaximum][e5.redMaximum][i2][e5.blueMaximum] - r4[e5.alphaMaximum][e5.redMinimum][i2][e5.blueMaximum] - r4[e5.alphaMinimum][e5.redMaximum][i2][e5.blueMaximum] + r4[e5.alphaMinimum][e5.redMinimum][i2][e5.blueMaximum] - (r4[e5.alphaMaximum][e5.redMaximum][i2][e5.blueMinimum] - r4[e5.alphaMaximum][e5.redMinimum][i2][e5.blueMinimum] - r4[e5.alphaMinimum][e5.redMaximum][i2][e5.blueMinimum] + r4[e5.alphaMinimum][e5.redMinimum][i2][e5.blueMinimum]);
            break;
          case _WuQuant$1._blue:
            n3 = r4[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][i2] - r4[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][i2] - r4[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][i2] + r4[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][i2] - (r4[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][i2] - r4[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][i2] - r4[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][i2] + r4[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][i2]);
            break;
          default:
            throw new Error("impossible");
        }
        return 0 | n3;
      }
      static _bottom(e5, t3, i2) {
        switch (t3) {
          case _WuQuant$1._alpha:
            return -i2[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (-i2[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          case _WuQuant$1._red:
            return -i2[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (-i2[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          case _WuQuant$1._green:
            return -i2[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (-i2[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          case _WuQuant$1._blue:
            return -i2[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] - (-i2[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          default:
            return 0;
        }
      }
      _calculateVariance(e5) {
        const t3 = _WuQuant$1._volume(e5, this._momentsRed), i2 = _WuQuant$1._volume(e5, this._momentsGreen), r4 = _WuQuant$1._volume(e5, this._momentsBlue), n3 = _WuQuant$1._volume(e5, this._momentsAlpha);
        return _WuQuant$1._volumeFloat(e5, this._moments) - (t3 * t3 + i2 * i2 + r4 * r4 + n3 * n3) / _WuQuant$1._volume(e5, this._weights);
      }
      _maximize(e5, t3, i2, r4, n3, a2, o3, s4, l2) {
        const u2 = 0 | _WuQuant$1._bottom(e5, t3, this._momentsRed), h2 = 0 | _WuQuant$1._bottom(e5, t3, this._momentsGreen), c3 = 0 | _WuQuant$1._bottom(e5, t3, this._momentsBlue), f2 = 0 | _WuQuant$1._bottom(e5, t3, this._momentsAlpha), d = 0 | _WuQuant$1._bottom(e5, t3, this._weights);
        let p2 = 0, m = -1;
        for (let _2 = i2; _2 < r4; ++_2) {
          let i3 = u2 + _WuQuant$1._top(e5, t3, _2, this._momentsRed), r5 = h2 + _WuQuant$1._top(e5, t3, _2, this._momentsGreen), g = c3 + _WuQuant$1._top(e5, t3, _2, this._momentsBlue), b2 = f2 + _WuQuant$1._top(e5, t3, _2, this._momentsAlpha), y2 = d + _WuQuant$1._top(e5, t3, _2, this._weights);
          if (0 !== y2) {
            let e6 = i3 * i3 + r5 * r5 + g * g + b2 * b2, t4 = e6 / y2;
            i3 = n3 - i3, r5 = a2 - r5, g = o3 - g, b2 = s4 - b2, y2 = l2 - y2, 0 !== y2 && (e6 = i3 * i3 + r5 * r5 + g * g + b2 * b2, t4 += e6 / y2, t4 > p2 && (p2 = t4, m = _2));
          }
        }
        return { max: p2, position: m };
      }
      _cut(e5, t3) {
        let i2;
        const r4 = _WuQuant$1._volume(e5, this._momentsRed), n3 = _WuQuant$1._volume(e5, this._momentsGreen), a2 = _WuQuant$1._volume(e5, this._momentsBlue), o3 = _WuQuant$1._volume(e5, this._momentsAlpha), s4 = _WuQuant$1._volume(e5, this._weights), l2 = this._maximize(e5, _WuQuant$1._red, e5.redMinimum + 1, e5.redMaximum, r4, n3, a2, o3, s4), u2 = this._maximize(e5, _WuQuant$1._green, e5.greenMinimum + 1, e5.greenMaximum, r4, n3, a2, o3, s4), h2 = this._maximize(e5, _WuQuant$1._blue, e5.blueMinimum + 1, e5.blueMaximum, r4, n3, a2, o3, s4), c3 = this._maximize(e5, _WuQuant$1._alpha, e5.alphaMinimum + 1, e5.alphaMaximum, r4, n3, a2, o3, s4);
        if (c3.max >= l2.max && c3.max >= u2.max && c3.max >= h2.max) {
          if (i2 = _WuQuant$1._alpha, c3.position < 0) return false;
        } else i2 = l2.max >= c3.max && l2.max >= u2.max && l2.max >= h2.max ? _WuQuant$1._red : u2.max >= c3.max && u2.max >= l2.max && u2.max >= h2.max ? _WuQuant$1._green : _WuQuant$1._blue;
        switch (t3.redMaximum = e5.redMaximum, t3.greenMaximum = e5.greenMaximum, t3.blueMaximum = e5.blueMaximum, t3.alphaMaximum = e5.alphaMaximum, i2) {
          case _WuQuant$1._red:
            t3.redMinimum = e5.redMaximum = l2.position, t3.greenMinimum = e5.greenMinimum, t3.blueMinimum = e5.blueMinimum, t3.alphaMinimum = e5.alphaMinimum;
            break;
          case _WuQuant$1._green:
            t3.greenMinimum = e5.greenMaximum = u2.position, t3.redMinimum = e5.redMinimum, t3.blueMinimum = e5.blueMinimum, t3.alphaMinimum = e5.alphaMinimum;
            break;
          case _WuQuant$1._blue:
            t3.blueMinimum = e5.blueMaximum = h2.position, t3.redMinimum = e5.redMinimum, t3.greenMinimum = e5.greenMinimum, t3.alphaMinimum = e5.alphaMinimum;
            break;
          case _WuQuant$1._alpha:
            t3.alphaMinimum = e5.alphaMaximum = c3.position, t3.blueMinimum = e5.blueMinimum, t3.redMinimum = e5.redMinimum, t3.greenMinimum = e5.greenMinimum;
        }
        return e5.volume = (e5.redMaximum - e5.redMinimum) * (e5.greenMaximum - e5.greenMinimum) * (e5.blueMaximum - e5.blueMinimum) * (e5.alphaMaximum - e5.alphaMinimum), t3.volume = (t3.redMaximum - t3.redMinimum) * (t3.greenMaximum - t3.greenMinimum) * (t3.blueMaximum - t3.blueMinimum) * (t3.alphaMaximum - t3.alphaMinimum), true;
      }
      _initialize(e5) {
        this._colors = e5, this._cubes = [];
        for (let t3 = 0; t3 < e5; t3++) this._cubes[t3] = new WuColorCube$1();
        this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D$1(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
        for (let e6 = 0; e6 < 256; ++e6) this._table[e6] = e6 * e6;
        this._pixels = [];
      }
      _setQuality(e5 = 5) {
        this._significantBitsPerChannel = e5, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
      }
    };
    WuQuant$1 = _WuQuant$1;
    __publicField$3(WuQuant$1, "_alpha", 3), __publicField$3(WuQuant$1, "_red", 2), __publicField$3(WuQuant$1, "_green", 1), __publicField$3(WuQuant$1, "_blue", 0);
    image_exports$1 = {};
    __export$1(image_exports$1, { AbstractImageQuantizer: /* @__PURE__ */ __name(() => AbstractImageQuantizer$1, "AbstractImageQuantizer"), ErrorDiffusionArray: /* @__PURE__ */ __name(() => ErrorDiffusionArray$1, "ErrorDiffusionArray"), ErrorDiffusionArrayKernel: /* @__PURE__ */ __name(() => ErrorDiffusionArrayKernel$1, "ErrorDiffusionArrayKernel"), ErrorDiffusionRiemersma: /* @__PURE__ */ __name(() => ErrorDiffusionRiemersma$1, "ErrorDiffusionRiemersma"), NearestColor: /* @__PURE__ */ __name(() => NearestColor$1, "NearestColor") });
    AbstractImageQuantizer$1 = class {
      static {
        __name(this, "AbstractImageQuantizer$1");
      }
      quantizeSync(e5, t3) {
        for (const i2 of this.quantize(e5, t3)) if (i2.pointContainer) return i2.pointContainer;
        throw new Error("unreachable");
      }
    };
    NearestColor$1 = class extends AbstractImageQuantizer$1 {
      static {
        __name(this, "NearestColor$1");
      }
      constructor(e5) {
        super(), __publicField$3(this, "_distance"), this._distance = e5;
      }
      *quantize(e5, t3) {
        const i2 = e5.getPointArray(), r4 = e5.getWidth(), n3 = e5.getHeight(), a2 = new ProgressTracker$1(n3, 99);
        for (let e6 = 0; e6 < n3; e6++) {
          a2.shouldNotify(e6) && (yield { progress: a2.progress });
          for (let n4 = 0, a3 = e6 * r4; n4 < r4; n4++, a3++) {
            const e7 = i2[a3];
            e7.from(t3.getNearestColor(this._distance, e7));
          }
        }
        yield { pointContainer: e5, progress: 100 };
      }
    };
    ErrorDiffusionArrayKernel$1 = ((e5) => (e5[e5.FloydSteinberg = 0] = "FloydSteinberg", e5[e5.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e5[e5.Stucki = 2] = "Stucki", e5[e5.Atkinson = 3] = "Atkinson", e5[e5.Jarvis = 4] = "Jarvis", e5[e5.Burkes = 5] = "Burkes", e5[e5.Sierra = 6] = "Sierra", e5[e5.TwoSierra = 7] = "TwoSierra", e5[e5.SierraLite = 8] = "SierraLite", e5))(ErrorDiffusionArrayKernel$1 || {});
    ErrorDiffusionArray$1 = class extends AbstractImageQuantizer$1 {
      static {
        __name(this, "ErrorDiffusionArray$1");
      }
      constructor(e5, t3, i2 = true, r4 = 0, n3 = false) {
        super(), __publicField$3(this, "_minColorDistance"), __publicField$3(this, "_serpentine"), __publicField$3(this, "_kernel"), __publicField$3(this, "_calculateErrorLikeGIMP"), __publicField$3(this, "_distance"), this._setKernel(t3), this._distance = e5, this._minColorDistance = r4, this._serpentine = i2, this._calculateErrorLikeGIMP = n3;
      }
      *quantize(e5, t3) {
        const i2 = e5.getPointArray(), r4 = new Point$1(), n3 = e5.getWidth(), a2 = e5.getHeight(), o3 = [];
        let s4 = 1, l2 = 1;
        for (const e6 of this._kernel) {
          const t4 = e6[2] + 1;
          l2 < t4 && (l2 = t4);
        }
        for (let e6 = 0; e6 < l2; e6++) this._fillErrorLine(o3[e6] = [], n3);
        const u2 = new ProgressTracker$1(a2, 99);
        for (let e6 = 0; e6 < a2; e6++) {
          u2.shouldNotify(e6) && (yield { progress: u2.progress }), this._serpentine && (s4 *= -1);
          const l3 = e6 * n3, h2 = 1 === s4 ? 0 : n3 - 1, c3 = 1 === s4 ? n3 : -1;
          this._fillErrorLine(o3[0], n3), o3.push(o3.shift());
          const f2 = o3[0];
          for (let u3 = h2, d = l3 + h2; u3 !== c3; u3 += s4, d += s4) {
            const l4 = i2[d], h3 = f2[u3];
            r4.from(l4);
            const c4 = Point$1.createByRGBA(inRange0to255Rounded$1(l4.r + h3[0]), inRange0to255Rounded$1(l4.g + h3[1]), inRange0to255Rounded$1(l4.b + h3[2]), inRange0to255Rounded$1(l4.a + h3[3])), p2 = t3.getNearestColor(this._distance, c4);
            if (l4.from(p2), this._minColorDistance) {
              if (this._distance.calculateNormalized(r4, p2) < this._minColorDistance) continue;
            }
            let m, _2, g, b2;
            this._calculateErrorLikeGIMP ? (m = c4.r - p2.r, _2 = c4.g - p2.g, g = c4.b - p2.b, b2 = c4.a - p2.a) : (m = r4.r - p2.r, _2 = r4.g - p2.g, g = r4.b - p2.b, b2 = r4.a - p2.a);
            const y2 = 1 === s4 ? 0 : this._kernel.length - 1, w = 1 === s4 ? this._kernel.length : -1;
            for (let t4 = y2; t4 !== w; t4 += s4) {
              const i3 = this._kernel[t4][1] * s4, r5 = this._kernel[t4][2];
              if (i3 + u3 >= 0 && i3 + u3 < n3 && r5 + e6 >= 0 && r5 + e6 < a2) {
                const e7 = this._kernel[t4][0], n4 = o3[r5][i3 + u3];
                n4[0] += m * e7, n4[1] += _2 * e7, n4[2] += g * e7, n4[3] += b2 * e7;
              }
            }
          }
        }
        yield { pointContainer: e5, progress: 100 };
      }
      _fillErrorLine(e5, t3) {
        e5.length > t3 && (e5.length = t3);
        const i2 = e5.length;
        for (let t4 = 0; t4 < i2; t4++) {
          const i3 = e5[t4];
          i3[0] = i3[1] = i3[2] = i3[3] = 0;
        }
        for (let r4 = i2; r4 < t3; r4++) e5[r4] = [0, 0, 0, 0];
      }
      _setKernel(e5) {
        switch (e5) {
          case 0:
            this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
            break;
          case 1:
            this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
            break;
          case 2:
            this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
            break;
          case 3:
            this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
            break;
          case 4:
            this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
            break;
          case 5:
            this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
            break;
          case 6:
            this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
            break;
          case 7:
            this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
            break;
          case 8:
            this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
            break;
          default:
            throw new Error(`ErrorDiffusionArray: unknown kernel = ${e5}`);
        }
      }
    };
    __name(hilbertCurve$1, "hilbertCurve$1");
    __name(walkHilbert$1, "walkHilbert$1");
    __name(visit$1, "visit$1");
    ErrorDiffusionRiemersma$1 = class extends AbstractImageQuantizer$1 {
      static {
        __name(this, "ErrorDiffusionRiemersma$1");
      }
      constructor(e5, t3 = 16, i2 = 1) {
        super(), __publicField$3(this, "_distance"), __publicField$3(this, "_weights"), __publicField$3(this, "_errorQueueSize"), this._distance = e5, this._errorQueueSize = t3, this._weights = ErrorDiffusionRiemersma$1._createWeights(i2, t3);
      }
      *quantize(e5, t3) {
        const i2 = e5.getPointArray(), r4 = e5.getWidth(), n3 = e5.getHeight(), a2 = [];
        let o3 = 0;
        for (let e6 = 0; e6 < this._errorQueueSize; e6++) a2[e6] = { r: 0, g: 0, b: 0, a: 0 };
        yield* hilbertCurve$1(r4, n3, (e6, n4) => {
          const s4 = i2[e6 + n4 * r4];
          let { r: l2, g: u2, b: h2, a: c3 } = s4;
          for (let e7 = 0; e7 < this._errorQueueSize; e7++) {
            const t4 = this._weights[e7], i3 = a2[(e7 + o3) % this._errorQueueSize];
            l2 += i3.r * t4, u2 += i3.g * t4, h2 += i3.b * t4, c3 += i3.a * t4;
          }
          const f2 = Point$1.createByRGBA(inRange0to255Rounded$1(l2), inRange0to255Rounded$1(u2), inRange0to255Rounded$1(h2), inRange0to255Rounded$1(c3)), d = t3.getNearestColor(this._distance, f2);
          o3 = (o3 + 1) % this._errorQueueSize;
          const p2 = (o3 + this._errorQueueSize - 1) % this._errorQueueSize;
          a2[p2].r = s4.r - d.r, a2[p2].g = s4.g - d.g, a2[p2].b = s4.b - d.b, a2[p2].a = s4.a - d.a, s4.from(d);
        }), yield { pointContainer: e5, progress: 100 };
      }
      static _createWeights(e5, t3) {
        const i2 = [], r4 = Math.exp(Math.log(t3) / (t3 - 1));
        for (let n3 = 0, a2 = 1; n3 < t3; n3++) i2[n3] = (a2 + 0.5 | 0) / t3 * e5, a2 *= r4;
        return i2;
      }
    };
    quality_exports$1 = {};
    __export$1(quality_exports$1, { ssim: /* @__PURE__ */ __name(() => ssim$1, "ssim") });
    K1$1 = 0.01;
    K2$1 = 0.03;
    __name(ssim$1, "ssim$1");
    __name(iterate$1, "iterate$1");
    __name(calculateLumaValuesForWindow$1, "calculateLumaValuesForWindow$1");
    __name(calculateAverageLuma$1, "calculateAverageLuma$1");
    setImmediateImpl = "function" == typeof setImmediate ? setImmediate : "undefined" != typeof process && "function" == typeof (null == process ? void 0 : process.nextTick) ? (e5) => process.nextTick(e5) : (e5) => setTimeout(e5, 0);
    __name(buildPaletteSync$1, "buildPaletteSync$1");
    __name(buildPalette, "buildPalette");
    __name(applyPaletteSync$1, "applyPaletteSync$1");
    __name(applyPalette, "applyPalette");
    __name(colorDistanceFormulaToColorDistance$1, "colorDistanceFormulaToColorDistance$1");
    __name(imageQuantizationToImageQuantizer$1, "imageQuantizationToImageQuantizer$1");
    __name(paletteQuantizationToPaletteQuantizer$1, "paletteQuantizationToPaletteQuantizer$1");
    imageQ = __toCommonJS(src_exports);
    gifframe = {};
    BitmapImage$1 = bitmapimage;
    GifFrame$1 = class e2 extends BitmapImage$1 {
      static {
        __name(this, "e");
      }
      constructor(...t3) {
        if (super(...t3), t3[0] instanceof e2) {
          const e5 = t3[0];
          this.xOffset = e5.xOffset, this.yOffset = e5.yOffset, this.disposalMethod = e5.disposalMethod, this.delayCentisecs = e5.delayCentisecs, this.interlaced = e5.interlaced;
        } else {
          const i2 = t3[t3.length - 1];
          let r4 = {};
          "object" != typeof i2 || i2 instanceof BitmapImage$1 || (r4 = i2), this.xOffset = r4.xOffset || 0, this.yOffset = r4.yOffset || 0, this.disposalMethod = void 0 !== r4.disposalMethod ? r4.disposalMethod : e2.DisposeToBackgroundColor, this.delayCentisecs = r4.delayCentisecs || 8, this.interlaced = r4.interlaced || false;
        }
      }
      getPalette() {
        const e5 = /* @__PURE__ */ new Set(), t3 = this.bitmap.data;
        let i2 = 0, r4 = false;
        for (; i2 < t3.length; ) {
          if (0 === t3[i2 + 3]) r4 = true;
          else {
            const r5 = t3.readUInt32BE(i2, true) >> 8 & 16777215;
            e5.add(r5);
          }
          i2 += 4;
        }
        const n3 = new Array(e5.size), a2 = e5.values();
        for (i2 = 0; i2 < n3.length; ++i2) n3[i2] = a2.next().value;
        n3.sort((e6, t4) => e6 - t4);
        let o3 = n3.length;
        return r4 && ++o3, { colors: n3, usesTransparency: r4, indexCount: o3 };
      }
    };
    __name(requireGifutil, "requireGifutil");
    __name(requireGifcodec, "requireGifcodec");
    GifFrame$1.DisposeToAnything = 0, GifFrame$1.DisposeNothing = 1, GifFrame$1.DisposeToBackgroundColor = 2, GifFrame$1.DisposeToPrevious = 3, gifframe.GifFrame = GifFrame$1;
    BitmapImage = bitmapimage;
    ({ Gif, GifError: GifError$1 } = gif$1);
    ({ GifCodec } = requireGifcodec());
    ({ GifFrame } = gifframe);
    GifUtil = requireGifutil();
    src = { BitmapImage, Gif, GifCodec, GifFrame, GifUtil, GifError: GifError$1 };
    __name(gif, "gif");
    encoder = { exports: {} };
    !function(e5) {
      function t3(e6) {
        var t4, i2, r4, n3, a2, o3 = Math.floor, s4 = new Array(64), l2 = new Array(64), u2 = new Array(64), h2 = new Array(64), c3 = new Array(65535), f2 = new Array(65535), d = new Array(64), p2 = new Array(64), m = [], _2 = 0, g = 7, b2 = new Array(64), y2 = new Array(64), w = new Array(64), v2 = new Array(256), x2 = new Array(2048), E2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], k2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], A2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], I = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], M2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], T2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], P = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], B2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
        function C2(e7, t5) {
          for (var i3 = 0, r5 = 0, n4 = new Array(), a3 = 1; a3 <= 16; a3++) {
            for (var o4 = 1; o4 <= e7[a3]; o4++) n4[t5[r5]] = [], n4[t5[r5]][0] = i3, n4[t5[r5]][1] = a3, r5++, i3++;
            i3 *= 2;
          }
          return n4;
        }
        __name(C2, "C");
        function R2(e7) {
          for (var t5 = e7[0], i3 = e7[1] - 1; i3 >= 0; ) t5 & 1 << i3 && (_2 |= 1 << g), i3--, --g < 0 && (255 == _2 ? (z2(255), z2(0)) : z2(_2), g = 7, _2 = 0);
        }
        __name(R2, "R");
        function z2(e7) {
          m.push(e7);
        }
        __name(z2, "z");
        function F(e7) {
          z2(e7 >> 8 & 255), z2(255 & e7);
        }
        __name(F, "F");
        function N2(e7, t5, i3, r5, n4) {
          for (var a3, o4 = n4[0], s5 = n4[240], l3 = function(e8, t6) {
            var i4, r6, n5, a4, o5, s6, l4, u4, h4, c4, f3 = 0;
            for (h4 = 0; h4 < 8; ++h4) {
              i4 = e8[f3], r6 = e8[f3 + 1], n5 = e8[f3 + 2], a4 = e8[f3 + 3], o5 = e8[f3 + 4], s6 = e8[f3 + 5], l4 = e8[f3 + 6];
              var p3 = i4 + (u4 = e8[f3 + 7]), m3 = i4 - u4, _4 = r6 + l4, g3 = r6 - l4, b4 = n5 + s6, y4 = n5 - s6, w3 = a4 + o5, v3 = a4 - o5, x3 = p3 + w3, E3 = p3 - w3, k3 = _4 + b4, S3 = _4 - b4;
              e8[f3] = x3 + k3, e8[f3 + 4] = x3 - k3;
              var A3 = 0.707106781 * (S3 + E3);
              e8[f3 + 2] = E3 + A3, e8[f3 + 6] = E3 - A3;
              var I2 = 0.382683433 * ((x3 = v3 + y4) - (S3 = g3 + m3)), M3 = 0.5411961 * x3 + I2, T3 = 1.306562965 * S3 + I2, P2 = 0.707106781 * (k3 = y4 + g3), B3 = m3 + P2, C3 = m3 - P2;
              e8[f3 + 5] = C3 + M3, e8[f3 + 3] = C3 - M3, e8[f3 + 1] = B3 + T3, e8[f3 + 7] = B3 - T3, f3 += 8;
            }
            for (f3 = 0, h4 = 0; h4 < 8; ++h4) {
              i4 = e8[f3], r6 = e8[f3 + 8], n5 = e8[f3 + 16], a4 = e8[f3 + 24], o5 = e8[f3 + 32], s6 = e8[f3 + 40], l4 = e8[f3 + 48];
              var R3 = i4 + (u4 = e8[f3 + 56]), z3 = i4 - u4, F2 = r6 + l4, N3 = r6 - l4, O3 = n5 + s6, D = n5 - s6, $ = a4 + o5, L2 = a4 - o5, U = R3 + $, Z = R3 - $, j = F2 + O3, G = F2 - O3;
              e8[f3] = U + j, e8[f3 + 32] = U - j;
              var H = 0.707106781 * (G + Z);
              e8[f3 + 16] = Z + H, e8[f3 + 48] = Z - H;
              var Q = 0.382683433 * ((U = L2 + D) - (G = N3 + z3)), W = 0.5411961 * U + Q, q = 1.306562965 * G + Q, V = 0.707106781 * (j = D + N3), Y2 = z3 + V, K = z3 - V;
              e8[f3 + 40] = K + W, e8[f3 + 24] = K - W, e8[f3 + 8] = Y2 + q, e8[f3 + 56] = Y2 - q, f3++;
            }
            for (h4 = 0; h4 < 64; ++h4) c4 = e8[h4] * t6[h4], d[h4] = c4 > 0 ? c4 + 0.5 | 0 : c4 - 0.5 | 0;
            return d;
          }(e7, t5), u3 = 0; u3 < 64; ++u3) p2[E2[u3]] = l3[u3];
          var h3 = p2[0] - i3;
          i3 = p2[0], 0 == h3 ? R2(r5[0]) : (R2(r5[f2[a3 = 32767 + h3]]), R2(c3[a3]));
          for (var m2 = 63; m2 > 0 && 0 == p2[m2]; m2--) ;
          if (0 == m2) return R2(o4), i3;
          for (var _3, g2 = 1; g2 <= m2; ) {
            for (var b3 = g2; 0 == p2[g2] && g2 <= m2; ++g2) ;
            var y3 = g2 - b3;
            if (y3 >= 16) {
              _3 = y3 >> 4;
              for (var w2 = 1; w2 <= _3; ++w2) R2(s5);
              y3 &= 15;
            }
            a3 = 32767 + p2[g2], R2(n4[(y3 << 4) + f2[a3]]), R2(c3[a3]), g2++;
          }
          return 63 != m2 && R2(o4), i3;
        }
        __name(N2, "N");
        function O2(e7) {
          if (e7 <= 0 && (e7 = 1), e7 > 100 && (e7 = 100), a2 != e7) {
            (function(e8) {
              for (var t5 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], i3 = 0; i3 < 64; i3++) {
                var r5 = o3((t5[i3] * e8 + 50) / 100);
                r5 < 1 ? r5 = 1 : r5 > 255 && (r5 = 255), s4[E2[i3]] = r5;
              }
              for (var n4 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
                var c4 = o3((n4[a3] * e8 + 50) / 100);
                c4 < 1 ? c4 = 1 : c4 > 255 && (c4 = 255), l2[E2[a3]] = c4;
              }
              for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d2 = 0, p3 = 0; p3 < 8; p3++) for (var m2 = 0; m2 < 8; m2++) u2[d2] = 1 / (s4[E2[d2]] * f3[p3] * f3[m2] * 8), h2[d2] = 1 / (l2[E2[d2]] * f3[p3] * f3[m2] * 8), d2++;
            })(e7 < 50 ? Math.floor(5e3 / e7) : Math.floor(200 - 2 * e7)), a2 = e7;
          }
        }
        __name(O2, "O");
        this.encode = function(e7, a3) {
          var o4;
          (/* @__PURE__ */ new Date()).getTime(), a3 && O2(a3), m = new Array(), _2 = 0, g = 7, F(65496), F(65504), F(16), z2(74), z2(70), z2(73), z2(70), z2(0), z2(1), z2(1), z2(0), F(1), F(1), z2(0), z2(0), void 0 !== (o4 = e7.comments) && o4.constructor === Array && o4.forEach((e8) => {
            if ("string" == typeof e8) {
              F(65534);
              var t5, i3 = e8.length;
              for (F(i3 + 2), t5 = 0; t5 < i3; t5++) z2(e8.charCodeAt(t5));
            }
          }), function(e8) {
            if (e8) {
              F(65505), 69 === e8[0] && 120 === e8[1] && 105 === e8[2] && 102 === e8[3] ? F(e8.length + 2) : (F(e8.length + 5 + 2), z2(69), z2(120), z2(105), z2(102), z2(0));
              for (var t5 = 0; t5 < e8.length; t5++) z2(e8[t5]);
            }
          }(e7.exifBuffer), function() {
            F(65499), F(132), z2(0);
            for (var e8 = 0; e8 < 64; e8++) z2(s4[e8]);
            z2(1);
            for (var t5 = 0; t5 < 64; t5++) z2(l2[t5]);
          }(), function(e8, t5) {
            F(65472), F(17), z2(8), F(t5), F(e8), z2(3), z2(1), z2(17), z2(0), z2(2), z2(17), z2(1), z2(3), z2(17), z2(1);
          }(e7.width, e7.height), function() {
            F(65476), F(418), z2(0);
            for (var e8 = 0; e8 < 16; e8++) z2(k2[e8 + 1]);
            for (var t5 = 0; t5 <= 11; t5++) z2(S2[t5]);
            z2(16);
            for (var i3 = 0; i3 < 16; i3++) z2(A2[i3 + 1]);
            for (var r5 = 0; r5 <= 161; r5++) z2(I[r5]);
            z2(1);
            for (var n4 = 0; n4 < 16; n4++) z2(M2[n4 + 1]);
            for (var a4 = 0; a4 <= 11; a4++) z2(T2[a4]);
            z2(17);
            for (var o5 = 0; o5 < 16; o5++) z2(P[o5 + 1]);
            for (var s5 = 0; s5 <= 161; s5++) z2(B2[s5]);
          }(), F(65498), F(12), z2(3), z2(1), z2(0), z2(2), z2(17), z2(3), z2(17), z2(0), z2(63), z2(0);
          var c4 = 0, f3 = 0, d2 = 0;
          _2 = 0, g = 7, this.encode.displayName = "_encode_";
          for (var p3, v3, E3, C3, D, $, L2, U, Z, j = e7.data, G = e7.width, H = e7.height, Q = 4 * G, W = 0; W < H; ) {
            for (p3 = 0; p3 < Q; ) {
              for ($ = D = Q * W + p3, L2 = -1, U = 0, Z = 0; Z < 64; Z++) $ = D + (U = Z >> 3) * Q + (L2 = 4 * (7 & Z)), W + U >= H && ($ -= Q * (W + 1 + U - H)), p3 + L2 >= Q && ($ -= p3 + L2 - Q + 4), v3 = j[$++], E3 = j[$++], C3 = j[$++], b2[Z] = (x2[v3] + x2[E3 + 256 | 0] + x2[C3 + 512 | 0] >> 16) - 128, y2[Z] = (x2[v3 + 768 | 0] + x2[E3 + 1024 | 0] + x2[C3 + 1280 | 0] >> 16) - 128, w[Z] = (x2[v3 + 1280 | 0] + x2[E3 + 1536 | 0] + x2[C3 + 1792 | 0] >> 16) - 128;
              c4 = N2(b2, u2, c4, t4, r4), f3 = N2(y2, h2, f3, i2, n3), d2 = N2(w, h2, d2, i2, n3), p3 += 32;
            }
            W += 8;
          }
          if (g >= 0) {
            var q = [];
            q[1] = g + 1, q[0] = (1 << g + 1) - 1, R2(q);
          }
          return F(65497), Buffer2.from(m);
        }, (/* @__PURE__ */ new Date()).getTime(), e6 || (e6 = 50), function() {
          for (var e7 = String.fromCharCode, t5 = 0; t5 < 256; t5++) v2[t5] = e7(t5);
        }(), t4 = C2(k2, S2), i2 = C2(M2, T2), r4 = C2(A2, I), n3 = C2(P, B2), function() {
          for (var e7 = 1, t5 = 2, i3 = 1; i3 <= 15; i3++) {
            for (var r5 = e7; r5 < t5; r5++) f2[32767 + r5] = i3, c3[32767 + r5] = [], c3[32767 + r5][1] = i3, c3[32767 + r5][0] = r5;
            for (var n4 = -(t5 - 1); n4 <= -e7; n4++) f2[32767 + n4] = i3, c3[32767 + n4] = [], c3[32767 + n4][1] = i3, c3[32767 + n4][0] = t5 - 1 + n4;
            e7 <<= 1, t5 <<= 1;
          }
        }(), function() {
          for (var e7 = 0; e7 < 256; e7++) x2[e7] = 19595 * e7, x2[e7 + 256 | 0] = 38470 * e7, x2[e7 + 512 | 0] = 7471 * e7 + 32768, x2[e7 + 768 | 0] = -11059 * e7, x2[e7 + 1024 | 0] = -21709 * e7, x2[e7 + 1280 | 0] = 32768 * e7 + 8421375, x2[e7 + 1536 | 0] = -27439 * e7, x2[e7 + 1792 | 0] = -5329 * e7;
        }(), O2(e6), (/* @__PURE__ */ new Date()).getTime();
      }
      __name(t3, "t");
      encoder.exports = function(e6, i2) {
        void 0 === i2 && (i2 = 50);
        var r4 = new t3(i2), n3 = r4.encode(e6, i2);
        return { data: n3, width: e6.width, height: e6.height };
      };
    }();
    encoderExports = encoder.exports;
    decoder = { exports: {} };
    module = decoder, JpegImage = function() {
      var e5 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t3 = 4017, i2 = 799, r4 = 3406, n3 = 2276, a2 = 1567, o3 = 3784, s4 = 5793, l2 = 2896;
      function u2() {
      }
      __name(u2, "u");
      function h2(e6, t4) {
        for (var i3, r5, n4 = 0, a3 = [], o4 = 16; o4 > 0 && !e6[o4 - 1]; ) o4--;
        a3.push({ children: [], index: 0 });
        var s5, l3 = a3[0];
        for (i3 = 0; i3 < o4; i3++) {
          for (r5 = 0; r5 < e6[i3]; r5++) {
            for ((l3 = a3.pop()).children[l3.index] = t4[n4]; l3.index > 0; ) {
              if (0 === a3.length) throw new Error("Could not recreate Huffman Table");
              l3 = a3.pop();
            }
            for (l3.index++, a3.push(l3); a3.length <= i3; ) a3.push(s5 = { children: [], index: 0 }), l3.children[l3.index] = s5.children, l3 = s5;
            n4++;
          }
          i3 + 1 < o4 && (a3.push(s5 = { children: [], index: 0 }), l3.children[l3.index] = s5.children, l3 = s5);
        }
        return a3[0].children;
      }
      __name(h2, "h");
      function c3(t4, i3, r5, n4, a3, o4, s5, l3, u3, h3) {
        r5.precision, r5.samplesPerLine, r5.scanLines;
        var c4 = r5.mcusPerLine, f3 = r5.progressive;
        r5.maxH, r5.maxV;
        var d2 = i3, p3 = 0, m2 = 0;
        function _3() {
          if (m2 > 0) return m2--, p3 >> m2 & 1;
          if (255 == (p3 = t4[i3++])) {
            var e6 = t4[i3++];
            if (e6) throw new Error("unexpected marker: " + (p3 << 8 | e6).toString(16));
          }
          return m2 = 7, p3 >>> 7;
        }
        __name(_3, "_");
        function g(e6) {
          for (var t5, i4 = e6; null !== (t5 = _3()); ) {
            if ("number" == typeof (i4 = i4[t5])) return i4;
            if ("object" != typeof i4) throw new Error("invalid huffman sequence");
          }
          return null;
        }
        __name(g, "g");
        function b2(e6) {
          for (var t5 = 0; e6 > 0; ) {
            var i4 = _3();
            if (null === i4) return;
            t5 = t5 << 1 | i4, e6--;
          }
          return t5;
        }
        __name(b2, "b");
        function y2(e6) {
          var t5 = b2(e6);
          return t5 >= 1 << e6 - 1 ? t5 : t5 + (-1 << e6) + 1;
        }
        __name(y2, "y");
        var w, v2 = 0, x2 = 0;
        function E2(e6, t5, i4, r6, n5) {
          var a4 = i4 % c4, o5 = (i4 / c4 | 0) * e6.v + r6, s6 = a4 * e6.h + n5;
          void 0 === e6.blocks[o5] && h3.tolerantDecoding || t5(e6, e6.blocks[o5][s6]);
        }
        __name(E2, "E");
        function k2(e6, t5, i4) {
          var r6 = i4 / e6.blocksPerLine | 0, n5 = i4 % e6.blocksPerLine;
          void 0 === e6.blocks[r6] && h3.tolerantDecoding || t5(e6, e6.blocks[r6][n5]);
        }
        __name(k2, "k");
        var S2, A2, I, M2, T2, P, B2 = n4.length;
        P = f3 ? 0 === o4 ? 0 === l3 ? function(e6, t5) {
          var i4 = g(e6.huffmanTableDC), r6 = 0 === i4 ? 0 : y2(i4) << u3;
          t5[0] = e6.pred += r6;
        } : function(e6, t5) {
          t5[0] |= _3() << u3;
        } : 0 === l3 ? function(t5, i4) {
          if (v2 > 0) v2--;
          else for (var r6 = o4, n5 = s5; r6 <= n5; ) {
            var a4 = g(t5.huffmanTableAC), l4 = 15 & a4, h4 = a4 >> 4;
            if (0 !== l4) i4[e5[r6 += h4]] = y2(l4) * (1 << u3), r6++;
            else {
              if (h4 < 15) {
                v2 = b2(h4) + (1 << h4) - 1;
                break;
              }
              r6 += 16;
            }
          }
        } : function(t5, i4) {
          for (var r6 = o4, n5 = s5, a4 = 0; r6 <= n5; ) {
            var l4 = e5[r6], h4 = i4[l4] < 0 ? -1 : 1;
            switch (x2) {
              case 0:
                var c5 = g(t5.huffmanTableAC), f4 = 15 & c5;
                if (a4 = c5 >> 4, 0 === f4) a4 < 15 ? (v2 = b2(a4) + (1 << a4), x2 = 4) : (a4 = 16, x2 = 1);
                else {
                  if (1 !== f4) throw new Error("invalid ACn encoding");
                  w = y2(f4), x2 = a4 ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                i4[l4] ? i4[l4] += (_3() << u3) * h4 : 0 == --a4 && (x2 = 2 == x2 ? 3 : 0);
                break;
              case 3:
                i4[l4] ? i4[l4] += (_3() << u3) * h4 : (i4[l4] = w << u3, x2 = 0);
                break;
              case 4:
                i4[l4] && (i4[l4] += (_3() << u3) * h4);
            }
            r6++;
          }
          4 === x2 && 0 == --v2 && (x2 = 0);
        } : function(t5, i4) {
          var r6 = g(t5.huffmanTableDC), n5 = 0 === r6 ? 0 : y2(r6);
          i4[0] = t5.pred += n5;
          for (var a4 = 1; a4 < 64; ) {
            var o5 = g(t5.huffmanTableAC), s6 = 15 & o5, l4 = o5 >> 4;
            if (0 !== s6) i4[e5[a4 += l4]] = y2(s6), a4++;
            else {
              if (l4 < 15) break;
              a4 += 16;
            }
          }
        };
        var C2, R2, z2, F, N2 = 0;
        for (R2 = 1 == B2 ? n4[0].blocksPerLine * n4[0].blocksPerColumn : c4 * r5.mcusPerColumn, a3 || (a3 = R2); N2 < R2; ) {
          for (A2 = 0; A2 < B2; A2++) n4[A2].pred = 0;
          if (v2 = 0, 1 == B2) for (S2 = n4[0], T2 = 0; T2 < a3; T2++) k2(S2, P, N2), N2++;
          else for (T2 = 0; T2 < a3; T2++) {
            for (A2 = 0; A2 < B2; A2++) for (z2 = (S2 = n4[A2]).h, F = S2.v, I = 0; I < F; I++) for (M2 = 0; M2 < z2; M2++) E2(S2, P, N2, I, M2);
            if (++N2 === R2) break;
          }
          if (N2 === R2) do {
            if (255 === t4[i3] && 0 !== t4[i3 + 1]) break;
            i3 += 1;
          } while (i3 < t4.length - 2);
          if (m2 = 0, (C2 = t4[i3] << 8 | t4[i3 + 1]) < 65280) throw new Error("marker was not found");
          if (!(C2 >= 65488 && C2 <= 65495)) break;
          i3 += 2;
        }
        return i3 - d2;
      }
      __name(c3, "c");
      function f2(e6, u3) {
        var h3, c4, f3 = [], d2 = u3.blocksPerLine, p3 = u3.blocksPerColumn, m2 = d2 << 3, g = new Int32Array(64), b2 = new Uint8Array(64);
        function y2(e7, h4, c5) {
          var f4, d3, p4, m3, _3, g2, b3, y3, w2, v3, x3 = u3.quantizationTable, E3 = c5;
          for (v3 = 0; v3 < 64; v3++) E3[v3] = e7[v3] * x3[v3];
          for (v3 = 0; v3 < 8; ++v3) {
            var k3 = 8 * v3;
            0 != E3[1 + k3] || 0 != E3[2 + k3] || 0 != E3[3 + k3] || 0 != E3[4 + k3] || 0 != E3[5 + k3] || 0 != E3[6 + k3] || 0 != E3[7 + k3] ? (f4 = s4 * E3[0 + k3] + 128 >> 8, d3 = s4 * E3[4 + k3] + 128 >> 8, p4 = E3[2 + k3], m3 = E3[6 + k3], _3 = l2 * (E3[1 + k3] - E3[7 + k3]) + 128 >> 8, y3 = l2 * (E3[1 + k3] + E3[7 + k3]) + 128 >> 8, g2 = E3[3 + k3] << 4, b3 = E3[5 + k3] << 4, w2 = f4 - d3 + 1 >> 1, f4 = f4 + d3 + 1 >> 1, d3 = w2, w2 = p4 * o3 + m3 * a2 + 128 >> 8, p4 = p4 * a2 - m3 * o3 + 128 >> 8, m3 = w2, w2 = _3 - b3 + 1 >> 1, _3 = _3 + b3 + 1 >> 1, b3 = w2, w2 = y3 + g2 + 1 >> 1, g2 = y3 - g2 + 1 >> 1, y3 = w2, w2 = f4 - m3 + 1 >> 1, f4 = f4 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p4 + 1 >> 1, d3 = d3 + p4 + 1 >> 1, p4 = w2, w2 = _3 * n3 + y3 * r4 + 2048 >> 12, _3 = _3 * r4 - y3 * n3 + 2048 >> 12, y3 = w2, w2 = g2 * i2 + b3 * t3 + 2048 >> 12, g2 = g2 * t3 - b3 * i2 + 2048 >> 12, b3 = w2, E3[0 + k3] = f4 + y3, E3[7 + k3] = f4 - y3, E3[1 + k3] = d3 + b3, E3[6 + k3] = d3 - b3, E3[2 + k3] = p4 + g2, E3[5 + k3] = p4 - g2, E3[3 + k3] = m3 + _3, E3[4 + k3] = m3 - _3) : (w2 = s4 * E3[0 + k3] + 512 >> 10, E3[0 + k3] = w2, E3[1 + k3] = w2, E3[2 + k3] = w2, E3[3 + k3] = w2, E3[4 + k3] = w2, E3[5 + k3] = w2, E3[6 + k3] = w2, E3[7 + k3] = w2);
          }
          for (v3 = 0; v3 < 8; ++v3) {
            var S3 = v3;
            0 != E3[8 + S3] || 0 != E3[16 + S3] || 0 != E3[24 + S3] || 0 != E3[32 + S3] || 0 != E3[40 + S3] || 0 != E3[48 + S3] || 0 != E3[56 + S3] ? (f4 = s4 * E3[0 + S3] + 2048 >> 12, d3 = s4 * E3[32 + S3] + 2048 >> 12, p4 = E3[16 + S3], m3 = E3[48 + S3], _3 = l2 * (E3[8 + S3] - E3[56 + S3]) + 2048 >> 12, y3 = l2 * (E3[8 + S3] + E3[56 + S3]) + 2048 >> 12, g2 = E3[24 + S3], b3 = E3[40 + S3], w2 = f4 - d3 + 1 >> 1, f4 = f4 + d3 + 1 >> 1, d3 = w2, w2 = p4 * o3 + m3 * a2 + 2048 >> 12, p4 = p4 * a2 - m3 * o3 + 2048 >> 12, m3 = w2, w2 = _3 - b3 + 1 >> 1, _3 = _3 + b3 + 1 >> 1, b3 = w2, w2 = y3 + g2 + 1 >> 1, g2 = y3 - g2 + 1 >> 1, y3 = w2, w2 = f4 - m3 + 1 >> 1, f4 = f4 + m3 + 1 >> 1, m3 = w2, w2 = d3 - p4 + 1 >> 1, d3 = d3 + p4 + 1 >> 1, p4 = w2, w2 = _3 * n3 + y3 * r4 + 2048 >> 12, _3 = _3 * r4 - y3 * n3 + 2048 >> 12, y3 = w2, w2 = g2 * i2 + b3 * t3 + 2048 >> 12, g2 = g2 * t3 - b3 * i2 + 2048 >> 12, b3 = w2, E3[0 + S3] = f4 + y3, E3[56 + S3] = f4 - y3, E3[8 + S3] = d3 + b3, E3[48 + S3] = d3 - b3, E3[16 + S3] = p4 + g2, E3[40 + S3] = p4 - g2, E3[24 + S3] = m3 + _3, E3[32 + S3] = m3 - _3) : (w2 = s4 * c5[v3 + 0] + 8192 >> 14, E3[0 + S3] = w2, E3[8 + S3] = w2, E3[16 + S3] = w2, E3[24 + S3] = w2, E3[32 + S3] = w2, E3[40 + S3] = w2, E3[48 + S3] = w2, E3[56 + S3] = w2);
          }
          for (v3 = 0; v3 < 64; ++v3) {
            var A2 = 128 + (E3[v3] + 8 >> 4);
            h4[v3] = A2 < 0 ? 0 : A2 > 255 ? 255 : A2;
          }
        }
        __name(y2, "y");
        _2(m2 * p3 * 8);
        for (var w = 0; w < p3; w++) {
          var v2 = w << 3;
          for (h3 = 0; h3 < 8; h3++) f3.push(new Uint8Array(m2));
          for (var x2 = 0; x2 < d2; x2++) {
            y2(u3.blocks[w][x2], b2, g);
            var E2 = 0, k2 = x2 << 3;
            for (c4 = 0; c4 < 8; c4++) {
              var S2 = f3[v2 + c4];
              for (h3 = 0; h3 < 8; h3++) S2[k2 + h3] = b2[E2++];
            }
          }
        }
        return f3;
      }
      __name(f2, "f");
      function d(e6) {
        return e6 < 0 ? 0 : e6 > 255 ? 255 : e6;
      }
      __name(d, "d");
      u2.prototype = { load: /* @__PURE__ */ __name(function(e6) {
        var t4 = new XMLHttpRequest();
        t4.open("GET", e6, true), t4.responseType = "arraybuffer", t4.onload = function() {
          var e7 = new Uint8Array(t4.response || t4.mozResponseArrayBuffer);
          this.parse(e7), this.onload && this.onload();
        }.bind(this), t4.send(null);
      }, "load"), parse: /* @__PURE__ */ __name(function(t4) {
        var i3 = 1e3 * this.opts.maxResolutionInMP * 1e3, r5 = 0;
        function n4() {
          var e6 = t4[r5] << 8 | t4[r5 + 1];
          return r5 += 2, e6;
        }
        __name(n4, "n");
        function a3(e6) {
          var t5, i4, r6 = 1, n5 = 1;
          for (i4 in e6.components) e6.components.hasOwnProperty(i4) && (r6 < (t5 = e6.components[i4]).h && (r6 = t5.h), n5 < t5.v && (n5 = t5.v));
          var a4 = Math.ceil(e6.samplesPerLine / 8 / r6), o5 = Math.ceil(e6.scanLines / 8 / n5);
          for (i4 in e6.components) if (e6.components.hasOwnProperty(i4)) {
            t5 = e6.components[i4];
            var s6 = Math.ceil(Math.ceil(e6.samplesPerLine / 8) * t5.h / r6), l4 = Math.ceil(Math.ceil(e6.scanLines / 8) * t5.v / n5), u4 = a4 * t5.h, h3 = o5 * t5.v, c4 = [];
            _2(h3 * u4 * 256);
            for (var f3 = 0; f3 < h3; f3++) {
              for (var d3 = [], p4 = 0; p4 < u4; p4++) d3.push(new Int32Array(64));
              c4.push(d3);
            }
            t5.blocksPerLine = s6, t5.blocksPerColumn = l4, t5.blocks = c4;
          }
          e6.maxH = r6, e6.maxV = n5, e6.mcusPerLine = a4, e6.mcusPerColumn = o5;
        }
        __name(a3, "a");
        t4.length;
        var o4, s5, l3, u3, d2 = null, p3 = null, m2 = [], g = [], b2 = [], y2 = [], w = n4(), v2 = -1;
        if (this.comments = [], 65496 != w) throw new Error("SOI not found");
        for (w = n4(); 65497 != w; ) {
          switch (w) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var x2 = (l3 = void 0, u3 = void 0, l3 = n4(), u3 = t4.subarray(r5, r5 + l3 - 2), r5 += u3.length, u3);
              if (65534 === w) {
                var E2 = String.fromCharCode.apply(null, x2);
                this.comments.push(E2);
              }
              65504 === w && 74 === x2[0] && 70 === x2[1] && 73 === x2[2] && 70 === x2[3] && 0 === x2[4] && (d2 = { version: { major: x2[5], minor: x2[6] }, densityUnits: x2[7], xDensity: x2[8] << 8 | x2[9], yDensity: x2[10] << 8 | x2[11], thumbWidth: x2[12], thumbHeight: x2[13], thumbData: x2.subarray(14, 14 + 3 * x2[12] * x2[13]) }), 65505 === w && 69 === x2[0] && 120 === x2[1] && 105 === x2[2] && 102 === x2[3] && 0 === x2[4] && (this.exifBuffer = x2.subarray(5, x2.length)), 65518 === w && 65 === x2[0] && 100 === x2[1] && 111 === x2[2] && 98 === x2[3] && 101 === x2[4] && 0 === x2[5] && (p3 = { version: x2[6], flags0: x2[7] << 8 | x2[8], flags1: x2[9] << 8 | x2[10], transformCode: x2[11] });
              break;
            case 65499:
              for (var k2 = n4() + r5 - 2; r5 < k2; ) {
                var S2 = t4[r5++];
                _2(256);
                var A2 = new Int32Array(64);
                if (S2 >> 4) {
                  if (S2 >> 4 != 1) throw new Error("DQT: invalid table spec");
                  for (q = 0; q < 64; q++) A2[e5[q]] = n4();
                } else for (q = 0; q < 64; q++) A2[e5[q]] = t4[r5++];
                m2[15 & S2] = A2;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              n4(), (o4 = {}).extended = 65473 === w, o4.progressive = 65474 === w, o4.precision = t4[r5++], o4.scanLines = n4(), o4.samplesPerLine = n4(), o4.components = {}, o4.componentsOrder = [];
              var I = o4.scanLines * o4.samplesPerLine;
              if (I > i3) {
                var M2 = Math.ceil((I - i3) / 1e6);
                throw new Error(`maxResolutionInMP limit exceeded by ${M2}MP`);
              }
              var T2, P = t4[r5++];
              for (Q = 0; Q < P; Q++) {
                T2 = t4[r5];
                var B2 = t4[r5 + 1] >> 4, C2 = 15 & t4[r5 + 1], R2 = t4[r5 + 2];
                if (B2 <= 0 || C2 <= 0) throw new Error("Invalid sampling factor, expected values above 0");
                o4.componentsOrder.push(T2), o4.components[T2] = { h: B2, v: C2, quantizationIdx: R2 }, r5 += 3;
              }
              a3(o4), g.push(o4);
              break;
            case 65476:
              var z2 = n4();
              for (Q = 2; Q < z2; ) {
                var F = t4[r5++], N2 = new Uint8Array(16), O2 = 0;
                for (q = 0; q < 16; q++, r5++) O2 += N2[q] = t4[r5];
                _2(16 + O2);
                var D = new Uint8Array(O2);
                for (q = 0; q < O2; q++, r5++) D[q] = t4[r5];
                Q += 17 + O2, (F >> 4 ? b2 : y2)[15 & F] = h2(N2, D);
              }
              break;
            case 65501:
              n4(), s5 = n4();
              break;
            case 65500:
              n4(), n4();
              break;
            case 65498:
              n4();
              var $ = t4[r5++], L2 = [];
              for (Q = 0; Q < $; Q++) {
                V = o4.components[t4[r5++]];
                var U = t4[r5++];
                V.huffmanTableDC = y2[U >> 4], V.huffmanTableAC = b2[15 & U], L2.push(V);
              }
              var Z = t4[r5++], j = t4[r5++], G = t4[r5++], H = c3(t4, r5, o4, L2, s5, Z, j, G >> 4, 15 & G, this.opts);
              r5 += H;
              break;
            case 65535:
              255 !== t4[r5] && r5--;
              break;
            default:
              if (255 == t4[r5 - 3] && t4[r5 - 2] >= 192 && t4[r5 - 2] <= 254) {
                r5 -= 3;
                break;
              }
              if (224 === w || 225 == w) {
                if (-1 !== v2) throw new Error(`first unknown JPEG marker at offset ${v2.toString(16)}, second unknown JPEG marker ${w.toString(16)} at offset ${(r5 - 1).toString(16)}`);
                v2 = r5 - 1;
                const e6 = n4();
                if (255 === t4[r5 + e6 - 2]) {
                  r5 += e6 - 2;
                  break;
                }
              }
              throw new Error("unknown JPEG marker " + w.toString(16));
          }
          w = n4();
        }
        if (1 != g.length) throw new Error("only single frame JPEGs supported");
        for (var Q = 0; Q < g.length; Q++) {
          var W = g[Q].components;
          for (var q in W) W[q].quantizationTable = m2[W[q].quantizationIdx], delete W[q].quantizationIdx;
        }
        for (this.width = o4.samplesPerLine, this.height = o4.scanLines, this.jfif = d2, this.adobe = p3, this.components = [], Q = 0; Q < o4.componentsOrder.length; Q++) {
          var V = o4.components[o4.componentsOrder[Q]];
          this.components.push({ lines: f2(0, V), scaleX: V.h / o4.maxH, scaleY: V.v / o4.maxV });
        }
      }, "parse"), getData: /* @__PURE__ */ __name(function(e6, t4) {
        var i3, r5, n4, a3, o4, s5, l3, u3, h3, c4, f3, p3, m2, g, b2, y2, w, v2, x2, E2, k2, S2 = this.width / e6, A2 = this.height / t4, I = 0, M2 = e6 * t4 * this.components.length;
        _2(M2);
        var T2 = new Uint8Array(M2);
        switch (this.components.length) {
          case 1:
            for (i3 = this.components[0], c4 = 0; c4 < t4; c4++) for (o4 = i3.lines[0 | c4 * i3.scaleY * A2], h3 = 0; h3 < e6; h3++) f3 = o4[0 | h3 * i3.scaleX * S2], T2[I++] = f3;
            break;
          case 2:
            for (i3 = this.components[0], r5 = this.components[1], c4 = 0; c4 < t4; c4++) for (o4 = i3.lines[0 | c4 * i3.scaleY * A2], s5 = r5.lines[0 | c4 * r5.scaleY * A2], h3 = 0; h3 < e6; h3++) f3 = o4[0 | h3 * i3.scaleX * S2], T2[I++] = f3, f3 = s5[0 | h3 * r5.scaleX * S2], T2[I++] = f3;
            break;
          case 3:
            for (k2 = true, this.adobe && this.adobe.transformCode ? k2 = true : void 0 !== this.opts.colorTransform && (k2 = !!this.opts.colorTransform), i3 = this.components[0], r5 = this.components[1], n4 = this.components[2], c4 = 0; c4 < t4; c4++) for (o4 = i3.lines[0 | c4 * i3.scaleY * A2], s5 = r5.lines[0 | c4 * r5.scaleY * A2], l3 = n4.lines[0 | c4 * n4.scaleY * A2], h3 = 0; h3 < e6; h3++) k2 ? (f3 = o4[0 | h3 * i3.scaleX * S2], p3 = s5[0 | h3 * r5.scaleX * S2], v2 = d(f3 + 1.402 * ((m2 = l3[0 | h3 * n4.scaleX * S2]) - 128)), x2 = d(f3 - 0.3441363 * (p3 - 128) - 0.71413636 * (m2 - 128)), E2 = d(f3 + 1.772 * (p3 - 128))) : (v2 = o4[0 | h3 * i3.scaleX * S2], x2 = s5[0 | h3 * r5.scaleX * S2], E2 = l3[0 | h3 * n4.scaleX * S2]), T2[I++] = v2, T2[I++] = x2, T2[I++] = E2;
            break;
          case 4:
            if (!this.adobe) throw new Error("Unsupported color mode (4 components)");
            for (k2 = false, this.adobe && this.adobe.transformCode ? k2 = true : void 0 !== this.opts.colorTransform && (k2 = !!this.opts.colorTransform), i3 = this.components[0], r5 = this.components[1], n4 = this.components[2], a3 = this.components[3], c4 = 0; c4 < t4; c4++) for (o4 = i3.lines[0 | c4 * i3.scaleY * A2], s5 = r5.lines[0 | c4 * r5.scaleY * A2], l3 = n4.lines[0 | c4 * n4.scaleY * A2], u3 = a3.lines[0 | c4 * a3.scaleY * A2], h3 = 0; h3 < e6; h3++) k2 ? (f3 = o4[0 | h3 * i3.scaleX * S2], p3 = s5[0 | h3 * r5.scaleX * S2], m2 = l3[0 | h3 * n4.scaleX * S2], g = u3[0 | h3 * a3.scaleX * S2], b2 = 255 - d(f3 + 1.402 * (m2 - 128)), y2 = 255 - d(f3 - 0.3441363 * (p3 - 128) - 0.71413636 * (m2 - 128)), w = 255 - d(f3 + 1.772 * (p3 - 128))) : (b2 = o4[0 | h3 * i3.scaleX * S2], y2 = s5[0 | h3 * r5.scaleX * S2], w = l3[0 | h3 * n4.scaleX * S2], g = u3[0 | h3 * a3.scaleX * S2]), T2[I++] = 255 - b2, T2[I++] = 255 - y2, T2[I++] = 255 - w, T2[I++] = 255 - g;
            break;
          default:
            throw new Error("Unsupported color mode");
        }
        return T2;
      }, "getData"), copyToImageData: /* @__PURE__ */ __name(function(e6, t4) {
        var i3, r5, n4, a3, o4, s5, l3, u3, h3, c4 = e6.width, f3 = e6.height, p3 = e6.data, m2 = this.getData(c4, f3), _3 = 0, g = 0;
        switch (this.components.length) {
          case 1:
            for (r5 = 0; r5 < f3; r5++) for (i3 = 0; i3 < c4; i3++) n4 = m2[_3++], p3[g++] = n4, p3[g++] = n4, p3[g++] = n4, t4 && (p3[g++] = 255);
            break;
          case 3:
            for (r5 = 0; r5 < f3; r5++) for (i3 = 0; i3 < c4; i3++) l3 = m2[_3++], u3 = m2[_3++], h3 = m2[_3++], p3[g++] = l3, p3[g++] = u3, p3[g++] = h3, t4 && (p3[g++] = 255);
            break;
          case 4:
            for (r5 = 0; r5 < f3; r5++) for (i3 = 0; i3 < c4; i3++) o4 = m2[_3++], s5 = m2[_3++], n4 = m2[_3++], l3 = 255 - d(o4 * (1 - (a3 = m2[_3++]) / 255) + a3), u3 = 255 - d(s5 * (1 - a3 / 255) + a3), h3 = 255 - d(n4 * (1 - a3 / 255) + a3), p3[g++] = l3, p3[g++] = u3, p3[g++] = h3, t4 && (p3[g++] = 255);
            break;
          default:
            throw new Error("Unsupported color mode");
        }
      }, "copyToImageData") };
      var p2 = 0, m = 0;
      function _2(e6 = 0) {
        var t4 = p2 + e6;
        if (t4 > m) {
          var i3 = Math.ceil((t4 - m) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${i3}MB`);
        }
        p2 = t4;
      }
      __name(_2, "_");
      return u2.resetMaxMemoryUsage = function(e6) {
        p2 = 0, m = e6;
      }, u2.getBytesAllocated = function() {
        return p2;
      }, u2.requestMemoryAllocation = _2, u2;
    }(), module.exports = function(e5, t3 = {}) {
      var i2 = { colorTransform: void 0, useTArray: false, formatAsRGBA: true, tolerantDecoding: true, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...t3 }, r4 = new Uint8Array(e5), n3 = new JpegImage();
      n3.opts = i2, JpegImage.resetMaxMemoryUsage(1024 * i2.maxMemoryUsageInMB * 1024), n3.parse(r4);
      var a2 = i2.formatAsRGBA ? 4 : 3, o3 = n3.width * n3.height * a2;
      try {
        JpegImage.requestMemoryAllocation(o3);
        var s4 = { width: n3.width, height: n3.height, exifBuffer: n3.exifBuffer, data: i2.useTArray ? new Uint8Array(o3) : Buffer2.alloc(o3) };
        n3.comments.length > 0 && (s4.comments = n3.comments);
      } catch (e6) {
        if (e6 instanceof RangeError) throw new Error("Could not allocate enough memory for the image. Required: " + o3);
        if (e6 instanceof ReferenceError && "Buffer is not defined" === e6.message) throw new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true");
        throw e6;
      }
      return n3.copyToImageData(s4, i2.formatAsRGBA), s4;
    };
    decoderExports = decoder.exports;
    encode2 = encoderExports;
    decode = decoderExports;
    jpegJs = { encode: encode2, decode };
    JPEG = getDefaultExportFromCjs(jpegJs);
    __name(jpeg$2, "jpeg$2");
    __name(commonjsRequire, "commonjsRequire");
    browser$1 = { exports: {} };
    browser$1.exports = (/* @__PURE__ */ function() {
      function e5(t3, i2, r4) {
        function n3(o4, s4) {
          if (!i2[o4]) {
            if (!t3[o4]) {
              var l2 = "function" == typeof commonjsRequire && commonjsRequire;
              if (!s4 && l2) return l2(o4, true);
              if (a2) return a2(o4, true);
              var u2 = new Error("Cannot find module '" + o4 + "'");
              throw u2.code = "MODULE_NOT_FOUND", u2;
            }
            var h2 = i2[o4] = { exports: {} };
            t3[o4][0].call(h2.exports, function(e6) {
              return n3(t3[o4][1][e6] || e6);
            }, h2, h2.exports, e5, t3, i2, r4);
          }
          return i2[o4].exports;
        }
        __name(n3, "n");
        for (var a2 = "function" == typeof commonjsRequire && commonjsRequire, o3 = 0; o3 < r4.length; o3++) n3(r4[o3]);
        return n3;
      }
      __name(e5, "e");
      return e5;
    }())({ 1: [function(e5, t3, i2) {
      (function(t4) {
        (function() {
          let r4 = e5("./interlace"), n3 = [function() {
          }, function(e6, t5, i3, r5) {
            if (r5 === t5.length) throw new Error("Ran out of data");
            let n4 = t5[r5];
            e6[i3] = n4, e6[i3 + 1] = n4, e6[i3 + 2] = n4, e6[i3 + 3] = 255;
          }, function(e6, t5, i3, r5) {
            if (r5 + 1 >= t5.length) throw new Error("Ran out of data");
            let n4 = t5[r5];
            e6[i3] = n4, e6[i3 + 1] = n4, e6[i3 + 2] = n4, e6[i3 + 3] = t5[r5 + 1];
          }, function(e6, t5, i3, r5) {
            if (r5 + 2 >= t5.length) throw new Error("Ran out of data");
            e6[i3] = t5[r5], e6[i3 + 1] = t5[r5 + 1], e6[i3 + 2] = t5[r5 + 2], e6[i3 + 3] = 255;
          }, function(e6, t5, i3, r5) {
            if (r5 + 3 >= t5.length) throw new Error("Ran out of data");
            e6[i3] = t5[r5], e6[i3 + 1] = t5[r5 + 1], e6[i3 + 2] = t5[r5 + 2], e6[i3 + 3] = t5[r5 + 3];
          }], a2 = [function() {
          }, function(e6, t5, i3, r5) {
            let n4 = t5[0];
            e6[i3] = n4, e6[i3 + 1] = n4, e6[i3 + 2] = n4, e6[i3 + 3] = r5;
          }, function(e6, t5, i3) {
            let r5 = t5[0];
            e6[i3] = r5, e6[i3 + 1] = r5, e6[i3 + 2] = r5, e6[i3 + 3] = t5[1];
          }, function(e6, t5, i3, r5) {
            e6[i3] = t5[0], e6[i3 + 1] = t5[1], e6[i3 + 2] = t5[2], e6[i3 + 3] = r5;
          }, function(e6, t5, i3) {
            e6[i3] = t5[0], e6[i3 + 1] = t5[1], e6[i3 + 2] = t5[2], e6[i3 + 3] = t5[3];
          }];
          function o3(e6, t5) {
            let i3 = [], r5 = 0;
            function n4() {
              if (r5 === e6.length) throw new Error("Ran out of data");
              let n5, a3, o4, s5, l3, u2, h2, c3, f2 = e6[r5];
              switch (r5++, t5) {
                default:
                  throw new Error("unrecognised depth");
                case 16:
                  h2 = e6[r5], r5++, i3.push((f2 << 8) + h2);
                  break;
                case 4:
                  h2 = 15 & f2, c3 = f2 >> 4, i3.push(c3, h2);
                  break;
                case 2:
                  l3 = 3 & f2, u2 = f2 >> 2 & 3, h2 = f2 >> 4 & 3, c3 = f2 >> 6 & 3, i3.push(c3, h2, u2, l3);
                  break;
                case 1:
                  n5 = 1 & f2, a3 = f2 >> 1 & 1, o4 = f2 >> 2 & 1, s5 = f2 >> 3 & 1, l3 = f2 >> 4 & 1, u2 = f2 >> 5 & 1, h2 = f2 >> 6 & 1, c3 = f2 >> 7 & 1, i3.push(c3, h2, u2, l3, s5, o4, a3, n5);
              }
            }
            __name(n4, "n");
            return { get: /* @__PURE__ */ __name(function(e7) {
              for (; i3.length < e7; ) n4();
              let t6 = i3.slice(0, e7);
              return i3 = i3.slice(e7), t6;
            }, "get"), resetAfterLine: /* @__PURE__ */ __name(function() {
              i3.length = 0;
            }, "resetAfterLine"), end: /* @__PURE__ */ __name(function() {
              if (r5 !== e6.length) throw new Error("extra data found");
            }, "end") };
          }
          __name(o3, "o");
          function s4(e6, t5, i3, r5, a3, o4) {
            let s5 = e6.width, l3 = e6.height, u2 = e6.index;
            for (let e7 = 0; e7 < l3; e7++) for (let l4 = 0; l4 < s5; l4++) {
              let s6 = i3(l4, e7, u2);
              n3[r5](t5, a3, s6, o4), o4 += r5;
            }
            return o4;
          }
          __name(s4, "s");
          function l2(e6, t5, i3, r5, n4, o4) {
            let s5 = e6.width, l3 = e6.height, u2 = e6.index;
            for (let e7 = 0; e7 < l3; e7++) {
              for (let l4 = 0; l4 < s5; l4++) {
                let s6 = n4.get(r5), h2 = i3(l4, e7, u2);
                a2[r5](t5, s6, h2, o4);
              }
              n4.resetAfterLine();
            }
          }
          __name(l2, "l");
          i2.dataToBitMap = function(e6, i3) {
            let n4, a3, u2 = i3.width, h2 = i3.height, c3 = i3.depth, f2 = i3.bpp, d = i3.interlace;
            8 !== c3 && (n4 = o3(e6, c3)), a3 = c3 <= 8 ? t4.alloc(u2 * h2 * 4) : new Uint16Array(u2 * h2 * 4);
            let p2, m, _2 = Math.pow(2, c3) - 1, g = 0;
            if (d) p2 = r4.getImagePasses(u2, h2), m = r4.getInterlaceIterator(u2, h2);
            else {
              let e7 = 0;
              m = /* @__PURE__ */ __name(function() {
                let t5 = e7;
                return e7 += 4, t5;
              }, "m"), p2 = [{ width: u2, height: h2 }];
            }
            for (let t5 = 0; t5 < p2.length; t5++) 8 === c3 ? g = s4(p2[t5], a3, m, f2, e6, g) : l2(p2[t5], a3, m, f2, n4, _2);
            if (8 === c3) {
              if (g !== e6.length) throw new Error("extra data found");
            } else n4.end();
            return a3;
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./interlace": 11, buffer: 32 }], 2: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("./constants");
          t3.exports = function(e6, t4, n3, a2) {
            let o3 = -1 !== [r4.COLORTYPE_COLOR_ALPHA, r4.COLORTYPE_ALPHA].indexOf(a2.colorType);
            if (a2.colorType === a2.inputColorType) {
              let t5 = function() {
                let e7 = new ArrayBuffer(2);
                return new DataView(e7).setInt16(0, 256, true), 256 !== new Int16Array(e7)[0];
              }();
              if (8 === a2.bitDepth || 16 === a2.bitDepth && t5) return e6;
            }
            let s4 = 16 !== a2.bitDepth ? e6 : new Uint16Array(e6.buffer), l2 = 255, u2 = r4.COLORTYPE_TO_BPP_MAP[a2.inputColorType];
            4 !== u2 || a2.inputHasAlpha || (u2 = 3);
            let h2 = r4.COLORTYPE_TO_BPP_MAP[a2.colorType];
            16 === a2.bitDepth && (l2 = 65535, h2 *= 2);
            let c3 = i3.alloc(t4 * n3 * h2), f2 = 0, d = 0, p2 = a2.bgColor || {};
            function m() {
              let e7, t5, i4, n4 = l2;
              switch (a2.inputColorType) {
                case r4.COLORTYPE_COLOR_ALPHA:
                  n4 = s4[f2 + 3], e7 = s4[f2], t5 = s4[f2 + 1], i4 = s4[f2 + 2];
                  break;
                case r4.COLORTYPE_COLOR:
                  e7 = s4[f2], t5 = s4[f2 + 1], i4 = s4[f2 + 2];
                  break;
                case r4.COLORTYPE_ALPHA:
                  n4 = s4[f2 + 1], e7 = s4[f2], t5 = e7, i4 = e7;
                  break;
                case r4.COLORTYPE_GRAYSCALE:
                  e7 = s4[f2], t5 = e7, i4 = e7;
                  break;
                default:
                  throw new Error("input color type:" + a2.inputColorType + " is not supported at present");
              }
              return a2.inputHasAlpha && (o3 || (n4 /= l2, e7 = Math.min(Math.max(Math.round((1 - n4) * p2.red + n4 * e7), 0), l2), t5 = Math.min(Math.max(Math.round((1 - n4) * p2.green + n4 * t5), 0), l2), i4 = Math.min(Math.max(Math.round((1 - n4) * p2.blue + n4 * i4), 0), l2))), { red: e7, green: t5, blue: i4, alpha: n4 };
            }
            __name(m, "m");
            void 0 === p2.red && (p2.red = l2), void 0 === p2.green && (p2.green = l2), void 0 === p2.blue && (p2.blue = l2);
            for (let e7 = 0; e7 < n3; e7++) for (let e8 = 0; e8 < t4; e8++) {
              let e9 = m();
              switch (a2.colorType) {
                case r4.COLORTYPE_COLOR_ALPHA:
                case r4.COLORTYPE_COLOR:
                  8 === a2.bitDepth ? (c3[d] = e9.red, c3[d + 1] = e9.green, c3[d + 2] = e9.blue, o3 && (c3[d + 3] = e9.alpha)) : (c3.writeUInt16BE(e9.red, d), c3.writeUInt16BE(e9.green, d + 2), c3.writeUInt16BE(e9.blue, d + 4), o3 && c3.writeUInt16BE(e9.alpha, d + 6));
                  break;
                case r4.COLORTYPE_ALPHA:
                case r4.COLORTYPE_GRAYSCALE: {
                  let t5 = (e9.red + e9.green + e9.blue) / 3;
                  8 === a2.bitDepth ? (c3[d] = t5, o3 && (c3[d + 1] = e9.alpha)) : (c3.writeUInt16BE(t5, d), o3 && c3.writeUInt16BE(e9.alpha, d + 2));
                  break;
                }
                default:
                  throw new Error("unrecognised color Type " + a2.colorType);
              }
              f2 += u2, d += h2;
            }
            return c3;
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./constants": 4, buffer: 32 }], 3: [function(e5, t3, i2) {
      (function(i3, r4) {
        (function() {
          let n3 = e5("util"), a2 = e5("stream"), o3 = t3.exports = function() {
            a2.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = false, this._encoding = "utf8", this.writable = true;
          };
          n3.inherits(o3, a2), o3.prototype.read = function(e6, t4) {
            this._reads.push({ length: Math.abs(e6), allowLess: e6 < 0, func: t4 }), i3.nextTick(function() {
              this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = false, this.emit("drain"));
            }.bind(this));
          }, o3.prototype.write = function(e6, t4) {
            if (!this.writable) return this.emit("error", new Error("Stream not writable")), false;
            let i4;
            return i4 = r4.isBuffer(e6) ? e6 : r4.from(e6, t4 || this._encoding), this._buffers.push(i4), this._buffered += i4.length, this._process(), this._reads && 0 === this._reads.length && (this._paused = true), this.writable && !this._paused;
          }, o3.prototype.end = function(e6, t4) {
            e6 && this.write(e6, t4), this.writable = false, this._buffers && (0 === this._buffers.length ? this._end() : (this._buffers.push(null), this._process()));
          }, o3.prototype.destroySoon = o3.prototype.end, o3.prototype._end = function() {
            this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
          }, o3.prototype.destroy = function() {
            this._buffers && (this.writable = false, this._reads = null, this._buffers = null, this.emit("close"));
          }, o3.prototype._processReadAllowingLess = function(e6) {
            this._reads.shift();
            let t4 = this._buffers[0];
            t4.length > e6.length ? (this._buffered -= e6.length, this._buffers[0] = t4.slice(e6.length), e6.func.call(this, t4.slice(0, e6.length))) : (this._buffered -= t4.length, this._buffers.shift(), e6.func.call(this, t4));
          }, o3.prototype._processRead = function(e6) {
            this._reads.shift();
            let t4 = 0, i4 = 0, n4 = r4.alloc(e6.length);
            for (; t4 < e6.length; ) {
              let r5 = this._buffers[i4++], a3 = Math.min(r5.length, e6.length - t4);
              r5.copy(n4, t4, 0, a3), t4 += a3, a3 !== r5.length && (this._buffers[--i4] = r5.slice(a3));
            }
            i4 > 0 && this._buffers.splice(0, i4), this._buffered -= e6.length, e6.func.call(this, n4);
          }, o3.prototype._process = function() {
            try {
              for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                let e6 = this._reads[0];
                if (e6.allowLess) this._processReadAllowingLess(e6);
                else {
                  if (!(this._buffered >= e6.length)) break;
                  this._processRead(e6);
                }
              }
              this._buffers && !this.writable && this._end();
            } catch (e6) {
              this.emit("error", e6);
            }
          };
        }).call(this);
      }).call(this, e5("_process"), e5("buffer").Buffer);
    }, { _process: 63, buffer: 32, stream: 65, util: 84 }], 4: [function(e5, t3, i2) {
      t3.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
    }, {}], 5: [function(e5, t3, i2) {
      let r4 = [];
      !function() {
        for (let e6 = 0; e6 < 256; e6++) {
          let t4 = e6;
          for (let e7 = 0; e7 < 8; e7++) 1 & t4 ? t4 = 3988292384 ^ t4 >>> 1 : t4 >>>= 1;
          r4[e6] = t4;
        }
      }();
      let n3 = t3.exports = function() {
        this._crc = -1;
      };
      n3.prototype.write = function(e6) {
        for (let t4 = 0; t4 < e6.length; t4++) this._crc = r4[255 & (this._crc ^ e6[t4])] ^ this._crc >>> 8;
        return true;
      }, n3.prototype.crc32 = function() {
        return ~this._crc;
      }, n3.crc32 = function(e6) {
        let t4 = -1;
        for (let i3 = 0; i3 < e6.length; i3++) t4 = r4[255 & (t4 ^ e6[i3])] ^ t4 >>> 8;
        return ~t4;
      };
    }, {}], 6: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("./paeth-predictor");
          function n3(e6, t4, i4, r5, n4) {
            for (let a3 = 0; a3 < i4; a3++) r5[n4 + a3] = e6[t4 + a3];
          }
          __name(n3, "n");
          function a2(e6, t4, i4) {
            let r5 = 0, n4 = t4 + i4;
            for (let i5 = t4; i5 < n4; i5++) r5 += Math.abs(e6[i5]);
            return r5;
          }
          __name(a2, "a");
          function o3(e6, t4, i4, r5, n4, a3) {
            for (let o4 = 0; o4 < i4; o4++) {
              let i5 = o4 >= a3 ? e6[t4 + o4 - a3] : 0, s5 = e6[t4 + o4] - i5;
              r5[n4 + o4] = s5;
            }
          }
          __name(o3, "o");
          function s4(e6, t4, i4, r5) {
            let n4 = 0;
            for (let a3 = 0; a3 < i4; a3++) {
              let i5 = a3 >= r5 ? e6[t4 + a3 - r5] : 0, o4 = e6[t4 + a3] - i5;
              n4 += Math.abs(o4);
            }
            return n4;
          }
          __name(s4, "s");
          function l2(e6, t4, i4, r5, n4) {
            for (let a3 = 0; a3 < i4; a3++) {
              let o4 = t4 > 0 ? e6[t4 + a3 - i4] : 0, s5 = e6[t4 + a3] - o4;
              r5[n4 + a3] = s5;
            }
          }
          __name(l2, "l");
          function u2(e6, t4, i4) {
            let r5 = 0, n4 = t4 + i4;
            for (let a3 = t4; a3 < n4; a3++) {
              let n5 = t4 > 0 ? e6[a3 - i4] : 0, o4 = e6[a3] - n5;
              r5 += Math.abs(o4);
            }
            return r5;
          }
          __name(u2, "u");
          function h2(e6, t4, i4, r5, n4, a3) {
            for (let o4 = 0; o4 < i4; o4++) {
              let s5 = o4 >= a3 ? e6[t4 + o4 - a3] : 0, l3 = t4 > 0 ? e6[t4 + o4 - i4] : 0, u3 = e6[t4 + o4] - (s5 + l3 >> 1);
              r5[n4 + o4] = u3;
            }
          }
          __name(h2, "h");
          function c3(e6, t4, i4, r5) {
            let n4 = 0;
            for (let a3 = 0; a3 < i4; a3++) {
              let o4 = a3 >= r5 ? e6[t4 + a3 - r5] : 0, s5 = t4 > 0 ? e6[t4 + a3 - i4] : 0, l3 = e6[t4 + a3] - (o4 + s5 >> 1);
              n4 += Math.abs(l3);
            }
            return n4;
          }
          __name(c3, "c");
          function f2(e6, t4, i4, n4, a3, o4) {
            for (let s5 = 0; s5 < i4; s5++) {
              let l3 = s5 >= o4 ? e6[t4 + s5 - o4] : 0, u3 = t4 > 0 ? e6[t4 + s5 - i4] : 0, h3 = t4 > 0 && s5 >= o4 ? e6[t4 + s5 - (i4 + o4)] : 0, c4 = e6[t4 + s5] - r4(l3, u3, h3);
              n4[a3 + s5] = c4;
            }
          }
          __name(f2, "f");
          function d(e6, t4, i4, n4) {
            let a3 = 0;
            for (let o4 = 0; o4 < i4; o4++) {
              let s5 = o4 >= n4 ? e6[t4 + o4 - n4] : 0, l3 = t4 > 0 ? e6[t4 + o4 - i4] : 0, u3 = t4 > 0 && o4 >= n4 ? e6[t4 + o4 - (i4 + n4)] : 0, h3 = e6[t4 + o4] - r4(s5, l3, u3);
              a3 += Math.abs(h3);
            }
            return a3;
          }
          __name(d, "d");
          let p2 = { 0: n3, 1: o3, 2: l2, 3: h2, 4: f2 }, m = { 0: a2, 1: s4, 2: u2, 3: c3, 4: d };
          t3.exports = function(e6, t4, r5, n4, a3) {
            let o4;
            if ("filterType" in n4 && -1 !== n4.filterType) {
              if ("number" != typeof n4.filterType) throw new Error("unrecognised filter types");
              o4 = [n4.filterType];
            } else o4 = [0, 1, 2, 3, 4];
            16 === n4.bitDepth && (a3 *= 2);
            let s5 = t4 * a3, l3 = 0, u3 = 0, h3 = i3.alloc((s5 + 1) * r5), c4 = o4[0];
            for (let t5 = 0; t5 < r5; t5++) {
              if (o4.length > 1) {
                let t6 = 1 / 0;
                for (let i4 = 0; i4 < o4.length; i4++) {
                  let r6 = m[o4[i4]](e6, u3, s5, a3);
                  r6 < t6 && (c4 = o4[i4], t6 = r6);
                }
              }
              h3[l3] = c4, l3++, p2[c4](e6, u3, s5, h3, l3, a3), l3 += s5, u3 += s5;
            }
            return h3;
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./paeth-predictor": 15, buffer: 32 }], 7: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("util"), n3 = e5("./chunkstream"), a2 = e5("./filter-parse"), o3 = t3.exports = function(e6) {
            n3.call(this);
            let t4 = [], r5 = this;
            this._filter = new a2(e6, { read: this.read.bind(this), write: /* @__PURE__ */ __name(function(e7) {
              t4.push(e7);
            }, "write"), complete: /* @__PURE__ */ __name(function() {
              r5.emit("complete", i3.concat(t4));
            }, "complete") }), this._filter.start();
          };
          r4.inherits(o3, n3);
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 32, util: 84 }], 8: [function(e5, t3, i2) {
      (function(t4) {
        (function() {
          let r4 = e5("./sync-reader"), n3 = e5("./filter-parse");
          i2.process = function(e6, i3) {
            let a2 = [], o3 = new r4(e6);
            return new n3(i3, { read: o3.read.bind(o3), write: /* @__PURE__ */ __name(function(e7) {
              a2.push(e7);
            }, "write"), complete: /* @__PURE__ */ __name(function() {
            }, "complete") }).start(), o3.process(), t4.concat(a2);
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 32 }], 9: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("./interlace"), n3 = e5("./paeth-predictor");
          function a2(e6, t4, i4) {
            let r5 = e6 * t4;
            return 8 !== i4 && (r5 = Math.ceil(r5 / (8 / i4))), r5;
          }
          __name(a2, "a");
          let o3 = t3.exports = function(e6, t4) {
            let i4 = e6.width, n4 = e6.height, o4 = e6.interlace, s4 = e6.bpp, l2 = e6.depth;
            if (this.read = t4.read, this.write = t4.write, this.complete = t4.complete, this._imageIndex = 0, this._images = [], o4) {
              let e7 = r4.getImagePasses(i4, n4);
              for (let t5 = 0; t5 < e7.length; t5++) this._images.push({ byteWidth: a2(e7[t5].width, s4, l2), height: e7[t5].height, lineIndex: 0 });
            } else this._images.push({ byteWidth: a2(i4, s4, l2), height: n4, lineIndex: 0 });
            this._xComparison = 8 === l2 ? s4 : 16 === l2 ? 2 * s4 : 1;
          };
          o3.prototype.start = function() {
            this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
          }, o3.prototype._unFilterType1 = function(e6, t4, i4) {
            let r5 = this._xComparison, n4 = r5 - 1;
            for (let a3 = 0; a3 < i4; a3++) {
              let i5 = e6[1 + a3], o4 = a3 > n4 ? t4[a3 - r5] : 0;
              t4[a3] = i5 + o4;
            }
          }, o3.prototype._unFilterType2 = function(e6, t4, i4) {
            let r5 = this._lastLine;
            for (let n4 = 0; n4 < i4; n4++) {
              let i5 = e6[1 + n4], a3 = r5 ? r5[n4] : 0;
              t4[n4] = i5 + a3;
            }
          }, o3.prototype._unFilterType3 = function(e6, t4, i4) {
            let r5 = this._xComparison, n4 = r5 - 1, a3 = this._lastLine;
            for (let o4 = 0; o4 < i4; o4++) {
              let i5 = e6[1 + o4], s4 = a3 ? a3[o4] : 0, l2 = o4 > n4 ? t4[o4 - r5] : 0, u2 = Math.floor((l2 + s4) / 2);
              t4[o4] = i5 + u2;
            }
          }, o3.prototype._unFilterType4 = function(e6, t4, i4) {
            let r5 = this._xComparison, a3 = r5 - 1, o4 = this._lastLine;
            for (let s4 = 0; s4 < i4; s4++) {
              let i5 = e6[1 + s4], l2 = o4 ? o4[s4] : 0, u2 = s4 > a3 ? t4[s4 - r5] : 0, h2 = s4 > a3 && o4 ? o4[s4 - r5] : 0, c3 = n3(u2, l2, h2);
              t4[s4] = i5 + c3;
            }
          }, o3.prototype._reverseFilterLine = function(e6) {
            let t4, r5 = e6[0], n4 = this._images[this._imageIndex], a3 = n4.byteWidth;
            if (0 === r5) t4 = e6.slice(1, a3 + 1);
            else switch (t4 = i3.alloc(a3), r5) {
              case 1:
                this._unFilterType1(e6, t4, a3);
                break;
              case 2:
                this._unFilterType2(e6, t4, a3);
                break;
              case 3:
                this._unFilterType3(e6, t4, a3);
                break;
              case 4:
                this._unFilterType4(e6, t4, a3);
                break;
              default:
                throw new Error("Unrecognised filter type - " + r5);
            }
            this.write(t4), n4.lineIndex++, n4.lineIndex >= n4.height ? (this._lastLine = null, this._imageIndex++, n4 = this._images[this._imageIndex]) : this._lastLine = t4, n4 ? this.read(n4.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 32 }], 10: [function(e5, t3, i2) {
      (function(e6) {
        (function() {
          function i3(e7, t4, i4, r5, n4) {
            let a2 = 0;
            for (let o3 = 0; o3 < r5; o3++) for (let r6 = 0; r6 < i4; r6++) {
              let i5 = n4[e7[a2]];
              if (!i5) throw new Error("index " + e7[a2] + " not in palette");
              for (let e8 = 0; e8 < 4; e8++) t4[a2 + e8] = i5[e8];
              a2 += 4;
            }
          }
          __name(i3, "i");
          function r4(e7, t4, i4, r5, n4) {
            let a2 = 0;
            for (let o3 = 0; o3 < r5; o3++) for (let r6 = 0; r6 < i4; r6++) {
              let i5 = false;
              if (1 === n4.length ? n4[0] === e7[a2] && (i5 = true) : n4[0] === e7[a2] && n4[1] === e7[a2 + 1] && n4[2] === e7[a2 + 2] && (i5 = true), i5) for (let e8 = 0; e8 < 4; e8++) t4[a2 + e8] = 0;
              a2 += 4;
            }
          }
          __name(r4, "r");
          function n3(e7, t4, i4, r5, n4) {
            let a2 = 255, o3 = Math.pow(2, n4) - 1, s4 = 0;
            for (let n5 = 0; n5 < r5; n5++) for (let r6 = 0; r6 < i4; r6++) {
              for (let i5 = 0; i5 < 4; i5++) t4[s4 + i5] = Math.floor(e7[s4 + i5] * a2 / o3 + 0.5);
              s4 += 4;
            }
          }
          __name(n3, "n");
          t3.exports = function(t4, a2, o3 = false) {
            let s4 = a2.depth, l2 = a2.width, u2 = a2.height, h2 = a2.colorType, c3 = a2.transColor, f2 = a2.palette, d = t4;
            return 3 === h2 ? i3(t4, d, l2, u2, f2) : (c3 && r4(t4, d, l2, u2, c3), 8 === s4 || o3 || (16 === s4 && (d = e6.alloc(l2 * u2 * 4)), n3(t4, d, l2, u2, s4))), d;
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { buffer: 32 }], 11: [function(e5, t3, i2) {
      let r4 = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
      i2.getImagePasses = function(e6, t4) {
        let i3 = [], n3 = e6 % 8, a2 = t4 % 8, o3 = (e6 - n3) / 8, s4 = (t4 - a2) / 8;
        for (let e7 = 0; e7 < r4.length; e7++) {
          let t5 = r4[e7], l2 = o3 * t5.x.length, u2 = s4 * t5.y.length;
          for (let e8 = 0; e8 < t5.x.length && t5.x[e8] < n3; e8++) l2++;
          for (let e8 = 0; e8 < t5.y.length && t5.y[e8] < a2; e8++) u2++;
          l2 > 0 && u2 > 0 && i3.push({ width: l2, height: u2, index: e7 });
        }
        return i3;
      }, i2.getInterlaceIterator = function(e6) {
        return function(t4, i3, n3) {
          let a2 = t4 % r4[n3].x.length, o3 = (t4 - a2) / r4[n3].x.length * 8 + r4[n3].x[a2], s4 = i3 % r4[n3].y.length;
          return 4 * o3 + ((i3 - s4) / r4[n3].y.length * 8 + r4[n3].y[s4]) * e6 * 4;
        };
      };
    }, {}], 12: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("util"), n3 = e5("stream"), a2 = e5("./constants"), o3 = e5("./packer"), s4 = t3.exports = function(e6) {
            n3.call(this);
            let t4 = e6 || {};
            this._packer = new o3(t4), this._deflate = this._packer.createDeflate(), this.readable = true;
          };
          r4.inherits(s4, n3), s4.prototype.pack = function(e6, t4, r5, n4) {
            this.emit("data", i3.from(a2.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(t4, r5)), n4 && this.emit("data", this._packer.packGAMA(n4));
            let o4 = this._packer.filterData(e6, t4, r5);
            this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(e7) {
              this.emit("data", this._packer.packIDAT(e7));
            }.bind(this)), this._deflate.on("end", function() {
              this.emit("data", this._packer.packIEND()), this.emit("end");
            }.bind(this)), this._deflate.end(o4);
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./constants": 4, "./packer": 14, buffer: 32, stream: 65, util: 84 }], 13: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = true, n3 = e5("zlib");
          n3.deflateSync || (r4 = false);
          let a2 = e5("./constants"), o3 = e5("./packer");
          t3.exports = function(e6, t4) {
            if (!r4) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            let s4 = new o3(t4 || {}), l2 = [];
            l2.push(i3.from(a2.PNG_SIGNATURE)), l2.push(s4.packIHDR(e6.width, e6.height)), e6.gamma && l2.push(s4.packGAMA(e6.gamma));
            let u2 = s4.filterData(e6.data, e6.width, e6.height), h2 = n3.deflateSync(u2, s4.getDeflateOptions());
            if (u2 = null, !h2 || !h2.length) throw new Error("bad png - invalid compressed data response");
            return l2.push(s4.packIDAT(h2)), l2.push(s4.packIEND()), i3.concat(l2);
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./constants": 4, "./packer": 14, buffer: 32, zlib: 31 }], 14: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("./constants"), n3 = e5("./crc"), a2 = e5("./bitpacker"), o3 = e5("./filter-pack"), s4 = e5("zlib"), l2 = t3.exports = function(e6) {
            if (this._options = e6, e6.deflateChunkSize = e6.deflateChunkSize || 32768, e6.deflateLevel = null != e6.deflateLevel ? e6.deflateLevel : 9, e6.deflateStrategy = null != e6.deflateStrategy ? e6.deflateStrategy : 3, e6.inputHasAlpha = null == e6.inputHasAlpha || e6.inputHasAlpha, e6.deflateFactory = e6.deflateFactory || s4.createDeflate, e6.bitDepth = e6.bitDepth || 8, e6.colorType = "number" == typeof e6.colorType ? e6.colorType : r4.COLORTYPE_COLOR_ALPHA, e6.inputColorType = "number" == typeof e6.inputColorType ? e6.inputColorType : r4.COLORTYPE_COLOR_ALPHA, -1 === [r4.COLORTYPE_GRAYSCALE, r4.COLORTYPE_COLOR, r4.COLORTYPE_COLOR_ALPHA, r4.COLORTYPE_ALPHA].indexOf(e6.colorType)) throw new Error("option color type:" + e6.colorType + " is not supported at present");
            if (-1 === [r4.COLORTYPE_GRAYSCALE, r4.COLORTYPE_COLOR, r4.COLORTYPE_COLOR_ALPHA, r4.COLORTYPE_ALPHA].indexOf(e6.inputColorType)) throw new Error("option input color type:" + e6.inputColorType + " is not supported at present");
            if (8 !== e6.bitDepth && 16 !== e6.bitDepth) throw new Error("option bit depth:" + e6.bitDepth + " is not supported at present");
          };
          l2.prototype.getDeflateOptions = function() {
            return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
          }, l2.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          }, l2.prototype.filterData = function(e6, t4, i4) {
            let n4 = a2(e6, t4, i4, this._options), s5 = r4.COLORTYPE_TO_BPP_MAP[this._options.colorType];
            return o3(n4, t4, i4, this._options, s5);
          }, l2.prototype._packChunk = function(e6, t4) {
            let r5 = t4 ? t4.length : 0, a3 = i3.alloc(r5 + 12);
            return a3.writeUInt32BE(r5, 0), a3.writeUInt32BE(e6, 4), t4 && t4.copy(a3, 8), a3.writeInt32BE(n3.crc32(a3.slice(4, a3.length - 4)), a3.length - 4), a3;
          }, l2.prototype.packGAMA = function(e6) {
            let t4 = i3.alloc(4);
            return t4.writeUInt32BE(Math.floor(e6 * r4.GAMMA_DIVISION), 0), this._packChunk(r4.TYPE_gAMA, t4);
          }, l2.prototype.packIHDR = function(e6, t4) {
            let n4 = i3.alloc(13);
            return n4.writeUInt32BE(e6, 0), n4.writeUInt32BE(t4, 4), n4[8] = this._options.bitDepth, n4[9] = this._options.colorType, n4[10] = 0, n4[11] = 0, n4[12] = 0, this._packChunk(r4.TYPE_IHDR, n4);
          }, l2.prototype.packIDAT = function(e6) {
            return this._packChunk(r4.TYPE_IDAT, e6);
          }, l2.prototype.packIEND = function() {
            return this._packChunk(r4.TYPE_IEND, null);
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 32, zlib: 31 }], 15: [function(e5, t3, i2) {
      t3.exports = function(e6, t4, i3) {
        let r4 = e6 + t4 - i3, n3 = Math.abs(r4 - e6), a2 = Math.abs(r4 - t4), o3 = Math.abs(r4 - i3);
        return n3 <= a2 && n3 <= o3 ? e6 : a2 <= o3 ? t4 : i3;
      };
    }, {}], 16: [function(e5, t3, i2) {
      let r4 = e5("util"), n3 = e5("zlib"), a2 = e5("./chunkstream"), o3 = e5("./filter-parse-async"), s4 = e5("./parser"), l2 = e5("./bitmapper"), u2 = e5("./format-normaliser"), h2 = t3.exports = function(e6) {
        a2.call(this), this._parser = new s4(e6, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = e6, this.writable = true, this._parser.start();
      };
      r4.inherits(h2, a2), h2.prototype._handleError = function(e6) {
        this.emit("error", e6), this.writable = false, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
        })), this.errord = true;
      }, h2.prototype._inflateData = function(e6) {
        if (!this._inflate) if (this._bitmapInfo.interlace) this._inflate = n3.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
        else {
          let e7 = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, t4 = Math.max(e7, n3.Z_MIN_CHUNK);
          this._inflate = n3.createInflate({ chunkSize: t4 });
          let i3 = e7, r5 = this.emit.bind(this, "error");
          this._inflate.on("error", function(e8) {
            i3 && r5(e8);
          }), this._filter.on("complete", this._complete.bind(this));
          let a3 = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(e8) {
            i3 && (e8.length > i3 && (e8 = e8.slice(0, i3)), i3 -= e8.length, a3(e8));
          }), this._inflate.on("end", this._filter.end.bind(this._filter));
        }
        this._inflate.write(e6);
      }, h2.prototype._handleMetaData = function(e6) {
        this._metaData = e6, this._bitmapInfo = Object.create(e6), this._filter = new o3(this._bitmapInfo);
      }, h2.prototype._handleTransColor = function(e6) {
        this._bitmapInfo.transColor = e6;
      }, h2.prototype._handlePalette = function(e6) {
        this._bitmapInfo.palette = e6;
      }, h2.prototype._simpleTransparency = function() {
        this._metaData.alpha = true;
      }, h2.prototype._headersFinished = function() {
        this.emit("metadata", this._metaData);
      }, h2.prototype._finished = function() {
        this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
      }, h2.prototype._complete = function(e6) {
        if (this.errord) return;
        let t4;
        try {
          let i3 = l2.dataToBitMap(e6, this._bitmapInfo);
          t4 = u2(i3, this._bitmapInfo, this._options.skipRescale), i3 = null;
        } catch (e7) {
          return void this._handleError(e7);
        }
        this.emit("parsed", t4);
      };
    }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 84, zlib: 31 }], 17: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = true, n3 = e5("zlib"), a2 = e5("./sync-inflate");
          n3.deflateSync || (r4 = false);
          let o3 = e5("./sync-reader"), s4 = e5("./filter-parse-sync"), l2 = e5("./parser"), u2 = e5("./bitmapper"), h2 = e5("./format-normaliser");
          t3.exports = function(e6, t4) {
            if (!r4) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            let c3, f2, d;
            function p2(e7) {
              c3 = e7;
            }
            __name(p2, "p");
            function m(e7) {
              f2 = e7;
            }
            __name(m, "m");
            function _2(e7) {
              f2.transColor = e7;
            }
            __name(_2, "_");
            function g(e7) {
              f2.palette = e7;
            }
            __name(g, "g");
            function b2() {
              f2.alpha = true;
            }
            __name(b2, "b");
            function y2(e7) {
              d = e7;
            }
            __name(y2, "y");
            let w = [];
            function v2(e7) {
              w.push(e7);
            }
            __name(v2, "v");
            let x2 = new o3(e6);
            if (new l2(t4, { read: x2.read.bind(x2), error: p2, metadata: m, gamma: y2, palette: g, transColor: _2, inflateData: v2, simpleTransparency: b2 }).start(), x2.process(), c3) throw c3;
            let E2, k2 = i3.concat(w);
            if (w.length = 0, f2.interlace) E2 = n3.inflateSync(k2);
            else {
              let e7 = (1 + (f2.width * f2.bpp * f2.depth + 7 >> 3)) * f2.height;
              E2 = a2(k2, { chunkSize: e7, maxLength: e7 });
            }
            if (k2 = null, !E2 || !E2.length) throw new Error("bad png - invalid inflate data response");
            let S2 = s4.process(E2, f2);
            k2 = null;
            let A2 = u2.dataToBitMap(S2, f2);
            S2 = null;
            let I = h2(A2, f2, t4.skipRescale);
            return f2.data = I, f2.gamma = d || 0, f2;
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 32, zlib: 31 }], 18: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          let r4 = e5("./constants"), n3 = e5("./crc"), a2 = t3.exports = function(e6, t4) {
            this._options = e6, e6.checkCRC = false !== e6.checkCRC, this._hasIHDR = false, this._hasIEND = false, this._emittedHeadersFinished = false, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[r4.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[r4.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[r4.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[r4.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[r4.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[r4.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = t4.read, this.error = t4.error, this.metadata = t4.metadata, this.gamma = t4.gamma, this.transColor = t4.transColor, this.palette = t4.palette, this.parsed = t4.parsed, this.inflateData = t4.inflateData, this.finished = t4.finished, this.simpleTransparency = t4.simpleTransparency, this.headersFinished = t4.headersFinished || function() {
            };
          };
          a2.prototype.start = function() {
            this.read(r4.PNG_SIGNATURE.length, this._parseSignature.bind(this));
          }, a2.prototype._parseSignature = function(e6) {
            let t4 = r4.PNG_SIGNATURE;
            for (let i4 = 0; i4 < t4.length; i4++) if (e6[i4] !== t4[i4]) return void this.error(new Error("Invalid file signature"));
            this.read(8, this._parseChunkBegin.bind(this));
          }, a2.prototype._parseChunkBegin = function(e6) {
            let t4 = e6.readUInt32BE(0), a3 = e6.readUInt32BE(4), o3 = "";
            for (let t5 = 4; t5 < 8; t5++) o3 += String.fromCharCode(e6[t5]);
            let s4 = Boolean(32 & e6[4]);
            if (this._hasIHDR || a3 === r4.TYPE_IHDR) {
              if (this._crc = new n3(), this._crc.write(i3.from(o3)), this._chunks[a3]) return this._chunks[a3](t4);
              s4 ? this.read(t4 + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + o3));
            } else this.error(new Error("Expected IHDR on beggining"));
          }, a2.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          }, a2.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          }, a2.prototype._parseChunkEnd = function(e6) {
            let t4 = e6.readInt32BE(0), i4 = this._crc.crc32();
            this._options.checkCRC && i4 !== t4 ? this.error(new Error("Crc error - " + t4 + " - " + i4)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
          }, a2.prototype._handleIHDR = function(e6) {
            this.read(e6, this._parseIHDR.bind(this));
          }, a2.prototype._parseIHDR = function(e6) {
            this._crc.write(e6);
            let t4 = e6.readUInt32BE(0), i4 = e6.readUInt32BE(4), n4 = e6[8], a3 = e6[9], o3 = e6[10], s4 = e6[11], l2 = e6[12];
            if (8 !== n4 && 4 !== n4 && 2 !== n4 && 1 !== n4 && 16 !== n4) return void this.error(new Error("Unsupported bit depth " + n4));
            if (!(a3 in r4.COLORTYPE_TO_BPP_MAP)) return void this.error(new Error("Unsupported color type"));
            if (0 !== o3) return void this.error(new Error("Unsupported compression method"));
            if (0 !== s4) return void this.error(new Error("Unsupported filter method"));
            if (0 !== l2 && 1 !== l2) return void this.error(new Error("Unsupported interlace method"));
            this._colorType = a3;
            let u2 = r4.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = true, this.metadata({ width: t4, height: i4, depth: n4, interlace: Boolean(l2), palette: Boolean(a3 & r4.COLORTYPE_PALETTE), color: Boolean(a3 & r4.COLORTYPE_COLOR), alpha: Boolean(a3 & r4.COLORTYPE_ALPHA), bpp: u2, colorType: a3 }), this._handleChunkEnd();
          }, a2.prototype._handlePLTE = function(e6) {
            this.read(e6, this._parsePLTE.bind(this));
          }, a2.prototype._parsePLTE = function(e6) {
            this._crc.write(e6);
            let t4 = Math.floor(e6.length / 3);
            for (let i4 = 0; i4 < t4; i4++) this._palette.push([e6[3 * i4], e6[3 * i4 + 1], e6[3 * i4 + 2], 255]);
            this.palette(this._palette), this._handleChunkEnd();
          }, a2.prototype._handleTRNS = function(e6) {
            this.simpleTransparency(), this.read(e6, this._parseTRNS.bind(this));
          }, a2.prototype._parseTRNS = function(e6) {
            if (this._crc.write(e6), this._colorType === r4.COLORTYPE_PALETTE_COLOR) {
              if (0 === this._palette.length) return void this.error(new Error("Transparency chunk must be after palette"));
              if (e6.length > this._palette.length) return void this.error(new Error("More transparent colors than palette size"));
              for (let t4 = 0; t4 < e6.length; t4++) this._palette[t4][3] = e6[t4];
              this.palette(this._palette);
            }
            this._colorType === r4.COLORTYPE_GRAYSCALE && this.transColor([e6.readUInt16BE(0)]), this._colorType === r4.COLORTYPE_COLOR && this.transColor([e6.readUInt16BE(0), e6.readUInt16BE(2), e6.readUInt16BE(4)]), this._handleChunkEnd();
          }, a2.prototype._handleGAMA = function(e6) {
            this.read(e6, this._parseGAMA.bind(this));
          }, a2.prototype._parseGAMA = function(e6) {
            this._crc.write(e6), this.gamma(e6.readUInt32BE(0) / r4.GAMMA_DIVISION), this._handleChunkEnd();
          }, a2.prototype._handleIDAT = function(e6) {
            this._emittedHeadersFinished || (this._emittedHeadersFinished = true, this.headersFinished()), this.read(-e6, this._parseIDAT.bind(this, e6));
          }, a2.prototype._parseIDAT = function(e6, t4) {
            if (this._crc.write(t4), this._colorType === r4.COLORTYPE_PALETTE_COLOR && 0 === this._palette.length) throw new Error("Expected palette not found");
            this.inflateData(t4);
            let i4 = e6 - t4.length;
            i4 > 0 ? this._handleIDAT(i4) : this._handleChunkEnd();
          }, a2.prototype._handleIEND = function(e6) {
            this.read(e6, this._parseIEND.bind(this));
          }, a2.prototype._parseIEND = function(e6) {
            this._crc.write(e6), this._hasIEND = true, this._handleChunkEnd(), this.finished && this.finished();
          };
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "./constants": 4, "./crc": 5, buffer: 32 }], 19: [function(e5, t3, i2) {
      let r4 = e5("./parser-sync"), n3 = e5("./packer-sync");
      i2.read = function(e6, t4) {
        return r4(e6, t4 || {});
      }, i2.write = function(e6, t4) {
        return n3(e6, t4);
      };
    }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(e5, t3, i2) {
      (function(t4, r4) {
        (function() {
          let n3 = e5("util"), a2 = e5("stream"), o3 = e5("./parser-async"), s4 = e5("./packer-async"), l2 = e5("./png-sync"), u2 = i2.PNG = function(e6) {
            a2.call(this), e6 = e6 || {}, this.width = 0 | e6.width, this.height = 0 | e6.height, this.data = this.width > 0 && this.height > 0 ? r4.alloc(4 * this.width * this.height) : null, e6.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = true, this._parser = new o3(e6), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(e7) {
              this.data = e7, this.emit("parsed", e7);
            }.bind(this)), this._packer = new s4(e6), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
          };
          n3.inherits(u2, a2), u2.sync = l2, u2.prototype.pack = function() {
            return this.data && this.data.length ? (t4.nextTick(function() {
              this._packer.pack(this.data, this.width, this.height, this.gamma);
            }.bind(this)), this) : (this.emit("error", "No data provided"), this);
          }, u2.prototype.parse = function(e6, t5) {
            if (t5) {
              let e7, i3;
              e7 = function(e8) {
                this.removeListener("error", i3), this.data = e8, t5(null, this);
              }.bind(this), i3 = function(i4) {
                this.removeListener("parsed", e7), t5(i4, null);
              }.bind(this), this.once("parsed", e7), this.once("error", i3);
            }
            return this.end(e6), this;
          }, u2.prototype.write = function(e6) {
            return this._parser.write(e6), true;
          }, u2.prototype.end = function(e6) {
            this._parser.end(e6);
          }, u2.prototype._metadata = function(e6) {
            this.width = e6.width, this.height = e6.height, this.emit("metadata", e6);
          }, u2.prototype._gamma = function(e6) {
            this.gamma = e6;
          }, u2.prototype._handleClose = function() {
            this._parser.writable || this._packer.readable || this.emit("close");
          }, u2.bitblt = function(e6, t5, i3, r5, n4, a3, o4, s5) {
            if (r5 |= 0, n4 |= 0, a3 |= 0, o4 |= 0, s5 |= 0, (i3 |= 0) > e6.width || r5 > e6.height || i3 + n4 > e6.width || r5 + a3 > e6.height) throw new Error("bitblt reading outside image");
            if (o4 > t5.width || s5 > t5.height || o4 + n4 > t5.width || s5 + a3 > t5.height) throw new Error("bitblt writing outside image");
            for (let l3 = 0; l3 < a3; l3++) e6.data.copy(t5.data, (s5 + l3) * t5.width + o4 << 2, (r5 + l3) * e6.width + i3 << 2, (r5 + l3) * e6.width + i3 + n4 << 2);
          }, u2.prototype.bitblt = function(e6, t5, i3, r5, n4, a3, o4) {
            return u2.bitblt(this, e6, t5, i3, r5, n4, a3, o4), this;
          }, u2.adjustGamma = function(e6) {
            if (e6.gamma) {
              for (let t5 = 0; t5 < e6.height; t5++) for (let i3 = 0; i3 < e6.width; i3++) {
                let r5 = e6.width * t5 + i3 << 2;
                for (let t6 = 0; t6 < 3; t6++) {
                  let i4 = e6.data[r5 + t6] / 255;
                  i4 = Math.pow(i4, 1 / 2.2 / e6.gamma), e6.data[r5 + t6] = Math.round(255 * i4);
                }
              }
              e6.gamma = 0;
            }
          }, u2.prototype.adjustGamma = function() {
            u2.adjustGamma(this);
          };
        }).call(this);
      }).call(this, e5("_process"), e5("buffer").Buffer);
    }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 63, buffer: 32, stream: 65, util: 84 }], 21: [function(e5, t3, i2) {
      (function(r4, n3) {
        (function() {
          let r5 = e5("assert").ok, a2 = e5("zlib"), o3 = e5("util"), s4 = e5("buffer").kMaxLength;
          function l2(e6) {
            if (!(this instanceof l2)) return new l2(e6);
            e6 && e6.chunkSize < a2.Z_MIN_CHUNK && (e6.chunkSize = a2.Z_MIN_CHUNK), a2.Inflate.call(this, e6), this._offset = void 0 === this._offset ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, e6 && null != e6.maxLength && (this._maxLength = e6.maxLength);
          }
          __name(l2, "l");
          function u2(e6) {
            return new l2(e6);
          }
          __name(u2, "u");
          function h2(e6, t4) {
            e6._handle && (e6._handle.close(), e6._handle = null);
          }
          __name(h2, "h");
          function c3(e6, t4) {
            if ("string" == typeof t4 && (t4 = n3.from(t4)), !(t4 instanceof n3)) throw new TypeError("Not a string or buffer");
            let i3 = e6._finishFlushFlag;
            return null == i3 && (i3 = a2.Z_FINISH), e6._processChunk(t4, i3);
          }
          __name(c3, "c");
          function f2(e6, t4) {
            return c3(new l2(t4), e6);
          }
          __name(f2, "f");
          l2.prototype._processChunk = function(e6, t4, i3) {
            if ("function" == typeof i3) return a2.Inflate._processChunk.call(this, e6, t4, i3);
            let o4, l3, u3 = this, c4 = e6 && e6.length, f3 = this._chunkSize - this._offset, d = this._maxLength, p2 = 0, m = [], _2 = 0;
            function g(e7, t5) {
              if (u3._hadError) return;
              let i4 = f3 - t5;
              if (r5(i4 >= 0, "have should not go down"), i4 > 0) {
                let e8 = u3._buffer.slice(u3._offset, u3._offset + i4);
                if (u3._offset += i4, e8.length > d && (e8 = e8.slice(0, d)), m.push(e8), _2 += e8.length, d -= e8.length, 0 === d) return false;
              }
              return (0 === t5 || u3._offset >= u3._chunkSize) && (f3 = u3._chunkSize, u3._offset = 0, u3._buffer = n3.allocUnsafe(u3._chunkSize)), 0 === t5 && (p2 += c4 - e7, c4 = e7, true);
            }
            __name(g, "g");
            this.on("error", function(e7) {
              o4 = e7;
            }), r5(this._handle, "zlib binding closed");
            do {
              l3 = this._handle.writeSync(t4, e6, p2, c4, this._buffer, this._offset, f3), l3 = l3 || this._writeState;
            } while (!this._hadError && g(l3[0], l3[1]));
            if (this._hadError) throw o4;
            if (_2 >= s4) throw h2(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + s4.toString(16) + " bytes");
            let b2 = n3.concat(m, _2);
            return h2(this), b2;
          }, o3.inherits(l2, a2.Inflate), t3.exports = i2 = f2, i2.Inflate = l2, i2.createInflate = u2, i2.inflateSync = f2;
        }).call(this);
      }).call(this, e5("_process"), e5("buffer").Buffer);
    }, { _process: 63, assert: 23, buffer: 32, util: 84, zlib: 31 }], 22: [function(e5, t3, i2) {
      let r4 = t3.exports = function(e6) {
        this._buffer = e6, this._reads = [];
      };
      r4.prototype.read = function(e6, t4) {
        this._reads.push({ length: Math.abs(e6), allowLess: e6 < 0, func: t4 });
      }, r4.prototype.process = function() {
        for (; this._reads.length > 0 && this._buffer.length; ) {
          let e6 = this._reads[0];
          if (!this._buffer.length || !(this._buffer.length >= e6.length || e6.allowLess)) break;
          {
            this._reads.shift();
            let t4 = this._buffer;
            this._buffer = t4.slice(e6.length), e6.func.call(this, t4.slice(0, e6.length));
          }
        }
        if (this._reads.length > 0) throw new Error("There are some read requests waitng on finished stream");
        if (this._buffer.length > 0) throw new Error("unrecognised content at end of stream");
      };
    }, {}], 23: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          var r4 = e5("object-assign");
          function n3(e6, t4) {
            if (e6 === t4) return 0;
            for (var i4 = e6.length, r5 = t4.length, n4 = 0, a3 = Math.min(i4, r5); n4 < a3; ++n4) if (e6[n4] !== t4[n4]) {
              i4 = e6[n4], r5 = t4[n4];
              break;
            }
            return i4 < r5 ? -1 : r5 < i4 ? 1 : 0;
          }
          __name(n3, "n");
          function a2(e6) {
            return i3.Buffer && "function" == typeof i3.Buffer.isBuffer ? i3.Buffer.isBuffer(e6) : !(null == e6 || !e6._isBuffer);
          }
          __name(a2, "a");
          var o3 = e5("util/"), s4 = Object.prototype.hasOwnProperty, l2 = Array.prototype.slice, u2 = "foo" === function() {
          }.name;
          function h2(e6) {
            return Object.prototype.toString.call(e6);
          }
          __name(h2, "h");
          function c3(e6) {
            return !a2(e6) && "function" == typeof i3.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e6) : !!e6 && (e6 instanceof DataView || !!(e6.buffer && e6.buffer instanceof ArrayBuffer)));
          }
          __name(c3, "c");
          var f2 = t3.exports = y2, d = /\s*function\s+([^\(\s]*)\s*/;
          function p2(e6) {
            if (o3.isFunction(e6)) {
              if (u2) return e6.name;
              var t4 = e6.toString().match(d);
              return t4 && t4[1];
            }
          }
          __name(p2, "p");
          function m(e6, t4) {
            return "string" == typeof e6 ? e6.length < t4 ? e6 : e6.slice(0, t4) : e6;
          }
          __name(m, "m");
          function _2(e6) {
            if (u2 || !o3.isFunction(e6)) return o3.inspect(e6);
            var t4 = p2(e6);
            return "[Function" + (t4 ? ": " + t4 : "") + "]";
          }
          __name(_2, "_");
          function g(e6) {
            return m(_2(e6.actual), 128) + " " + e6.operator + " " + m(_2(e6.expected), 128);
          }
          __name(g, "g");
          function b2(e6, t4, i4, r5, n4) {
            throw new f2.AssertionError({ message: i4, actual: e6, expected: t4, operator: r5, stackStartFunction: n4 });
          }
          __name(b2, "b");
          function y2(e6, t4) {
            e6 || b2(e6, true, t4, "==", f2.ok);
          }
          __name(y2, "y");
          function w(e6, t4, i4, r5) {
            if (e6 === t4) return true;
            if (a2(e6) && a2(t4)) return 0 === n3(e6, t4);
            if (o3.isDate(e6) && o3.isDate(t4)) return e6.getTime() === t4.getTime();
            if (o3.isRegExp(e6) && o3.isRegExp(t4)) return e6.source === t4.source && e6.global === t4.global && e6.multiline === t4.multiline && e6.lastIndex === t4.lastIndex && e6.ignoreCase === t4.ignoreCase;
            if (null !== e6 && "object" == typeof e6 || null !== t4 && "object" == typeof t4) {
              if (c3(e6) && c3(t4) && h2(e6) === h2(t4) && !(e6 instanceof Float32Array || e6 instanceof Float64Array)) return 0 === n3(new Uint8Array(e6.buffer), new Uint8Array(t4.buffer));
              if (a2(e6) !== a2(t4)) return false;
              var s5 = (r5 = r5 || { actual: [], expected: [] }).actual.indexOf(e6);
              return -1 !== s5 && s5 === r5.expected.indexOf(t4) || (r5.actual.push(e6), r5.expected.push(t4), x2(e6, t4, i4, r5));
            }
            return i4 ? e6 === t4 : e6 == t4;
          }
          __name(w, "w");
          function v2(e6) {
            return "[object Arguments]" == Object.prototype.toString.call(e6);
          }
          __name(v2, "v");
          function x2(e6, t4, i4, r5) {
            if (null == e6 || null == t4) return false;
            if (o3.isPrimitive(e6) || o3.isPrimitive(t4)) return e6 === t4;
            if (i4 && Object.getPrototypeOf(e6) !== Object.getPrototypeOf(t4)) return false;
            var n4 = v2(e6), a3 = v2(t4);
            if (n4 && !a3 || !n4 && a3) return false;
            if (n4) return w(e6 = l2.call(e6), t4 = l2.call(t4), i4);
            var s5, u3, h3 = M2(e6), c4 = M2(t4);
            if (h3.length !== c4.length) return false;
            for (h3.sort(), c4.sort(), u3 = h3.length - 1; u3 >= 0; u3--) if (h3[u3] !== c4[u3]) return false;
            for (u3 = h3.length - 1; u3 >= 0; u3--) if (!w(e6[s5 = h3[u3]], t4[s5], i4, r5)) return false;
            return true;
          }
          __name(x2, "x");
          function E2(e6, t4, i4) {
            w(e6, t4, true) && b2(e6, t4, i4, "notDeepStrictEqual", E2);
          }
          __name(E2, "E");
          function k2(e6, t4) {
            if (!e6 || !t4) return false;
            if ("[object RegExp]" == Object.prototype.toString.call(t4)) return t4.test(e6);
            try {
              if (e6 instanceof t4) return true;
            } catch (e7) {
            }
            return !Error.isPrototypeOf(t4) && true === t4.call({}, e6);
          }
          __name(k2, "k");
          function S2(e6) {
            var t4;
            try {
              e6();
            } catch (e7) {
              t4 = e7;
            }
            return t4;
          }
          __name(S2, "S");
          function A2(e6, t4, i4, r5) {
            var n4;
            if ("function" != typeof t4) throw new TypeError('"block" argument must be a function');
            "string" == typeof i4 && (r5 = i4, i4 = null), n4 = S2(t4), r5 = (i4 && i4.name ? " (" + i4.name + ")." : ".") + (r5 ? " " + r5 : "."), e6 && !n4 && b2(n4, i4, "Missing expected exception" + r5);
            var a3 = "string" == typeof r5, s5 = !e6 && n4 && !i4;
            if ((!e6 && o3.isError(n4) && a3 && k2(n4, i4) || s5) && b2(n4, i4, "Got unwanted exception" + r5), e6 && n4 && i4 && !k2(n4, i4) || !e6 && n4) throw n4;
          }
          __name(A2, "A");
          function I(e6, t4) {
            e6 || b2(e6, true, t4, "==", I);
          }
          __name(I, "I");
          f2.AssertionError = function(e6) {
            this.name = "AssertionError", this.actual = e6.actual, this.expected = e6.expected, this.operator = e6.operator, e6.message ? (this.message = e6.message, this.generatedMessage = false) : (this.message = g(this), this.generatedMessage = true);
            var t4 = e6.stackStartFunction || b2;
            if (Error.captureStackTrace) Error.captureStackTrace(this, t4);
            else {
              var i4 = new Error();
              if (i4.stack) {
                var r5 = i4.stack, n4 = p2(t4), a3 = r5.indexOf("\n" + n4);
                if (a3 >= 0) {
                  var o4 = r5.indexOf("\n", a3 + 1);
                  r5 = r5.substring(o4 + 1);
                }
                this.stack = r5;
              }
            }
          }, o3.inherits(f2.AssertionError, Error), f2.fail = b2, f2.ok = y2, f2.equal = function(e6, t4, i4) {
            e6 != t4 && b2(e6, t4, i4, "==", f2.equal);
          }, f2.notEqual = function(e6, t4, i4) {
            e6 == t4 && b2(e6, t4, i4, "!=", f2.notEqual);
          }, f2.deepEqual = function(e6, t4, i4) {
            w(e6, t4, false) || b2(e6, t4, i4, "deepEqual", f2.deepEqual);
          }, f2.deepStrictEqual = function(e6, t4, i4) {
            w(e6, t4, true) || b2(e6, t4, i4, "deepStrictEqual", f2.deepStrictEqual);
          }, f2.notDeepEqual = function(e6, t4, i4) {
            w(e6, t4, false) && b2(e6, t4, i4, "notDeepEqual", f2.notDeepEqual);
          }, f2.notDeepStrictEqual = E2, f2.strictEqual = function(e6, t4, i4) {
            e6 !== t4 && b2(e6, t4, i4, "===", f2.strictEqual);
          }, f2.notStrictEqual = function(e6, t4, i4) {
            e6 === t4 && b2(e6, t4, i4, "!==", f2.notStrictEqual);
          }, f2.throws = function(e6, t4, i4) {
            A2(true, e6, t4, i4);
          }, f2.doesNotThrow = function(e6, t4, i4) {
            A2(false, e6, t4, i4);
          }, f2.ifError = function(e6) {
            if (e6) throw e6;
          }, f2.strict = r4(I, f2, { equal: f2.strictEqual, deepEqual: f2.deepStrictEqual, notEqual: f2.notStrictEqual, notDeepEqual: f2.notDeepStrictEqual }), f2.strict.strict = f2.strict;
          var M2 = Object.keys || function(e6) {
            var t4 = [];
            for (var i4 in e6) s4.call(e6, i4) && t4.push(i4);
            return t4;
          };
        }).call(this);
      }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { "object-assign": 51, "util/": 26 }], 24: [function(e5, t3, i2) {
      "function" == typeof Object.create ? t3.exports = function(e6, t4) {
        e6.super_ = t4, e6.prototype = Object.create(t4.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } });
      } : t3.exports = function(e6, t4) {
        e6.super_ = t4;
        var i3 = /* @__PURE__ */ __name(function() {
        }, "i");
        i3.prototype = t4.prototype, e6.prototype = new i3(), e6.prototype.constructor = e6;
      };
    }, {}], 25: [function(e5, t3, i2) {
      t3.exports = function(e6) {
        return e6 && "object" == typeof e6 && "function" == typeof e6.copy && "function" == typeof e6.fill && "function" == typeof e6.readUInt8;
      };
    }, {}], 26: [function(e5, t3, i2) {
      (function(t4, r4) {
        (function() {
          var n3 = /%[sdj%]/g;
          i2.format = function(e6) {
            if (!x2(e6)) {
              for (var t5 = [], i3 = 0; i3 < arguments.length; i3++) t5.push(s4(arguments[i3]));
              return t5.join(" ");
            }
            i3 = 1;
            for (var r5 = arguments, a3 = r5.length, o4 = String(e6).replace(n3, function(e7) {
              if ("%%" === e7) return "%";
              if (i3 >= a3) return e7;
              switch (e7) {
                case "%s":
                  return String(r5[i3++]);
                case "%d":
                  return Number(r5[i3++]);
                case "%j":
                  try {
                    return JSON.stringify(r5[i3++]);
                  } catch (e8) {
                    return "[Circular]";
                  }
                default:
                  return e7;
              }
            }), l3 = r5[i3]; i3 < a3; l3 = r5[++i3]) y2(l3) || !A2(l3) ? o4 += " " + l3 : o4 += " " + s4(l3);
            return o4;
          }, i2.deprecate = function(e6, n4) {
            if (k2(r4.process)) return function() {
              return i2.deprecate(e6, n4).apply(this, arguments);
            };
            if (true === t4.noDeprecation) return e6;
            var a3 = false;
            function o4() {
              if (!a3) {
                if (t4.throwDeprecation) throw new Error(n4);
                t4.traceDeprecation ? console.trace(n4) : console.error(n4), a3 = true;
              }
              return e6.apply(this, arguments);
            }
            __name(o4, "o");
            return o4;
          };
          var a2, o3 = {};
          function s4(e6, t5) {
            var r5 = { seen: [], stylize: u2 };
            return arguments.length >= 3 && (r5.depth = arguments[2]), arguments.length >= 4 && (r5.colors = arguments[3]), b2(t5) ? r5.showHidden = t5 : t5 && i2._extend(r5, t5), k2(r5.showHidden) && (r5.showHidden = false), k2(r5.depth) && (r5.depth = 2), k2(r5.colors) && (r5.colors = false), k2(r5.customInspect) && (r5.customInspect = true), r5.colors && (r5.stylize = l2), c3(r5, e6, r5.depth);
          }
          __name(s4, "s");
          function l2(e6, t5) {
            var i3 = s4.styles[t5];
            return i3 ? "\x1B[" + s4.colors[i3][0] + "m" + e6 + "\x1B[" + s4.colors[i3][1] + "m" : e6;
          }
          __name(l2, "l");
          function u2(e6, t5) {
            return e6;
          }
          __name(u2, "u");
          function h2(e6) {
            var t5 = {};
            return e6.forEach(function(e7, i3) {
              t5[e7] = true;
            }), t5;
          }
          __name(h2, "h");
          function c3(e6, t5, r5) {
            if (e6.customInspect && t5 && T2(t5.inspect) && t5.inspect !== i2.inspect && (!t5.constructor || t5.constructor.prototype !== t5)) {
              var n4 = t5.inspect(r5, e6);
              return x2(n4) || (n4 = c3(e6, n4, r5)), n4;
            }
            var a3 = f2(e6, t5);
            if (a3) return a3;
            var o4 = Object.keys(t5), s5 = h2(o4);
            if (e6.showHidden && (o4 = Object.getOwnPropertyNames(t5)), M2(t5) && (o4.indexOf("message") >= 0 || o4.indexOf("description") >= 0)) return d(t5);
            if (0 === o4.length) {
              if (T2(t5)) {
                var l3 = t5.name ? ": " + t5.name : "";
                return e6.stylize("[Function" + l3 + "]", "special");
              }
              if (S2(t5)) return e6.stylize(RegExp.prototype.toString.call(t5), "regexp");
              if (I(t5)) return e6.stylize(Date.prototype.toString.call(t5), "date");
              if (M2(t5)) return d(t5);
            }
            var u3, b3 = "", y3 = false, w2 = ["{", "}"];
            return g(t5) && (y3 = true, w2 = ["[", "]"]), T2(t5) && (b3 = " [Function" + (t5.name ? ": " + t5.name : "") + "]"), S2(t5) && (b3 = " " + RegExp.prototype.toString.call(t5)), I(t5) && (b3 = " " + Date.prototype.toUTCString.call(t5)), M2(t5) && (b3 = " " + d(t5)), 0 !== o4.length || y3 && 0 != t5.length ? r5 < 0 ? S2(t5) ? e6.stylize(RegExp.prototype.toString.call(t5), "regexp") : e6.stylize("[Object]", "special") : (e6.seen.push(t5), u3 = y3 ? p2(e6, t5, r5, s5, o4) : o4.map(function(i3) {
              return m(e6, t5, r5, s5, i3, y3);
            }), e6.seen.pop(), _2(u3, b3, w2)) : w2[0] + b3 + w2[1];
          }
          __name(c3, "c");
          function f2(e6, t5) {
            if (k2(t5)) return e6.stylize("undefined", "undefined");
            if (x2(t5)) {
              var i3 = "'" + JSON.stringify(t5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return e6.stylize(i3, "string");
            }
            return v2(t5) ? e6.stylize("" + t5, "number") : b2(t5) ? e6.stylize("" + t5, "boolean") : y2(t5) ? e6.stylize("null", "null") : void 0;
          }
          __name(f2, "f");
          function d(e6) {
            return "[" + Error.prototype.toString.call(e6) + "]";
          }
          __name(d, "d");
          function p2(e6, t5, i3, r5, n4) {
            for (var a3 = [], o4 = 0, s5 = t5.length; o4 < s5; ++o4) F(t5, String(o4)) ? a3.push(m(e6, t5, i3, r5, String(o4), true)) : a3.push("");
            return n4.forEach(function(n5) {
              n5.match(/^\d+$/) || a3.push(m(e6, t5, i3, r5, n5, true));
            }), a3;
          }
          __name(p2, "p");
          function m(e6, t5, i3, r5, n4, a3) {
            var o4, s5, l3;
            if ((l3 = Object.getOwnPropertyDescriptor(t5, n4) || { value: t5[n4] }).get ? s5 = l3.set ? e6.stylize("[Getter/Setter]", "special") : e6.stylize("[Getter]", "special") : l3.set && (s5 = e6.stylize("[Setter]", "special")), F(r5, n4) || (o4 = "[" + n4 + "]"), s5 || (e6.seen.indexOf(l3.value) < 0 ? (s5 = y2(i3) ? c3(e6, l3.value, null) : c3(e6, l3.value, i3 - 1)).indexOf("\n") > -1 && (s5 = a3 ? s5.split("\n").map(function(e7) {
              return "  " + e7;
            }).join("\n").substr(2) : "\n" + s5.split("\n").map(function(e7) {
              return "   " + e7;
            }).join("\n")) : s5 = e6.stylize("[Circular]", "special")), k2(o4)) {
              if (a3 && n4.match(/^\d+$/)) return s5;
              (o4 = JSON.stringify("" + n4)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o4 = o4.substr(1, o4.length - 2), o4 = e6.stylize(o4, "name")) : (o4 = o4.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o4 = e6.stylize(o4, "string"));
            }
            return o4 + ": " + s5;
          }
          __name(m, "m");
          function _2(e6, t5, i3) {
            return e6.reduce(function(e7, t6) {
              return t6.indexOf("\n"), e7 + t6.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60 ? i3[0] + ("" === t5 ? "" : t5 + "\n ") + " " + e6.join(",\n  ") + " " + i3[1] : i3[0] + t5 + " " + e6.join(", ") + " " + i3[1];
          }
          __name(_2, "_");
          function g(e6) {
            return Array.isArray(e6);
          }
          __name(g, "g");
          function b2(e6) {
            return "boolean" == typeof e6;
          }
          __name(b2, "b");
          function y2(e6) {
            return null === e6;
          }
          __name(y2, "y");
          function w(e6) {
            return null == e6;
          }
          __name(w, "w");
          function v2(e6) {
            return "number" == typeof e6;
          }
          __name(v2, "v");
          function x2(e6) {
            return "string" == typeof e6;
          }
          __name(x2, "x");
          function E2(e6) {
            return "symbol" == typeof e6;
          }
          __name(E2, "E");
          function k2(e6) {
            return void 0 === e6;
          }
          __name(k2, "k");
          function S2(e6) {
            return A2(e6) && "[object RegExp]" === B2(e6);
          }
          __name(S2, "S");
          function A2(e6) {
            return "object" == typeof e6 && null !== e6;
          }
          __name(A2, "A");
          function I(e6) {
            return A2(e6) && "[object Date]" === B2(e6);
          }
          __name(I, "I");
          function M2(e6) {
            return A2(e6) && ("[object Error]" === B2(e6) || e6 instanceof Error);
          }
          __name(M2, "M");
          function T2(e6) {
            return "function" == typeof e6;
          }
          __name(T2, "T");
          function P(e6) {
            return null === e6 || "boolean" == typeof e6 || "number" == typeof e6 || "string" == typeof e6 || "symbol" == typeof e6 || void 0 === e6;
          }
          __name(P, "P");
          function B2(e6) {
            return Object.prototype.toString.call(e6);
          }
          __name(B2, "B");
          function C2(e6) {
            return e6 < 10 ? "0" + e6.toString(10) : e6.toString(10);
          }
          __name(C2, "C");
          i2.debuglog = function(e6) {
            if (k2(a2) && (a2 = t4.env.NODE_DEBUG || ""), e6 = e6.toUpperCase(), !o3[e6]) if (new RegExp("\\b" + e6 + "\\b", "i").test(a2)) {
              var r5 = t4.pid;
              o3[e6] = function() {
                var t5 = i2.format.apply(i2, arguments);
                console.error("%s %d: %s", e6, r5, t5);
              };
            } else o3[e6] = function() {
            };
            return o3[e6];
          }, i2.inspect = s4, s4.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, s4.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.isArray = g, i2.isBoolean = b2, i2.isNull = y2, i2.isNullOrUndefined = w, i2.isNumber = v2, i2.isString = x2, i2.isSymbol = E2, i2.isUndefined = k2, i2.isRegExp = S2, i2.isObject = A2, i2.isDate = I, i2.isError = M2, i2.isFunction = T2, i2.isPrimitive = P, i2.isBuffer = e5("./support/isBuffer");
          var R2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function z2() {
            var e6 = /* @__PURE__ */ new Date(), t5 = [C2(e6.getHours()), C2(e6.getMinutes()), C2(e6.getSeconds())].join(":");
            return [e6.getDate(), R2[e6.getMonth()], t5].join(" ");
          }
          __name(z2, "z");
          function F(e6, t5) {
            return Object.prototype.hasOwnProperty.call(e6, t5);
          }
          __name(F, "F");
          i2.log = function() {
            console.log("%s - %s", z2(), i2.format.apply(i2, arguments));
          }, i2.inherits = e5("inherits"), i2._extend = function(e6, t5) {
            if (!t5 || !A2(t5)) return e6;
            for (var i3 = Object.keys(t5), r5 = i3.length; r5--; ) e6[i3[r5]] = t5[i3[r5]];
            return e6;
          };
        }).call(this);
      }).call(this, e5("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { "./support/isBuffer": 25, _process: 63, inherits: 24 }], 27: [function(e5, t3, i2) {
      (function(e6) {
        (function() {
          var i3 = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], r4 = "undefined" == typeof globalThis ? e6 : globalThis;
          t3.exports = function() {
            for (var e7 = [], t4 = 0; t4 < i3.length; t4++) "function" == typeof r4[i3[t4]] && (e7[e7.length] = i3[t4]);
            return e7;
          };
        }).call(this);
      }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 28: [function(e5, t3, i2) {
      i2.byteLength = h2, i2.toByteArray = f2, i2.fromByteArray = m;
      for (var r4 = [], n3 = [], a2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s4 = 0, l2 = o3.length; s4 < l2; ++s4) r4[s4] = o3[s4], n3[o3.charCodeAt(s4)] = s4;
      function u2(e6) {
        var t4 = e6.length;
        if (t4 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var i3 = e6.indexOf("=");
        return -1 === i3 && (i3 = t4), [i3, i3 === t4 ? 0 : 4 - i3 % 4];
      }
      __name(u2, "u");
      function h2(e6) {
        var t4 = u2(e6), i3 = t4[0], r5 = t4[1];
        return 3 * (i3 + r5) / 4 - r5;
      }
      __name(h2, "h");
      function c3(e6, t4, i3) {
        return 3 * (t4 + i3) / 4 - i3;
      }
      __name(c3, "c");
      function f2(e6) {
        var t4, i3, r5 = u2(e6), o4 = r5[0], s5 = r5[1], l3 = new a2(c3(e6, o4, s5)), h3 = 0, f3 = s5 > 0 ? o4 - 4 : o4;
        for (i3 = 0; i3 < f3; i3 += 4) t4 = n3[e6.charCodeAt(i3)] << 18 | n3[e6.charCodeAt(i3 + 1)] << 12 | n3[e6.charCodeAt(i3 + 2)] << 6 | n3[e6.charCodeAt(i3 + 3)], l3[h3++] = t4 >> 16 & 255, l3[h3++] = t4 >> 8 & 255, l3[h3++] = 255 & t4;
        return 2 === s5 && (t4 = n3[e6.charCodeAt(i3)] << 2 | n3[e6.charCodeAt(i3 + 1)] >> 4, l3[h3++] = 255 & t4), 1 === s5 && (t4 = n3[e6.charCodeAt(i3)] << 10 | n3[e6.charCodeAt(i3 + 1)] << 4 | n3[e6.charCodeAt(i3 + 2)] >> 2, l3[h3++] = t4 >> 8 & 255, l3[h3++] = 255 & t4), l3;
      }
      __name(f2, "f");
      function d(e6) {
        return r4[e6 >> 18 & 63] + r4[e6 >> 12 & 63] + r4[e6 >> 6 & 63] + r4[63 & e6];
      }
      __name(d, "d");
      function p2(e6, t4, i3) {
        for (var r5, n4 = [], a3 = t4; a3 < i3; a3 += 3) r5 = (e6[a3] << 16 & 16711680) + (e6[a3 + 1] << 8 & 65280) + (255 & e6[a3 + 2]), n4.push(d(r5));
        return n4.join("");
      }
      __name(p2, "p");
      function m(e6) {
        for (var t4, i3 = e6.length, n4 = i3 % 3, a3 = [], o4 = 16383, s5 = 0, l3 = i3 - n4; s5 < l3; s5 += o4) a3.push(p2(e6, s5, s5 + o4 > l3 ? l3 : s5 + o4));
        return 1 === n4 ? (t4 = e6[i3 - 1], a3.push(r4[t4 >> 2] + r4[t4 << 4 & 63] + "==")) : 2 === n4 && (t4 = (e6[i3 - 2] << 8) + e6[i3 - 1], a3.push(r4[t4 >> 10] + r4[t4 >> 4 & 63] + r4[t4 << 2 & 63] + "=")), a3.join("");
      }
      __name(m, "m");
      n3["-".charCodeAt(0)] = 62, n3["_".charCodeAt(0)] = 63;
    }, {}], 29: [function(e5, t3, i2) {
    }, {}], 30: [function(e5, t3, i2) {
      (function(t4, r4) {
        (function() {
          var n3 = e5("assert"), a2 = e5("pako/lib/zlib/zstream"), o3 = e5("pako/lib/zlib/deflate.js"), s4 = e5("pako/lib/zlib/inflate.js"), l2 = e5("pako/lib/zlib/constants");
          for (var u2 in l2) i2[u2] = l2[u2];
          i2.NONE = 0, i2.DEFLATE = 1, i2.INFLATE = 2, i2.GZIP = 3, i2.GUNZIP = 4, i2.DEFLATERAW = 5, i2.INFLATERAW = 6, i2.UNZIP = 7;
          var h2 = 31, c3 = 139;
          function f2(e6) {
            if ("number" != typeof e6 || e6 < i2.DEFLATE || e6 > i2.UNZIP) throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = false, this.level = 0, this.memLevel = 0, this.mode = e6, this.strategy = 0, this.windowBits = 0, this.write_in_progress = false, this.pending_close = false, this.gzip_id_bytes_read = 0;
          }
          __name(f2, "f");
          f2.prototype.close = function() {
            this.write_in_progress ? this.pending_close = true : (this.pending_close = false, n3(this.init_done, "close before init"), n3(this.mode <= i2.UNZIP), this.mode === i2.DEFLATE || this.mode === i2.GZIP || this.mode === i2.DEFLATERAW ? o3.deflateEnd(this.strm) : this.mode !== i2.INFLATE && this.mode !== i2.GUNZIP && this.mode !== i2.INFLATERAW && this.mode !== i2.UNZIP || s4.inflateEnd(this.strm), this.mode = i2.NONE, this.dictionary = null);
          }, f2.prototype.write = function(e6, t5, i3, r5, n4, a3, o4) {
            return this._write(true, e6, t5, i3, r5, n4, a3, o4);
          }, f2.prototype.writeSync = function(e6, t5, i3, r5, n4, a3, o4) {
            return this._write(false, e6, t5, i3, r5, n4, a3, o4);
          }, f2.prototype._write = function(e6, a3, o4, s5, l3, u3, h3, c4) {
            if (n3.equal(arguments.length, 8), n3(this.init_done, "write before init"), n3(this.mode !== i2.NONE, "already finalized"), n3.equal(false, this.write_in_progress, "write already in progress"), n3.equal(false, this.pending_close, "close is pending"), this.write_in_progress = true, n3.equal(false, void 0 === a3, "must provide flush value"), this.write_in_progress = true, a3 !== i2.Z_NO_FLUSH && a3 !== i2.Z_PARTIAL_FLUSH && a3 !== i2.Z_SYNC_FLUSH && a3 !== i2.Z_FULL_FLUSH && a3 !== i2.Z_FINISH && a3 !== i2.Z_BLOCK) throw new Error("Invalid flush value");
            if (null == o4 && (o4 = r4.alloc(0), l3 = 0, s5 = 0), this.strm.avail_in = l3, this.strm.input = o4, this.strm.next_in = s5, this.strm.avail_out = c4, this.strm.output = u3, this.strm.next_out = h3, this.flush = a3, !e6) return this._process(), this._checkError() ? this._afterSync() : void 0;
            var f3 = this;
            return t4.nextTick(function() {
              f3._process(), f3._after();
            }), this;
          }, f2.prototype._afterSync = function() {
            var e6 = this.strm.avail_out, t5 = this.strm.avail_in;
            return this.write_in_progress = false, [t5, e6];
          }, f2.prototype._process = function() {
            var e6 = null;
            switch (this.mode) {
              case i2.DEFLATE:
              case i2.GZIP:
              case i2.DEFLATERAW:
                this.err = o3.deflate(this.strm, this.flush);
                break;
              case i2.UNZIP:
                switch (this.strm.avail_in > 0 && (e6 = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (null === e6) break;
                    if (this.strm.input[e6] !== h2) {
                      this.mode = i2.INFLATE;
                      break;
                    }
                    if (this.gzip_id_bytes_read = 1, e6++, 1 === this.strm.avail_in) break;
                  case 1:
                    if (null === e6) break;
                    this.strm.input[e6] === c3 ? (this.gzip_id_bytes_read = 2, this.mode = i2.GUNZIP) : this.mode = i2.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              case i2.INFLATE:
              case i2.GUNZIP:
              case i2.INFLATERAW:
                for (this.err = s4.inflate(this.strm, this.flush), this.err === i2.Z_NEED_DICT && this.dictionary && (this.err = s4.inflateSetDictionary(this.strm, this.dictionary), this.err === i2.Z_OK ? this.err = s4.inflate(this.strm, this.flush) : this.err === i2.Z_DATA_ERROR && (this.err = i2.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === i2.GUNZIP && this.err === i2.Z_STREAM_END && 0 !== this.strm.next_in[0]; ) this.reset(), this.err = s4.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, f2.prototype._checkError = function() {
            switch (this.err) {
              case i2.Z_OK:
              case i2.Z_BUF_ERROR:
                if (0 !== this.strm.avail_out && this.flush === i2.Z_FINISH) return this._error("unexpected end of file"), false;
                break;
              case i2.Z_STREAM_END:
                break;
              case i2.Z_NEED_DICT:
                return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), false;
              default:
                return this._error("Zlib error"), false;
            }
            return true;
          }, f2.prototype._after = function() {
            if (this._checkError()) {
              var e6 = this.strm.avail_out, t5 = this.strm.avail_in;
              this.write_in_progress = false, this.callback(t5, e6), this.pending_close && this.close();
            }
          }, f2.prototype._error = function(e6) {
            this.strm.msg && (e6 = this.strm.msg), this.onerror(e6, this.err), this.write_in_progress = false, this.pending_close && this.close();
          }, f2.prototype.init = function(e6, t5, r5, a3, o4) {
            n3(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), n3(e6 >= 8 && e6 <= 15, "invalid windowBits"), n3(t5 >= -1 && t5 <= 9, "invalid compression level"), n3(r5 >= 1 && r5 <= 9, "invalid memlevel"), n3(a3 === i2.Z_FILTERED || a3 === i2.Z_HUFFMAN_ONLY || a3 === i2.Z_RLE || a3 === i2.Z_FIXED || a3 === i2.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(t5, e6, r5, a3, o4), this._setDictionary();
          }, f2.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, f2.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, f2.prototype._init = function(e6, t5, r5, n4, l3) {
            switch (this.level = e6, this.windowBits = t5, this.memLevel = r5, this.strategy = n4, this.flush = i2.Z_NO_FLUSH, this.err = i2.Z_OK, this.mode !== i2.GZIP && this.mode !== i2.GUNZIP || (this.windowBits += 16), this.mode === i2.UNZIP && (this.windowBits += 32), this.mode !== i2.DEFLATERAW && this.mode !== i2.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new a2(), this.mode) {
              case i2.DEFLATE:
              case i2.GZIP:
              case i2.DEFLATERAW:
                this.err = o3.deflateInit2(this.strm, this.level, i2.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case i2.INFLATE:
              case i2.GUNZIP:
              case i2.INFLATERAW:
              case i2.UNZIP:
                this.err = s4.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== i2.Z_OK && this._error("Init error"), this.dictionary = l3, this.write_in_progress = false, this.init_done = true;
          }, f2.prototype._setDictionary = function() {
            if (null != this.dictionary) {
              switch (this.err = i2.Z_OK, this.mode) {
                case i2.DEFLATE:
                case i2.DEFLATERAW:
                  this.err = o3.deflateSetDictionary(this.strm, this.dictionary);
              }
              this.err !== i2.Z_OK && this._error("Failed to set dictionary");
            }
          }, f2.prototype._reset = function() {
            switch (this.err = i2.Z_OK, this.mode) {
              case i2.DEFLATE:
              case i2.DEFLATERAW:
              case i2.GZIP:
                this.err = o3.deflateReset(this.strm);
                break;
              case i2.INFLATE:
              case i2.INFLATERAW:
              case i2.GUNZIP:
                this.err = s4.inflateReset(this.strm);
            }
            this.err !== i2.Z_OK && this._error("Failed to reset stream");
          }, i2.Zlib = f2;
        }).call(this);
      }).call(this, e5("_process"), e5("buffer").Buffer);
    }, { _process: 63, assert: 23, buffer: 32, "pako/lib/zlib/constants": 54, "pako/lib/zlib/deflate.js": 56, "pako/lib/zlib/inflate.js": 58, "pako/lib/zlib/zstream": 62 }], 31: [function(e5, t3, i2) {
      (function(t4) {
        (function() {
          var r4 = e5("buffer").Buffer, n3 = e5("stream").Transform, a2 = e5("./binding"), o3 = e5("util"), s4 = e5("assert").ok, l2 = e5("buffer").kMaxLength, u2 = "Cannot create final Buffer. It would be larger than 0x" + l2.toString(16) + " bytes";
          a2.Z_MIN_WINDOWBITS = 8, a2.Z_MAX_WINDOWBITS = 15, a2.Z_DEFAULT_WINDOWBITS = 15, a2.Z_MIN_CHUNK = 64, a2.Z_MAX_CHUNK = 1 / 0, a2.Z_DEFAULT_CHUNK = 16384, a2.Z_MIN_MEMLEVEL = 1, a2.Z_MAX_MEMLEVEL = 9, a2.Z_DEFAULT_MEMLEVEL = 8, a2.Z_MIN_LEVEL = -1, a2.Z_MAX_LEVEL = 9, a2.Z_DEFAULT_LEVEL = a2.Z_DEFAULT_COMPRESSION;
          for (var h2 = Object.keys(a2), c3 = 0; c3 < h2.length; c3++) {
            var f2 = h2[c3];
            f2.match(/^Z/) && Object.defineProperty(i2, f2, { enumerable: true, value: a2[f2], writable: false });
          }
          for (var d = { Z_OK: a2.Z_OK, Z_STREAM_END: a2.Z_STREAM_END, Z_NEED_DICT: a2.Z_NEED_DICT, Z_ERRNO: a2.Z_ERRNO, Z_STREAM_ERROR: a2.Z_STREAM_ERROR, Z_DATA_ERROR: a2.Z_DATA_ERROR, Z_MEM_ERROR: a2.Z_MEM_ERROR, Z_BUF_ERROR: a2.Z_BUF_ERROR, Z_VERSION_ERROR: a2.Z_VERSION_ERROR }, p2 = Object.keys(d), m = 0; m < p2.length; m++) {
            var _2 = p2[m];
            d[d[_2]] = _2;
          }
          function g(e6, t5, i3) {
            var n4 = [], a3 = 0;
            function o4() {
              for (var t6; null !== (t6 = e6.read()); ) n4.push(t6), a3 += t6.length;
              e6.once("readable", o4);
            }
            __name(o4, "o");
            function s5(t6) {
              e6.removeListener("end", h3), e6.removeListener("readable", o4), i3(t6);
            }
            __name(s5, "s");
            function h3() {
              var t6, o5 = null;
              a3 >= l2 ? o5 = new RangeError(u2) : t6 = r4.concat(n4, a3), n4 = [], e6.close(), i3(o5, t6);
            }
            __name(h3, "h");
            e6.on("error", s5), e6.on("end", h3), e6.end(t5), o4();
          }
          __name(g, "g");
          function b2(e6, t5) {
            if ("string" == typeof t5 && (t5 = r4.from(t5)), !r4.isBuffer(t5)) throw new TypeError("Not a string or buffer");
            var i3 = e6._finishFlushFlag;
            return e6._processChunk(t5, i3);
          }
          __name(b2, "b");
          function y2(e6) {
            if (!(this instanceof y2)) return new y2(e6);
            I.call(this, e6, a2.DEFLATE);
          }
          __name(y2, "y");
          function w(e6) {
            if (!(this instanceof w)) return new w(e6);
            I.call(this, e6, a2.INFLATE);
          }
          __name(w, "w");
          function v2(e6) {
            if (!(this instanceof v2)) return new v2(e6);
            I.call(this, e6, a2.GZIP);
          }
          __name(v2, "v");
          function x2(e6) {
            if (!(this instanceof x2)) return new x2(e6);
            I.call(this, e6, a2.GUNZIP);
          }
          __name(x2, "x");
          function E2(e6) {
            if (!(this instanceof E2)) return new E2(e6);
            I.call(this, e6, a2.DEFLATERAW);
          }
          __name(E2, "E");
          function k2(e6) {
            if (!(this instanceof k2)) return new k2(e6);
            I.call(this, e6, a2.INFLATERAW);
          }
          __name(k2, "k");
          function S2(e6) {
            if (!(this instanceof S2)) return new S2(e6);
            I.call(this, e6, a2.UNZIP);
          }
          __name(S2, "S");
          function A2(e6) {
            return e6 === a2.Z_NO_FLUSH || e6 === a2.Z_PARTIAL_FLUSH || e6 === a2.Z_SYNC_FLUSH || e6 === a2.Z_FULL_FLUSH || e6 === a2.Z_FINISH || e6 === a2.Z_BLOCK;
          }
          __name(A2, "A");
          function I(e6, t5) {
            var o4 = this;
            if (this._opts = e6 = e6 || {}, this._chunkSize = e6.chunkSize || i2.Z_DEFAULT_CHUNK, n3.call(this, e6), e6.flush && !A2(e6.flush)) throw new Error("Invalid flush flag: " + e6.flush);
            if (e6.finishFlush && !A2(e6.finishFlush)) throw new Error("Invalid flush flag: " + e6.finishFlush);
            if (this._flushFlag = e6.flush || a2.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== e6.finishFlush ? e6.finishFlush : a2.Z_FINISH, e6.chunkSize && (e6.chunkSize < i2.Z_MIN_CHUNK || e6.chunkSize > i2.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + e6.chunkSize);
            if (e6.windowBits && (e6.windowBits < i2.Z_MIN_WINDOWBITS || e6.windowBits > i2.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + e6.windowBits);
            if (e6.level && (e6.level < i2.Z_MIN_LEVEL || e6.level > i2.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + e6.level);
            if (e6.memLevel && (e6.memLevel < i2.Z_MIN_MEMLEVEL || e6.memLevel > i2.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + e6.memLevel);
            if (e6.strategy && e6.strategy != i2.Z_FILTERED && e6.strategy != i2.Z_HUFFMAN_ONLY && e6.strategy != i2.Z_RLE && e6.strategy != i2.Z_FIXED && e6.strategy != i2.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + e6.strategy);
            if (e6.dictionary && !r4.isBuffer(e6.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new a2.Zlib(t5);
            var s5 = this;
            this._hadError = false, this._handle.onerror = function(e7, t6) {
              M2(s5), s5._hadError = true;
              var r5 = new Error(e7);
              r5.errno = t6, r5.code = i2.codes[t6], s5.emit("error", r5);
            };
            var l3 = i2.Z_DEFAULT_COMPRESSION;
            "number" == typeof e6.level && (l3 = e6.level);
            var u3 = i2.Z_DEFAULT_STRATEGY;
            "number" == typeof e6.strategy && (u3 = e6.strategy), this._handle.init(e6.windowBits || i2.Z_DEFAULT_WINDOWBITS, l3, e6.memLevel || i2.Z_DEFAULT_MEMLEVEL, u3, e6.dictionary), this._buffer = r4.allocUnsafe(this._chunkSize), this._offset = 0, this._level = l3, this._strategy = u3, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: /* @__PURE__ */ __name(function() {
              return !o4._handle;
            }, "get"), configurable: true, enumerable: true });
          }
          __name(I, "I");
          function M2(e6, i3) {
            i3 && t4.nextTick(i3), e6._handle && (e6._handle.close(), e6._handle = null);
          }
          __name(M2, "M");
          function T2(e6) {
            e6.emit("close");
          }
          __name(T2, "T");
          Object.defineProperty(i2, "codes", { enumerable: true, value: Object.freeze(d), writable: false }), i2.Deflate = y2, i2.Inflate = w, i2.Gzip = v2, i2.Gunzip = x2, i2.DeflateRaw = E2, i2.InflateRaw = k2, i2.Unzip = S2, i2.createDeflate = function(e6) {
            return new y2(e6);
          }, i2.createInflate = function(e6) {
            return new w(e6);
          }, i2.createDeflateRaw = function(e6) {
            return new E2(e6);
          }, i2.createInflateRaw = function(e6) {
            return new k2(e6);
          }, i2.createGzip = function(e6) {
            return new v2(e6);
          }, i2.createGunzip = function(e6) {
            return new x2(e6);
          }, i2.createUnzip = function(e6) {
            return new S2(e6);
          }, i2.deflate = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new y2(t5), e6, i3);
          }, i2.deflateSync = function(e6, t5) {
            return b2(new y2(t5), e6);
          }, i2.gzip = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new v2(t5), e6, i3);
          }, i2.gzipSync = function(e6, t5) {
            return b2(new v2(t5), e6);
          }, i2.deflateRaw = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new E2(t5), e6, i3);
          }, i2.deflateRawSync = function(e6, t5) {
            return b2(new E2(t5), e6);
          }, i2.unzip = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new S2(t5), e6, i3);
          }, i2.unzipSync = function(e6, t5) {
            return b2(new S2(t5), e6);
          }, i2.inflate = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new w(t5), e6, i3);
          }, i2.inflateSync = function(e6, t5) {
            return b2(new w(t5), e6);
          }, i2.gunzip = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new x2(t5), e6, i3);
          }, i2.gunzipSync = function(e6, t5) {
            return b2(new x2(t5), e6);
          }, i2.inflateRaw = function(e6, t5, i3) {
            return "function" == typeof t5 && (i3 = t5, t5 = {}), g(new k2(t5), e6, i3);
          }, i2.inflateRawSync = function(e6, t5) {
            return b2(new k2(t5), e6);
          }, o3.inherits(I, n3), I.prototype.params = function(e6, r5, n4) {
            if (e6 < i2.Z_MIN_LEVEL || e6 > i2.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + e6);
            if (r5 != i2.Z_FILTERED && r5 != i2.Z_HUFFMAN_ONLY && r5 != i2.Z_RLE && r5 != i2.Z_FIXED && r5 != i2.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + r5);
            if (this._level !== e6 || this._strategy !== r5) {
              var o4 = this;
              this.flush(a2.Z_SYNC_FLUSH, function() {
                s4(o4._handle, "zlib binding closed"), o4._handle.params(e6, r5), o4._hadError || (o4._level = e6, o4._strategy = r5, n4 && n4());
              });
            } else t4.nextTick(n4);
          }, I.prototype.reset = function() {
            return s4(this._handle, "zlib binding closed"), this._handle.reset();
          }, I.prototype._flush = function(e6) {
            this._transform(r4.alloc(0), "", e6);
          }, I.prototype.flush = function(e6, i3) {
            var n4 = this, o4 = this._writableState;
            ("function" == typeof e6 || void 0 === e6 && !i3) && (i3 = e6, e6 = a2.Z_FULL_FLUSH), o4.ended ? i3 && t4.nextTick(i3) : o4.ending ? i3 && this.once("end", i3) : o4.needDrain ? i3 && this.once("drain", function() {
              return n4.flush(e6, i3);
            }) : (this._flushFlag = e6, this.write(r4.alloc(0), "", i3));
          }, I.prototype.close = function(e6) {
            M2(this, e6), t4.nextTick(T2, this);
          }, I.prototype._transform = function(e6, t5, i3) {
            var n4, o4 = this._writableState, s5 = (o4.ending || o4.ended) && (!e6 || o4.length === e6.length);
            return null === e6 || r4.isBuffer(e6) ? this._handle ? (s5 ? n4 = this._finishFlushFlag : (n4 = this._flushFlag, e6.length >= o4.length && (this._flushFlag = this._opts.flush || a2.Z_NO_FLUSH)), void this._processChunk(e6, n4, i3)) : i3(new Error("zlib binding closed")) : i3(new Error("invalid input"));
          }, I.prototype._processChunk = function(e6, t5, i3) {
            var n4 = e6 && e6.length, a3 = this._chunkSize - this._offset, o4 = 0, h3 = this, c4 = "function" == typeof i3;
            if (!c4) {
              var f3, d2 = [], p3 = 0;
              this.on("error", function(e7) {
                f3 = e7;
              }), s4(this._handle, "zlib binding closed");
              do {
                var m2 = this._handle.writeSync(t5, e6, o4, n4, this._buffer, this._offset, a3);
              } while (!this._hadError && b3(m2[0], m2[1]));
              if (this._hadError) throw f3;
              if (p3 >= l2) throw M2(this), new RangeError(u2);
              var _3 = r4.concat(d2, p3);
              return M2(this), _3;
            }
            s4(this._handle, "zlib binding closed");
            var g2 = this._handle.write(t5, e6, o4, n4, this._buffer, this._offset, a3);
            function b3(l3, u3) {
              if (this && (this.buffer = null, this.callback = null), !h3._hadError) {
                var f4 = a3 - u3;
                if (s4(f4 >= 0, "have should not go down"), f4 > 0) {
                  var m3 = h3._buffer.slice(h3._offset, h3._offset + f4);
                  h3._offset += f4, c4 ? h3.push(m3) : (d2.push(m3), p3 += m3.length);
                }
                if ((0 === u3 || h3._offset >= h3._chunkSize) && (a3 = h3._chunkSize, h3._offset = 0, h3._buffer = r4.allocUnsafe(h3._chunkSize)), 0 === u3) {
                  if (o4 += n4 - l3, n4 = l3, !c4) return true;
                  var _4 = h3._handle.write(t5, e6, o4, n4, h3._buffer, h3._offset, h3._chunkSize);
                  return _4.callback = b3, void (_4.buffer = e6);
                }
                if (!c4) return false;
                i3();
              }
            }
            __name(b3, "b");
            g2.buffer = e6, g2.callback = b3;
          }, o3.inherits(y2, I), o3.inherits(w, I), o3.inherits(v2, I), o3.inherits(x2, I), o3.inherits(E2, I), o3.inherits(k2, I), o3.inherits(S2, I);
        }).call(this);
      }).call(this, e5("_process"));
    }, { "./binding": 30, _process: 63, assert: 23, buffer: 32, stream: 65, util: 84 }], 32: [function(e5, t3, i2) {
      (function(t4) {
        (function() {
          var t5 = e5("base64-js"), r4 = e5("ieee754");
          i2.Buffer = s4, i2.SlowBuffer = g, i2.INSPECT_MAX_BYTES = 50;
          var n3 = 2147483647;
          function a2() {
            try {
              var e6 = new Uint8Array(1);
              return e6.__proto__ = { __proto__: Uint8Array.prototype, foo: /* @__PURE__ */ __name(function() {
                return 42;
              }, "foo") }, 42 === e6.foo();
            } catch (e7) {
              return false;
            }
          }
          __name(a2, "a");
          function o3(e6) {
            if (e6 > n3) throw new RangeError('The value "' + e6 + '" is invalid for option "size"');
            var t6 = new Uint8Array(e6);
            return t6.__proto__ = s4.prototype, t6;
          }
          __name(o3, "o");
          function s4(e6, t6, i3) {
            if ("number" == typeof e6) {
              if ("string" == typeof t6) throw new TypeError('The "string" argument must be of type string. Received type number');
              return c3(e6);
            }
            return l2(e6, t6, i3);
          }
          __name(s4, "s");
          function l2(e6, t6, i3) {
            if ("string" == typeof e6) return f2(e6, t6);
            if (ArrayBuffer.isView(e6)) return d(e6);
            if (null == e6) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e6);
            if (Y2(e6, ArrayBuffer) || e6 && Y2(e6.buffer, ArrayBuffer)) return p2(e6, t6, i3);
            if ("number" == typeof e6) throw new TypeError('The "value" argument must not be of type number. Received type number');
            var r5 = e6.valueOf && e6.valueOf();
            if (null != r5 && r5 !== e6) return s4.from(r5, t6, i3);
            var n4 = m(e6);
            if (n4) return n4;
            if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e6[Symbol.toPrimitive]) return s4.from(e6[Symbol.toPrimitive]("string"), t6, i3);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e6);
          }
          __name(l2, "l");
          function u2(e6) {
            if ("number" != typeof e6) throw new TypeError('"size" argument must be of type number');
            if (e6 < 0) throw new RangeError('The value "' + e6 + '" is invalid for option "size"');
          }
          __name(u2, "u");
          function h2(e6, t6, i3) {
            return u2(e6), e6 <= 0 ? o3(e6) : void 0 !== t6 ? "string" == typeof i3 ? o3(e6).fill(t6, i3) : o3(e6).fill(t6) : o3(e6);
          }
          __name(h2, "h");
          function c3(e6) {
            return u2(e6), o3(e6 < 0 ? 0 : 0 | _2(e6));
          }
          __name(c3, "c");
          function f2(e6, t6) {
            if ("string" == typeof t6 && "" !== t6 || (t6 = "utf8"), !s4.isEncoding(t6)) throw new TypeError("Unknown encoding: " + t6);
            var i3 = 0 | b2(e6, t6), r5 = o3(i3), n4 = r5.write(e6, t6);
            return n4 !== i3 && (r5 = r5.slice(0, n4)), r5;
          }
          __name(f2, "f");
          function d(e6) {
            for (var t6 = e6.length < 0 ? 0 : 0 | _2(e6.length), i3 = o3(t6), r5 = 0; r5 < t6; r5 += 1) i3[r5] = 255 & e6[r5];
            return i3;
          }
          __name(d, "d");
          function p2(e6, t6, i3) {
            if (t6 < 0 || e6.byteLength < t6) throw new RangeError('"offset" is outside of buffer bounds');
            if (e6.byteLength < t6 + (i3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
            var r5;
            return (r5 = void 0 === t6 && void 0 === i3 ? new Uint8Array(e6) : void 0 === i3 ? new Uint8Array(e6, t6) : new Uint8Array(e6, t6, i3)).__proto__ = s4.prototype, r5;
          }
          __name(p2, "p");
          function m(e6) {
            if (s4.isBuffer(e6)) {
              var t6 = 0 | _2(e6.length), i3 = o3(t6);
              return 0 === i3.length || e6.copy(i3, 0, 0, t6), i3;
            }
            return void 0 !== e6.length ? "number" != typeof e6.length || K(e6.length) ? o3(0) : d(e6) : "Buffer" === e6.type && Array.isArray(e6.data) ? d(e6.data) : void 0;
          }
          __name(m, "m");
          function _2(e6) {
            if (e6 >= n3) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n3.toString(16) + " bytes");
            return 0 | e6;
          }
          __name(_2, "_");
          function g(e6) {
            return +e6 != e6 && (e6 = 0), s4.alloc(+e6);
          }
          __name(g, "g");
          function b2(e6, t6) {
            if (s4.isBuffer(e6)) return e6.length;
            if (ArrayBuffer.isView(e6) || Y2(e6, ArrayBuffer)) return e6.byteLength;
            if ("string" != typeof e6) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e6);
            var i3 = e6.length, r5 = arguments.length > 2 && true === arguments[2];
            if (!r5 && 0 === i3) return 0;
            for (var n4 = false; ; ) switch (t6) {
              case "ascii":
              case "latin1":
              case "binary":
                return i3;
              case "utf8":
              case "utf-8":
                return H(e6).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * i3;
              case "hex":
                return i3 >>> 1;
              case "base64":
                return q(e6).length;
              default:
                if (n4) return r5 ? -1 : H(e6).length;
                t6 = ("" + t6).toLowerCase(), n4 = true;
            }
          }
          __name(b2, "b");
          function y2(e6, t6, i3) {
            var r5 = false;
            if ((void 0 === t6 || t6 < 0) && (t6 = 0), t6 > this.length) return "";
            if ((void 0 === i3 || i3 > this.length) && (i3 = this.length), i3 <= 0) return "";
            if ((i3 >>>= 0) <= (t6 >>>= 0)) return "";
            for (e6 || (e6 = "utf8"); ; ) switch (e6) {
              case "hex":
                return F(this, t6, i3);
              case "utf8":
              case "utf-8":
                return P(this, t6, i3);
              case "ascii":
                return R2(this, t6, i3);
              case "latin1":
              case "binary":
                return z2(this, t6, i3);
              case "base64":
                return T2(this, t6, i3);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return N2(this, t6, i3);
              default:
                if (r5) throw new TypeError("Unknown encoding: " + e6);
                e6 = (e6 + "").toLowerCase(), r5 = true;
            }
          }
          __name(y2, "y");
          function w(e6, t6, i3) {
            var r5 = e6[t6];
            e6[t6] = e6[i3], e6[i3] = r5;
          }
          __name(w, "w");
          function v2(e6, t6, i3, r5, n4) {
            if (0 === e6.length) return -1;
            if ("string" == typeof i3 ? (r5 = i3, i3 = 0) : i3 > 2147483647 ? i3 = 2147483647 : i3 < -2147483648 && (i3 = -2147483648), K(i3 = +i3) && (i3 = n4 ? 0 : e6.length - 1), i3 < 0 && (i3 = e6.length + i3), i3 >= e6.length) {
              if (n4) return -1;
              i3 = e6.length - 1;
            } else if (i3 < 0) {
              if (!n4) return -1;
              i3 = 0;
            }
            if ("string" == typeof t6 && (t6 = s4.from(t6, r5)), s4.isBuffer(t6)) return 0 === t6.length ? -1 : x2(e6, t6, i3, r5, n4);
            if ("number" == typeof t6) return t6 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n4 ? Uint8Array.prototype.indexOf.call(e6, t6, i3) : Uint8Array.prototype.lastIndexOf.call(e6, t6, i3) : x2(e6, [t6], i3, r5, n4);
            throw new TypeError("val must be string, number or Buffer");
          }
          __name(v2, "v");
          function x2(e6, t6, i3, r5, n4) {
            var a3, o4 = 1, s5 = e6.length, l3 = t6.length;
            if (void 0 !== r5 && ("ucs2" === (r5 = String(r5).toLowerCase()) || "ucs-2" === r5 || "utf16le" === r5 || "utf-16le" === r5)) {
              if (e6.length < 2 || t6.length < 2) return -1;
              o4 = 2, s5 /= 2, l3 /= 2, i3 /= 2;
            }
            function u3(e7, t7) {
              return 1 === o4 ? e7[t7] : e7.readUInt16BE(t7 * o4);
            }
            __name(u3, "u");
            if (n4) {
              var h3 = -1;
              for (a3 = i3; a3 < s5; a3++) if (u3(e6, a3) === u3(t6, -1 === h3 ? 0 : a3 - h3)) {
                if (-1 === h3 && (h3 = a3), a3 - h3 + 1 === l3) return h3 * o4;
              } else -1 !== h3 && (a3 -= a3 - h3), h3 = -1;
            } else for (i3 + l3 > s5 && (i3 = s5 - l3), a3 = i3; a3 >= 0; a3--) {
              for (var c4 = true, f3 = 0; f3 < l3; f3++) if (u3(e6, a3 + f3) !== u3(t6, f3)) {
                c4 = false;
                break;
              }
              if (c4) return a3;
            }
            return -1;
          }
          __name(x2, "x");
          function E2(e6, t6, i3, r5) {
            i3 = Number(i3) || 0;
            var n4 = e6.length - i3;
            r5 ? (r5 = Number(r5)) > n4 && (r5 = n4) : r5 = n4;
            var a3 = t6.length;
            r5 > a3 / 2 && (r5 = a3 / 2);
            for (var o4 = 0; o4 < r5; ++o4) {
              var s5 = parseInt(t6.substr(2 * o4, 2), 16);
              if (K(s5)) return o4;
              e6[i3 + o4] = s5;
            }
            return o4;
          }
          __name(E2, "E");
          function k2(e6, t6, i3, r5) {
            return V(H(t6, e6.length - i3), e6, i3, r5);
          }
          __name(k2, "k");
          function S2(e6, t6, i3, r5) {
            return V(Q(t6), e6, i3, r5);
          }
          __name(S2, "S");
          function A2(e6, t6, i3, r5) {
            return S2(e6, t6, i3, r5);
          }
          __name(A2, "A");
          function I(e6, t6, i3, r5) {
            return V(q(t6), e6, i3, r5);
          }
          __name(I, "I");
          function M2(e6, t6, i3, r5) {
            return V(W(t6, e6.length - i3), e6, i3, r5);
          }
          __name(M2, "M");
          function T2(e6, i3, r5) {
            return 0 === i3 && r5 === e6.length ? t5.fromByteArray(e6) : t5.fromByteArray(e6.slice(i3, r5));
          }
          __name(T2, "T");
          function P(e6, t6, i3) {
            i3 = Math.min(e6.length, i3);
            for (var r5 = [], n4 = t6; n4 < i3; ) {
              var a3, o4, s5, l3, u3 = e6[n4], h3 = null, c4 = u3 > 239 ? 4 : u3 > 223 ? 3 : u3 > 191 ? 2 : 1;
              if (n4 + c4 <= i3) switch (c4) {
                case 1:
                  u3 < 128 && (h3 = u3);
                  break;
                case 2:
                  128 == (192 & (a3 = e6[n4 + 1])) && (l3 = (31 & u3) << 6 | 63 & a3) > 127 && (h3 = l3);
                  break;
                case 3:
                  a3 = e6[n4 + 1], o4 = e6[n4 + 2], 128 == (192 & a3) && 128 == (192 & o4) && (l3 = (15 & u3) << 12 | (63 & a3) << 6 | 63 & o4) > 2047 && (l3 < 55296 || l3 > 57343) && (h3 = l3);
                  break;
                case 4:
                  a3 = e6[n4 + 1], o4 = e6[n4 + 2], s5 = e6[n4 + 3], 128 == (192 & a3) && 128 == (192 & o4) && 128 == (192 & s5) && (l3 = (15 & u3) << 18 | (63 & a3) << 12 | (63 & o4) << 6 | 63 & s5) > 65535 && l3 < 1114112 && (h3 = l3);
              }
              null === h3 ? (h3 = 65533, c4 = 1) : h3 > 65535 && (h3 -= 65536, r5.push(h3 >>> 10 & 1023 | 55296), h3 = 56320 | 1023 & h3), r5.push(h3), n4 += c4;
            }
            return C2(r5);
          }
          __name(P, "P");
          i2.kMaxLength = n3, s4.TYPED_ARRAY_SUPPORT = a2(), s4.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s4.prototype, "parent", { enumerable: true, get: /* @__PURE__ */ __name(function() {
            if (s4.isBuffer(this)) return this.buffer;
          }, "get") }), Object.defineProperty(s4.prototype, "offset", { enumerable: true, get: /* @__PURE__ */ __name(function() {
            if (s4.isBuffer(this)) return this.byteOffset;
          }, "get") }), "undefined" != typeof Symbol && null != Symbol.species && s4[Symbol.species] === s4 && Object.defineProperty(s4, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s4.poolSize = 8192, s4.from = function(e6, t6, i3) {
            return l2(e6, t6, i3);
          }, s4.prototype.__proto__ = Uint8Array.prototype, s4.__proto__ = Uint8Array, s4.alloc = function(e6, t6, i3) {
            return h2(e6, t6, i3);
          }, s4.allocUnsafe = function(e6) {
            return c3(e6);
          }, s4.allocUnsafeSlow = function(e6) {
            return c3(e6);
          }, s4.isBuffer = function(e6) {
            return null != e6 && true === e6._isBuffer && e6 !== s4.prototype;
          }, s4.compare = function(e6, t6) {
            if (Y2(e6, Uint8Array) && (e6 = s4.from(e6, e6.offset, e6.byteLength)), Y2(t6, Uint8Array) && (t6 = s4.from(t6, t6.offset, t6.byteLength)), !s4.isBuffer(e6) || !s4.isBuffer(t6)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e6 === t6) return 0;
            for (var i3 = e6.length, r5 = t6.length, n4 = 0, a3 = Math.min(i3, r5); n4 < a3; ++n4) if (e6[n4] !== t6[n4]) {
              i3 = e6[n4], r5 = t6[n4];
              break;
            }
            return i3 < r5 ? -1 : r5 < i3 ? 1 : 0;
          }, s4.isEncoding = function(e6) {
            switch (String(e6).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, s4.concat = function(e6, t6) {
            if (!Array.isArray(e6)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e6.length) return s4.alloc(0);
            var i3;
            if (void 0 === t6) for (t6 = 0, i3 = 0; i3 < e6.length; ++i3) t6 += e6[i3].length;
            var r5 = s4.allocUnsafe(t6), n4 = 0;
            for (i3 = 0; i3 < e6.length; ++i3) {
              var a3 = e6[i3];
              if (Y2(a3, Uint8Array) && (a3 = s4.from(a3)), !s4.isBuffer(a3)) throw new TypeError('"list" argument must be an Array of Buffers');
              a3.copy(r5, n4), n4 += a3.length;
            }
            return r5;
          }, s4.byteLength = b2, s4.prototype._isBuffer = true, s4.prototype.swap16 = function() {
            var e6 = this.length;
            if (e6 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t6 = 0; t6 < e6; t6 += 2) w(this, t6, t6 + 1);
            return this;
          }, s4.prototype.swap32 = function() {
            var e6 = this.length;
            if (e6 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t6 = 0; t6 < e6; t6 += 4) w(this, t6, t6 + 3), w(this, t6 + 1, t6 + 2);
            return this;
          }, s4.prototype.swap64 = function() {
            var e6 = this.length;
            if (e6 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t6 = 0; t6 < e6; t6 += 8) w(this, t6, t6 + 7), w(this, t6 + 1, t6 + 6), w(this, t6 + 2, t6 + 5), w(this, t6 + 3, t6 + 4);
            return this;
          }, s4.prototype.toString = function() {
            var e6 = this.length;
            return 0 === e6 ? "" : 0 === arguments.length ? P(this, 0, e6) : y2.apply(this, arguments);
          }, s4.prototype.toLocaleString = s4.prototype.toString, s4.prototype.equals = function(e6) {
            if (!s4.isBuffer(e6)) throw new TypeError("Argument must be a Buffer");
            return this === e6 || 0 === s4.compare(this, e6);
          }, s4.prototype.inspect = function() {
            var e6 = "", t6 = i2.INSPECT_MAX_BYTES;
            return e6 = this.toString("hex", 0, t6).replace(/(.{2})/g, "$1 ").trim(), this.length > t6 && (e6 += " ... "), "<Buffer " + e6 + ">";
          }, s4.prototype.compare = function(e6, t6, i3, r5, n4) {
            if (Y2(e6, Uint8Array) && (e6 = s4.from(e6, e6.offset, e6.byteLength)), !s4.isBuffer(e6)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e6);
            if (void 0 === t6 && (t6 = 0), void 0 === i3 && (i3 = e6 ? e6.length : 0), void 0 === r5 && (r5 = 0), void 0 === n4 && (n4 = this.length), t6 < 0 || i3 > e6.length || r5 < 0 || n4 > this.length) throw new RangeError("out of range index");
            if (r5 >= n4 && t6 >= i3) return 0;
            if (r5 >= n4) return -1;
            if (t6 >= i3) return 1;
            if (this === e6) return 0;
            for (var a3 = (n4 >>>= 0) - (r5 >>>= 0), o4 = (i3 >>>= 0) - (t6 >>>= 0), l3 = Math.min(a3, o4), u3 = this.slice(r5, n4), h3 = e6.slice(t6, i3), c4 = 0; c4 < l3; ++c4) if (u3[c4] !== h3[c4]) {
              a3 = u3[c4], o4 = h3[c4];
              break;
            }
            return a3 < o4 ? -1 : o4 < a3 ? 1 : 0;
          }, s4.prototype.includes = function(e6, t6, i3) {
            return -1 !== this.indexOf(e6, t6, i3);
          }, s4.prototype.indexOf = function(e6, t6, i3) {
            return v2(this, e6, t6, i3, true);
          }, s4.prototype.lastIndexOf = function(e6, t6, i3) {
            return v2(this, e6, t6, i3, false);
          }, s4.prototype.write = function(e6, t6, i3, r5) {
            if (void 0 === t6) r5 = "utf8", i3 = this.length, t6 = 0;
            else if (void 0 === i3 && "string" == typeof t6) r5 = t6, i3 = this.length, t6 = 0;
            else {
              if (!isFinite(t6)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              t6 >>>= 0, isFinite(i3) ? (i3 >>>= 0, void 0 === r5 && (r5 = "utf8")) : (r5 = i3, i3 = void 0);
            }
            var n4 = this.length - t6;
            if ((void 0 === i3 || i3 > n4) && (i3 = n4), e6.length > 0 && (i3 < 0 || t6 < 0) || t6 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            r5 || (r5 = "utf8");
            for (var a3 = false; ; ) switch (r5) {
              case "hex":
                return E2(this, e6, t6, i3);
              case "utf8":
              case "utf-8":
                return k2(this, e6, t6, i3);
              case "ascii":
                return S2(this, e6, t6, i3);
              case "latin1":
              case "binary":
                return A2(this, e6, t6, i3);
              case "base64":
                return I(this, e6, t6, i3);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return M2(this, e6, t6, i3);
              default:
                if (a3) throw new TypeError("Unknown encoding: " + r5);
                r5 = ("" + r5).toLowerCase(), a3 = true;
            }
          }, s4.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var B2 = 4096;
          function C2(e6) {
            var t6 = e6.length;
            if (t6 <= B2) return String.fromCharCode.apply(String, e6);
            for (var i3 = "", r5 = 0; r5 < t6; ) i3 += String.fromCharCode.apply(String, e6.slice(r5, r5 += B2));
            return i3;
          }
          __name(C2, "C");
          function R2(e6, t6, i3) {
            var r5 = "";
            i3 = Math.min(e6.length, i3);
            for (var n4 = t6; n4 < i3; ++n4) r5 += String.fromCharCode(127 & e6[n4]);
            return r5;
          }
          __name(R2, "R");
          function z2(e6, t6, i3) {
            var r5 = "";
            i3 = Math.min(e6.length, i3);
            for (var n4 = t6; n4 < i3; ++n4) r5 += String.fromCharCode(e6[n4]);
            return r5;
          }
          __name(z2, "z");
          function F(e6, t6, i3) {
            var r5 = e6.length;
            (!t6 || t6 < 0) && (t6 = 0), (!i3 || i3 < 0 || i3 > r5) && (i3 = r5);
            for (var n4 = "", a3 = t6; a3 < i3; ++a3) n4 += G(e6[a3]);
            return n4;
          }
          __name(F, "F");
          function N2(e6, t6, i3) {
            for (var r5 = e6.slice(t6, i3), n4 = "", a3 = 0; a3 < r5.length; a3 += 2) n4 += String.fromCharCode(r5[a3] + 256 * r5[a3 + 1]);
            return n4;
          }
          __name(N2, "N");
          function O2(e6, t6, i3) {
            if (e6 % 1 != 0 || e6 < 0) throw new RangeError("offset is not uint");
            if (e6 + t6 > i3) throw new RangeError("Trying to access beyond buffer length");
          }
          __name(O2, "O");
          function D(e6, t6, i3, r5, n4, a3) {
            if (!s4.isBuffer(e6)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t6 > n4 || t6 < a3) throw new RangeError('"value" argument is out of bounds');
            if (i3 + r5 > e6.length) throw new RangeError("Index out of range");
          }
          __name(D, "D");
          function $(e6, t6, i3, r5, n4, a3) {
            if (i3 + r5 > e6.length) throw new RangeError("Index out of range");
            if (i3 < 0) throw new RangeError("Index out of range");
          }
          __name($, "$");
          function L2(e6, t6, i3, n4, a3) {
            return t6 = +t6, i3 >>>= 0, a3 || $(e6, t6, i3, 4), r4.write(e6, t6, i3, n4, 23, 4), i3 + 4;
          }
          __name(L2, "L");
          function U(e6, t6, i3, n4, a3) {
            return t6 = +t6, i3 >>>= 0, a3 || $(e6, t6, i3, 8), r4.write(e6, t6, i3, n4, 52, 8), i3 + 8;
          }
          __name(U, "U");
          s4.prototype.slice = function(e6, t6) {
            var i3 = this.length;
            (e6 = ~~e6) < 0 ? (e6 += i3) < 0 && (e6 = 0) : e6 > i3 && (e6 = i3), (t6 = void 0 === t6 ? i3 : ~~t6) < 0 ? (t6 += i3) < 0 && (t6 = 0) : t6 > i3 && (t6 = i3), t6 < e6 && (t6 = e6);
            var r5 = this.subarray(e6, t6);
            return r5.__proto__ = s4.prototype, r5;
          }, s4.prototype.readUIntLE = function(e6, t6, i3) {
            e6 >>>= 0, t6 >>>= 0, i3 || O2(e6, t6, this.length);
            for (var r5 = this[e6], n4 = 1, a3 = 0; ++a3 < t6 && (n4 *= 256); ) r5 += this[e6 + a3] * n4;
            return r5;
          }, s4.prototype.readUIntBE = function(e6, t6, i3) {
            e6 >>>= 0, t6 >>>= 0, i3 || O2(e6, t6, this.length);
            for (var r5 = this[e6 + --t6], n4 = 1; t6 > 0 && (n4 *= 256); ) r5 += this[e6 + --t6] * n4;
            return r5;
          }, s4.prototype.readUInt8 = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 1, this.length), this[e6];
          }, s4.prototype.readUInt16LE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 2, this.length), this[e6] | this[e6 + 1] << 8;
          }, s4.prototype.readUInt16BE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 2, this.length), this[e6] << 8 | this[e6 + 1];
          }, s4.prototype.readUInt32LE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 4, this.length), (this[e6] | this[e6 + 1] << 8 | this[e6 + 2] << 16) + 16777216 * this[e6 + 3];
          }, s4.prototype.readUInt32BE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 4, this.length), 16777216 * this[e6] + (this[e6 + 1] << 16 | this[e6 + 2] << 8 | this[e6 + 3]);
          }, s4.prototype.readIntLE = function(e6, t6, i3) {
            e6 >>>= 0, t6 >>>= 0, i3 || O2(e6, t6, this.length);
            for (var r5 = this[e6], n4 = 1, a3 = 0; ++a3 < t6 && (n4 *= 256); ) r5 += this[e6 + a3] * n4;
            return r5 >= (n4 *= 128) && (r5 -= Math.pow(2, 8 * t6)), r5;
          }, s4.prototype.readIntBE = function(e6, t6, i3) {
            e6 >>>= 0, t6 >>>= 0, i3 || O2(e6, t6, this.length);
            for (var r5 = t6, n4 = 1, a3 = this[e6 + --r5]; r5 > 0 && (n4 *= 256); ) a3 += this[e6 + --r5] * n4;
            return a3 >= (n4 *= 128) && (a3 -= Math.pow(2, 8 * t6)), a3;
          }, s4.prototype.readInt8 = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 1, this.length), 128 & this[e6] ? -1 * (255 - this[e6] + 1) : this[e6];
          }, s4.prototype.readInt16LE = function(e6, t6) {
            e6 >>>= 0, t6 || O2(e6, 2, this.length);
            var i3 = this[e6] | this[e6 + 1] << 8;
            return 32768 & i3 ? 4294901760 | i3 : i3;
          }, s4.prototype.readInt16BE = function(e6, t6) {
            e6 >>>= 0, t6 || O2(e6, 2, this.length);
            var i3 = this[e6 + 1] | this[e6] << 8;
            return 32768 & i3 ? 4294901760 | i3 : i3;
          }, s4.prototype.readInt32LE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 4, this.length), this[e6] | this[e6 + 1] << 8 | this[e6 + 2] << 16 | this[e6 + 3] << 24;
          }, s4.prototype.readInt32BE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 4, this.length), this[e6] << 24 | this[e6 + 1] << 16 | this[e6 + 2] << 8 | this[e6 + 3];
          }, s4.prototype.readFloatLE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 4, this.length), r4.read(this, e6, true, 23, 4);
          }, s4.prototype.readFloatBE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 4, this.length), r4.read(this, e6, false, 23, 4);
          }, s4.prototype.readDoubleLE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 8, this.length), r4.read(this, e6, true, 52, 8);
          }, s4.prototype.readDoubleBE = function(e6, t6) {
            return e6 >>>= 0, t6 || O2(e6, 8, this.length), r4.read(this, e6, false, 52, 8);
          }, s4.prototype.writeUIntLE = function(e6, t6, i3, r5) {
            e6 = +e6, t6 >>>= 0, i3 >>>= 0, r5 || D(this, e6, t6, i3, Math.pow(2, 8 * i3) - 1, 0);
            var n4 = 1, a3 = 0;
            for (this[t6] = 255 & e6; ++a3 < i3 && (n4 *= 256); ) this[t6 + a3] = e6 / n4 & 255;
            return t6 + i3;
          }, s4.prototype.writeUIntBE = function(e6, t6, i3, r5) {
            e6 = +e6, t6 >>>= 0, i3 >>>= 0, r5 || D(this, e6, t6, i3, Math.pow(2, 8 * i3) - 1, 0);
            var n4 = i3 - 1, a3 = 1;
            for (this[t6 + n4] = 255 & e6; --n4 >= 0 && (a3 *= 256); ) this[t6 + n4] = e6 / a3 & 255;
            return t6 + i3;
          }, s4.prototype.writeUInt8 = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 1, 255, 0), this[t6] = 255 & e6, t6 + 1;
          }, s4.prototype.writeUInt16LE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 2, 65535, 0), this[t6] = 255 & e6, this[t6 + 1] = e6 >>> 8, t6 + 2;
          }, s4.prototype.writeUInt16BE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 2, 65535, 0), this[t6] = e6 >>> 8, this[t6 + 1] = 255 & e6, t6 + 2;
          }, s4.prototype.writeUInt32LE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 4, 4294967295, 0), this[t6 + 3] = e6 >>> 24, this[t6 + 2] = e6 >>> 16, this[t6 + 1] = e6 >>> 8, this[t6] = 255 & e6, t6 + 4;
          }, s4.prototype.writeUInt32BE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 4, 4294967295, 0), this[t6] = e6 >>> 24, this[t6 + 1] = e6 >>> 16, this[t6 + 2] = e6 >>> 8, this[t6 + 3] = 255 & e6, t6 + 4;
          }, s4.prototype.writeIntLE = function(e6, t6, i3, r5) {
            if (e6 = +e6, t6 >>>= 0, !r5) {
              var n4 = Math.pow(2, 8 * i3 - 1);
              D(this, e6, t6, i3, n4 - 1, -n4);
            }
            var a3 = 0, o4 = 1, s5 = 0;
            for (this[t6] = 255 & e6; ++a3 < i3 && (o4 *= 256); ) e6 < 0 && 0 === s5 && 0 !== this[t6 + a3 - 1] && (s5 = 1), this[t6 + a3] = (e6 / o4 | 0) - s5 & 255;
            return t6 + i3;
          }, s4.prototype.writeIntBE = function(e6, t6, i3, r5) {
            if (e6 = +e6, t6 >>>= 0, !r5) {
              var n4 = Math.pow(2, 8 * i3 - 1);
              D(this, e6, t6, i3, n4 - 1, -n4);
            }
            var a3 = i3 - 1, o4 = 1, s5 = 0;
            for (this[t6 + a3] = 255 & e6; --a3 >= 0 && (o4 *= 256); ) e6 < 0 && 0 === s5 && 0 !== this[t6 + a3 + 1] && (s5 = 1), this[t6 + a3] = (e6 / o4 | 0) - s5 & 255;
            return t6 + i3;
          }, s4.prototype.writeInt8 = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 1, 127, -128), e6 < 0 && (e6 = 255 + e6 + 1), this[t6] = 255 & e6, t6 + 1;
          }, s4.prototype.writeInt16LE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 2, 32767, -32768), this[t6] = 255 & e6, this[t6 + 1] = e6 >>> 8, t6 + 2;
          }, s4.prototype.writeInt16BE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 2, 32767, -32768), this[t6] = e6 >>> 8, this[t6 + 1] = 255 & e6, t6 + 2;
          }, s4.prototype.writeInt32LE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 4, 2147483647, -2147483648), this[t6] = 255 & e6, this[t6 + 1] = e6 >>> 8, this[t6 + 2] = e6 >>> 16, this[t6 + 3] = e6 >>> 24, t6 + 4;
          }, s4.prototype.writeInt32BE = function(e6, t6, i3) {
            return e6 = +e6, t6 >>>= 0, i3 || D(this, e6, t6, 4, 2147483647, -2147483648), e6 < 0 && (e6 = 4294967295 + e6 + 1), this[t6] = e6 >>> 24, this[t6 + 1] = e6 >>> 16, this[t6 + 2] = e6 >>> 8, this[t6 + 3] = 255 & e6, t6 + 4;
          }, s4.prototype.writeFloatLE = function(e6, t6, i3) {
            return L2(this, e6, t6, true, i3);
          }, s4.prototype.writeFloatBE = function(e6, t6, i3) {
            return L2(this, e6, t6, false, i3);
          }, s4.prototype.writeDoubleLE = function(e6, t6, i3) {
            return U(this, e6, t6, true, i3);
          }, s4.prototype.writeDoubleBE = function(e6, t6, i3) {
            return U(this, e6, t6, false, i3);
          }, s4.prototype.copy = function(e6, t6, i3, r5) {
            if (!s4.isBuffer(e6)) throw new TypeError("argument should be a Buffer");
            if (i3 || (i3 = 0), r5 || 0 === r5 || (r5 = this.length), t6 >= e6.length && (t6 = e6.length), t6 || (t6 = 0), r5 > 0 && r5 < i3 && (r5 = i3), r5 === i3) return 0;
            if (0 === e6.length || 0 === this.length) return 0;
            if (t6 < 0) throw new RangeError("targetStart out of bounds");
            if (i3 < 0 || i3 >= this.length) throw new RangeError("Index out of range");
            if (r5 < 0) throw new RangeError("sourceEnd out of bounds");
            r5 > this.length && (r5 = this.length), e6.length - t6 < r5 - i3 && (r5 = e6.length - t6 + i3);
            var n4 = r5 - i3;
            if (this === e6 && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t6, i3, r5);
            else if (this === e6 && i3 < t6 && t6 < r5) for (var a3 = n4 - 1; a3 >= 0; --a3) e6[a3 + t6] = this[a3 + i3];
            else Uint8Array.prototype.set.call(e6, this.subarray(i3, r5), t6);
            return n4;
          }, s4.prototype.fill = function(e6, t6, i3, r5) {
            if ("string" == typeof e6) {
              if ("string" == typeof t6 ? (r5 = t6, t6 = 0, i3 = this.length) : "string" == typeof i3 && (r5 = i3, i3 = this.length), void 0 !== r5 && "string" != typeof r5) throw new TypeError("encoding must be a string");
              if ("string" == typeof r5 && !s4.isEncoding(r5)) throw new TypeError("Unknown encoding: " + r5);
              if (1 === e6.length) {
                var n4 = e6.charCodeAt(0);
                ("utf8" === r5 && n4 < 128 || "latin1" === r5) && (e6 = n4);
              }
            } else "number" == typeof e6 && (e6 &= 255);
            if (t6 < 0 || this.length < t6 || this.length < i3) throw new RangeError("Out of range index");
            if (i3 <= t6) return this;
            var a3;
            if (t6 >>>= 0, i3 = void 0 === i3 ? this.length : i3 >>> 0, e6 || (e6 = 0), "number" == typeof e6) for (a3 = t6; a3 < i3; ++a3) this[a3] = e6;
            else {
              var o4 = s4.isBuffer(e6) ? e6 : s4.from(e6, r5), l3 = o4.length;
              if (0 === l3) throw new TypeError('The value "' + e6 + '" is invalid for argument "value"');
              for (a3 = 0; a3 < i3 - t6; ++a3) this[a3 + t6] = o4[a3 % l3];
            }
            return this;
          };
          var Z = /[^+/0-9A-Za-z-_]/g;
          function j(e6) {
            if ((e6 = (e6 = e6.split("=")[0]).trim().replace(Z, "")).length < 2) return "";
            for (; e6.length % 4 != 0; ) e6 += "=";
            return e6;
          }
          __name(j, "j");
          function G(e6) {
            return e6 < 16 ? "0" + e6.toString(16) : e6.toString(16);
          }
          __name(G, "G");
          function H(e6, t6) {
            var i3;
            t6 = t6 || 1 / 0;
            for (var r5 = e6.length, n4 = null, a3 = [], o4 = 0; o4 < r5; ++o4) {
              if ((i3 = e6.charCodeAt(o4)) > 55295 && i3 < 57344) {
                if (!n4) {
                  if (i3 > 56319) {
                    (t6 -= 3) > -1 && a3.push(239, 191, 189);
                    continue;
                  }
                  if (o4 + 1 === r5) {
                    (t6 -= 3) > -1 && a3.push(239, 191, 189);
                    continue;
                  }
                  n4 = i3;
                  continue;
                }
                if (i3 < 56320) {
                  (t6 -= 3) > -1 && a3.push(239, 191, 189), n4 = i3;
                  continue;
                }
                i3 = 65536 + (n4 - 55296 << 10 | i3 - 56320);
              } else n4 && (t6 -= 3) > -1 && a3.push(239, 191, 189);
              if (n4 = null, i3 < 128) {
                if ((t6 -= 1) < 0) break;
                a3.push(i3);
              } else if (i3 < 2048) {
                if ((t6 -= 2) < 0) break;
                a3.push(i3 >> 6 | 192, 63 & i3 | 128);
              } else if (i3 < 65536) {
                if ((t6 -= 3) < 0) break;
                a3.push(i3 >> 12 | 224, i3 >> 6 & 63 | 128, 63 & i3 | 128);
              } else {
                if (!(i3 < 1114112)) throw new Error("Invalid code point");
                if ((t6 -= 4) < 0) break;
                a3.push(i3 >> 18 | 240, i3 >> 12 & 63 | 128, i3 >> 6 & 63 | 128, 63 & i3 | 128);
              }
            }
            return a3;
          }
          __name(H, "H");
          function Q(e6) {
            for (var t6 = [], i3 = 0; i3 < e6.length; ++i3) t6.push(255 & e6.charCodeAt(i3));
            return t6;
          }
          __name(Q, "Q");
          function W(e6, t6) {
            for (var i3, r5, n4, a3 = [], o4 = 0; o4 < e6.length && !((t6 -= 2) < 0); ++o4) r5 = (i3 = e6.charCodeAt(o4)) >> 8, n4 = i3 % 256, a3.push(n4), a3.push(r5);
            return a3;
          }
          __name(W, "W");
          function q(e6) {
            return t5.toByteArray(j(e6));
          }
          __name(q, "q");
          function V(e6, t6, i3, r5) {
            for (var n4 = 0; n4 < r5 && !(n4 + i3 >= t6.length || n4 >= e6.length); ++n4) t6[n4 + i3] = e6[n4];
            return n4;
          }
          __name(V, "V");
          function Y2(e6, t6) {
            return e6 instanceof t6 || null != e6 && null != e6.constructor && null != e6.constructor.name && e6.constructor.name === t6.name;
          }
          __name(Y2, "Y");
          function K(e6) {
            return e6 != e6;
          }
          __name(K, "K");
        }).call(this);
      }).call(this, e5("buffer").Buffer);
    }, { "base64-js": 28, buffer: 32, ieee754: 45 }], 33: [function(e5, t3, i2) {
      var r4 = e5("get-intrinsic"), n3 = e5("./"), a2 = n3(r4("String.prototype.indexOf"));
      t3.exports = function(e6, t4) {
        var i3 = r4(e6, !!t4);
        return "function" == typeof i3 && a2(e6, ".prototype.") > -1 ? n3(i3) : i3;
      };
    }, { "./": 34, "get-intrinsic": 39 }], 34: [function(e5, t3, i2) {
      var r4 = e5("function-bind"), n3 = e5("get-intrinsic"), a2 = n3("%Function.prototype.apply%"), o3 = n3("%Function.prototype.call%"), s4 = n3("%Reflect.apply%", true) || r4.call(o3, a2), l2 = n3("%Object.getOwnPropertyDescriptor%", true), u2 = n3("%Object.defineProperty%", true), h2 = n3("%Math.max%");
      if (u2) try {
        u2({}, "a", { value: 1 });
      } catch (e6) {
        u2 = null;
      }
      t3.exports = function(e6) {
        var t4 = s4(r4, o3, arguments);
        return l2 && u2 && l2(t4, "length").configurable && u2(t4, "length", { value: 1 + h2(0, e6.length - (arguments.length - 1)) }), t4;
      };
      var c3 = /* @__PURE__ */ __name(function() {
        return s4(r4, a2, arguments);
      }, "c");
      u2 ? u2(t3.exports, "apply", { value: c3 }) : t3.exports.apply = c3;
    }, { "function-bind": 38, "get-intrinsic": 39 }], 35: [function(e5, t3, i2) {
      var r4, n3 = "object" == typeof Reflect ? Reflect : null, a2 = n3 && "function" == typeof n3.apply ? n3.apply : function(e6, t4, i3) {
        return Function.prototype.apply.call(e6, t4, i3);
      };
      function o3(e6) {
        console && console.warn && console.warn(e6);
      }
      __name(o3, "o");
      r4 = n3 && "function" == typeof n3.ownKeys ? n3.ownKeys : Object.getOwnPropertySymbols ? function(e6) {
        return Object.getOwnPropertyNames(e6).concat(Object.getOwnPropertySymbols(e6));
      } : function(e6) {
        return Object.getOwnPropertyNames(e6);
      };
      var s4 = Number.isNaN || function(e6) {
        return e6 != e6;
      };
      function l2() {
        l2.init.call(this);
      }
      __name(l2, "l");
      t3.exports = l2, t3.exports.once = w, l2.EventEmitter = l2, l2.prototype._events = void 0, l2.prototype._eventsCount = 0, l2.prototype._maxListeners = void 0;
      var u2 = 10;
      function h2(e6) {
        if ("function" != typeof e6) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e6);
      }
      __name(h2, "h");
      function c3(e6) {
        return void 0 === e6._maxListeners ? l2.defaultMaxListeners : e6._maxListeners;
      }
      __name(c3, "c");
      function f2(e6, t4, i3, r5) {
        var n4, a3, s5;
        if (h2(i3), void 0 === (a3 = e6._events) ? (a3 = e6._events = /* @__PURE__ */ Object.create(null), e6._eventsCount = 0) : (void 0 !== a3.newListener && (e6.emit("newListener", t4, i3.listener ? i3.listener : i3), a3 = e6._events), s5 = a3[t4]), void 0 === s5) s5 = a3[t4] = i3, ++e6._eventsCount;
        else if ("function" == typeof s5 ? s5 = a3[t4] = r5 ? [i3, s5] : [s5, i3] : r5 ? s5.unshift(i3) : s5.push(i3), (n4 = c3(e6)) > 0 && s5.length > n4 && !s5.warned) {
          s5.warned = true;
          var l3 = new Error("Possible EventEmitter memory leak detected. " + s5.length + " " + String(t4) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          l3.name = "MaxListenersExceededWarning", l3.emitter = e6, l3.type = t4, l3.count = s5.length, o3(l3);
        }
        return e6;
      }
      __name(f2, "f");
      function d() {
        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      __name(d, "d");
      function p2(e6, t4, i3) {
        var r5 = { fired: false, wrapFn: void 0, target: e6, type: t4, listener: i3 }, n4 = d.bind(r5);
        return n4.listener = i3, r5.wrapFn = n4, n4;
      }
      __name(p2, "p");
      function m(e6, t4, i3) {
        var r5 = e6._events;
        if (void 0 === r5) return [];
        var n4 = r5[t4];
        return void 0 === n4 ? [] : "function" == typeof n4 ? i3 ? [n4.listener || n4] : [n4] : i3 ? y2(n4) : g(n4, n4.length);
      }
      __name(m, "m");
      function _2(e6) {
        var t4 = this._events;
        if (void 0 !== t4) {
          var i3 = t4[e6];
          if ("function" == typeof i3) return 1;
          if (void 0 !== i3) return i3.length;
        }
        return 0;
      }
      __name(_2, "_");
      function g(e6, t4) {
        for (var i3 = new Array(t4), r5 = 0; r5 < t4; ++r5) i3[r5] = e6[r5];
        return i3;
      }
      __name(g, "g");
      function b2(e6, t4) {
        for (; t4 + 1 < e6.length; t4++) e6[t4] = e6[t4 + 1];
        e6.pop();
      }
      __name(b2, "b");
      function y2(e6) {
        for (var t4 = new Array(e6.length), i3 = 0; i3 < t4.length; ++i3) t4[i3] = e6[i3].listener || e6[i3];
        return t4;
      }
      __name(y2, "y");
      function w(e6, t4) {
        return new Promise(function(i3, r5) {
          function n4(i4) {
            e6.removeListener(t4, a3), r5(i4);
          }
          __name(n4, "n");
          function a3() {
            "function" == typeof e6.removeListener && e6.removeListener("error", n4), i3([].slice.call(arguments));
          }
          __name(a3, "a");
          x2(e6, t4, a3, { once: true }), "error" !== t4 && v2(e6, n4, { once: true });
        });
      }
      __name(w, "w");
      function v2(e6, t4, i3) {
        "function" == typeof e6.on && x2(e6, "error", t4, i3);
      }
      __name(v2, "v");
      function x2(e6, t4, i3, r5) {
        if ("function" == typeof e6.on) r5.once ? e6.once(t4, i3) : e6.on(t4, i3);
        else {
          if ("function" != typeof e6.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e6);
          e6.addEventListener(t4, /* @__PURE__ */ __name(function n4(a3) {
            r5.once && e6.removeEventListener(t4, n4), i3(a3);
          }, "n"));
        }
      }
      __name(x2, "x");
      Object.defineProperty(l2, "defaultMaxListeners", { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return u2;
      }, "get"), set: /* @__PURE__ */ __name(function(e6) {
        if ("number" != typeof e6 || e6 < 0 || s4(e6)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e6 + ".");
        u2 = e6;
      }, "set") }), l2.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, l2.prototype.setMaxListeners = function(e6) {
        if ("number" != typeof e6 || e6 < 0 || s4(e6)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e6 + ".");
        return this._maxListeners = e6, this;
      }, l2.prototype.getMaxListeners = function() {
        return c3(this);
      }, l2.prototype.emit = function(e6) {
        for (var t4 = [], i3 = 1; i3 < arguments.length; i3++) t4.push(arguments[i3]);
        var r5 = "error" === e6, n4 = this._events;
        if (void 0 !== n4) r5 = r5 && void 0 === n4.error;
        else if (!r5) return false;
        if (r5) {
          var o4;
          if (t4.length > 0 && (o4 = t4[0]), o4 instanceof Error) throw o4;
          var s5 = new Error("Unhandled error." + (o4 ? " (" + o4.message + ")" : ""));
          throw s5.context = o4, s5;
        }
        var l3 = n4[e6];
        if (void 0 === l3) return false;
        if ("function" == typeof l3) a2(l3, this, t4);
        else {
          var u3 = l3.length, h3 = g(l3, u3);
          for (i3 = 0; i3 < u3; ++i3) a2(h3[i3], this, t4);
        }
        return true;
      }, l2.prototype.addListener = function(e6, t4) {
        return f2(this, e6, t4, false);
      }, l2.prototype.on = l2.prototype.addListener, l2.prototype.prependListener = function(e6, t4) {
        return f2(this, e6, t4, true);
      }, l2.prototype.once = function(e6, t4) {
        return h2(t4), this.on(e6, p2(this, e6, t4)), this;
      }, l2.prototype.prependOnceListener = function(e6, t4) {
        return h2(t4), this.prependListener(e6, p2(this, e6, t4)), this;
      }, l2.prototype.removeListener = function(e6, t4) {
        var i3, r5, n4, a3, o4;
        if (h2(t4), void 0 === (r5 = this._events)) return this;
        if (void 0 === (i3 = r5[e6])) return this;
        if (i3 === t4 || i3.listener === t4) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r5[e6], r5.removeListener && this.emit("removeListener", e6, i3.listener || t4));
        else if ("function" != typeof i3) {
          for (n4 = -1, a3 = i3.length - 1; a3 >= 0; a3--) if (i3[a3] === t4 || i3[a3].listener === t4) {
            o4 = i3[a3].listener, n4 = a3;
            break;
          }
          if (n4 < 0) return this;
          0 === n4 ? i3.shift() : b2(i3, n4), 1 === i3.length && (r5[e6] = i3[0]), void 0 !== r5.removeListener && this.emit("removeListener", e6, o4 || t4);
        }
        return this;
      }, l2.prototype.off = l2.prototype.removeListener, l2.prototype.removeAllListeners = function(e6) {
        var t4, i3, r5;
        if (void 0 === (i3 = this._events)) return this;
        if (void 0 === i3.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== i3[e6] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete i3[e6]), this;
        if (0 === arguments.length) {
          var n4, a3 = Object.keys(i3);
          for (r5 = 0; r5 < a3.length; ++r5) "removeListener" !== (n4 = a3[r5]) && this.removeAllListeners(n4);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t4 = i3[e6])) this.removeListener(e6, t4);
        else if (void 0 !== t4) for (r5 = t4.length - 1; r5 >= 0; r5--) this.removeListener(e6, t4[r5]);
        return this;
      }, l2.prototype.listeners = function(e6) {
        return m(this, e6, true);
      }, l2.prototype.rawListeners = function(e6) {
        return m(this, e6, false);
      }, l2.listenerCount = function(e6, t4) {
        return "function" == typeof e6.listenerCount ? e6.listenerCount(t4) : _2.call(e6, t4);
      }, l2.prototype.listenerCount = _2, l2.prototype.eventNames = function() {
        return this._eventsCount > 0 ? r4(this._events) : [];
      };
    }, {}], 36: [function(e5, t3, i2) {
      var r4 = e5("is-callable"), n3 = Object.prototype.toString, a2 = Object.prototype.hasOwnProperty, o3 = /* @__PURE__ */ __name(function(e6, t4, i3) {
        for (var r5 = 0, n4 = e6.length; r5 < n4; r5++) a2.call(e6, r5) && (null == i3 ? t4(e6[r5], r5, e6) : t4.call(i3, e6[r5], r5, e6));
      }, "o"), s4 = /* @__PURE__ */ __name(function(e6, t4, i3) {
        for (var r5 = 0, n4 = e6.length; r5 < n4; r5++) null == i3 ? t4(e6.charAt(r5), r5, e6) : t4.call(i3, e6.charAt(r5), r5, e6);
      }, "s"), l2 = /* @__PURE__ */ __name(function(e6, t4, i3) {
        for (var r5 in e6) a2.call(e6, r5) && (null == i3 ? t4(e6[r5], r5, e6) : t4.call(i3, e6[r5], r5, e6));
      }, "l"), u2 = /* @__PURE__ */ __name(function(e6, t4, i3) {
        if (!r4(t4)) throw new TypeError("iterator must be a function");
        var a3;
        arguments.length >= 3 && (a3 = i3), "[object Array]" === n3.call(e6) ? o3(e6, t4, a3) : "string" == typeof e6 ? s4(e6, t4, a3) : l2(e6, t4, a3);
      }, "u");
      t3.exports = u2;
    }, { "is-callable": 48 }], 37: [function(e5, t3, i2) {
      var r4 = "Function.prototype.bind called on incompatible ", n3 = Array.prototype.slice, a2 = Object.prototype.toString, o3 = "[object Function]";
      t3.exports = function(e6) {
        var t4 = this;
        if ("function" != typeof t4 || a2.call(t4) !== o3) throw new TypeError(r4 + t4);
        for (var i3, s4 = n3.call(arguments, 1), l2 = function() {
          if (this instanceof i3) {
            var r5 = t4.apply(this, s4.concat(n3.call(arguments)));
            return Object(r5) === r5 ? r5 : this;
          }
          return t4.apply(e6, s4.concat(n3.call(arguments)));
        }, u2 = Math.max(0, t4.length - s4.length), h2 = [], c3 = 0; c3 < u2; c3++) h2.push("$" + c3);
        if (i3 = Function("binder", "return function (" + h2.join(",") + "){ return binder.apply(this,arguments); }")(l2), t4.prototype) {
          var f2 = /* @__PURE__ */ __name(function() {
          }, "f");
          f2.prototype = t4.prototype, i3.prototype = new f2(), f2.prototype = null;
        }
        return i3;
      };
    }, {}], 38: [function(e5, t3, i2) {
      var r4 = e5("./implementation");
      t3.exports = Function.prototype.bind || r4;
    }, { "./implementation": 37 }], 39: [function(e5, t3, i2) {
      var r4, n3 = SyntaxError, a2 = Function, o3 = TypeError, s4 = /* @__PURE__ */ __name(function(e6) {
        try {
          return a2('"use strict"; return (' + e6 + ").constructor;")();
        } catch (e7) {
        }
      }, "s"), l2 = Object.getOwnPropertyDescriptor;
      if (l2) try {
        l2({}, "");
      } catch (e6) {
        l2 = null;
      }
      var u2 = /* @__PURE__ */ __name(function() {
        throw new o3();
      }, "u"), h2 = l2 ? function() {
        try {
          return u2;
        } catch (e6) {
          try {
            return l2(arguments, "callee").get;
          } catch (e7) {
            return u2;
          }
        }
      }() : u2, c3 = e5("has-symbols")(), f2 = Object.getPrototypeOf || function(e6) {
        return e6.__proto__;
      }, d = {}, p2 = "undefined" == typeof Uint8Array ? r4 : f2(Uint8Array), m = { "%AggregateError%": "undefined" == typeof AggregateError ? r4 : AggregateError, "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? r4 : ArrayBuffer, "%ArrayIteratorPrototype%": c3 ? f2([][Symbol.iterator]()) : r4, "%AsyncFromSyncIteratorPrototype%": r4, "%AsyncFunction%": d, "%AsyncGenerator%": d, "%AsyncGeneratorFunction%": d, "%AsyncIteratorPrototype%": d, "%Atomics%": "undefined" == typeof Atomics ? r4 : Atomics, "%BigInt%": "undefined" == typeof BigInt ? r4 : BigInt, "%BigInt64Array%": "undefined" == typeof BigInt64Array ? r4 : BigInt64Array, "%BigUint64Array%": "undefined" == typeof BigUint64Array ? r4 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": "undefined" == typeof DataView ? r4 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": "undefined" == typeof Float32Array ? r4 : Float32Array, "%Float64Array%": "undefined" == typeof Float64Array ? r4 : Float64Array, "%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? r4 : FinalizationRegistry, "%Function%": a2, "%GeneratorFunction%": d, "%Int8Array%": "undefined" == typeof Int8Array ? r4 : Int8Array, "%Int16Array%": "undefined" == typeof Int16Array ? r4 : Int16Array, "%Int32Array%": "undefined" == typeof Int32Array ? r4 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": c3 ? f2(f2([][Symbol.iterator]())) : r4, "%JSON%": "object" == typeof JSON ? JSON : r4, "%Map%": "undefined" == typeof Map ? r4 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && c3 ? f2((/* @__PURE__ */ new Map())[Symbol.iterator]()) : r4, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? r4 : Promise, "%Proxy%": "undefined" == typeof Proxy ? r4 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": "undefined" == typeof Reflect ? r4 : Reflect, "%RegExp%": RegExp, "%Set%": "undefined" == typeof Set ? r4 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && c3 ? f2((/* @__PURE__ */ new Set())[Symbol.iterator]()) : r4, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? r4 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": c3 ? f2(""[Symbol.iterator]()) : r4, "%Symbol%": c3 ? Symbol : r4, "%SyntaxError%": n3, "%ThrowTypeError%": h2, "%TypedArray%": p2, "%TypeError%": o3, "%Uint8Array%": "undefined" == typeof Uint8Array ? r4 : Uint8Array, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? r4 : Uint8ClampedArray, "%Uint16Array%": "undefined" == typeof Uint16Array ? r4 : Uint16Array, "%Uint32Array%": "undefined" == typeof Uint32Array ? r4 : Uint32Array, "%URIError%": URIError, "%WeakMap%": "undefined" == typeof WeakMap ? r4 : WeakMap, "%WeakRef%": "undefined" == typeof WeakRef ? r4 : WeakRef, "%WeakSet%": "undefined" == typeof WeakSet ? r4 : WeakSet };
      try {
        null.error;
      } catch (e6) {
        var _2 = f2(f2(e6));
        m["%Error.prototype%"] = _2;
      }
      var g = /* @__PURE__ */ __name(function e6(t4) {
        var i3;
        if ("%AsyncFunction%" === t4) i3 = s4("async function () {}");
        else if ("%GeneratorFunction%" === t4) i3 = s4("function* () {}");
        else if ("%AsyncGeneratorFunction%" === t4) i3 = s4("async function* () {}");
        else if ("%AsyncGenerator%" === t4) {
          var r5 = e6("%AsyncGeneratorFunction%");
          r5 && (i3 = r5.prototype);
        } else if ("%AsyncIteratorPrototype%" === t4) {
          var n4 = e6("%AsyncGenerator%");
          n4 && (i3 = f2(n4.prototype));
        }
        return m[t4] = i3, i3;
      }, "e"), b2 = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, y2 = e5("function-bind"), w = e5("has"), v2 = y2.call(Function.call, Array.prototype.concat), x2 = y2.call(Function.apply, Array.prototype.splice), E2 = y2.call(Function.call, String.prototype.replace), k2 = y2.call(Function.call, String.prototype.slice), S2 = y2.call(Function.call, RegExp.prototype.exec), A2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, I = /\\(\\)?/g, M2 = /* @__PURE__ */ __name(function(e6) {
        var t4 = k2(e6, 0, 1), i3 = k2(e6, -1);
        if ("%" === t4 && "%" !== i3) throw new n3("invalid intrinsic syntax, expected closing `%`");
        if ("%" === i3 && "%" !== t4) throw new n3("invalid intrinsic syntax, expected opening `%`");
        var r5 = [];
        return E2(e6, A2, function(e7, t5, i4, n4) {
          r5[r5.length] = i4 ? E2(n4, I, "$1") : t5 || e7;
        }), r5;
      }, "M"), T2 = /* @__PURE__ */ __name(function(e6, t4) {
        var i3, r5 = e6;
        if (w(b2, r5) && (r5 = "%" + (i3 = b2[r5])[0] + "%"), w(m, r5)) {
          var a3 = m[r5];
          if (a3 === d && (a3 = g(r5)), void 0 === a3 && !t4) throw new o3("intrinsic " + e6 + " exists, but is not available. Please file an issue!");
          return { alias: i3, name: r5, value: a3 };
        }
        throw new n3("intrinsic " + e6 + " does not exist!");
      }, "T");
      t3.exports = function(e6, t4) {
        if ("string" != typeof e6 || 0 === e6.length) throw new o3("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof t4) throw new o3('"allowMissing" argument must be a boolean');
        if (null === S2(/^%?[^%]*%?$/, e6)) throw new n3("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var i3 = M2(e6), r5 = i3.length > 0 ? i3[0] : "", a3 = T2("%" + r5 + "%", t4), s5 = a3.name, u3 = a3.value, h3 = false, c4 = a3.alias;
        c4 && (r5 = c4[0], x2(i3, v2([0, 1], c4)));
        for (var f3 = 1, d2 = true; f3 < i3.length; f3 += 1) {
          var p3 = i3[f3], _3 = k2(p3, 0, 1), g2 = k2(p3, -1);
          if (('"' === _3 || "'" === _3 || "`" === _3 || '"' === g2 || "'" === g2 || "`" === g2) && _3 !== g2) throw new n3("property names with quotes must have matching quotes");
          if ("constructor" !== p3 && d2 || (h3 = true), w(m, s5 = "%" + (r5 += "." + p3) + "%")) u3 = m[s5];
          else if (null != u3) {
            if (!(p3 in u3)) {
              if (!t4) throw new o3("base intrinsic for " + e6 + " exists, but the property is not available.");
              return;
            }
            if (l2 && f3 + 1 >= i3.length) {
              var b3 = l2(u3, p3);
              u3 = (d2 = !!b3) && "get" in b3 && !("originalValue" in b3.get) ? b3.get : u3[p3];
            } else d2 = w(u3, p3), u3 = u3[p3];
            d2 && !h3 && (m[s5] = u3);
          }
        }
        return u3;
      };
    }, { "function-bind": 38, has: 44, "has-symbols": 41 }], 40: [function(e5, t3, i2) {
      var r4 = e5("get-intrinsic")("%Object.getOwnPropertyDescriptor%", true);
      if (r4) try {
        r4([], "length");
      } catch (e6) {
        r4 = null;
      }
      t3.exports = r4;
    }, { "get-intrinsic": 39 }], 41: [function(e5, t3, i2) {
      var r4 = "undefined" != typeof Symbol && Symbol, n3 = e5("./shams");
      t3.exports = function() {
        return "function" == typeof r4 && "function" == typeof Symbol && "symbol" == typeof r4("foo") && "symbol" == typeof Symbol("bar") && n3();
      };
    }, { "./shams": 42 }], 42: [function(e5, t3, i2) {
      t3.exports = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
        if ("symbol" == typeof Symbol.iterator) return true;
        var e6 = {}, t4 = Symbol("test"), i3 = Object(t4);
        if ("string" == typeof t4) return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(t4)) return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(i3)) return false;
        var r4 = 42;
        for (t4 in e6[t4] = r4, e6) return false;
        if ("function" == typeof Object.keys && 0 !== Object.keys(e6).length) return false;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e6).length) return false;
        var n3 = Object.getOwnPropertySymbols(e6);
        if (1 !== n3.length || n3[0] !== t4) return false;
        if (!Object.prototype.propertyIsEnumerable.call(e6, t4)) return false;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
          var a2 = Object.getOwnPropertyDescriptor(e6, t4);
          if (a2.value !== r4 || true !== a2.enumerable) return false;
        }
        return true;
      };
    }, {}], 43: [function(e5, t3, i2) {
      var r4 = e5("has-symbols/shams");
      t3.exports = function() {
        return r4() && !!Symbol.toStringTag;
      };
    }, { "has-symbols/shams": 42 }], 44: [function(e5, t3, i2) {
      var r4 = e5("function-bind");
      t3.exports = r4.call(Function.call, Object.prototype.hasOwnProperty);
    }, { "function-bind": 38 }], 45: [function(e5, t3, i2) {
      i2.read = function(e6, t4, i3, r4, n3) {
        var a2, o3, s4 = 8 * n3 - r4 - 1, l2 = (1 << s4) - 1, u2 = l2 >> 1, h2 = -7, c3 = i3 ? n3 - 1 : 0, f2 = i3 ? -1 : 1, d = e6[t4 + c3];
        for (c3 += f2, a2 = d & (1 << -h2) - 1, d >>= -h2, h2 += s4; h2 > 0; a2 = 256 * a2 + e6[t4 + c3], c3 += f2, h2 -= 8) ;
        for (o3 = a2 & (1 << -h2) - 1, a2 >>= -h2, h2 += r4; h2 > 0; o3 = 256 * o3 + e6[t4 + c3], c3 += f2, h2 -= 8) ;
        if (0 === a2) a2 = 1 - u2;
        else {
          if (a2 === l2) return o3 ? NaN : 1 / 0 * (d ? -1 : 1);
          o3 += Math.pow(2, r4), a2 -= u2;
        }
        return (d ? -1 : 1) * o3 * Math.pow(2, a2 - r4);
      }, i2.write = function(e6, t4, i3, r4, n3, a2) {
        var o3, s4, l2, u2 = 8 * a2 - n3 - 1, h2 = (1 << u2) - 1, c3 = h2 >> 1, f2 = 23 === n3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r4 ? 0 : a2 - 1, p2 = r4 ? 1 : -1, m = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
        for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (s4 = isNaN(t4) ? 1 : 0, o3 = h2) : (o3 = Math.floor(Math.log(t4) / Math.LN2), t4 * (l2 = Math.pow(2, -o3)) < 1 && (o3--, l2 *= 2), (t4 += o3 + c3 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - c3)) * l2 >= 2 && (o3++, l2 /= 2), o3 + c3 >= h2 ? (s4 = 0, o3 = h2) : o3 + c3 >= 1 ? (s4 = (t4 * l2 - 1) * Math.pow(2, n3), o3 += c3) : (s4 = t4 * Math.pow(2, c3 - 1) * Math.pow(2, n3), o3 = 0)); n3 >= 8; e6[i3 + d] = 255 & s4, d += p2, s4 /= 256, n3 -= 8) ;
        for (o3 = o3 << n3 | s4, u2 += n3; u2 > 0; e6[i3 + d] = 255 & o3, d += p2, o3 /= 256, u2 -= 8) ;
        e6[i3 + d - p2] |= 128 * m;
      };
    }, {}], 46: [function(e5, t3, i2) {
      "function" == typeof Object.create ? t3.exports = function(e6, t4) {
        t4 && (e6.super_ = t4, e6.prototype = Object.create(t4.prototype, { constructor: { value: e6, enumerable: false, writable: true, configurable: true } }));
      } : t3.exports = function(e6, t4) {
        if (t4) {
          e6.super_ = t4;
          var i3 = /* @__PURE__ */ __name(function() {
          }, "i");
          i3.prototype = t4.prototype, e6.prototype = new i3(), e6.prototype.constructor = e6;
        }
      };
    }, {}], 47: [function(e5, t3, i2) {
      var r4 = e5("has-tostringtag/shams")(), n3 = e5("call-bind/callBound")("Object.prototype.toString"), a2 = /* @__PURE__ */ __name(function(e6) {
        return !(r4 && e6 && "object" == typeof e6 && Symbol.toStringTag in e6) && "[object Arguments]" === n3(e6);
      }, "a"), o3 = /* @__PURE__ */ __name(function(e6) {
        return !!a2(e6) || null !== e6 && "object" == typeof e6 && "number" == typeof e6.length && e6.length >= 0 && "[object Array]" !== n3(e6) && "[object Function]" === n3(e6.callee);
      }, "o"), s4 = function() {
        return a2(arguments);
      }();
      a2.isLegacyArguments = o3, t3.exports = s4 ? a2 : o3;
    }, { "call-bind/callBound": 33, "has-tostringtag/shams": 43 }], 48: [function(e5, t3, i2) {
      var r4, n3, a2 = Function.prototype.toString, o3 = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
      if ("function" == typeof o3 && "function" == typeof Object.defineProperty) try {
        r4 = Object.defineProperty({}, "length", { get: /* @__PURE__ */ __name(function() {
          throw n3;
        }, "get") }), n3 = {}, o3(function() {
          throw 42;
        }, null, r4);
      } catch (e6) {
        e6 !== n3 && (o3 = null);
      }
      else o3 = null;
      var s4 = /^\s*class\b/, l2 = /* @__PURE__ */ __name(function(e6) {
        try {
          var t4 = a2.call(e6);
          return s4.test(t4);
        } catch (e7) {
          return false;
        }
      }, "l"), u2 = /* @__PURE__ */ __name(function(e6) {
        try {
          return !l2(e6) && (a2.call(e6), true);
        } catch (e7) {
          return false;
        }
      }, "u"), h2 = Object.prototype.toString, c3 = "[object Object]", f2 = "[object Function]", d = "[object GeneratorFunction]", p2 = "[object HTMLAllCollection]", m = "[object HTML document.all class]", _2 = "[object HTMLCollection]", g = "function" == typeof Symbol && !!Symbol.toStringTag, b2 = !(0 in [,]), y2 = /* @__PURE__ */ __name(function() {
        return false;
      }, "y");
      if ("object" == typeof document) {
        var w = document.all;
        h2.call(w) === h2.call(document.all) && (y2 = /* @__PURE__ */ __name(function(e6) {
          if ((b2 || !e6) && (void 0 === e6 || "object" == typeof e6)) try {
            var t4 = h2.call(e6);
            return (t4 === p2 || t4 === m || t4 === _2 || t4 === c3) && null == e6("");
          } catch (e7) {
          }
          return false;
        }, "y"));
      }
      t3.exports = o3 ? function(e6) {
        if (y2(e6)) return true;
        if (!e6) return false;
        if ("function" != typeof e6 && "object" != typeof e6) return false;
        try {
          o3(e6, null, r4);
        } catch (e7) {
          if (e7 !== n3) return false;
        }
        return !l2(e6) && u2(e6);
      } : function(e6) {
        if (y2(e6)) return true;
        if (!e6) return false;
        if ("function" != typeof e6 && "object" != typeof e6) return false;
        if (g) return u2(e6);
        if (l2(e6)) return false;
        var t4 = h2.call(e6);
        return !(t4 !== f2 && t4 !== d && !/^\[object HTML/.test(t4)) && u2(e6);
      };
    }, {}], 49: [function(e5, t3, i2) {
      var r4, n3 = Object.prototype.toString, a2 = Function.prototype.toString, o3 = /^\s*(?:function)?\*/, s4 = e5("has-tostringtag/shams")(), l2 = Object.getPrototypeOf, u2 = /* @__PURE__ */ __name(function() {
        if (!s4) return false;
        try {
          return Function("return function*() {}")();
        } catch (e6) {
        }
      }, "u");
      t3.exports = function(e6) {
        if ("function" != typeof e6) return false;
        if (o3.test(a2.call(e6))) return true;
        if (!s4) return "[object GeneratorFunction]" === n3.call(e6);
        if (!l2) return false;
        if (void 0 === r4) {
          var t4 = u2();
          r4 = !!t4 && l2(t4);
        }
        return l2(e6) === r4;
      };
    }, { "has-tostringtag/shams": 43 }], 50: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          var r4 = e5("for-each"), n3 = e5("available-typed-arrays"), a2 = e5("call-bind/callBound"), o3 = a2("Object.prototype.toString"), s4 = e5("has-tostringtag/shams")(), l2 = e5("gopd"), u2 = "undefined" == typeof globalThis ? i3 : globalThis, h2 = n3(), c3 = a2("Array.prototype.indexOf", true) || function(e6, t4) {
            for (var i4 = 0; i4 < e6.length; i4 += 1) if (e6[i4] === t4) return i4;
            return -1;
          }, f2 = a2("String.prototype.slice"), d = {}, p2 = Object.getPrototypeOf;
          s4 && l2 && p2 && r4(h2, function(e6) {
            var t4 = new u2[e6]();
            if (Symbol.toStringTag in t4) {
              var i4 = p2(t4), r5 = l2(i4, Symbol.toStringTag);
              if (!r5) {
                var n4 = p2(i4);
                r5 = l2(n4, Symbol.toStringTag);
              }
              d[e6] = r5.get;
            }
          });
          var m = /* @__PURE__ */ __name(function(e6) {
            var t4 = false;
            return r4(d, function(i4, r5) {
              if (!t4) try {
                t4 = i4.call(e6) === r5;
              } catch (e7) {
              }
            }), t4;
          }, "m");
          t3.exports = function(e6) {
            if (!e6 || "object" != typeof e6) return false;
            if (!s4 || !(Symbol.toStringTag in e6)) {
              var t4 = f2(o3(e6), 8, -1);
              return c3(h2, t4) > -1;
            }
            return !!l2 && m(e6);
          };
        }).call(this);
      }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43 }], 51: [function(e5, t3, i2) {
      var r4 = Object.getOwnPropertySymbols, n3 = Object.prototype.hasOwnProperty, a2 = Object.prototype.propertyIsEnumerable;
      function o3(e6) {
        if (null == e6) throw new TypeError("Object.assign cannot be called with null or undefined");
        return Object(e6);
      }
      __name(o3, "o");
      function s4() {
        try {
          if (!Object.assign) return false;
          var e6 = new String("abc");
          if (e6[5] = "de", "5" === Object.getOwnPropertyNames(e6)[0]) return false;
          for (var t4 = {}, i3 = 0; i3 < 10; i3++) t4["_" + String.fromCharCode(i3)] = i3;
          var r5 = Object.getOwnPropertyNames(t4).map(function(e7) {
            return t4[e7];
          });
          if ("0123456789" !== r5.join("")) return false;
          var n4 = {};
          return "abcdefghijklmnopqrst".split("").forEach(function(e7) {
            n4[e7] = e7;
          }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n4)).join("");
        } catch (e7) {
          return false;
        }
      }
      __name(s4, "s");
      t3.exports = s4() ? Object.assign : function(e6, t4) {
        for (var i3, s5, l2 = o3(e6), u2 = 1; u2 < arguments.length; u2++) {
          for (var h2 in i3 = Object(arguments[u2])) n3.call(i3, h2) && (l2[h2] = i3[h2]);
          if (r4) {
            s5 = r4(i3);
            for (var c3 = 0; c3 < s5.length; c3++) a2.call(i3, s5[c3]) && (l2[s5[c3]] = i3[s5[c3]]);
          }
        }
        return l2;
      };
    }, {}], 52: [function(e5, t3, i2) {
      var r4 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      function n3(e6, t4) {
        return Object.prototype.hasOwnProperty.call(e6, t4);
      }
      __name(n3, "n");
      i2.assign = function(e6) {
        for (var t4 = Array.prototype.slice.call(arguments, 1); t4.length; ) {
          var i3 = t4.shift();
          if (i3) {
            if ("object" != typeof i3) throw new TypeError(i3 + "must be non-object");
            for (var r5 in i3) n3(i3, r5) && (e6[r5] = i3[r5]);
          }
        }
        return e6;
      }, i2.shrinkBuf = function(e6, t4) {
        return e6.length === t4 ? e6 : e6.subarray ? e6.subarray(0, t4) : (e6.length = t4, e6);
      };
      var a2 = { arraySet: /* @__PURE__ */ __name(function(e6, t4, i3, r5, n4) {
        if (t4.subarray && e6.subarray) e6.set(t4.subarray(i3, i3 + r5), n4);
        else for (var a3 = 0; a3 < r5; a3++) e6[n4 + a3] = t4[i3 + a3];
      }, "arraySet"), flattenChunks: /* @__PURE__ */ __name(function(e6) {
        var t4, i3, r5, n4, a3, o4;
        for (r5 = 0, t4 = 0, i3 = e6.length; t4 < i3; t4++) r5 += e6[t4].length;
        for (o4 = new Uint8Array(r5), n4 = 0, t4 = 0, i3 = e6.length; t4 < i3; t4++) a3 = e6[t4], o4.set(a3, n4), n4 += a3.length;
        return o4;
      }, "flattenChunks") }, o3 = { arraySet: /* @__PURE__ */ __name(function(e6, t4, i3, r5, n4) {
        for (var a3 = 0; a3 < r5; a3++) e6[n4 + a3] = t4[i3 + a3];
      }, "arraySet"), flattenChunks: /* @__PURE__ */ __name(function(e6) {
        return [].concat.apply([], e6);
      }, "flattenChunks") };
      i2.setTyped = function(e6) {
        e6 ? (i2.Buf8 = Uint8Array, i2.Buf16 = Uint16Array, i2.Buf32 = Int32Array, i2.assign(i2, a2)) : (i2.Buf8 = Array, i2.Buf16 = Array, i2.Buf32 = Array, i2.assign(i2, o3));
      }, i2.setTyped(r4);
    }, {}], 53: [function(e5, t3, i2) {
      function r4(e6, t4, i3, r5) {
        for (var n3 = 65535 & e6, a2 = e6 >>> 16 & 65535, o3 = 0; 0 !== i3; ) {
          i3 -= o3 = i3 > 2e3 ? 2e3 : i3;
          do {
            a2 = a2 + (n3 = n3 + t4[r5++] | 0) | 0;
          } while (--o3);
          n3 %= 65521, a2 %= 65521;
        }
        return n3 | a2 << 16;
      }
      __name(r4, "r");
      t3.exports = r4;
    }, {}], 54: [function(e5, t3, i2) {
      t3.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 55: [function(e5, t3, i2) {
      function r4() {
        for (var e6, t4 = [], i3 = 0; i3 < 256; i3++) {
          e6 = i3;
          for (var r5 = 0; r5 < 8; r5++) e6 = 1 & e6 ? 3988292384 ^ e6 >>> 1 : e6 >>> 1;
          t4[i3] = e6;
        }
        return t4;
      }
      __name(r4, "r");
      var n3 = r4();
      function a2(e6, t4, i3, r5) {
        var a3 = n3, o3 = r5 + i3;
        e6 ^= -1;
        for (var s4 = r5; s4 < o3; s4++) e6 = e6 >>> 8 ^ a3[255 & (e6 ^ t4[s4])];
        return ~e6;
      }
      __name(a2, "a");
      t3.exports = a2;
    }, {}], 56: [function(e5, t3, i2) {
      var r4, n3 = e5("../utils/common"), a2 = e5("./trees"), o3 = e5("./adler32"), s4 = e5("./crc32"), l2 = e5("./messages"), u2 = 0, h2 = 1, c3 = 3, f2 = 4, d = 5, p2 = 0, m = 1, _2 = -2, g = -3, b2 = -5, y2 = -1, w = 1, v2 = 2, x2 = 3, E2 = 4, k2 = 0, S2 = 2, A2 = 8, I = 9, M2 = 15, T2 = 8, P = 286, B2 = 30, C2 = 19, R2 = 2 * P + 1, z2 = 15, F = 3, N2 = 258, O2 = N2 + F + 1, D = 32, $ = 42, L2 = 69, U = 73, Z = 91, j = 103, G = 113, H = 666, Q = 1, W = 2, q = 3, V = 4, Y2 = 3;
      function K(e6, t4) {
        return e6.msg = l2[t4], t4;
      }
      __name(K, "K");
      function J(e6) {
        return (e6 << 1) - (e6 > 4 ? 9 : 0);
      }
      __name(J, "J");
      function X(e6) {
        for (var t4 = e6.length; --t4 >= 0; ) e6[t4] = 0;
      }
      __name(X, "X");
      function ee(e6) {
        var t4 = e6.state, i3 = t4.pending;
        i3 > e6.avail_out && (i3 = e6.avail_out), 0 !== i3 && (n3.arraySet(e6.output, t4.pending_buf, t4.pending_out, i3, e6.next_out), e6.next_out += i3, t4.pending_out += i3, e6.total_out += i3, e6.avail_out -= i3, t4.pending -= i3, 0 === t4.pending && (t4.pending_out = 0));
      }
      __name(ee, "ee");
      function te(e6, t4) {
        a2._tr_flush_block(e6, e6.block_start >= 0 ? e6.block_start : -1, e6.strstart - e6.block_start, t4), e6.block_start = e6.strstart, ee(e6.strm);
      }
      __name(te, "te");
      function ie(e6, t4) {
        e6.pending_buf[e6.pending++] = t4;
      }
      __name(ie, "ie");
      function re(e6, t4) {
        e6.pending_buf[e6.pending++] = t4 >>> 8 & 255, e6.pending_buf[e6.pending++] = 255 & t4;
      }
      __name(re, "re");
      function ne(e6, t4, i3, r5) {
        var a3 = e6.avail_in;
        return a3 > r5 && (a3 = r5), 0 === a3 ? 0 : (e6.avail_in -= a3, n3.arraySet(t4, e6.input, e6.next_in, a3, i3), 1 === e6.state.wrap ? e6.adler = o3(e6.adler, t4, a3, i3) : 2 === e6.state.wrap && (e6.adler = s4(e6.adler, t4, a3, i3)), e6.next_in += a3, e6.total_in += a3, a3);
      }
      __name(ne, "ne");
      function ae(e6, t4) {
        var i3, r5, n4 = e6.max_chain_length, a3 = e6.strstart, o4 = e6.prev_length, s5 = e6.nice_match, l3 = e6.strstart > e6.w_size - O2 ? e6.strstart - (e6.w_size - O2) : 0, u3 = e6.window, h3 = e6.w_mask, c4 = e6.prev, f3 = e6.strstart + N2, d2 = u3[a3 + o4 - 1], p3 = u3[a3 + o4];
        e6.prev_length >= e6.good_match && (n4 >>= 2), s5 > e6.lookahead && (s5 = e6.lookahead);
        do {
          if (u3[(i3 = t4) + o4] === p3 && u3[i3 + o4 - 1] === d2 && u3[i3] === u3[a3] && u3[++i3] === u3[a3 + 1]) {
            a3 += 2, i3++;
            do {
            } while (u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && u3[++a3] === u3[++i3] && a3 < f3);
            if (r5 = N2 - (f3 - a3), a3 = f3 - N2, r5 > o4) {
              if (e6.match_start = t4, o4 = r5, r5 >= s5) break;
              d2 = u3[a3 + o4 - 1], p3 = u3[a3 + o4];
            }
          }
        } while ((t4 = c4[t4 & h3]) > l3 && 0 != --n4);
        return o4 <= e6.lookahead ? o4 : e6.lookahead;
      }
      __name(ae, "ae");
      function oe(e6) {
        var t4, i3, r5, a3, o4, s5 = e6.w_size;
        do {
          if (a3 = e6.window_size - e6.lookahead - e6.strstart, e6.strstart >= s5 + (s5 - O2)) {
            n3.arraySet(e6.window, e6.window, s5, s5, 0), e6.match_start -= s5, e6.strstart -= s5, e6.block_start -= s5, t4 = i3 = e6.hash_size;
            do {
              r5 = e6.head[--t4], e6.head[t4] = r5 >= s5 ? r5 - s5 : 0;
            } while (--i3);
            t4 = i3 = s5;
            do {
              r5 = e6.prev[--t4], e6.prev[t4] = r5 >= s5 ? r5 - s5 : 0;
            } while (--i3);
            a3 += s5;
          }
          if (0 === e6.strm.avail_in) break;
          if (i3 = ne(e6.strm, e6.window, e6.strstart + e6.lookahead, a3), e6.lookahead += i3, e6.lookahead + e6.insert >= F) for (o4 = e6.strstart - e6.insert, e6.ins_h = e6.window[o4], e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[o4 + 1]) & e6.hash_mask; e6.insert && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[o4 + F - 1]) & e6.hash_mask, e6.prev[o4 & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = o4, o4++, e6.insert--, !(e6.lookahead + e6.insert < F)); ) ;
        } while (e6.lookahead < O2 && 0 !== e6.strm.avail_in);
      }
      __name(oe, "oe");
      function se(e6, t4) {
        var i3 = 65535;
        for (i3 > e6.pending_buf_size - 5 && (i3 = e6.pending_buf_size - 5); ; ) {
          if (e6.lookahead <= 1) {
            if (oe(e6), 0 === e6.lookahead && t4 === u2) return Q;
            if (0 === e6.lookahead) break;
          }
          e6.strstart += e6.lookahead, e6.lookahead = 0;
          var r5 = e6.block_start + i3;
          if ((0 === e6.strstart || e6.strstart >= r5) && (e6.lookahead = e6.strstart - r5, e6.strstart = r5, te(e6, false), 0 === e6.strm.avail_out)) return Q;
          if (e6.strstart - e6.block_start >= e6.w_size - O2 && (te(e6, false), 0 === e6.strm.avail_out)) return Q;
        }
        return e6.insert = 0, t4 === f2 ? (te(e6, true), 0 === e6.strm.avail_out ? q : V) : (e6.strstart > e6.block_start && (te(e6, false), e6.strm.avail_out), Q);
      }
      __name(se, "se");
      function le(e6, t4) {
        for (var i3, r5; ; ) {
          if (e6.lookahead < O2) {
            if (oe(e6), e6.lookahead < O2 && t4 === u2) return Q;
            if (0 === e6.lookahead) break;
          }
          if (i3 = 0, e6.lookahead >= F && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + F - 1]) & e6.hash_mask, i3 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart), 0 !== i3 && e6.strstart - i3 <= e6.w_size - O2 && (e6.match_length = ae(e6, i3)), e6.match_length >= F) if (r5 = a2._tr_tally(e6, e6.strstart - e6.match_start, e6.match_length - F), e6.lookahead -= e6.match_length, e6.match_length <= e6.max_lazy_match && e6.lookahead >= F) {
            e6.match_length--;
            do {
              e6.strstart++, e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + F - 1]) & e6.hash_mask, i3 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart;
            } while (0 != --e6.match_length);
            e6.strstart++;
          } else e6.strstart += e6.match_length, e6.match_length = 0, e6.ins_h = e6.window[e6.strstart], e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + 1]) & e6.hash_mask;
          else r5 = a2._tr_tally(e6, 0, e6.window[e6.strstart]), e6.lookahead--, e6.strstart++;
          if (r5 && (te(e6, false), 0 === e6.strm.avail_out)) return Q;
        }
        return e6.insert = e6.strstart < F - 1 ? e6.strstart : F - 1, t4 === f2 ? (te(e6, true), 0 === e6.strm.avail_out ? q : V) : e6.last_lit && (te(e6, false), 0 === e6.strm.avail_out) ? Q : W;
      }
      __name(le, "le");
      function ue(e6, t4) {
        for (var i3, r5, n4; ; ) {
          if (e6.lookahead < O2) {
            if (oe(e6), e6.lookahead < O2 && t4 === u2) return Q;
            if (0 === e6.lookahead) break;
          }
          if (i3 = 0, e6.lookahead >= F && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + F - 1]) & e6.hash_mask, i3 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart), e6.prev_length = e6.match_length, e6.prev_match = e6.match_start, e6.match_length = F - 1, 0 !== i3 && e6.prev_length < e6.max_lazy_match && e6.strstart - i3 <= e6.w_size - O2 && (e6.match_length = ae(e6, i3), e6.match_length <= 5 && (e6.strategy === w || e6.match_length === F && e6.strstart - e6.match_start > 4096) && (e6.match_length = F - 1)), e6.prev_length >= F && e6.match_length <= e6.prev_length) {
            n4 = e6.strstart + e6.lookahead - F, r5 = a2._tr_tally(e6, e6.strstart - 1 - e6.prev_match, e6.prev_length - F), e6.lookahead -= e6.prev_length - 1, e6.prev_length -= 2;
            do {
              ++e6.strstart <= n4 && (e6.ins_h = (e6.ins_h << e6.hash_shift ^ e6.window[e6.strstart + F - 1]) & e6.hash_mask, i3 = e6.prev[e6.strstart & e6.w_mask] = e6.head[e6.ins_h], e6.head[e6.ins_h] = e6.strstart);
            } while (0 != --e6.prev_length);
            if (e6.match_available = 0, e6.match_length = F - 1, e6.strstart++, r5 && (te(e6, false), 0 === e6.strm.avail_out)) return Q;
          } else if (e6.match_available) {
            if ((r5 = a2._tr_tally(e6, 0, e6.window[e6.strstart - 1])) && te(e6, false), e6.strstart++, e6.lookahead--, 0 === e6.strm.avail_out) return Q;
          } else e6.match_available = 1, e6.strstart++, e6.lookahead--;
        }
        return e6.match_available && (r5 = a2._tr_tally(e6, 0, e6.window[e6.strstart - 1]), e6.match_available = 0), e6.insert = e6.strstart < F - 1 ? e6.strstart : F - 1, t4 === f2 ? (te(e6, true), 0 === e6.strm.avail_out ? q : V) : e6.last_lit && (te(e6, false), 0 === e6.strm.avail_out) ? Q : W;
      }
      __name(ue, "ue");
      function he(e6, t4) {
        for (var i3, r5, n4, o4, s5 = e6.window; ; ) {
          if (e6.lookahead <= N2) {
            if (oe(e6), e6.lookahead <= N2 && t4 === u2) return Q;
            if (0 === e6.lookahead) break;
          }
          if (e6.match_length = 0, e6.lookahead >= F && e6.strstart > 0 && (r5 = s5[n4 = e6.strstart - 1]) === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4]) {
            o4 = e6.strstart + N2;
            do {
            } while (r5 === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4] && r5 === s5[++n4] && n4 < o4);
            e6.match_length = N2 - (o4 - n4), e6.match_length > e6.lookahead && (e6.match_length = e6.lookahead);
          }
          if (e6.match_length >= F ? (i3 = a2._tr_tally(e6, 1, e6.match_length - F), e6.lookahead -= e6.match_length, e6.strstart += e6.match_length, e6.match_length = 0) : (i3 = a2._tr_tally(e6, 0, e6.window[e6.strstart]), e6.lookahead--, e6.strstart++), i3 && (te(e6, false), 0 === e6.strm.avail_out)) return Q;
        }
        return e6.insert = 0, t4 === f2 ? (te(e6, true), 0 === e6.strm.avail_out ? q : V) : e6.last_lit && (te(e6, false), 0 === e6.strm.avail_out) ? Q : W;
      }
      __name(he, "he");
      function ce(e6, t4) {
        for (var i3; ; ) {
          if (0 === e6.lookahead && (oe(e6), 0 === e6.lookahead)) {
            if (t4 === u2) return Q;
            break;
          }
          if (e6.match_length = 0, i3 = a2._tr_tally(e6, 0, e6.window[e6.strstart]), e6.lookahead--, e6.strstart++, i3 && (te(e6, false), 0 === e6.strm.avail_out)) return Q;
        }
        return e6.insert = 0, t4 === f2 ? (te(e6, true), 0 === e6.strm.avail_out ? q : V) : e6.last_lit && (te(e6, false), 0 === e6.strm.avail_out) ? Q : W;
      }
      __name(ce, "ce");
      function fe(e6, t4, i3, r5, n4) {
        this.good_length = e6, this.max_lazy = t4, this.nice_length = i3, this.max_chain = r5, this.func = n4;
      }
      __name(fe, "fe");
      function de(e6) {
        e6.window_size = 2 * e6.w_size, X(e6.head), e6.max_lazy_match = r4[e6.level].max_lazy, e6.good_match = r4[e6.level].good_length, e6.nice_match = r4[e6.level].nice_length, e6.max_chain_length = r4[e6.level].max_chain, e6.strstart = 0, e6.block_start = 0, e6.lookahead = 0, e6.insert = 0, e6.match_length = e6.prev_length = F - 1, e6.match_available = 0, e6.ins_h = 0;
      }
      __name(de, "de");
      function pe() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = A2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new n3.Buf16(2 * R2), this.dyn_dtree = new n3.Buf16(2 * (2 * B2 + 1)), this.bl_tree = new n3.Buf16(2 * (2 * C2 + 1)), X(this.dyn_ltree), X(this.dyn_dtree), X(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new n3.Buf16(z2 + 1), this.heap = new n3.Buf16(2 * P + 1), X(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new n3.Buf16(2 * P + 1), X(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      __name(pe, "pe");
      function me(e6) {
        var t4;
        return e6 && e6.state ? (e6.total_in = e6.total_out = 0, e6.data_type = S2, (t4 = e6.state).pending = 0, t4.pending_out = 0, t4.wrap < 0 && (t4.wrap = -t4.wrap), t4.status = t4.wrap ? $ : G, e6.adler = 2 === t4.wrap ? 0 : 1, t4.last_flush = u2, a2._tr_init(t4), p2) : K(e6, _2);
      }
      __name(me, "me");
      function _e(e6) {
        var t4 = me(e6);
        return t4 === p2 && de(e6.state), t4;
      }
      __name(_e, "_e");
      function ge(e6, t4) {
        return e6 && e6.state ? 2 !== e6.state.wrap ? _2 : (e6.state.gzhead = t4, p2) : _2;
      }
      __name(ge, "ge");
      function be(e6, t4, i3, r5, a3, o4) {
        if (!e6) return _2;
        var s5 = 1;
        if (t4 === y2 && (t4 = 6), r5 < 0 ? (s5 = 0, r5 = -r5) : r5 > 15 && (s5 = 2, r5 -= 16), a3 < 1 || a3 > I || i3 !== A2 || r5 < 8 || r5 > 15 || t4 < 0 || t4 > 9 || o4 < 0 || o4 > E2) return K(e6, _2);
        8 === r5 && (r5 = 9);
        var l3 = new pe();
        return e6.state = l3, l3.strm = e6, l3.wrap = s5, l3.gzhead = null, l3.w_bits = r5, l3.w_size = 1 << l3.w_bits, l3.w_mask = l3.w_size - 1, l3.hash_bits = a3 + 7, l3.hash_size = 1 << l3.hash_bits, l3.hash_mask = l3.hash_size - 1, l3.hash_shift = ~~((l3.hash_bits + F - 1) / F), l3.window = new n3.Buf8(2 * l3.w_size), l3.head = new n3.Buf16(l3.hash_size), l3.prev = new n3.Buf16(l3.w_size), l3.lit_bufsize = 1 << a3 + 6, l3.pending_buf_size = 4 * l3.lit_bufsize, l3.pending_buf = new n3.Buf8(l3.pending_buf_size), l3.d_buf = 1 * l3.lit_bufsize, l3.l_buf = 3 * l3.lit_bufsize, l3.level = t4, l3.strategy = o4, l3.method = i3, _e(e6);
      }
      __name(be, "be");
      function ye(e6, t4) {
        return be(e6, t4, A2, M2, T2, k2);
      }
      __name(ye, "ye");
      function we(e6, t4) {
        var i3, n4, o4, l3;
        if (!e6 || !e6.state || t4 > d || t4 < 0) return e6 ? K(e6, _2) : _2;
        if (n4 = e6.state, !e6.output || !e6.input && 0 !== e6.avail_in || n4.status === H && t4 !== f2) return K(e6, 0 === e6.avail_out ? b2 : _2);
        if (n4.strm = e6, i3 = n4.last_flush, n4.last_flush = t4, n4.status === $) if (2 === n4.wrap) e6.adler = 0, ie(n4, 31), ie(n4, 139), ie(n4, 8), n4.gzhead ? (ie(n4, (n4.gzhead.text ? 1 : 0) + (n4.gzhead.hcrc ? 2 : 0) + (n4.gzhead.extra ? 4 : 0) + (n4.gzhead.name ? 8 : 0) + (n4.gzhead.comment ? 16 : 0)), ie(n4, 255 & n4.gzhead.time), ie(n4, n4.gzhead.time >> 8 & 255), ie(n4, n4.gzhead.time >> 16 & 255), ie(n4, n4.gzhead.time >> 24 & 255), ie(n4, 9 === n4.level ? 2 : n4.strategy >= v2 || n4.level < 2 ? 4 : 0), ie(n4, 255 & n4.gzhead.os), n4.gzhead.extra && n4.gzhead.extra.length && (ie(n4, 255 & n4.gzhead.extra.length), ie(n4, n4.gzhead.extra.length >> 8 & 255)), n4.gzhead.hcrc && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending, 0)), n4.gzindex = 0, n4.status = L2) : (ie(n4, 0), ie(n4, 0), ie(n4, 0), ie(n4, 0), ie(n4, 0), ie(n4, 9 === n4.level ? 2 : n4.strategy >= v2 || n4.level < 2 ? 4 : 0), ie(n4, Y2), n4.status = G);
        else {
          var g2 = A2 + (n4.w_bits - 8 << 4) << 8;
          g2 |= (n4.strategy >= v2 || n4.level < 2 ? 0 : n4.level < 6 ? 1 : 6 === n4.level ? 2 : 3) << 6, 0 !== n4.strstart && (g2 |= D), g2 += 31 - g2 % 31, n4.status = G, re(n4, g2), 0 !== n4.strstart && (re(n4, e6.adler >>> 16), re(n4, 65535 & e6.adler)), e6.adler = 1;
        }
        if (n4.status === L2) if (n4.gzhead.extra) {
          for (o4 = n4.pending; n4.gzindex < (65535 & n4.gzhead.extra.length) && (n4.pending !== n4.pending_buf_size || (n4.gzhead.hcrc && n4.pending > o4 && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending - o4, o4)), ee(e6), o4 = n4.pending, n4.pending !== n4.pending_buf_size)); ) ie(n4, 255 & n4.gzhead.extra[n4.gzindex]), n4.gzindex++;
          n4.gzhead.hcrc && n4.pending > o4 && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending - o4, o4)), n4.gzindex === n4.gzhead.extra.length && (n4.gzindex = 0, n4.status = U);
        } else n4.status = U;
        if (n4.status === U) if (n4.gzhead.name) {
          o4 = n4.pending;
          do {
            if (n4.pending === n4.pending_buf_size && (n4.gzhead.hcrc && n4.pending > o4 && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending - o4, o4)), ee(e6), o4 = n4.pending, n4.pending === n4.pending_buf_size)) {
              l3 = 1;
              break;
            }
            l3 = n4.gzindex < n4.gzhead.name.length ? 255 & n4.gzhead.name.charCodeAt(n4.gzindex++) : 0, ie(n4, l3);
          } while (0 !== l3);
          n4.gzhead.hcrc && n4.pending > o4 && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending - o4, o4)), 0 === l3 && (n4.gzindex = 0, n4.status = Z);
        } else n4.status = Z;
        if (n4.status === Z) if (n4.gzhead.comment) {
          o4 = n4.pending;
          do {
            if (n4.pending === n4.pending_buf_size && (n4.gzhead.hcrc && n4.pending > o4 && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending - o4, o4)), ee(e6), o4 = n4.pending, n4.pending === n4.pending_buf_size)) {
              l3 = 1;
              break;
            }
            l3 = n4.gzindex < n4.gzhead.comment.length ? 255 & n4.gzhead.comment.charCodeAt(n4.gzindex++) : 0, ie(n4, l3);
          } while (0 !== l3);
          n4.gzhead.hcrc && n4.pending > o4 && (e6.adler = s4(e6.adler, n4.pending_buf, n4.pending - o4, o4)), 0 === l3 && (n4.status = j);
        } else n4.status = j;
        if (n4.status === j && (n4.gzhead.hcrc ? (n4.pending + 2 > n4.pending_buf_size && ee(e6), n4.pending + 2 <= n4.pending_buf_size && (ie(n4, 255 & e6.adler), ie(n4, e6.adler >> 8 & 255), e6.adler = 0, n4.status = G)) : n4.status = G), 0 !== n4.pending) {
          if (ee(e6), 0 === e6.avail_out) return n4.last_flush = -1, p2;
        } else if (0 === e6.avail_in && J(t4) <= J(i3) && t4 !== f2) return K(e6, b2);
        if (n4.status === H && 0 !== e6.avail_in) return K(e6, b2);
        if (0 !== e6.avail_in || 0 !== n4.lookahead || t4 !== u2 && n4.status !== H) {
          var y3 = n4.strategy === v2 ? ce(n4, t4) : n4.strategy === x2 ? he(n4, t4) : r4[n4.level].func(n4, t4);
          if (y3 !== q && y3 !== V || (n4.status = H), y3 === Q || y3 === q) return 0 === e6.avail_out && (n4.last_flush = -1), p2;
          if (y3 === W && (t4 === h2 ? a2._tr_align(n4) : t4 !== d && (a2._tr_stored_block(n4, 0, 0, false), t4 === c3 && (X(n4.head), 0 === n4.lookahead && (n4.strstart = 0, n4.block_start = 0, n4.insert = 0))), ee(e6), 0 === e6.avail_out)) return n4.last_flush = -1, p2;
        }
        return t4 !== f2 ? p2 : n4.wrap <= 0 ? m : (2 === n4.wrap ? (ie(n4, 255 & e6.adler), ie(n4, e6.adler >> 8 & 255), ie(n4, e6.adler >> 16 & 255), ie(n4, e6.adler >> 24 & 255), ie(n4, 255 & e6.total_in), ie(n4, e6.total_in >> 8 & 255), ie(n4, e6.total_in >> 16 & 255), ie(n4, e6.total_in >> 24 & 255)) : (re(n4, e6.adler >>> 16), re(n4, 65535 & e6.adler)), ee(e6), n4.wrap > 0 && (n4.wrap = -n4.wrap), 0 !== n4.pending ? p2 : m);
      }
      __name(we, "we");
      function ve(e6) {
        var t4;
        return e6 && e6.state ? (t4 = e6.state.status) !== $ && t4 !== L2 && t4 !== U && t4 !== Z && t4 !== j && t4 !== G && t4 !== H ? K(e6, _2) : (e6.state = null, t4 === G ? K(e6, g) : p2) : _2;
      }
      __name(ve, "ve");
      function xe(e6, t4) {
        var i3, r5, a3, s5, l3, u3, h3, c4, f3 = t4.length;
        if (!e6 || !e6.state) return _2;
        if (2 === (s5 = (i3 = e6.state).wrap) || 1 === s5 && i3.status !== $ || i3.lookahead) return _2;
        for (1 === s5 && (e6.adler = o3(e6.adler, t4, f3, 0)), i3.wrap = 0, f3 >= i3.w_size && (0 === s5 && (X(i3.head), i3.strstart = 0, i3.block_start = 0, i3.insert = 0), c4 = new n3.Buf8(i3.w_size), n3.arraySet(c4, t4, f3 - i3.w_size, i3.w_size, 0), t4 = c4, f3 = i3.w_size), l3 = e6.avail_in, u3 = e6.next_in, h3 = e6.input, e6.avail_in = f3, e6.next_in = 0, e6.input = t4, oe(i3); i3.lookahead >= F; ) {
          r5 = i3.strstart, a3 = i3.lookahead - (F - 1);
          do {
            i3.ins_h = (i3.ins_h << i3.hash_shift ^ i3.window[r5 + F - 1]) & i3.hash_mask, i3.prev[r5 & i3.w_mask] = i3.head[i3.ins_h], i3.head[i3.ins_h] = r5, r5++;
          } while (--a3);
          i3.strstart = r5, i3.lookahead = F - 1, oe(i3);
        }
        return i3.strstart += i3.lookahead, i3.block_start = i3.strstart, i3.insert = i3.lookahead, i3.lookahead = 0, i3.match_length = i3.prev_length = F - 1, i3.match_available = 0, e6.next_in = u3, e6.input = h3, e6.avail_in = l3, i3.wrap = s5, p2;
      }
      __name(xe, "xe");
      r4 = [new fe(0, 0, 0, 0, se), new fe(4, 4, 8, 4, le), new fe(4, 5, 16, 8, le), new fe(4, 6, 32, 32, le), new fe(4, 4, 16, 16, ue), new fe(8, 16, 32, 32, ue), new fe(8, 16, 128, 128, ue), new fe(8, 32, 128, 256, ue), new fe(32, 128, 258, 1024, ue), new fe(32, 258, 258, 4096, ue)], i2.deflateInit = ye, i2.deflateInit2 = be, i2.deflateReset = _e, i2.deflateResetKeep = me, i2.deflateSetHeader = ge, i2.deflate = we, i2.deflateEnd = ve, i2.deflateSetDictionary = xe, i2.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./messages": 60, "./trees": 61 }], 57: [function(e5, t3, i2) {
      var r4 = 30, n3 = 12;
      t3.exports = function(e6, t4) {
        var i3, a2, o3, s4, l2, u2, h2, c3, f2, d, p2, m, _2, g, b2, y2, w, v2, x2, E2, k2, S2, A2, I, M2;
        i3 = e6.state, a2 = e6.next_in, I = e6.input, o3 = a2 + (e6.avail_in - 5), s4 = e6.next_out, M2 = e6.output, l2 = s4 - (t4 - e6.avail_out), u2 = s4 + (e6.avail_out - 257), h2 = i3.dmax, c3 = i3.wsize, f2 = i3.whave, d = i3.wnext, p2 = i3.window, m = i3.hold, _2 = i3.bits, g = i3.lencode, b2 = i3.distcode, y2 = (1 << i3.lenbits) - 1, w = (1 << i3.distbits) - 1;
        e: do {
          _2 < 15 && (m += I[a2++] << _2, _2 += 8, m += I[a2++] << _2, _2 += 8), v2 = g[m & y2];
          t: for (; ; ) {
            if (m >>>= x2 = v2 >>> 24, _2 -= x2, 0 == (x2 = v2 >>> 16 & 255)) M2[s4++] = 65535 & v2;
            else {
              if (!(16 & x2)) {
                if (64 & x2) {
                  if (32 & x2) {
                    i3.mode = n3;
                    break e;
                  }
                  e6.msg = "invalid literal/length code", i3.mode = r4;
                  break e;
                }
                v2 = g[(65535 & v2) + (m & (1 << x2) - 1)];
                continue t;
              }
              for (E2 = 65535 & v2, (x2 &= 15) && (_2 < x2 && (m += I[a2++] << _2, _2 += 8), E2 += m & (1 << x2) - 1, m >>>= x2, _2 -= x2), _2 < 15 && (m += I[a2++] << _2, _2 += 8, m += I[a2++] << _2, _2 += 8), v2 = b2[m & w]; ; ) {
                if (m >>>= x2 = v2 >>> 24, _2 -= x2, 16 & (x2 = v2 >>> 16 & 255)) {
                  if (k2 = 65535 & v2, _2 < (x2 &= 15) && (m += I[a2++] << _2, (_2 += 8) < x2 && (m += I[a2++] << _2, _2 += 8)), (k2 += m & (1 << x2) - 1) > h2) {
                    e6.msg = "invalid distance too far back", i3.mode = r4;
                    break e;
                  }
                  if (m >>>= x2, _2 -= x2, k2 > (x2 = s4 - l2)) {
                    if ((x2 = k2 - x2) > f2 && i3.sane) {
                      e6.msg = "invalid distance too far back", i3.mode = r4;
                      break e;
                    }
                    if (S2 = 0, A2 = p2, 0 === d) {
                      if (S2 += c3 - x2, x2 < E2) {
                        E2 -= x2;
                        do {
                          M2[s4++] = p2[S2++];
                        } while (--x2);
                        S2 = s4 - k2, A2 = M2;
                      }
                    } else if (d < x2) {
                      if (S2 += c3 + d - x2, (x2 -= d) < E2) {
                        E2 -= x2;
                        do {
                          M2[s4++] = p2[S2++];
                        } while (--x2);
                        if (S2 = 0, d < E2) {
                          E2 -= x2 = d;
                          do {
                            M2[s4++] = p2[S2++];
                          } while (--x2);
                          S2 = s4 - k2, A2 = M2;
                        }
                      }
                    } else if (S2 += d - x2, x2 < E2) {
                      E2 -= x2;
                      do {
                        M2[s4++] = p2[S2++];
                      } while (--x2);
                      S2 = s4 - k2, A2 = M2;
                    }
                    for (; E2 > 2; ) M2[s4++] = A2[S2++], M2[s4++] = A2[S2++], M2[s4++] = A2[S2++], E2 -= 3;
                    E2 && (M2[s4++] = A2[S2++], E2 > 1 && (M2[s4++] = A2[S2++]));
                  } else {
                    S2 = s4 - k2;
                    do {
                      M2[s4++] = M2[S2++], M2[s4++] = M2[S2++], M2[s4++] = M2[S2++], E2 -= 3;
                    } while (E2 > 2);
                    E2 && (M2[s4++] = M2[S2++], E2 > 1 && (M2[s4++] = M2[S2++]));
                  }
                  break;
                }
                if (64 & x2) {
                  e6.msg = "invalid distance code", i3.mode = r4;
                  break e;
                }
                v2 = b2[(65535 & v2) + (m & (1 << x2) - 1)];
              }
            }
            break;
          }
        } while (a2 < o3 && s4 < u2);
        a2 -= E2 = _2 >> 3, m &= (1 << (_2 -= E2 << 3)) - 1, e6.next_in = a2, e6.next_out = s4, e6.avail_in = a2 < o3 ? o3 - a2 + 5 : 5 - (a2 - o3), e6.avail_out = s4 < u2 ? u2 - s4 + 257 : 257 - (s4 - u2), i3.hold = m, i3.bits = _2;
      };
    }, {}], 58: [function(e5, t3, i2) {
      var r4 = e5("../utils/common"), n3 = e5("./adler32"), a2 = e5("./crc32"), o3 = e5("./inffast"), s4 = e5("./inftrees"), l2 = 0, u2 = 1, h2 = 2, c3 = 4, f2 = 5, d = 6, p2 = 0, m = 1, _2 = 2, g = -2, b2 = -3, y2 = -4, w = -5, v2 = 8, x2 = 1, E2 = 2, k2 = 3, S2 = 4, A2 = 5, I = 6, M2 = 7, T2 = 8, P = 9, B2 = 10, C2 = 11, R2 = 12, z2 = 13, F = 14, N2 = 15, O2 = 16, D = 17, $ = 18, L2 = 19, U = 20, Z = 21, j = 22, G = 23, H = 24, Q = 25, W = 26, q = 27, V = 28, Y2 = 29, K = 30, J = 31, X = 852, ee = 592, te = 15;
      function ie(e6) {
        return (e6 >>> 24 & 255) + (e6 >>> 8 & 65280) + ((65280 & e6) << 8) + ((255 & e6) << 24);
      }
      __name(ie, "ie");
      function re() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r4.Buf16(320), this.work = new r4.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      __name(re, "re");
      function ne(e6) {
        var t4;
        return e6 && e6.state ? (t4 = e6.state, e6.total_in = e6.total_out = t4.total = 0, e6.msg = "", t4.wrap && (e6.adler = 1 & t4.wrap), t4.mode = x2, t4.last = 0, t4.havedict = 0, t4.dmax = 32768, t4.head = null, t4.hold = 0, t4.bits = 0, t4.lencode = t4.lendyn = new r4.Buf32(X), t4.distcode = t4.distdyn = new r4.Buf32(ee), t4.sane = 1, t4.back = -1, p2) : g;
      }
      __name(ne, "ne");
      function ae(e6) {
        var t4;
        return e6 && e6.state ? ((t4 = e6.state).wsize = 0, t4.whave = 0, t4.wnext = 0, ne(e6)) : g;
      }
      __name(ae, "ae");
      function oe(e6, t4) {
        var i3, r5;
        return e6 && e6.state ? (r5 = e6.state, t4 < 0 ? (i3 = 0, t4 = -t4) : (i3 = 1 + (t4 >> 4), t4 < 48 && (t4 &= 15)), t4 && (t4 < 8 || t4 > 15) ? g : (null !== r5.window && r5.wbits !== t4 && (r5.window = null), r5.wrap = i3, r5.wbits = t4, ae(e6))) : g;
      }
      __name(oe, "oe");
      function se(e6, t4) {
        var i3, r5;
        return e6 ? (r5 = new re(), e6.state = r5, r5.window = null, (i3 = oe(e6, t4)) !== p2 && (e6.state = null), i3) : g;
      }
      __name(se, "se");
      function le(e6) {
        return se(e6, te);
      }
      __name(le, "le");
      var ue, he, ce = true;
      function fe(e6) {
        if (ce) {
          var t4;
          for (ue = new r4.Buf32(512), he = new r4.Buf32(32), t4 = 0; t4 < 144; ) e6.lens[t4++] = 8;
          for (; t4 < 256; ) e6.lens[t4++] = 9;
          for (; t4 < 280; ) e6.lens[t4++] = 7;
          for (; t4 < 288; ) e6.lens[t4++] = 8;
          for (s4(u2, e6.lens, 0, 288, ue, 0, e6.work, { bits: 9 }), t4 = 0; t4 < 32; ) e6.lens[t4++] = 5;
          s4(h2, e6.lens, 0, 32, he, 0, e6.work, { bits: 5 }), ce = false;
        }
        e6.lencode = ue, e6.lenbits = 9, e6.distcode = he, e6.distbits = 5;
      }
      __name(fe, "fe");
      function de(e6, t4, i3, n4) {
        var a3, o4 = e6.state;
        return null === o4.window && (o4.wsize = 1 << o4.wbits, o4.wnext = 0, o4.whave = 0, o4.window = new r4.Buf8(o4.wsize)), n4 >= o4.wsize ? (r4.arraySet(o4.window, t4, i3 - o4.wsize, o4.wsize, 0), o4.wnext = 0, o4.whave = o4.wsize) : ((a3 = o4.wsize - o4.wnext) > n4 && (a3 = n4), r4.arraySet(o4.window, t4, i3 - n4, a3, o4.wnext), (n4 -= a3) ? (r4.arraySet(o4.window, t4, i3 - n4, n4, 0), o4.wnext = n4, o4.whave = o4.wsize) : (o4.wnext += a3, o4.wnext === o4.wsize && (o4.wnext = 0), o4.whave < o4.wsize && (o4.whave += a3))), 0;
      }
      __name(de, "de");
      function pe(e6, t4) {
        var i3, X2, ee2, te2, re2, ne2, ae2, oe2, se2, le2, ue2, he2, ce2, pe2, me2, _e2, ge2, be, ye, we, ve, xe, Ee, ke, Se = 0, Ae = new r4.Buf8(4), Ie = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e6 || !e6.state || !e6.output || !e6.input && 0 !== e6.avail_in) return g;
        (i3 = e6.state).mode === R2 && (i3.mode = z2), re2 = e6.next_out, ee2 = e6.output, ae2 = e6.avail_out, te2 = e6.next_in, X2 = e6.input, ne2 = e6.avail_in, oe2 = i3.hold, se2 = i3.bits, le2 = ne2, ue2 = ae2, xe = p2;
        e: for (; ; ) switch (i3.mode) {
          case x2:
            if (0 === i3.wrap) {
              i3.mode = z2;
              break;
            }
            for (; se2 < 16; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (2 & i3.wrap && 35615 === oe2) {
              i3.check = 0, Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0), oe2 = 0, se2 = 0, i3.mode = E2;
              break;
            }
            if (i3.flags = 0, i3.head && (i3.head.done = false), !(1 & i3.wrap) || (((255 & oe2) << 8) + (oe2 >> 8)) % 31) {
              e6.msg = "incorrect header check", i3.mode = K;
              break;
            }
            if ((15 & oe2) !== v2) {
              e6.msg = "unknown compression method", i3.mode = K;
              break;
            }
            if (se2 -= 4, ve = 8 + (15 & (oe2 >>>= 4)), 0 === i3.wbits) i3.wbits = ve;
            else if (ve > i3.wbits) {
              e6.msg = "invalid window size", i3.mode = K;
              break;
            }
            i3.dmax = 1 << ve, e6.adler = i3.check = 1, i3.mode = 512 & oe2 ? B2 : R2, oe2 = 0, se2 = 0;
            break;
          case E2:
            for (; se2 < 16; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (i3.flags = oe2, (255 & i3.flags) !== v2) {
              e6.msg = "unknown compression method", i3.mode = K;
              break;
            }
            if (57344 & i3.flags) {
              e6.msg = "unknown header flags set", i3.mode = K;
              break;
            }
            i3.head && (i3.head.text = oe2 >> 8 & 1), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0)), oe2 = 0, se2 = 0, i3.mode = k2;
          case k2:
            for (; se2 < 32; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            i3.head && (i3.head.time = oe2), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, Ae[2] = oe2 >>> 16 & 255, Ae[3] = oe2 >>> 24 & 255, i3.check = a2(i3.check, Ae, 4, 0)), oe2 = 0, se2 = 0, i3.mode = S2;
          case S2:
            for (; se2 < 16; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            i3.head && (i3.head.xflags = 255 & oe2, i3.head.os = oe2 >> 8), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0)), oe2 = 0, se2 = 0, i3.mode = A2;
          case A2:
            if (1024 & i3.flags) {
              for (; se2 < 16; ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.length = oe2, i3.head && (i3.head.extra_len = oe2), 512 & i3.flags && (Ae[0] = 255 & oe2, Ae[1] = oe2 >>> 8 & 255, i3.check = a2(i3.check, Ae, 2, 0)), oe2 = 0, se2 = 0;
            } else i3.head && (i3.head.extra = null);
            i3.mode = I;
          case I:
            if (1024 & i3.flags && ((he2 = i3.length) > ne2 && (he2 = ne2), he2 && (i3.head && (ve = i3.head.extra_len - i3.length, i3.head.extra || (i3.head.extra = new Array(i3.head.extra_len)), r4.arraySet(i3.head.extra, X2, te2, he2, ve)), 512 & i3.flags && (i3.check = a2(i3.check, X2, he2, te2)), ne2 -= he2, te2 += he2, i3.length -= he2), i3.length)) break e;
            i3.length = 0, i3.mode = M2;
          case M2:
            if (2048 & i3.flags) {
              if (0 === ne2) break e;
              he2 = 0;
              do {
                ve = X2[te2 + he2++], i3.head && ve && i3.length < 65536 && (i3.head.name += String.fromCharCode(ve));
              } while (ve && he2 < ne2);
              if (512 & i3.flags && (i3.check = a2(i3.check, X2, he2, te2)), ne2 -= he2, te2 += he2, ve) break e;
            } else i3.head && (i3.head.name = null);
            i3.length = 0, i3.mode = T2;
          case T2:
            if (4096 & i3.flags) {
              if (0 === ne2) break e;
              he2 = 0;
              do {
                ve = X2[te2 + he2++], i3.head && ve && i3.length < 65536 && (i3.head.comment += String.fromCharCode(ve));
              } while (ve && he2 < ne2);
              if (512 & i3.flags && (i3.check = a2(i3.check, X2, he2, te2)), ne2 -= he2, te2 += he2, ve) break e;
            } else i3.head && (i3.head.comment = null);
            i3.mode = P;
          case P:
            if (512 & i3.flags) {
              for (; se2 < 16; ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (oe2 !== (65535 & i3.check)) {
                e6.msg = "header crc mismatch", i3.mode = K;
                break;
              }
              oe2 = 0, se2 = 0;
            }
            i3.head && (i3.head.hcrc = i3.flags >> 9 & 1, i3.head.done = true), e6.adler = i3.check = 0, i3.mode = R2;
            break;
          case B2:
            for (; se2 < 32; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            e6.adler = i3.check = ie(oe2), oe2 = 0, se2 = 0, i3.mode = C2;
          case C2:
            if (0 === i3.havedict) return e6.next_out = re2, e6.avail_out = ae2, e6.next_in = te2, e6.avail_in = ne2, i3.hold = oe2, i3.bits = se2, _2;
            e6.adler = i3.check = 1, i3.mode = R2;
          case R2:
            if (t4 === f2 || t4 === d) break e;
          case z2:
            if (i3.last) {
              oe2 >>>= 7 & se2, se2 -= 7 & se2, i3.mode = q;
              break;
            }
            for (; se2 < 3; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            switch (i3.last = 1 & oe2, se2 -= 1, 3 & (oe2 >>>= 1)) {
              case 0:
                i3.mode = F;
                break;
              case 1:
                if (fe(i3), i3.mode = U, t4 === d) {
                  oe2 >>>= 2, se2 -= 2;
                  break e;
                }
                break;
              case 2:
                i3.mode = D;
                break;
              case 3:
                e6.msg = "invalid block type", i3.mode = K;
            }
            oe2 >>>= 2, se2 -= 2;
            break;
          case F:
            for (oe2 >>>= 7 & se2, se2 -= 7 & se2; se2 < 32; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if ((65535 & oe2) != (oe2 >>> 16 ^ 65535)) {
              e6.msg = "invalid stored block lengths", i3.mode = K;
              break;
            }
            if (i3.length = 65535 & oe2, oe2 = 0, se2 = 0, i3.mode = N2, t4 === d) break e;
          case N2:
            i3.mode = O2;
          case O2:
            if (he2 = i3.length) {
              if (he2 > ne2 && (he2 = ne2), he2 > ae2 && (he2 = ae2), 0 === he2) break e;
              r4.arraySet(ee2, X2, te2, he2, re2), ne2 -= he2, te2 += he2, ae2 -= he2, re2 += he2, i3.length -= he2;
              break;
            }
            i3.mode = R2;
            break;
          case D:
            for (; se2 < 14; ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (i3.nlen = 257 + (31 & oe2), oe2 >>>= 5, se2 -= 5, i3.ndist = 1 + (31 & oe2), oe2 >>>= 5, se2 -= 5, i3.ncode = 4 + (15 & oe2), oe2 >>>= 4, se2 -= 4, i3.nlen > 286 || i3.ndist > 30) {
              e6.msg = "too many length or distance symbols", i3.mode = K;
              break;
            }
            i3.have = 0, i3.mode = $;
          case $:
            for (; i3.have < i3.ncode; ) {
              for (; se2 < 3; ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.lens[Ie[i3.have++]] = 7 & oe2, oe2 >>>= 3, se2 -= 3;
            }
            for (; i3.have < 19; ) i3.lens[Ie[i3.have++]] = 0;
            if (i3.lencode = i3.lendyn, i3.lenbits = 7, Ee = { bits: i3.lenbits }, xe = s4(l2, i3.lens, 0, 19, i3.lencode, 0, i3.work, Ee), i3.lenbits = Ee.bits, xe) {
              e6.msg = "invalid code lengths set", i3.mode = K;
              break;
            }
            i3.have = 0, i3.mode = L2;
          case L2:
            for (; i3.have < i3.nlen + i3.ndist; ) {
              for (; _e2 = (Se = i3.lencode[oe2 & (1 << i3.lenbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (ge2 < 16) oe2 >>>= me2, se2 -= me2, i3.lens[i3.have++] = ge2;
              else {
                if (16 === ge2) {
                  for (ke = me2 + 2; se2 < ke; ) {
                    if (0 === ne2) break e;
                    ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                  }
                  if (oe2 >>>= me2, se2 -= me2, 0 === i3.have) {
                    e6.msg = "invalid bit length repeat", i3.mode = K;
                    break;
                  }
                  ve = i3.lens[i3.have - 1], he2 = 3 + (3 & oe2), oe2 >>>= 2, se2 -= 2;
                } else if (17 === ge2) {
                  for (ke = me2 + 3; se2 < ke; ) {
                    if (0 === ne2) break e;
                    ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                  }
                  se2 -= me2, ve = 0, he2 = 3 + (7 & (oe2 >>>= me2)), oe2 >>>= 3, se2 -= 3;
                } else {
                  for (ke = me2 + 7; se2 < ke; ) {
                    if (0 === ne2) break e;
                    ne2--, oe2 += X2[te2++] << se2, se2 += 8;
                  }
                  se2 -= me2, ve = 0, he2 = 11 + (127 & (oe2 >>>= me2)), oe2 >>>= 7, se2 -= 7;
                }
                if (i3.have + he2 > i3.nlen + i3.ndist) {
                  e6.msg = "invalid bit length repeat", i3.mode = K;
                  break;
                }
                for (; he2--; ) i3.lens[i3.have++] = ve;
              }
            }
            if (i3.mode === K) break;
            if (0 === i3.lens[256]) {
              e6.msg = "invalid code -- missing end-of-block", i3.mode = K;
              break;
            }
            if (i3.lenbits = 9, Ee = { bits: i3.lenbits }, xe = s4(u2, i3.lens, 0, i3.nlen, i3.lencode, 0, i3.work, Ee), i3.lenbits = Ee.bits, xe) {
              e6.msg = "invalid literal/lengths set", i3.mode = K;
              break;
            }
            if (i3.distbits = 6, i3.distcode = i3.distdyn, Ee = { bits: i3.distbits }, xe = s4(h2, i3.lens, i3.nlen, i3.ndist, i3.distcode, 0, i3.work, Ee), i3.distbits = Ee.bits, xe) {
              e6.msg = "invalid distances set", i3.mode = K;
              break;
            }
            if (i3.mode = U, t4 === d) break e;
          case U:
            i3.mode = Z;
          case Z:
            if (ne2 >= 6 && ae2 >= 258) {
              e6.next_out = re2, e6.avail_out = ae2, e6.next_in = te2, e6.avail_in = ne2, i3.hold = oe2, i3.bits = se2, o3(e6, ue2), re2 = e6.next_out, ee2 = e6.output, ae2 = e6.avail_out, te2 = e6.next_in, X2 = e6.input, ne2 = e6.avail_in, oe2 = i3.hold, se2 = i3.bits, i3.mode === R2 && (i3.back = -1);
              break;
            }
            for (i3.back = 0; _e2 = (Se = i3.lencode[oe2 & (1 << i3.lenbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (_e2 && !(240 & _e2)) {
              for (be = me2, ye = _e2, we = ge2; _e2 = (Se = i3.lencode[we + ((oe2 & (1 << be + ye) - 1) >> be)]) >>> 16 & 255, ge2 = 65535 & Se, !(be + (me2 = Se >>> 24) <= se2); ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              oe2 >>>= be, se2 -= be, i3.back += be;
            }
            if (oe2 >>>= me2, se2 -= me2, i3.back += me2, i3.length = ge2, 0 === _e2) {
              i3.mode = W;
              break;
            }
            if (32 & _e2) {
              i3.back = -1, i3.mode = R2;
              break;
            }
            if (64 & _e2) {
              e6.msg = "invalid literal/length code", i3.mode = K;
              break;
            }
            i3.extra = 15 & _e2, i3.mode = j;
          case j:
            if (i3.extra) {
              for (ke = i3.extra; se2 < ke; ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.length += oe2 & (1 << i3.extra) - 1, oe2 >>>= i3.extra, se2 -= i3.extra, i3.back += i3.extra;
            }
            i3.was = i3.length, i3.mode = G;
          case G:
            for (; _e2 = (Se = i3.distcode[oe2 & (1 << i3.distbits) - 1]) >>> 16 & 255, ge2 = 65535 & Se, !((me2 = Se >>> 24) <= se2); ) {
              if (0 === ne2) break e;
              ne2--, oe2 += X2[te2++] << se2, se2 += 8;
            }
            if (!(240 & _e2)) {
              for (be = me2, ye = _e2, we = ge2; _e2 = (Se = i3.distcode[we + ((oe2 & (1 << be + ye) - 1) >> be)]) >>> 16 & 255, ge2 = 65535 & Se, !(be + (me2 = Se >>> 24) <= se2); ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              oe2 >>>= be, se2 -= be, i3.back += be;
            }
            if (oe2 >>>= me2, se2 -= me2, i3.back += me2, 64 & _e2) {
              e6.msg = "invalid distance code", i3.mode = K;
              break;
            }
            i3.offset = ge2, i3.extra = 15 & _e2, i3.mode = H;
          case H:
            if (i3.extra) {
              for (ke = i3.extra; se2 < ke; ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              i3.offset += oe2 & (1 << i3.extra) - 1, oe2 >>>= i3.extra, se2 -= i3.extra, i3.back += i3.extra;
            }
            if (i3.offset > i3.dmax) {
              e6.msg = "invalid distance too far back", i3.mode = K;
              break;
            }
            i3.mode = Q;
          case Q:
            if (0 === ae2) break e;
            if (he2 = ue2 - ae2, i3.offset > he2) {
              if ((he2 = i3.offset - he2) > i3.whave && i3.sane) {
                e6.msg = "invalid distance too far back", i3.mode = K;
                break;
              }
              he2 > i3.wnext ? (he2 -= i3.wnext, ce2 = i3.wsize - he2) : ce2 = i3.wnext - he2, he2 > i3.length && (he2 = i3.length), pe2 = i3.window;
            } else pe2 = ee2, ce2 = re2 - i3.offset, he2 = i3.length;
            he2 > ae2 && (he2 = ae2), ae2 -= he2, i3.length -= he2;
            do {
              ee2[re2++] = pe2[ce2++];
            } while (--he2);
            0 === i3.length && (i3.mode = Z);
            break;
          case W:
            if (0 === ae2) break e;
            ee2[re2++] = i3.length, ae2--, i3.mode = Z;
            break;
          case q:
            if (i3.wrap) {
              for (; se2 < 32; ) {
                if (0 === ne2) break e;
                ne2--, oe2 |= X2[te2++] << se2, se2 += 8;
              }
              if (ue2 -= ae2, e6.total_out += ue2, i3.total += ue2, ue2 && (e6.adler = i3.check = i3.flags ? a2(i3.check, ee2, ue2, re2 - ue2) : n3(i3.check, ee2, ue2, re2 - ue2)), ue2 = ae2, (i3.flags ? oe2 : ie(oe2)) !== i3.check) {
                e6.msg = "incorrect data check", i3.mode = K;
                break;
              }
              oe2 = 0, se2 = 0;
            }
            i3.mode = V;
          case V:
            if (i3.wrap && i3.flags) {
              for (; se2 < 32; ) {
                if (0 === ne2) break e;
                ne2--, oe2 += X2[te2++] << se2, se2 += 8;
              }
              if (oe2 !== (4294967295 & i3.total)) {
                e6.msg = "incorrect length check", i3.mode = K;
                break;
              }
              oe2 = 0, se2 = 0;
            }
            i3.mode = Y2;
          case Y2:
            xe = m;
            break e;
          case K:
            xe = b2;
            break e;
          case J:
            return y2;
          default:
            return g;
        }
        return e6.next_out = re2, e6.avail_out = ae2, e6.next_in = te2, e6.avail_in = ne2, i3.hold = oe2, i3.bits = se2, (i3.wsize || ue2 !== e6.avail_out && i3.mode < K && (i3.mode < q || t4 !== c3)) && de(e6, e6.output, e6.next_out, ue2 - e6.avail_out), le2 -= e6.avail_in, ue2 -= e6.avail_out, e6.total_in += le2, e6.total_out += ue2, i3.total += ue2, i3.wrap && ue2 && (e6.adler = i3.check = i3.flags ? a2(i3.check, ee2, ue2, e6.next_out - ue2) : n3(i3.check, ee2, ue2, e6.next_out - ue2)), e6.data_type = i3.bits + (i3.last ? 64 : 0) + (i3.mode === R2 ? 128 : 0) + (i3.mode === U || i3.mode === N2 ? 256 : 0), (0 === le2 && 0 === ue2 || t4 === c3) && xe === p2 && (xe = w), xe;
      }
      __name(pe, "pe");
      function me(e6) {
        if (!e6 || !e6.state) return g;
        var t4 = e6.state;
        return t4.window && (t4.window = null), e6.state = null, p2;
      }
      __name(me, "me");
      function _e(e6, t4) {
        var i3;
        return e6 && e6.state && 2 & (i3 = e6.state).wrap ? (i3.head = t4, t4.done = false, p2) : g;
      }
      __name(_e, "_e");
      function ge(e6, t4) {
        var i3, r5 = t4.length;
        return e6 && e6.state ? 0 !== (i3 = e6.state).wrap && i3.mode !== C2 ? g : i3.mode === C2 && n3(1, t4, r5, 0) !== i3.check ? b2 : de(e6, t4, r5, r5) ? (i3.mode = J, y2) : (i3.havedict = 1, p2) : g;
      }
      __name(ge, "ge");
      i2.inflateReset = ae, i2.inflateReset2 = oe, i2.inflateResetKeep = ne, i2.inflateInit = le, i2.inflateInit2 = se, i2.inflate = pe, i2.inflateEnd = me, i2.inflateGetHeader = _e, i2.inflateSetDictionary = ge, i2.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 52, "./adler32": 53, "./crc32": 55, "./inffast": 57, "./inftrees": 59 }], 59: [function(e5, t3, i2) {
      var r4 = e5("../utils/common"), n3 = 15, a2 = 852, o3 = 592, s4 = 0, l2 = 1, u2 = 2, h2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c3 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], f2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t3.exports = function(e6, t4, i3, p2, m, _2, g, b2) {
        var y2, w, v2, x2, E2, k2, S2, A2, I, M2 = b2.bits, T2 = 0, P = 0, B2 = 0, C2 = 0, R2 = 0, z2 = 0, F = 0, N2 = 0, O2 = 0, D = 0, $ = null, L2 = 0, U = new r4.Buf16(n3 + 1), Z = new r4.Buf16(n3 + 1), j = null, G = 0;
        for (T2 = 0; T2 <= n3; T2++) U[T2] = 0;
        for (P = 0; P < p2; P++) U[t4[i3 + P]]++;
        for (R2 = M2, C2 = n3; C2 >= 1 && 0 === U[C2]; C2--) ;
        if (R2 > C2 && (R2 = C2), 0 === C2) return m[_2++] = 20971520, m[_2++] = 20971520, b2.bits = 1, 0;
        for (B2 = 1; B2 < C2 && 0 === U[B2]; B2++) ;
        for (R2 < B2 && (R2 = B2), N2 = 1, T2 = 1; T2 <= n3; T2++) if (N2 <<= 1, (N2 -= U[T2]) < 0) return -1;
        if (N2 > 0 && (e6 === s4 || 1 !== C2)) return -1;
        for (Z[1] = 0, T2 = 1; T2 < n3; T2++) Z[T2 + 1] = Z[T2] + U[T2];
        for (P = 0; P < p2; P++) 0 !== t4[i3 + P] && (g[Z[t4[i3 + P]]++] = P);
        if (e6 === s4 ? ($ = j = g, k2 = 19) : e6 === l2 ? ($ = h2, L2 -= 257, j = c3, G -= 257, k2 = 256) : ($ = f2, j = d, k2 = -1), D = 0, P = 0, T2 = B2, E2 = _2, z2 = R2, F = 0, v2 = -1, x2 = (O2 = 1 << R2) - 1, e6 === l2 && O2 > a2 || e6 === u2 && O2 > o3) return 1;
        for (; ; ) {
          S2 = T2 - F, g[P] < k2 ? (A2 = 0, I = g[P]) : g[P] > k2 ? (A2 = j[G + g[P]], I = $[L2 + g[P]]) : (A2 = 96, I = 0), y2 = 1 << T2 - F, B2 = w = 1 << z2;
          do {
            m[E2 + (D >> F) + (w -= y2)] = S2 << 24 | A2 << 16 | I;
          } while (0 !== w);
          for (y2 = 1 << T2 - 1; D & y2; ) y2 >>= 1;
          if (0 !== y2 ? (D &= y2 - 1, D += y2) : D = 0, P++, 0 == --U[T2]) {
            if (T2 === C2) break;
            T2 = t4[i3 + g[P]];
          }
          if (T2 > R2 && (D & x2) !== v2) {
            for (0 === F && (F = R2), E2 += B2, N2 = 1 << (z2 = T2 - F); z2 + F < C2 && !((N2 -= U[z2 + F]) <= 0); ) z2++, N2 <<= 1;
            if (O2 += 1 << z2, e6 === l2 && O2 > a2 || e6 === u2 && O2 > o3) return 1;
            m[v2 = D & x2] = R2 << 24 | z2 << 16 | E2 - _2;
          }
        }
        return 0 !== D && (m[E2 + D] = T2 - F << 24 | 64 << 16), b2.bits = R2, 0;
      };
    }, { "../utils/common": 52 }], 60: [function(e5, t3, i2) {
      t3.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 61: [function(e5, t3, i2) {
      var r4 = e5("../utils/common"), n3 = 4, a2 = 0, o3 = 1, s4 = 2;
      function l2(e6) {
        for (var t4 = e6.length; --t4 >= 0; ) e6[t4] = 0;
      }
      __name(l2, "l");
      var u2 = 0, h2 = 1, c3 = 2, f2 = 3, d = 258, p2 = 29, m = 256, _2 = m + 1 + p2, g = 30, b2 = 19, y2 = 2 * _2 + 1, w = 15, v2 = 16, x2 = 7, E2 = 256, k2 = 16, S2 = 17, A2 = 18, I = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], T2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], P = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], B2 = 512, C2 = new Array(2 * (_2 + 2));
      l2(C2);
      var R2 = new Array(2 * g);
      l2(R2);
      var z2 = new Array(B2);
      l2(z2);
      var F = new Array(d - f2 + 1);
      l2(F);
      var N2 = new Array(p2);
      l2(N2);
      var O2, D, $, L2 = new Array(g);
      function U(e6, t4, i3, r5, n4) {
        this.static_tree = e6, this.extra_bits = t4, this.extra_base = i3, this.elems = r5, this.max_length = n4, this.has_stree = e6 && e6.length;
      }
      __name(U, "U");
      function Z(e6, t4) {
        this.dyn_tree = e6, this.max_code = 0, this.stat_desc = t4;
      }
      __name(Z, "Z");
      function j(e6) {
        return e6 < 256 ? z2[e6] : z2[256 + (e6 >>> 7)];
      }
      __name(j, "j");
      function G(e6, t4) {
        e6.pending_buf[e6.pending++] = 255 & t4, e6.pending_buf[e6.pending++] = t4 >>> 8 & 255;
      }
      __name(G, "G");
      function H(e6, t4, i3) {
        e6.bi_valid > v2 - i3 ? (e6.bi_buf |= t4 << e6.bi_valid & 65535, G(e6, e6.bi_buf), e6.bi_buf = t4 >> v2 - e6.bi_valid, e6.bi_valid += i3 - v2) : (e6.bi_buf |= t4 << e6.bi_valid & 65535, e6.bi_valid += i3);
      }
      __name(H, "H");
      function Q(e6, t4, i3) {
        H(e6, i3[2 * t4], i3[2 * t4 + 1]);
      }
      __name(Q, "Q");
      function W(e6, t4) {
        var i3 = 0;
        do {
          i3 |= 1 & e6, e6 >>>= 1, i3 <<= 1;
        } while (--t4 > 0);
        return i3 >>> 1;
      }
      __name(W, "W");
      function q(e6) {
        16 === e6.bi_valid ? (G(e6, e6.bi_buf), e6.bi_buf = 0, e6.bi_valid = 0) : e6.bi_valid >= 8 && (e6.pending_buf[e6.pending++] = 255 & e6.bi_buf, e6.bi_buf >>= 8, e6.bi_valid -= 8);
      }
      __name(q, "q");
      function V(e6, t4) {
        var i3, r5, n4, a3, o4, s5, l3 = t4.dyn_tree, u3 = t4.max_code, h3 = t4.stat_desc.static_tree, c4 = t4.stat_desc.has_stree, f3 = t4.stat_desc.extra_bits, d2 = t4.stat_desc.extra_base, p3 = t4.stat_desc.max_length, m2 = 0;
        for (a3 = 0; a3 <= w; a3++) e6.bl_count[a3] = 0;
        for (l3[2 * e6.heap[e6.heap_max] + 1] = 0, i3 = e6.heap_max + 1; i3 < y2; i3++) (a3 = l3[2 * l3[2 * (r5 = e6.heap[i3]) + 1] + 1] + 1) > p3 && (a3 = p3, m2++), l3[2 * r5 + 1] = a3, r5 > u3 || (e6.bl_count[a3]++, o4 = 0, r5 >= d2 && (o4 = f3[r5 - d2]), s5 = l3[2 * r5], e6.opt_len += s5 * (a3 + o4), c4 && (e6.static_len += s5 * (h3[2 * r5 + 1] + o4)));
        if (0 !== m2) {
          do {
            for (a3 = p3 - 1; 0 === e6.bl_count[a3]; ) a3--;
            e6.bl_count[a3]--, e6.bl_count[a3 + 1] += 2, e6.bl_count[p3]--, m2 -= 2;
          } while (m2 > 0);
          for (a3 = p3; 0 !== a3; a3--) for (r5 = e6.bl_count[a3]; 0 !== r5; ) (n4 = e6.heap[--i3]) > u3 || (l3[2 * n4 + 1] !== a3 && (e6.opt_len += (a3 - l3[2 * n4 + 1]) * l3[2 * n4], l3[2 * n4 + 1] = a3), r5--);
        }
      }
      __name(V, "V");
      function Y2(e6, t4, i3) {
        var r5, n4, a3 = new Array(w + 1), o4 = 0;
        for (r5 = 1; r5 <= w; r5++) a3[r5] = o4 = o4 + i3[r5 - 1] << 1;
        for (n4 = 0; n4 <= t4; n4++) {
          var s5 = e6[2 * n4 + 1];
          0 !== s5 && (e6[2 * n4] = W(a3[s5]++, s5));
        }
      }
      __name(Y2, "Y");
      function K() {
        var e6, t4, i3, r5, n4, a3 = new Array(w + 1);
        for (i3 = 0, r5 = 0; r5 < p2 - 1; r5++) for (N2[r5] = i3, e6 = 0; e6 < 1 << I[r5]; e6++) F[i3++] = r5;
        for (F[i3 - 1] = r5, n4 = 0, r5 = 0; r5 < 16; r5++) for (L2[r5] = n4, e6 = 0; e6 < 1 << M2[r5]; e6++) z2[n4++] = r5;
        for (n4 >>= 7; r5 < g; r5++) for (L2[r5] = n4 << 7, e6 = 0; e6 < 1 << M2[r5] - 7; e6++) z2[256 + n4++] = r5;
        for (t4 = 0; t4 <= w; t4++) a3[t4] = 0;
        for (e6 = 0; e6 <= 143; ) C2[2 * e6 + 1] = 8, e6++, a3[8]++;
        for (; e6 <= 255; ) C2[2 * e6 + 1] = 9, e6++, a3[9]++;
        for (; e6 <= 279; ) C2[2 * e6 + 1] = 7, e6++, a3[7]++;
        for (; e6 <= 287; ) C2[2 * e6 + 1] = 8, e6++, a3[8]++;
        for (Y2(C2, _2 + 1, a3), e6 = 0; e6 < g; e6++) R2[2 * e6 + 1] = 5, R2[2 * e6] = W(e6, 5);
        O2 = new U(C2, I, m + 1, _2, w), D = new U(R2, M2, 0, g, w), $ = new U(new Array(0), T2, 0, b2, x2);
      }
      __name(K, "K");
      function J(e6) {
        var t4;
        for (t4 = 0; t4 < _2; t4++) e6.dyn_ltree[2 * t4] = 0;
        for (t4 = 0; t4 < g; t4++) e6.dyn_dtree[2 * t4] = 0;
        for (t4 = 0; t4 < b2; t4++) e6.bl_tree[2 * t4] = 0;
        e6.dyn_ltree[2 * E2] = 1, e6.opt_len = e6.static_len = 0, e6.last_lit = e6.matches = 0;
      }
      __name(J, "J");
      function X(e6) {
        e6.bi_valid > 8 ? G(e6, e6.bi_buf) : e6.bi_valid > 0 && (e6.pending_buf[e6.pending++] = e6.bi_buf), e6.bi_buf = 0, e6.bi_valid = 0;
      }
      __name(X, "X");
      function ee(e6, t4, i3, n4) {
        X(e6), G(e6, i3), G(e6, ~i3), r4.arraySet(e6.pending_buf, e6.window, t4, i3, e6.pending), e6.pending += i3;
      }
      __name(ee, "ee");
      function te(e6, t4, i3, r5) {
        var n4 = 2 * t4, a3 = 2 * i3;
        return e6[n4] < e6[a3] || e6[n4] === e6[a3] && r5[t4] <= r5[i3];
      }
      __name(te, "te");
      function ie(e6, t4, i3) {
        for (var r5 = e6.heap[i3], n4 = i3 << 1; n4 <= e6.heap_len && (n4 < e6.heap_len && te(t4, e6.heap[n4 + 1], e6.heap[n4], e6.depth) && n4++, !te(t4, r5, e6.heap[n4], e6.depth)); ) e6.heap[i3] = e6.heap[n4], i3 = n4, n4 <<= 1;
        e6.heap[i3] = r5;
      }
      __name(ie, "ie");
      function re(e6, t4, i3) {
        var r5, n4, a3, o4, s5 = 0;
        if (0 !== e6.last_lit) do {
          r5 = e6.pending_buf[e6.d_buf + 2 * s5] << 8 | e6.pending_buf[e6.d_buf + 2 * s5 + 1], n4 = e6.pending_buf[e6.l_buf + s5], s5++, 0 === r5 ? Q(e6, n4, t4) : (Q(e6, (a3 = F[n4]) + m + 1, t4), 0 !== (o4 = I[a3]) && H(e6, n4 -= N2[a3], o4), Q(e6, a3 = j(--r5), i3), 0 !== (o4 = M2[a3]) && H(e6, r5 -= L2[a3], o4));
        } while (s5 < e6.last_lit);
        Q(e6, E2, t4);
      }
      __name(re, "re");
      function ne(e6, t4) {
        var i3, r5, n4, a3 = t4.dyn_tree, o4 = t4.stat_desc.static_tree, s5 = t4.stat_desc.has_stree, l3 = t4.stat_desc.elems, u3 = -1;
        for (e6.heap_len = 0, e6.heap_max = y2, i3 = 0; i3 < l3; i3++) 0 !== a3[2 * i3] ? (e6.heap[++e6.heap_len] = u3 = i3, e6.depth[i3] = 0) : a3[2 * i3 + 1] = 0;
        for (; e6.heap_len < 2; ) a3[2 * (n4 = e6.heap[++e6.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e6.depth[n4] = 0, e6.opt_len--, s5 && (e6.static_len -= o4[2 * n4 + 1]);
        for (t4.max_code = u3, i3 = e6.heap_len >> 1; i3 >= 1; i3--) ie(e6, a3, i3);
        n4 = l3;
        do {
          i3 = e6.heap[1], e6.heap[1] = e6.heap[e6.heap_len--], ie(e6, a3, 1), r5 = e6.heap[1], e6.heap[--e6.heap_max] = i3, e6.heap[--e6.heap_max] = r5, a3[2 * n4] = a3[2 * i3] + a3[2 * r5], e6.depth[n4] = (e6.depth[i3] >= e6.depth[r5] ? e6.depth[i3] : e6.depth[r5]) + 1, a3[2 * i3 + 1] = a3[2 * r5 + 1] = n4, e6.heap[1] = n4++, ie(e6, a3, 1);
        } while (e6.heap_len >= 2);
        e6.heap[--e6.heap_max] = e6.heap[1], V(e6, t4), Y2(a3, u3, e6.bl_count);
      }
      __name(ne, "ne");
      function ae(e6, t4, i3) {
        var r5, n4, a3 = -1, o4 = t4[1], s5 = 0, l3 = 7, u3 = 4;
        for (0 === o4 && (l3 = 138, u3 = 3), t4[2 * (i3 + 1) + 1] = 65535, r5 = 0; r5 <= i3; r5++) n4 = o4, o4 = t4[2 * (r5 + 1) + 1], ++s5 < l3 && n4 === o4 || (s5 < u3 ? e6.bl_tree[2 * n4] += s5 : 0 !== n4 ? (n4 !== a3 && e6.bl_tree[2 * n4]++, e6.bl_tree[2 * k2]++) : s5 <= 10 ? e6.bl_tree[2 * S2]++ : e6.bl_tree[2 * A2]++, s5 = 0, a3 = n4, 0 === o4 ? (l3 = 138, u3 = 3) : n4 === o4 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4));
      }
      __name(ae, "ae");
      function oe(e6, t4, i3) {
        var r5, n4, a3 = -1, o4 = t4[1], s5 = 0, l3 = 7, u3 = 4;
        for (0 === o4 && (l3 = 138, u3 = 3), r5 = 0; r5 <= i3; r5++) if (n4 = o4, o4 = t4[2 * (r5 + 1) + 1], !(++s5 < l3 && n4 === o4)) {
          if (s5 < u3) do {
            Q(e6, n4, e6.bl_tree);
          } while (0 != --s5);
          else 0 !== n4 ? (n4 !== a3 && (Q(e6, n4, e6.bl_tree), s5--), Q(e6, k2, e6.bl_tree), H(e6, s5 - 3, 2)) : s5 <= 10 ? (Q(e6, S2, e6.bl_tree), H(e6, s5 - 3, 3)) : (Q(e6, A2, e6.bl_tree), H(e6, s5 - 11, 7));
          s5 = 0, a3 = n4, 0 === o4 ? (l3 = 138, u3 = 3) : n4 === o4 ? (l3 = 6, u3 = 3) : (l3 = 7, u3 = 4);
        }
      }
      __name(oe, "oe");
      function se(e6) {
        var t4;
        for (ae(e6, e6.dyn_ltree, e6.l_desc.max_code), ae(e6, e6.dyn_dtree, e6.d_desc.max_code), ne(e6, e6.bl_desc), t4 = b2 - 1; t4 >= 3 && 0 === e6.bl_tree[2 * P[t4] + 1]; t4--) ;
        return e6.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
      }
      __name(se, "se");
      function le(e6, t4, i3, r5) {
        var n4;
        for (H(e6, t4 - 257, 5), H(e6, i3 - 1, 5), H(e6, r5 - 4, 4), n4 = 0; n4 < r5; n4++) H(e6, e6.bl_tree[2 * P[n4] + 1], 3);
        oe(e6, e6.dyn_ltree, t4 - 1), oe(e6, e6.dyn_dtree, i3 - 1);
      }
      __name(le, "le");
      function ue(e6) {
        var t4, i3 = 4093624447;
        for (t4 = 0; t4 <= 31; t4++, i3 >>>= 1) if (1 & i3 && 0 !== e6.dyn_ltree[2 * t4]) return a2;
        if (0 !== e6.dyn_ltree[18] || 0 !== e6.dyn_ltree[20] || 0 !== e6.dyn_ltree[26]) return o3;
        for (t4 = 32; t4 < m; t4++) if (0 !== e6.dyn_ltree[2 * t4]) return o3;
        return a2;
      }
      __name(ue, "ue");
      l2(L2);
      var he = false;
      function ce(e6) {
        he || (K(), he = true), e6.l_desc = new Z(e6.dyn_ltree, O2), e6.d_desc = new Z(e6.dyn_dtree, D), e6.bl_desc = new Z(e6.bl_tree, $), e6.bi_buf = 0, e6.bi_valid = 0, J(e6);
      }
      __name(ce, "ce");
      function fe(e6, t4, i3, r5) {
        H(e6, (u2 << 1) + (r5 ? 1 : 0), 3), ee(e6, t4, i3);
      }
      __name(fe, "fe");
      function de(e6) {
        H(e6, h2 << 1, 3), Q(e6, E2, C2), q(e6);
      }
      __name(de, "de");
      function pe(e6, t4, i3, r5) {
        var a3, o4, l3 = 0;
        e6.level > 0 ? (e6.strm.data_type === s4 && (e6.strm.data_type = ue(e6)), ne(e6, e6.l_desc), ne(e6, e6.d_desc), l3 = se(e6), a3 = e6.opt_len + 3 + 7 >>> 3, (o4 = e6.static_len + 3 + 7 >>> 3) <= a3 && (a3 = o4)) : a3 = o4 = i3 + 5, i3 + 4 <= a3 && -1 !== t4 ? fe(e6, t4, i3, r5) : e6.strategy === n3 || o4 === a3 ? (H(e6, (h2 << 1) + (r5 ? 1 : 0), 3), re(e6, C2, R2)) : (H(e6, (c3 << 1) + (r5 ? 1 : 0), 3), le(e6, e6.l_desc.max_code + 1, e6.d_desc.max_code + 1, l3 + 1), re(e6, e6.dyn_ltree, e6.dyn_dtree)), J(e6), r5 && X(e6);
      }
      __name(pe, "pe");
      function me(e6, t4, i3) {
        return e6.pending_buf[e6.d_buf + 2 * e6.last_lit] = t4 >>> 8 & 255, e6.pending_buf[e6.d_buf + 2 * e6.last_lit + 1] = 255 & t4, e6.pending_buf[e6.l_buf + e6.last_lit] = 255 & i3, e6.last_lit++, 0 === t4 ? e6.dyn_ltree[2 * i3]++ : (e6.matches++, t4--, e6.dyn_ltree[2 * (F[i3] + m + 1)]++, e6.dyn_dtree[2 * j(t4)]++), e6.last_lit === e6.lit_bufsize - 1;
      }
      __name(me, "me");
      i2._tr_init = ce, i2._tr_stored_block = fe, i2._tr_flush_block = pe, i2._tr_tally = me, i2._tr_align = de;
    }, { "../utils/common": 52 }], 62: [function(e5, t3, i2) {
      function r4() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
      __name(r4, "r");
      t3.exports = r4;
    }, {}], 63: [function(e5, t3, i2) {
      var r4, n3, a2 = t3.exports = {};
      function o3() {
        throw new Error("setTimeout has not been defined");
      }
      __name(o3, "o");
      function s4() {
        throw new Error("clearTimeout has not been defined");
      }
      __name(s4, "s");
      function l2(e6) {
        if (r4 === setTimeout) return setTimeout(e6, 0);
        if ((r4 === o3 || !r4) && setTimeout) return r4 = setTimeout, setTimeout(e6, 0);
        try {
          return r4(e6, 0);
        } catch (t4) {
          try {
            return r4.call(null, e6, 0);
          } catch (t5) {
            return r4.call(this, e6, 0);
          }
        }
      }
      __name(l2, "l");
      function u2(e6) {
        if (n3 === clearTimeout) return clearTimeout(e6);
        if ((n3 === s4 || !n3) && clearTimeout) return n3 = clearTimeout, clearTimeout(e6);
        try {
          return n3(e6);
        } catch (t4) {
          try {
            return n3.call(null, e6);
          } catch (t5) {
            return n3.call(this, e6);
          }
        }
      }
      __name(u2, "u");
      !function() {
        try {
          r4 = "function" == typeof setTimeout ? setTimeout : o3;
        } catch (e6) {
          r4 = o3;
        }
        try {
          n3 = "function" == typeof clearTimeout ? clearTimeout : s4;
        } catch (e6) {
          n3 = s4;
        }
      }();
      var h2, c3 = [], f2 = false, d = -1;
      function p2() {
        f2 && h2 && (f2 = false, h2.length ? c3 = h2.concat(c3) : d = -1, c3.length && m());
      }
      __name(p2, "p");
      function m() {
        if (!f2) {
          var e6 = l2(p2);
          f2 = true;
          for (var t4 = c3.length; t4; ) {
            for (h2 = c3, c3 = []; ++d < t4; ) h2 && h2[d].run();
            d = -1, t4 = c3.length;
          }
          h2 = null, f2 = false, u2(e6);
        }
      }
      __name(m, "m");
      function _2(e6, t4) {
        this.fun = e6, this.array = t4;
      }
      __name(_2, "_");
      function g() {
      }
      __name(g, "g");
      a2.nextTick = function(e6) {
        var t4 = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var i3 = 1; i3 < arguments.length; i3++) t4[i3 - 1] = arguments[i3];
        c3.push(new _2(e6, t4)), 1 !== c3.length || f2 || l2(m);
      }, _2.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, a2.title = "browser", a2.browser = true, a2.env = {}, a2.argv = [], a2.version = "", a2.versions = {}, a2.on = g, a2.addListener = g, a2.once = g, a2.off = g, a2.removeListener = g, a2.removeAllListeners = g, a2.emit = g, a2.prependListener = g, a2.prependOnceListener = g, a2.listeners = function(e6) {
        return [];
      }, a2.binding = function(e6) {
        throw new Error("process.binding is not supported");
      }, a2.cwd = function() {
        return "/";
      }, a2.chdir = function(e6) {
        throw new Error("process.chdir is not supported");
      }, a2.umask = function() {
        return 0;
      };
    }, {}], 64: [function(e5, t3, i2) {
      var r4 = e5("buffer"), n3 = r4.Buffer;
      function a2(e6, t4) {
        for (var i3 in e6) t4[i3] = e6[i3];
      }
      __name(a2, "a");
      function o3(e6, t4, i3) {
        return n3(e6, t4, i3);
      }
      __name(o3, "o");
      n3.from && n3.alloc && n3.allocUnsafe && n3.allocUnsafeSlow ? t3.exports = r4 : (a2(r4, i2), i2.Buffer = o3), o3.prototype = Object.create(n3.prototype), a2(n3, o3), o3.from = function(e6, t4, i3) {
        if ("number" == typeof e6) throw new TypeError("Argument must not be a number");
        return n3(e6, t4, i3);
      }, o3.alloc = function(e6, t4, i3) {
        if ("number" != typeof e6) throw new TypeError("Argument must be a number");
        var r5 = n3(e6);
        return void 0 !== t4 ? "string" == typeof i3 ? r5.fill(t4, i3) : r5.fill(t4) : r5.fill(0), r5;
      }, o3.allocUnsafe = function(e6) {
        if ("number" != typeof e6) throw new TypeError("Argument must be a number");
        return n3(e6);
      }, o3.allocUnsafeSlow = function(e6) {
        if ("number" != typeof e6) throw new TypeError("Argument must be a number");
        return r4.SlowBuffer(e6);
      };
    }, { buffer: 32 }], 65: [function(e5, t3, i2) {
      t3.exports = n3;
      var r4 = e5("events").EventEmitter;
      function n3() {
        r4.call(this);
      }
      __name(n3, "n");
      e5("inherits")(n3, r4), n3.Readable = e5("readable-stream/lib/_stream_readable.js"), n3.Writable = e5("readable-stream/lib/_stream_writable.js"), n3.Duplex = e5("readable-stream/lib/_stream_duplex.js"), n3.Transform = e5("readable-stream/lib/_stream_transform.js"), n3.PassThrough = e5("readable-stream/lib/_stream_passthrough.js"), n3.finished = e5("readable-stream/lib/internal/streams/end-of-stream.js"), n3.pipeline = e5("readable-stream/lib/internal/streams/pipeline.js"), n3.Stream = n3, n3.prototype.pipe = function(e6, t4) {
        var i3 = this;
        function n4(t5) {
          e6.writable && false === e6.write(t5) && i3.pause && i3.pause();
        }
        __name(n4, "n");
        function a2() {
          i3.readable && i3.resume && i3.resume();
        }
        __name(a2, "a");
        i3.on("data", n4), e6.on("drain", a2), e6._isStdio || t4 && false === t4.end || (i3.on("end", s4), i3.on("close", l2));
        var o3 = false;
        function s4() {
          o3 || (o3 = true, e6.end());
        }
        __name(s4, "s");
        function l2() {
          o3 || (o3 = true, "function" == typeof e6.destroy && e6.destroy());
        }
        __name(l2, "l");
        function u2(e7) {
          if (h2(), 0 === r4.listenerCount(this, "error")) throw e7;
        }
        __name(u2, "u");
        function h2() {
          i3.removeListener("data", n4), e6.removeListener("drain", a2), i3.removeListener("end", s4), i3.removeListener("close", l2), i3.removeListener("error", u2), e6.removeListener("error", u2), i3.removeListener("end", h2), i3.removeListener("close", h2), e6.removeListener("close", h2);
        }
        __name(h2, "h");
        return i3.on("error", u2), e6.on("error", u2), i3.on("end", h2), i3.on("close", h2), e6.on("close", h2), e6.emit("pipe", i3), e6;
      };
    }, { events: 35, inherits: 46, "readable-stream/lib/_stream_duplex.js": 67, "readable-stream/lib/_stream_passthrough.js": 68, "readable-stream/lib/_stream_readable.js": 69, "readable-stream/lib/_stream_transform.js": 70, "readable-stream/lib/_stream_writable.js": 71, "readable-stream/lib/internal/streams/end-of-stream.js": 75, "readable-stream/lib/internal/streams/pipeline.js": 77 }], 66: [function(e5, t3, i2) {
      function r4(e6, t4) {
        e6.prototype = Object.create(t4.prototype), e6.prototype.constructor = e6, e6.__proto__ = t4;
      }
      __name(r4, "r");
      var n3 = {};
      function a2(e6, t4, i3) {
        function a3(e7, i4, r5) {
          return "string" == typeof t4 ? t4 : t4(e7, i4, r5);
        }
        __name(a3, "a");
        i3 || (i3 = Error);
        var o4 = function(e7) {
          function t5(t6, i4, r5) {
            return e7.call(this, a3(t6, i4, r5)) || this;
          }
          __name(t5, "t");
          return r4(t5, e7), t5;
        }(i3);
        o4.prototype.name = i3.name, o4.prototype.code = e6, n3[e6] = o4;
      }
      __name(a2, "a");
      function o3(e6, t4) {
        if (Array.isArray(e6)) {
          var i3 = e6.length;
          return e6 = e6.map(function(e7) {
            return String(e7);
          }), i3 > 2 ? "one of ".concat(t4, " ").concat(e6.slice(0, i3 - 1).join(", "), ", or ") + e6[i3 - 1] : 2 === i3 ? "one of ".concat(t4, " ").concat(e6[0], " or ").concat(e6[1]) : "of ".concat(t4, " ").concat(e6[0]);
        }
        return "of ".concat(t4, " ").concat(String(e6));
      }
      __name(o3, "o");
      function s4(e6, t4, i3) {
        return e6.substr(0, t4.length) === t4;
      }
      __name(s4, "s");
      function l2(e6, t4, i3) {
        return (void 0 === i3 || i3 > e6.length) && (i3 = e6.length), e6.substring(i3 - t4.length, i3) === t4;
      }
      __name(l2, "l");
      function u2(e6, t4, i3) {
        return "number" != typeof i3 && (i3 = 0), !(i3 + t4.length > e6.length) && -1 !== e6.indexOf(t4, i3);
      }
      __name(u2, "u");
      a2("ERR_INVALID_OPT_VALUE", function(e6, t4) {
        return 'The value "' + t4 + '" is invalid for option "' + e6 + '"';
      }, TypeError), a2("ERR_INVALID_ARG_TYPE", function(e6, t4, i3) {
        var r5, n4;
        if ("string" == typeof t4 && s4(t4, "not ") ? (r5 = "must not be", t4 = t4.replace(/^not /, "")) : r5 = "must be", l2(e6, " argument")) n4 = "The ".concat(e6, " ").concat(r5, " ").concat(o3(t4, "type"));
        else {
          var a3 = u2(e6, ".") ? "property" : "argument";
          n4 = 'The "'.concat(e6, '" ').concat(a3, " ").concat(r5, " ").concat(o3(t4, "type"));
        }
        return n4 += ". Received type ".concat(typeof i3);
      }, TypeError), a2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), a2("ERR_METHOD_NOT_IMPLEMENTED", function(e6) {
        return "The " + e6 + " method is not implemented";
      }), a2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), a2("ERR_STREAM_DESTROYED", function(e6) {
        return "Cannot call " + e6 + " after a stream was destroyed";
      }), a2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), a2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), a2("ERR_STREAM_WRITE_AFTER_END", "write after end"), a2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), a2("ERR_UNKNOWN_ENCODING", function(e6) {
        return "Unknown encoding: " + e6;
      }, TypeError), a2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t3.exports.codes = n3;
    }, {}], 67: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          var r4 = Object.keys || function(e6) {
            var t4 = [];
            for (var i4 in e6) t4.push(i4);
            return t4;
          };
          t3.exports = u2;
          var n3 = e5("./_stream_readable"), a2 = e5("./_stream_writable");
          e5("inherits")(u2, n3);
          for (var o3 = r4(a2.prototype), s4 = 0; s4 < o3.length; s4++) {
            var l2 = o3[s4];
            u2.prototype[l2] || (u2.prototype[l2] = a2.prototype[l2]);
          }
          function u2(e6) {
            if (!(this instanceof u2)) return new u2(e6);
            n3.call(this, e6), a2.call(this, e6), this.allowHalfOpen = true, e6 && (false === e6.readable && (this.readable = false), false === e6.writable && (this.writable = false), false === e6.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", h2)));
          }
          __name(u2, "u");
          function h2() {
            this._writableState.ended || i3.nextTick(c3, this);
          }
          __name(h2, "h");
          function c3(e6) {
            e6.end();
          }
          __name(c3, "c");
          Object.defineProperty(u2.prototype, "writableHighWaterMark", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._writableState.highWaterMark;
          }, "get") }), Object.defineProperty(u2.prototype, "writableBuffer", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._writableState && this._writableState.getBuffer();
          }, "get") }), Object.defineProperty(u2.prototype, "writableLength", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._writableState.length;
          }, "get") }), Object.defineProperty(u2.prototype, "destroyed", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
          }, "get"), set: /* @__PURE__ */ __name(function(e6) {
            void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e6, this._writableState.destroyed = e6);
          }, "set") });
        }).call(this);
      }).call(this, e5("_process"));
    }, { "./_stream_readable": 69, "./_stream_writable": 71, _process: 63, inherits: 46 }], 68: [function(e5, t3, i2) {
      t3.exports = n3;
      var r4 = e5("./_stream_transform");
      function n3(e6) {
        if (!(this instanceof n3)) return new n3(e6);
        r4.call(this, e6);
      }
      __name(n3, "n");
      e5("inherits")(n3, r4), n3.prototype._transform = function(e6, t4, i3) {
        i3(null, e6);
      };
    }, { "./_stream_transform": 70, inherits: 46 }], 69: [function(e5, t3, i2) {
      (function(i3, r4) {
        (function() {
          var n3;
          t3.exports = M2, M2.ReadableState = I, e5("events").EventEmitter;
          var a2 = /* @__PURE__ */ __name(function(e6, t4) {
            return e6.listeners(t4).length;
          }, "a"), o3 = e5("./internal/streams/stream"), s4 = e5("buffer").Buffer, l2 = r4.Uint8Array || function() {
          };
          function u2(e6) {
            return s4.from(e6);
          }
          __name(u2, "u");
          function h2(e6) {
            return s4.isBuffer(e6) || e6 instanceof l2;
          }
          __name(h2, "h");
          var c3, f2 = e5("util");
          c3 = f2 && f2.debuglog ? f2.debuglog("stream") : function() {
          };
          var d, p2, m, _2 = e5("./internal/streams/buffer_list"), g = e5("./internal/streams/destroy"), b2 = e5("./internal/streams/state").getHighWaterMark, y2 = e5("../errors").codes, w = y2.ERR_INVALID_ARG_TYPE, v2 = y2.ERR_STREAM_PUSH_AFTER_EOF, x2 = y2.ERR_METHOD_NOT_IMPLEMENTED, E2 = y2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          e5("inherits")(M2, o3);
          var k2 = g.errorOrDestroy, S2 = ["error", "close", "destroy", "pause", "resume"];
          function A2(e6, t4, i4) {
            if ("function" == typeof e6.prependListener) return e6.prependListener(t4, i4);
            e6._events && e6._events[t4] ? Array.isArray(e6._events[t4]) ? e6._events[t4].unshift(i4) : e6._events[t4] = [i4, e6._events[t4]] : e6.on(t4, i4);
          }
          __name(A2, "A");
          function I(t4, i4, r5) {
            n3 = n3 || e5("./_stream_duplex"), t4 = t4 || {}, "boolean" != typeof r5 && (r5 = i4 instanceof n3), this.objectMode = !!t4.objectMode, r5 && (this.objectMode = this.objectMode || !!t4.readableObjectMode), this.highWaterMark = b2(this, t4, "readableHighWaterMark", r5), this.buffer = new _2(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.destroyed = false, this.defaultEncoding = t4.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t4.encoding && (d || (d = e5("string_decoder/").StringDecoder), this.decoder = new d(t4.encoding), this.encoding = t4.encoding);
          }
          __name(I, "I");
          function M2(t4) {
            if (n3 = n3 || e5("./_stream_duplex"), !(this instanceof M2)) return new M2(t4);
            var i4 = this instanceof n3;
            this._readableState = new I(t4, this, i4), this.readable = true, t4 && ("function" == typeof t4.read && (this._read = t4.read), "function" == typeof t4.destroy && (this._destroy = t4.destroy)), o3.call(this);
          }
          __name(M2, "M");
          function T2(e6, t4, i4, r5, n4) {
            c3("readableAddChunk", t4);
            var a3, o4 = e6._readableState;
            if (null === t4) o4.reading = false, F(e6, o4);
            else if (n4 || (a3 = B2(o4, t4)), a3) k2(e6, a3);
            else if (o4.objectMode || t4 && t4.length > 0) if ("string" == typeof t4 || o4.objectMode || Object.getPrototypeOf(t4) === s4.prototype || (t4 = u2(t4)), r5) o4.endEmitted ? k2(e6, new E2()) : P(e6, o4, t4, true);
            else if (o4.ended) k2(e6, new v2());
            else {
              if (o4.destroyed) return false;
              o4.reading = false, o4.decoder && !i4 ? (t4 = o4.decoder.write(t4), o4.objectMode || 0 !== t4.length ? P(e6, o4, t4, false) : D(e6, o4)) : P(e6, o4, t4, false);
            }
            else r5 || (o4.reading = false, D(e6, o4));
            return !o4.ended && (o4.length < o4.highWaterMark || 0 === o4.length);
          }
          __name(T2, "T");
          function P(e6, t4, i4, r5) {
            t4.flowing && 0 === t4.length && !t4.sync ? (t4.awaitDrain = 0, e6.emit("data", i4)) : (t4.length += t4.objectMode ? 1 : i4.length, r5 ? t4.buffer.unshift(i4) : t4.buffer.push(i4), t4.needReadable && N2(e6)), D(e6, t4);
          }
          __name(P, "P");
          function B2(e6, t4) {
            var i4;
            return h2(t4) || "string" == typeof t4 || void 0 === t4 || e6.objectMode || (i4 = new w("chunk", ["string", "Buffer", "Uint8Array"], t4)), i4;
          }
          __name(B2, "B");
          Object.defineProperty(M2.prototype, "destroyed", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return void 0 !== this._readableState && this._readableState.destroyed;
          }, "get"), set: /* @__PURE__ */ __name(function(e6) {
            this._readableState && (this._readableState.destroyed = e6);
          }, "set") }), M2.prototype.destroy = g.destroy, M2.prototype._undestroy = g.undestroy, M2.prototype._destroy = function(e6, t4) {
            t4(e6);
          }, M2.prototype.push = function(e6, t4) {
            var i4, r5 = this._readableState;
            return r5.objectMode ? i4 = true : "string" == typeof e6 && ((t4 = t4 || r5.defaultEncoding) !== r5.encoding && (e6 = s4.from(e6, t4), t4 = ""), i4 = true), T2(this, e6, t4, false, i4);
          }, M2.prototype.unshift = function(e6) {
            return T2(this, e6, null, true, false);
          }, M2.prototype.isPaused = function() {
            return false === this._readableState.flowing;
          }, M2.prototype.setEncoding = function(t4) {
            d || (d = e5("string_decoder/").StringDecoder);
            var i4 = new d(t4);
            this._readableState.decoder = i4, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var r5 = this._readableState.buffer.head, n4 = ""; null !== r5; ) n4 += i4.write(r5.data), r5 = r5.next;
            return this._readableState.buffer.clear(), "" !== n4 && this._readableState.buffer.push(n4), this._readableState.length = n4.length, this;
          };
          var C2 = 1073741824;
          function R2(e6) {
            return e6 >= C2 ? e6 = C2 : (e6--, e6 |= e6 >>> 1, e6 |= e6 >>> 2, e6 |= e6 >>> 4, e6 |= e6 >>> 8, e6 |= e6 >>> 16, e6++), e6;
          }
          __name(R2, "R");
          function z2(e6, t4) {
            return e6 <= 0 || 0 === t4.length && t4.ended ? 0 : t4.objectMode ? 1 : e6 != e6 ? t4.flowing && t4.length ? t4.buffer.head.data.length : t4.length : (e6 > t4.highWaterMark && (t4.highWaterMark = R2(e6)), e6 <= t4.length ? e6 : t4.ended ? t4.length : (t4.needReadable = true, 0));
          }
          __name(z2, "z");
          function F(e6, t4) {
            if (c3("onEofChunk"), !t4.ended) {
              if (t4.decoder) {
                var i4 = t4.decoder.end();
                i4 && i4.length && (t4.buffer.push(i4), t4.length += t4.objectMode ? 1 : i4.length);
              }
              t4.ended = true, t4.sync ? N2(e6) : (t4.needReadable = false, t4.emittedReadable || (t4.emittedReadable = true, O2(e6)));
            }
          }
          __name(F, "F");
          function N2(e6) {
            var t4 = e6._readableState;
            c3("emitReadable", t4.needReadable, t4.emittedReadable), t4.needReadable = false, t4.emittedReadable || (c3("emitReadable", t4.flowing), t4.emittedReadable = true, i3.nextTick(O2, e6));
          }
          __name(N2, "N");
          function O2(e6) {
            var t4 = e6._readableState;
            c3("emitReadable_", t4.destroyed, t4.length, t4.ended), t4.destroyed || !t4.length && !t4.ended || (e6.emit("readable"), t4.emittedReadable = false), t4.needReadable = !t4.flowing && !t4.ended && t4.length <= t4.highWaterMark, H(e6);
          }
          __name(O2, "O");
          function D(e6, t4) {
            t4.readingMore || (t4.readingMore = true, i3.nextTick($, e6, t4));
          }
          __name(D, "D");
          function $(e6, t4) {
            for (; !t4.reading && !t4.ended && (t4.length < t4.highWaterMark || t4.flowing && 0 === t4.length); ) {
              var i4 = t4.length;
              if (c3("maybeReadMore read 0"), e6.read(0), i4 === t4.length) break;
            }
            t4.readingMore = false;
          }
          __name($, "$");
          function L2(e6) {
            return function() {
              var t4 = e6._readableState;
              c3("pipeOnDrain", t4.awaitDrain), t4.awaitDrain && t4.awaitDrain--, 0 === t4.awaitDrain && a2(e6, "data") && (t4.flowing = true, H(e6));
            };
          }
          __name(L2, "L");
          function U(e6) {
            var t4 = e6._readableState;
            t4.readableListening = e6.listenerCount("readable") > 0, t4.resumeScheduled && !t4.paused ? t4.flowing = true : e6.listenerCount("data") > 0 && e6.resume();
          }
          __name(U, "U");
          function Z(e6) {
            c3("readable nexttick read 0"), e6.read(0);
          }
          __name(Z, "Z");
          function j(e6, t4) {
            t4.resumeScheduled || (t4.resumeScheduled = true, i3.nextTick(G, e6, t4));
          }
          __name(j, "j");
          function G(e6, t4) {
            c3("resume", t4.reading), t4.reading || e6.read(0), t4.resumeScheduled = false, e6.emit("resume"), H(e6), t4.flowing && !t4.reading && e6.read(0);
          }
          __name(G, "G");
          function H(e6) {
            var t4 = e6._readableState;
            for (c3("flow", t4.flowing); t4.flowing && null !== e6.read(); ) ;
          }
          __name(H, "H");
          function Q(e6, t4) {
            return 0 === t4.length ? null : (t4.objectMode ? i4 = t4.buffer.shift() : !e6 || e6 >= t4.length ? (i4 = t4.decoder ? t4.buffer.join("") : 1 === t4.buffer.length ? t4.buffer.first() : t4.buffer.concat(t4.length), t4.buffer.clear()) : i4 = t4.buffer.consume(e6, t4.decoder), i4);
            var i4;
          }
          __name(Q, "Q");
          function W(e6) {
            var t4 = e6._readableState;
            c3("endReadable", t4.endEmitted), t4.endEmitted || (t4.ended = true, i3.nextTick(q, t4, e6));
          }
          __name(W, "W");
          function q(e6, t4) {
            if (c3("endReadableNT", e6.endEmitted, e6.length), !e6.endEmitted && 0 === e6.length && (e6.endEmitted = true, t4.readable = false, t4.emit("end"), e6.autoDestroy)) {
              var i4 = t4._writableState;
              (!i4 || i4.autoDestroy && i4.finished) && t4.destroy();
            }
          }
          __name(q, "q");
          function V(e6, t4) {
            for (var i4 = 0, r5 = e6.length; i4 < r5; i4++) if (e6[i4] === t4) return i4;
            return -1;
          }
          __name(V, "V");
          M2.prototype.read = function(e6) {
            c3("read", e6), e6 = parseInt(e6, 10);
            var t4 = this._readableState, i4 = e6;
            if (0 !== e6 && (t4.emittedReadable = false), 0 === e6 && t4.needReadable && ((0 !== t4.highWaterMark ? t4.length >= t4.highWaterMark : t4.length > 0) || t4.ended)) return c3("read: emitReadable", t4.length, t4.ended), 0 === t4.length && t4.ended ? W(this) : N2(this), null;
            if (0 === (e6 = z2(e6, t4)) && t4.ended) return 0 === t4.length && W(this), null;
            var r5, n4 = t4.needReadable;
            return c3("need readable", n4), (0 === t4.length || t4.length - e6 < t4.highWaterMark) && c3("length less than watermark", n4 = true), t4.ended || t4.reading ? c3("reading or ended", n4 = false) : n4 && (c3("do read"), t4.reading = true, t4.sync = true, 0 === t4.length && (t4.needReadable = true), this._read(t4.highWaterMark), t4.sync = false, t4.reading || (e6 = z2(i4, t4))), null === (r5 = e6 > 0 ? Q(e6, t4) : null) ? (t4.needReadable = t4.length <= t4.highWaterMark, e6 = 0) : (t4.length -= e6, t4.awaitDrain = 0), 0 === t4.length && (t4.ended || (t4.needReadable = true), i4 !== e6 && t4.ended && W(this)), null !== r5 && this.emit("data", r5), r5;
          }, M2.prototype._read = function(e6) {
            k2(this, new x2("_read()"));
          }, M2.prototype.pipe = function(e6, t4) {
            var r5 = this, n4 = this._readableState;
            switch (n4.pipesCount) {
              case 0:
                n4.pipes = e6;
                break;
              case 1:
                n4.pipes = [n4.pipes, e6];
                break;
              default:
                n4.pipes.push(e6);
            }
            n4.pipesCount += 1, c3("pipe count=%d opts=%j", n4.pipesCount, t4);
            var o4 = t4 && false === t4.end || e6 === i3.stdout || e6 === i3.stderr ? g2 : l3;
            function s5(e7, t5) {
              c3("onunpipe"), e7 === r5 && t5 && false === t5.hasUnpiped && (t5.hasUnpiped = true, f3());
            }
            __name(s5, "s");
            function l3() {
              c3("onend"), e6.end();
            }
            __name(l3, "l");
            n4.endEmitted ? i3.nextTick(o4) : r5.once("end", o4), e6.on("unpipe", s5);
            var u3 = L2(r5);
            e6.on("drain", u3);
            var h3 = false;
            function f3() {
              c3("cleanup"), e6.removeListener("close", m2), e6.removeListener("finish", _3), e6.removeListener("drain", u3), e6.removeListener("error", p3), e6.removeListener("unpipe", s5), r5.removeListener("end", l3), r5.removeListener("end", g2), r5.removeListener("data", d2), h3 = true, !n4.awaitDrain || e6._writableState && !e6._writableState.needDrain || u3();
            }
            __name(f3, "f");
            function d2(t5) {
              c3("ondata");
              var i4 = e6.write(t5);
              c3("dest.write", i4), false === i4 && ((1 === n4.pipesCount && n4.pipes === e6 || n4.pipesCount > 1 && -1 !== V(n4.pipes, e6)) && !h3 && (c3("false write response, pause", n4.awaitDrain), n4.awaitDrain++), r5.pause());
            }
            __name(d2, "d");
            function p3(t5) {
              c3("onerror", t5), g2(), e6.removeListener("error", p3), 0 === a2(e6, "error") && k2(e6, t5);
            }
            __name(p3, "p");
            function m2() {
              e6.removeListener("finish", _3), g2();
            }
            __name(m2, "m");
            function _3() {
              c3("onfinish"), e6.removeListener("close", m2), g2();
            }
            __name(_3, "_");
            function g2() {
              c3("unpipe"), r5.unpipe(e6);
            }
            __name(g2, "g");
            return r5.on("data", d2), A2(e6, "error", p3), e6.once("close", m2), e6.once("finish", _3), e6.emit("pipe", r5), n4.flowing || (c3("pipe resume"), r5.resume()), e6;
          }, M2.prototype.unpipe = function(e6) {
            var t4 = this._readableState, i4 = { hasUnpiped: false };
            if (0 === t4.pipesCount) return this;
            if (1 === t4.pipesCount) return e6 && e6 !== t4.pipes || (e6 || (e6 = t4.pipes), t4.pipes = null, t4.pipesCount = 0, t4.flowing = false, e6 && e6.emit("unpipe", this, i4)), this;
            if (!e6) {
              var r5 = t4.pipes, n4 = t4.pipesCount;
              t4.pipes = null, t4.pipesCount = 0, t4.flowing = false;
              for (var a3 = 0; a3 < n4; a3++) r5[a3].emit("unpipe", this, { hasUnpiped: false });
              return this;
            }
            var o4 = V(t4.pipes, e6);
            return -1 === o4 || (t4.pipes.splice(o4, 1), t4.pipesCount -= 1, 1 === t4.pipesCount && (t4.pipes = t4.pipes[0]), e6.emit("unpipe", this, i4)), this;
          }, M2.prototype.on = function(e6, t4) {
            var r5 = o3.prototype.on.call(this, e6, t4), n4 = this._readableState;
            return "data" === e6 ? (n4.readableListening = this.listenerCount("readable") > 0, false !== n4.flowing && this.resume()) : "readable" === e6 && (n4.endEmitted || n4.readableListening || (n4.readableListening = n4.needReadable = true, n4.flowing = false, n4.emittedReadable = false, c3("on readable", n4.length, n4.reading), n4.length ? N2(this) : n4.reading || i3.nextTick(Z, this))), r5;
          }, M2.prototype.addListener = M2.prototype.on, M2.prototype.removeListener = function(e6, t4) {
            var r5 = o3.prototype.removeListener.call(this, e6, t4);
            return "readable" === e6 && i3.nextTick(U, this), r5;
          }, M2.prototype.removeAllListeners = function(e6) {
            var t4 = o3.prototype.removeAllListeners.apply(this, arguments);
            return "readable" !== e6 && void 0 !== e6 || i3.nextTick(U, this), t4;
          }, M2.prototype.resume = function() {
            var e6 = this._readableState;
            return e6.flowing || (c3("resume"), e6.flowing = !e6.readableListening, j(this, e6)), e6.paused = false, this;
          }, M2.prototype.pause = function() {
            return c3("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (c3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
          }, M2.prototype.wrap = function(e6) {
            var t4 = this, i4 = this._readableState, r5 = false;
            for (var n4 in e6.on("end", function() {
              if (c3("wrapped end"), i4.decoder && !i4.ended) {
                var e7 = i4.decoder.end();
                e7 && e7.length && t4.push(e7);
              }
              t4.push(null);
            }), e6.on("data", function(n5) {
              c3("wrapped data"), i4.decoder && (n5 = i4.decoder.write(n5)), i4.objectMode && null == n5 || (i4.objectMode || n5 && n5.length) && (t4.push(n5) || (r5 = true, e6.pause()));
            }), e6) void 0 === this[n4] && "function" == typeof e6[n4] && (this[n4] = /* @__PURE__ */ function(t5) {
              return function() {
                return e6[t5].apply(e6, arguments);
              };
            }(n4));
            for (var a3 = 0; a3 < S2.length; a3++) e6.on(S2[a3], this.emit.bind(this, S2[a3]));
            return this._read = function(t5) {
              c3("wrapped _read", t5), r5 && (r5 = false, e6.resume());
            }, this;
          }, "function" == typeof Symbol && (M2.prototype[Symbol.asyncIterator] = function() {
            return void 0 === p2 && (p2 = e5("./internal/streams/async_iterator")), p2(this);
          }), Object.defineProperty(M2.prototype, "readableHighWaterMark", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._readableState.highWaterMark;
          }, "get") }), Object.defineProperty(M2.prototype, "readableBuffer", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._readableState && this._readableState.buffer;
          }, "get") }), Object.defineProperty(M2.prototype, "readableFlowing", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._readableState.flowing;
          }, "get"), set: /* @__PURE__ */ __name(function(e6) {
            this._readableState && (this._readableState.flowing = e6);
          }, "set") }), M2._fromList = Q, Object.defineProperty(M2.prototype, "readableLength", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._readableState.length;
          }, "get") }), "function" == typeof Symbol && (M2.from = function(t4, i4) {
            return void 0 === m && (m = e5("./internal/streams/from")), m(M2, t4, i4);
          });
        }).call(this);
      }).call(this, e5("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/async_iterator": 72, "./internal/streams/buffer_list": 73, "./internal/streams/destroy": 74, "./internal/streams/from": 76, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, events: 35, inherits: 46, "string_decoder/": 80, util: 29 }], 70: [function(e5, t3, i2) {
      t3.exports = h2;
      var r4 = e5("../errors").codes, n3 = r4.ERR_METHOD_NOT_IMPLEMENTED, a2 = r4.ERR_MULTIPLE_CALLBACK, o3 = r4.ERR_TRANSFORM_ALREADY_TRANSFORMING, s4 = r4.ERR_TRANSFORM_WITH_LENGTH_0, l2 = e5("./_stream_duplex");
      function u2(e6, t4) {
        var i3 = this._transformState;
        i3.transforming = false;
        var r5 = i3.writecb;
        if (null === r5) return this.emit("error", new a2());
        i3.writechunk = null, i3.writecb = null, null != t4 && this.push(t4), r5(e6);
        var n4 = this._readableState;
        n4.reading = false, (n4.needReadable || n4.length < n4.highWaterMark) && this._read(n4.highWaterMark);
      }
      __name(u2, "u");
      function h2(e6) {
        if (!(this instanceof h2)) return new h2(e6);
        l2.call(this, e6), this._transformState = { afterTransform: u2.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e6 && ("function" == typeof e6.transform && (this._transform = e6.transform), "function" == typeof e6.flush && (this._flush = e6.flush)), this.on("prefinish", c3);
      }
      __name(h2, "h");
      function c3() {
        var e6 = this;
        "function" != typeof this._flush || this._readableState.destroyed ? f2(this, null, null) : this._flush(function(t4, i3) {
          f2(e6, t4, i3);
        });
      }
      __name(c3, "c");
      function f2(e6, t4, i3) {
        if (t4) return e6.emit("error", t4);
        if (null != i3 && e6.push(i3), e6._writableState.length) throw new s4();
        if (e6._transformState.transforming) throw new o3();
        return e6.push(null);
      }
      __name(f2, "f");
      e5("inherits")(h2, l2), h2.prototype.push = function(e6, t4) {
        return this._transformState.needTransform = false, l2.prototype.push.call(this, e6, t4);
      }, h2.prototype._transform = function(e6, t4, i3) {
        i3(new n3("_transform()"));
      }, h2.prototype._write = function(e6, t4, i3) {
        var r5 = this._transformState;
        if (r5.writecb = i3, r5.writechunk = e6, r5.writeencoding = t4, !r5.transforming) {
          var n4 = this._readableState;
          (r5.needTransform || n4.needReadable || n4.length < n4.highWaterMark) && this._read(n4.highWaterMark);
        }
      }, h2.prototype._read = function(e6) {
        var t4 = this._transformState;
        null === t4.writechunk || t4.transforming ? t4.needTransform = true : (t4.transforming = true, this._transform(t4.writechunk, t4.writeencoding, t4.afterTransform));
      }, h2.prototype._destroy = function(e6, t4) {
        l2.prototype._destroy.call(this, e6, function(e7) {
          t4(e7);
        });
      };
    }, { "../errors": 66, "./_stream_duplex": 67, inherits: 46 }], 71: [function(e5, t3, i2) {
      (function(i3, r4) {
        (function() {
          function n3(e6) {
            var t4 = this;
            this.next = null, this.entry = null, this.finish = function() {
              G(t4, e6);
            };
          }
          __name(n3, "n");
          var a2;
          t3.exports = I, I.WritableState = A2;
          var o3 = { deprecate: e5("util-deprecate") }, s4 = e5("./internal/streams/stream"), l2 = e5("buffer").Buffer, u2 = r4.Uint8Array || function() {
          };
          function h2(e6) {
            return l2.from(e6);
          }
          __name(h2, "h");
          function c3(e6) {
            return l2.isBuffer(e6) || e6 instanceof u2;
          }
          __name(c3, "c");
          var f2, d = e5("./internal/streams/destroy"), p2 = e5("./internal/streams/state").getHighWaterMark, m = e5("../errors").codes, _2 = m.ERR_INVALID_ARG_TYPE, g = m.ERR_METHOD_NOT_IMPLEMENTED, b2 = m.ERR_MULTIPLE_CALLBACK, y2 = m.ERR_STREAM_CANNOT_PIPE, w = m.ERR_STREAM_DESTROYED, v2 = m.ERR_STREAM_NULL_VALUES, x2 = m.ERR_STREAM_WRITE_AFTER_END, E2 = m.ERR_UNKNOWN_ENCODING, k2 = d.errorOrDestroy;
          function S2() {
          }
          __name(S2, "S");
          function A2(t4, i4, r5) {
            a2 = a2 || e5("./_stream_duplex"), t4 = t4 || {}, "boolean" != typeof r5 && (r5 = i4 instanceof a2), this.objectMode = !!t4.objectMode, r5 && (this.objectMode = this.objectMode || !!t4.writableObjectMode), this.highWaterMark = p2(this, t4, "writableHighWaterMark", r5), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
            var o4 = false === t4.decodeStrings;
            this.decodeStrings = !o4, this.defaultEncoding = t4.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e6) {
              F(i4, e6);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t4.emitClose, this.autoDestroy = !!t4.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new n3(this);
          }
          __name(A2, "A");
          function I(t4) {
            var i4 = this instanceof (a2 = a2 || e5("./_stream_duplex"));
            if (!i4 && !f2.call(I, this)) return new I(t4);
            this._writableState = new A2(t4, this, i4), this.writable = true, t4 && ("function" == typeof t4.write && (this._write = t4.write), "function" == typeof t4.writev && (this._writev = t4.writev), "function" == typeof t4.destroy && (this._destroy = t4.destroy), "function" == typeof t4.final && (this._final = t4.final)), s4.call(this);
          }
          __name(I, "I");
          function M2(e6, t4) {
            var r5 = new x2();
            k2(e6, r5), i3.nextTick(t4, r5);
          }
          __name(M2, "M");
          function T2(e6, t4, r5, n4) {
            var a3;
            return null === r5 ? a3 = new v2() : "string" == typeof r5 || t4.objectMode || (a3 = new _2("chunk", ["string", "Buffer"], r5)), !a3 || (k2(e6, a3), i3.nextTick(n4, a3), false);
          }
          __name(T2, "T");
          function P(e6, t4, i4) {
            return e6.objectMode || false === e6.decodeStrings || "string" != typeof t4 || (t4 = l2.from(t4, i4)), t4;
          }
          __name(P, "P");
          function B2(e6, t4, i4, r5, n4, a3) {
            if (!i4) {
              var o4 = P(t4, r5, n4);
              r5 !== o4 && (i4 = true, n4 = "buffer", r5 = o4);
            }
            var s5 = t4.objectMode ? 1 : r5.length;
            t4.length += s5;
            var l3 = t4.length < t4.highWaterMark;
            if (l3 || (t4.needDrain = true), t4.writing || t4.corked) {
              var u3 = t4.lastBufferedRequest;
              t4.lastBufferedRequest = { chunk: r5, encoding: n4, isBuf: i4, callback: a3, next: null }, u3 ? u3.next = t4.lastBufferedRequest : t4.bufferedRequest = t4.lastBufferedRequest, t4.bufferedRequestCount += 1;
            } else C2(e6, t4, false, s5, r5, n4, a3);
            return l3;
          }
          __name(B2, "B");
          function C2(e6, t4, i4, r5, n4, a3, o4) {
            t4.writelen = r5, t4.writecb = o4, t4.writing = true, t4.sync = true, t4.destroyed ? t4.onwrite(new w("write")) : i4 ? e6._writev(n4, t4.onwrite) : e6._write(n4, a3, t4.onwrite), t4.sync = false;
          }
          __name(C2, "C");
          function R2(e6, t4, r5, n4, a3) {
            --t4.pendingcb, r5 ? (i3.nextTick(a3, n4), i3.nextTick(Z, e6, t4), e6._writableState.errorEmitted = true, k2(e6, n4)) : (a3(n4), e6._writableState.errorEmitted = true, k2(e6, n4), Z(e6, t4));
          }
          __name(R2, "R");
          function z2(e6) {
            e6.writing = false, e6.writecb = null, e6.length -= e6.writelen, e6.writelen = 0;
          }
          __name(z2, "z");
          function F(e6, t4) {
            var r5 = e6._writableState, n4 = r5.sync, a3 = r5.writecb;
            if ("function" != typeof a3) throw new b2();
            if (z2(r5), t4) R2(e6, r5, n4, t4, a3);
            else {
              var o4 = $(r5) || e6.destroyed;
              o4 || r5.corked || r5.bufferProcessing || !r5.bufferedRequest || D(e6, r5), n4 ? i3.nextTick(N2, e6, r5, o4, a3) : N2(e6, r5, o4, a3);
            }
          }
          __name(F, "F");
          function N2(e6, t4, i4, r5) {
            i4 || O2(e6, t4), t4.pendingcb--, r5(), Z(e6, t4);
          }
          __name(N2, "N");
          function O2(e6, t4) {
            0 === t4.length && t4.needDrain && (t4.needDrain = false, e6.emit("drain"));
          }
          __name(O2, "O");
          function D(e6, t4) {
            t4.bufferProcessing = true;
            var i4 = t4.bufferedRequest;
            if (e6._writev && i4 && i4.next) {
              var r5 = t4.bufferedRequestCount, a3 = new Array(r5), o4 = t4.corkedRequestsFree;
              o4.entry = i4;
              for (var s5 = 0, l3 = true; i4; ) a3[s5] = i4, i4.isBuf || (l3 = false), i4 = i4.next, s5 += 1;
              a3.allBuffers = l3, C2(e6, t4, true, t4.length, a3, "", o4.finish), t4.pendingcb++, t4.lastBufferedRequest = null, o4.next ? (t4.corkedRequestsFree = o4.next, o4.next = null) : t4.corkedRequestsFree = new n3(t4), t4.bufferedRequestCount = 0;
            } else {
              for (; i4; ) {
                var u3 = i4.chunk, h3 = i4.encoding, c4 = i4.callback;
                if (C2(e6, t4, false, t4.objectMode ? 1 : u3.length, u3, h3, c4), i4 = i4.next, t4.bufferedRequestCount--, t4.writing) break;
              }
              null === i4 && (t4.lastBufferedRequest = null);
            }
            t4.bufferedRequest = i4, t4.bufferProcessing = false;
          }
          __name(D, "D");
          function $(e6) {
            return e6.ending && 0 === e6.length && null === e6.bufferedRequest && !e6.finished && !e6.writing;
          }
          __name($, "$");
          function L2(e6, t4) {
            e6._final(function(i4) {
              t4.pendingcb--, i4 && k2(e6, i4), t4.prefinished = true, e6.emit("prefinish"), Z(e6, t4);
            });
          }
          __name(L2, "L");
          function U(e6, t4) {
            t4.prefinished || t4.finalCalled || ("function" != typeof e6._final || t4.destroyed ? (t4.prefinished = true, e6.emit("prefinish")) : (t4.pendingcb++, t4.finalCalled = true, i3.nextTick(L2, e6, t4)));
          }
          __name(U, "U");
          function Z(e6, t4) {
            var i4 = $(t4);
            if (i4 && (U(e6, t4), 0 === t4.pendingcb && (t4.finished = true, e6.emit("finish"), t4.autoDestroy))) {
              var r5 = e6._readableState;
              (!r5 || r5.autoDestroy && r5.endEmitted) && e6.destroy();
            }
            return i4;
          }
          __name(Z, "Z");
          function j(e6, t4, r5) {
            t4.ending = true, Z(e6, t4), r5 && (t4.finished ? i3.nextTick(r5) : e6.once("finish", r5)), t4.ended = true, e6.writable = false;
          }
          __name(j, "j");
          function G(e6, t4, i4) {
            var r5 = e6.entry;
            for (e6.entry = null; r5; ) {
              var n4 = r5.callback;
              t4.pendingcb--, n4(i4), r5 = r5.next;
            }
            t4.corkedRequestsFree.next = e6;
          }
          __name(G, "G");
          e5("inherits")(I, s4), A2.prototype.getBuffer = function() {
            for (var e6 = this.bufferedRequest, t4 = []; e6; ) t4.push(e6), e6 = e6.next;
            return t4;
          }, function() {
            try {
              Object.defineProperty(A2.prototype, "buffer", { get: o3.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch (e6) {
            }
          }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (f2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, { value: /* @__PURE__ */ __name(function(e6) {
            return !!f2.call(this, e6) || this === I && e6 && e6._writableState instanceof A2;
          }, "value") })) : f2 = /* @__PURE__ */ __name(function(e6) {
            return e6 instanceof this;
          }, "f"), I.prototype.pipe = function() {
            k2(this, new y2());
          }, I.prototype.write = function(e6, t4, i4) {
            var r5 = this._writableState, n4 = false, a3 = !r5.objectMode && c3(e6);
            return a3 && !l2.isBuffer(e6) && (e6 = h2(e6)), "function" == typeof t4 && (i4 = t4, t4 = null), a3 ? t4 = "buffer" : t4 || (t4 = r5.defaultEncoding), "function" != typeof i4 && (i4 = S2), r5.ending ? M2(this, i4) : (a3 || T2(this, r5, e6, i4)) && (r5.pendingcb++, n4 = B2(this, r5, a3, e6, t4, i4)), n4;
          }, I.prototype.cork = function() {
            this._writableState.corked++;
          }, I.prototype.uncork = function() {
            var e6 = this._writableState;
            e6.corked && (e6.corked--, e6.writing || e6.corked || e6.bufferProcessing || !e6.bufferedRequest || D(this, e6));
          }, I.prototype.setDefaultEncoding = function(e6) {
            if ("string" == typeof e6 && (e6 = e6.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e6 + "").toLowerCase()) > -1)) throw new E2(e6);
            return this._writableState.defaultEncoding = e6, this;
          }, Object.defineProperty(I.prototype, "writableBuffer", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._writableState && this._writableState.getBuffer();
          }, "get") }), Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._writableState.highWaterMark;
          }, "get") }), I.prototype._write = function(e6, t4, i4) {
            i4(new g("_write()"));
          }, I.prototype._writev = null, I.prototype.end = function(e6, t4, i4) {
            var r5 = this._writableState;
            return "function" == typeof e6 ? (i4 = e6, e6 = null, t4 = null) : "function" == typeof t4 && (i4 = t4, t4 = null), null != e6 && this.write(e6, t4), r5.corked && (r5.corked = 1, this.uncork()), r5.ending || j(this, r5, i4), this;
          }, Object.defineProperty(I.prototype, "writableLength", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return this._writableState.length;
          }, "get") }), Object.defineProperty(I.prototype, "destroyed", { enumerable: false, get: /* @__PURE__ */ __name(function() {
            return void 0 !== this._writableState && this._writableState.destroyed;
          }, "get"), set: /* @__PURE__ */ __name(function(e6) {
            this._writableState && (this._writableState.destroyed = e6);
          }, "set") }), I.prototype.destroy = d.destroy, I.prototype._undestroy = d.undestroy, I.prototype._destroy = function(e6, t4) {
            t4(e6);
          };
        }).call(this);
      }).call(this, e5("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { "../errors": 66, "./_stream_duplex": 67, "./internal/streams/destroy": 74, "./internal/streams/state": 78, "./internal/streams/stream": 79, _process: 63, buffer: 32, inherits: 46, "util-deprecate": 81 }], 72: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          var r4;
          function n3(e6, t4, i4) {
            return t4 in e6 ? Object.defineProperty(e6, t4, { value: i4, enumerable: true, configurable: true, writable: true }) : e6[t4] = i4, e6;
          }
          __name(n3, "n");
          var a2 = e5("./end-of-stream"), o3 = Symbol("lastResolve"), s4 = Symbol("lastReject"), l2 = Symbol("error"), u2 = Symbol("ended"), h2 = Symbol("lastPromise"), c3 = Symbol("handlePromise"), f2 = Symbol("stream");
          function d(e6, t4) {
            return { value: e6, done: t4 };
          }
          __name(d, "d");
          function p2(e6) {
            var t4 = e6[o3];
            if (null !== t4) {
              var i4 = e6[f2].read();
              null !== i4 && (e6[h2] = null, e6[o3] = null, e6[s4] = null, t4(d(i4, false)));
            }
          }
          __name(p2, "p");
          function m(e6) {
            i3.nextTick(p2, e6);
          }
          __name(m, "m");
          function _2(e6, t4) {
            return function(i4, r5) {
              e6.then(function() {
                t4[u2] ? i4(d(void 0, true)) : t4[c3](i4, r5);
              }, r5);
            };
          }
          __name(_2, "_");
          var g = Object.getPrototypeOf(function() {
          }), b2 = Object.setPrototypeOf((r4 = { get stream() {
            return this[f2];
          }, next: /* @__PURE__ */ __name(function() {
            var e6 = this, t4 = this[l2];
            if (null !== t4) return Promise.reject(t4);
            if (this[u2]) return Promise.resolve(d(void 0, true));
            if (this[f2].destroyed) return new Promise(function(t5, r6) {
              i3.nextTick(function() {
                e6[l2] ? r6(e6[l2]) : t5(d(void 0, true));
              });
            });
            var r5, n4 = this[h2];
            if (n4) r5 = new Promise(_2(n4, this));
            else {
              var a3 = this[f2].read();
              if (null !== a3) return Promise.resolve(d(a3, false));
              r5 = new Promise(this[c3]);
            }
            return this[h2] = r5, r5;
          }, "next") }, n3(r4, Symbol.asyncIterator, function() {
            return this;
          }), n3(r4, "return", function() {
            var e6 = this;
            return new Promise(function(t4, i4) {
              e6[f2].destroy(null, function(e7) {
                e7 ? i4(e7) : t4(d(void 0, true));
              });
            });
          }), r4), g), y2 = /* @__PURE__ */ __name(function(e6) {
            var t4, i4 = Object.create(b2, (n3(t4 = {}, f2, { value: e6, writable: true }), n3(t4, o3, { value: null, writable: true }), n3(t4, s4, { value: null, writable: true }), n3(t4, l2, { value: null, writable: true }), n3(t4, u2, { value: e6._readableState.endEmitted, writable: true }), n3(t4, c3, { value: /* @__PURE__ */ __name(function(e7, t5) {
              var r5 = i4[f2].read();
              r5 ? (i4[h2] = null, i4[o3] = null, i4[s4] = null, e7(d(r5, false))) : (i4[o3] = e7, i4[s4] = t5);
            }, "value"), writable: true }), t4));
            return i4[h2] = null, a2(e6, function(e7) {
              if (e7 && "ERR_STREAM_PREMATURE_CLOSE" !== e7.code) {
                var t5 = i4[s4];
                return null !== t5 && (i4[h2] = null, i4[o3] = null, i4[s4] = null, t5(e7)), void (i4[l2] = e7);
              }
              var r5 = i4[o3];
              null !== r5 && (i4[h2] = null, i4[o3] = null, i4[s4] = null, r5(d(void 0, true))), i4[u2] = true;
            }), e6.on("readable", m.bind(null, i4)), i4;
          }, "y");
          t3.exports = y2;
        }).call(this);
      }).call(this, e5("_process"));
    }, { "./end-of-stream": 75, _process: 63 }], 73: [function(e5, t3, i2) {
      function r4(e6, t4) {
        var i3 = Object.keys(e6);
        if (Object.getOwnPropertySymbols) {
          var r5 = Object.getOwnPropertySymbols(e6);
          t4 && (r5 = r5.filter(function(t5) {
            return Object.getOwnPropertyDescriptor(e6, t5).enumerable;
          })), i3.push.apply(i3, r5);
        }
        return i3;
      }
      __name(r4, "r");
      function n3(e6) {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var i3 = null != arguments[t4] ? arguments[t4] : {};
          t4 % 2 ? r4(Object(i3), true).forEach(function(t5) {
            a2(e6, t5, i3[t5]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e6, Object.getOwnPropertyDescriptors(i3)) : r4(Object(i3)).forEach(function(t5) {
            Object.defineProperty(e6, t5, Object.getOwnPropertyDescriptor(i3, t5));
          });
        }
        return e6;
      }
      __name(n3, "n");
      function a2(e6, t4, i3) {
        return t4 in e6 ? Object.defineProperty(e6, t4, { value: i3, enumerable: true, configurable: true, writable: true }) : e6[t4] = i3, e6;
      }
      __name(a2, "a");
      function o3(e6, t4) {
        if (!(e6 instanceof t4)) throw new TypeError("Cannot call a class as a function");
      }
      __name(o3, "o");
      function s4(e6, t4) {
        for (var i3 = 0; i3 < t4.length; i3++) {
          var r5 = t4[i3];
          r5.enumerable = r5.enumerable || false, r5.configurable = true, "value" in r5 && (r5.writable = true), Object.defineProperty(e6, r5.key, r5);
        }
      }
      __name(s4, "s");
      function l2(e6, t4, i3) {
        return t4 && s4(e6.prototype, t4), e6;
      }
      __name(l2, "l");
      var u2 = e5("buffer").Buffer, h2 = e5("util").inspect, c3 = h2 && h2.custom || "inspect";
      function f2(e6, t4, i3) {
        u2.prototype.copy.call(e6, t4, i3);
      }
      __name(f2, "f");
      t3.exports = function() {
        function e6() {
          o3(this, e6), this.head = null, this.tail = null, this.length = 0;
        }
        __name(e6, "e");
        return l2(e6, [{ key: "push", value: /* @__PURE__ */ __name(function(e7) {
          var t4 = { data: e7, next: null };
          this.length > 0 ? this.tail.next = t4 : this.head = t4, this.tail = t4, ++this.length;
        }, "value") }, { key: "unshift", value: /* @__PURE__ */ __name(function(e7) {
          var t4 = { data: e7, next: this.head };
          0 === this.length && (this.tail = t4), this.head = t4, ++this.length;
        }, "value") }, { key: "shift", value: /* @__PURE__ */ __name(function() {
          if (0 !== this.length) {
            var e7 = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e7;
          }
        }, "value") }, { key: "clear", value: /* @__PURE__ */ __name(function() {
          this.head = this.tail = null, this.length = 0;
        }, "value") }, { key: "join", value: /* @__PURE__ */ __name(function(e7) {
          if (0 === this.length) return "";
          for (var t4 = this.head, i3 = "" + t4.data; t4 = t4.next; ) i3 += e7 + t4.data;
          return i3;
        }, "value") }, { key: "concat", value: /* @__PURE__ */ __name(function(e7) {
          if (0 === this.length) return u2.alloc(0);
          for (var t4 = u2.allocUnsafe(e7 >>> 0), i3 = this.head, r5 = 0; i3; ) f2(i3.data, t4, r5), r5 += i3.data.length, i3 = i3.next;
          return t4;
        }, "value") }, { key: "consume", value: /* @__PURE__ */ __name(function(e7, t4) {
          var i3;
          return e7 < this.head.data.length ? (i3 = this.head.data.slice(0, e7), this.head.data = this.head.data.slice(e7)) : i3 = e7 === this.head.data.length ? this.shift() : t4 ? this._getString(e7) : this._getBuffer(e7), i3;
        }, "value") }, { key: "first", value: /* @__PURE__ */ __name(function() {
          return this.head.data;
        }, "value") }, { key: "_getString", value: /* @__PURE__ */ __name(function(e7) {
          var t4 = this.head, i3 = 1, r5 = t4.data;
          for (e7 -= r5.length; t4 = t4.next; ) {
            var n4 = t4.data, a3 = e7 > n4.length ? n4.length : e7;
            if (a3 === n4.length ? r5 += n4 : r5 += n4.slice(0, e7), 0 == (e7 -= a3)) {
              a3 === n4.length ? (++i3, t4.next ? this.head = t4.next : this.head = this.tail = null) : (this.head = t4, t4.data = n4.slice(a3));
              break;
            }
            ++i3;
          }
          return this.length -= i3, r5;
        }, "value") }, { key: "_getBuffer", value: /* @__PURE__ */ __name(function(e7) {
          var t4 = u2.allocUnsafe(e7), i3 = this.head, r5 = 1;
          for (i3.data.copy(t4), e7 -= i3.data.length; i3 = i3.next; ) {
            var n4 = i3.data, a3 = e7 > n4.length ? n4.length : e7;
            if (n4.copy(t4, t4.length - e7, 0, a3), 0 == (e7 -= a3)) {
              a3 === n4.length ? (++r5, i3.next ? this.head = i3.next : this.head = this.tail = null) : (this.head = i3, i3.data = n4.slice(a3));
              break;
            }
            ++r5;
          }
          return this.length -= r5, t4;
        }, "value") }, { key: c3, value: /* @__PURE__ */ __name(function(e7, t4) {
          return h2(this, n3({}, t4, { depth: 0, customInspect: false }));
        }, "value") }]), e6;
      }();
    }, { buffer: 32, util: 29 }], 74: [function(e5, t3, i2) {
      (function(e6) {
        (function() {
          function i3(t4, i4) {
            var a3 = this, s5 = this._readableState && this._readableState.destroyed, l2 = this._writableState && this._writableState.destroyed;
            return s5 || l2 ? (i4 ? i4(t4) : t4 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, e6.nextTick(o3, this, t4)) : e6.nextTick(o3, this, t4)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t4 || null, function(t5) {
              !i4 && t5 ? a3._writableState ? a3._writableState.errorEmitted ? e6.nextTick(n3, a3) : (a3._writableState.errorEmitted = true, e6.nextTick(r4, a3, t5)) : e6.nextTick(r4, a3, t5) : i4 ? (e6.nextTick(n3, a3), i4(t5)) : e6.nextTick(n3, a3);
            }), this);
          }
          __name(i3, "i");
          function r4(e7, t4) {
            o3(e7, t4), n3(e7);
          }
          __name(r4, "r");
          function n3(e7) {
            e7._writableState && !e7._writableState.emitClose || e7._readableState && !e7._readableState.emitClose || e7.emit("close");
          }
          __name(n3, "n");
          function a2() {
            this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
          }
          __name(a2, "a");
          function o3(e7, t4) {
            e7.emit("error", t4);
          }
          __name(o3, "o");
          function s4(e7, t4) {
            var i4 = e7._readableState, r5 = e7._writableState;
            i4 && i4.autoDestroy || r5 && r5.autoDestroy ? e7.destroy(t4) : e7.emit("error", t4);
          }
          __name(s4, "s");
          t3.exports = { destroy: i3, undestroy: a2, errorOrDestroy: s4 };
        }).call(this);
      }).call(this, e5("_process"));
    }, { _process: 63 }], 75: [function(e5, t3, i2) {
      var r4 = e5("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function n3(e6) {
        var t4 = false;
        return function() {
          if (!t4) {
            t4 = true;
            for (var i3 = arguments.length, r5 = new Array(i3), n4 = 0; n4 < i3; n4++) r5[n4] = arguments[n4];
            e6.apply(this, r5);
          }
        };
      }
      __name(n3, "n");
      function a2() {
      }
      __name(a2, "a");
      function o3(e6) {
        return e6.setHeader && "function" == typeof e6.abort;
      }
      __name(o3, "o");
      function s4(e6, t4, i3) {
        if ("function" == typeof t4) return s4(e6, null, t4);
        t4 || (t4 = {}), i3 = n3(i3 || a2);
        var l2 = t4.readable || false !== t4.readable && e6.readable, u2 = t4.writable || false !== t4.writable && e6.writable, h2 = /* @__PURE__ */ __name(function() {
          e6.writable || f2();
        }, "h"), c3 = e6._writableState && e6._writableState.finished, f2 = /* @__PURE__ */ __name(function() {
          u2 = false, c3 = true, l2 || i3.call(e6);
        }, "f"), d = e6._readableState && e6._readableState.endEmitted, p2 = /* @__PURE__ */ __name(function() {
          l2 = false, d = true, u2 || i3.call(e6);
        }, "p"), m = /* @__PURE__ */ __name(function(t5) {
          i3.call(e6, t5);
        }, "m"), _2 = /* @__PURE__ */ __name(function() {
          var t5;
          return l2 && !d ? (e6._readableState && e6._readableState.ended || (t5 = new r4()), i3.call(e6, t5)) : u2 && !c3 ? (e6._writableState && e6._writableState.ended || (t5 = new r4()), i3.call(e6, t5)) : void 0;
        }, "_"), g = /* @__PURE__ */ __name(function() {
          e6.req.on("finish", f2);
        }, "g");
        return o3(e6) ? (e6.on("complete", f2), e6.on("abort", _2), e6.req ? g() : e6.on("request", g)) : u2 && !e6._writableState && (e6.on("end", h2), e6.on("close", h2)), e6.on("end", p2), e6.on("finish", f2), false !== t4.error && e6.on("error", m), e6.on("close", _2), function() {
          e6.removeListener("complete", f2), e6.removeListener("abort", _2), e6.removeListener("request", g), e6.req && e6.req.removeListener("finish", f2), e6.removeListener("end", h2), e6.removeListener("close", h2), e6.removeListener("finish", f2), e6.removeListener("end", p2), e6.removeListener("error", m), e6.removeListener("close", _2);
        };
      }
      __name(s4, "s");
      t3.exports = s4;
    }, { "../../../errors": 66 }], 76: [function(e5, t3, i2) {
      t3.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 77: [function(e5, t3, i2) {
      var r4;
      function n3(e6) {
        var t4 = false;
        return function() {
          t4 || (t4 = true, e6.apply(void 0, arguments));
        };
      }
      __name(n3, "n");
      var a2 = e5("../../../errors").codes, o3 = a2.ERR_MISSING_ARGS, s4 = a2.ERR_STREAM_DESTROYED;
      function l2(e6) {
        if (e6) throw e6;
      }
      __name(l2, "l");
      function u2(e6) {
        return e6.setHeader && "function" == typeof e6.abort;
      }
      __name(u2, "u");
      function h2(t4, i3, a3, o4) {
        o4 = n3(o4);
        var l3 = false;
        t4.on("close", function() {
          l3 = true;
        }), void 0 === r4 && (r4 = e5("./end-of-stream")), r4(t4, { readable: i3, writable: a3 }, function(e6) {
          if (e6) return o4(e6);
          l3 = true, o4();
        });
        var h3 = false;
        return function(e6) {
          if (!l3 && !h3) return h3 = true, u2(t4) ? t4.abort() : "function" == typeof t4.destroy ? t4.destroy() : void o4(e6 || new s4("pipe"));
        };
      }
      __name(h2, "h");
      function c3(e6) {
        e6();
      }
      __name(c3, "c");
      function f2(e6, t4) {
        return e6.pipe(t4);
      }
      __name(f2, "f");
      function d(e6) {
        return e6.length ? "function" != typeof e6[e6.length - 1] ? l2 : e6.pop() : l2;
      }
      __name(d, "d");
      function p2() {
        for (var e6 = arguments.length, t4 = new Array(e6), i3 = 0; i3 < e6; i3++) t4[i3] = arguments[i3];
        var r5, n4 = d(t4);
        if (Array.isArray(t4[0]) && (t4 = t4[0]), t4.length < 2) throw new o3("streams");
        var a3 = t4.map(function(e7, i4) {
          var o4 = i4 < t4.length - 1;
          return h2(e7, o4, i4 > 0, function(e8) {
            r5 || (r5 = e8), e8 && a3.forEach(c3), o4 || (a3.forEach(c3), n4(r5));
          });
        });
        return t4.reduce(f2);
      }
      __name(p2, "p");
      t3.exports = p2;
    }, { "../../../errors": 66, "./end-of-stream": 75 }], 78: [function(e5, t3, i2) {
      var r4 = e5("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function n3(e6, t4, i3) {
        return null != e6.highWaterMark ? e6.highWaterMark : t4 ? e6[i3] : null;
      }
      __name(n3, "n");
      function a2(e6, t4, i3, a3) {
        var o3 = n3(t4, a3, i3);
        if (null != o3) {
          if (!isFinite(o3) || Math.floor(o3) !== o3 || o3 < 0) throw new r4(a3 ? i3 : "highWaterMark", o3);
          return Math.floor(o3);
        }
        return e6.objectMode ? 16 : 16384;
      }
      __name(a2, "a");
      t3.exports = { getHighWaterMark: a2 };
    }, { "../../../errors": 66 }], 79: [function(e5, t3, i2) {
      t3.exports = e5("events").EventEmitter;
    }, { events: 35 }], 80: [function(e5, t3, i2) {
      var r4 = e5("safe-buffer").Buffer, n3 = r4.isEncoding || function(e6) {
        switch ((e6 = "" + e6) && e6.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function a2(e6) {
        if (!e6) return "utf8";
        for (var t4; ; ) switch (e6) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e6;
          default:
            if (t4) return;
            e6 = ("" + e6).toLowerCase(), t4 = true;
        }
      }
      __name(a2, "a");
      function o3(e6) {
        var t4 = a2(e6);
        if ("string" != typeof t4 && (r4.isEncoding === n3 || !n3(e6))) throw new Error("Unknown encoding: " + e6);
        return t4 || e6;
      }
      __name(o3, "o");
      function s4(e6) {
        var t4;
        switch (this.encoding = o3(e6), this.encoding) {
          case "utf16le":
            this.text = p2, this.end = m, t4 = 4;
            break;
          case "utf8":
            this.fillLast = c3, t4 = 4;
            break;
          case "base64":
            this.text = _2, this.end = g, t4 = 3;
            break;
          default:
            return this.write = b2, void (this.end = y2);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r4.allocUnsafe(t4);
      }
      __name(s4, "s");
      function l2(e6) {
        return e6 <= 127 ? 0 : e6 >> 5 == 6 ? 2 : e6 >> 4 == 14 ? 3 : e6 >> 3 == 30 ? 4 : e6 >> 6 == 2 ? -1 : -2;
      }
      __name(l2, "l");
      function u2(e6, t4, i3) {
        var r5 = t4.length - 1;
        if (r5 < i3) return 0;
        var n4 = l2(t4[r5]);
        return n4 >= 0 ? (n4 > 0 && (e6.lastNeed = n4 - 1), n4) : --r5 < i3 || -2 === n4 ? 0 : (n4 = l2(t4[r5])) >= 0 ? (n4 > 0 && (e6.lastNeed = n4 - 2), n4) : --r5 < i3 || -2 === n4 ? 0 : (n4 = l2(t4[r5])) >= 0 ? (n4 > 0 && (2 === n4 ? n4 = 0 : e6.lastNeed = n4 - 3), n4) : 0;
      }
      __name(u2, "u");
      function h2(e6, t4, i3) {
        if (128 != (192 & t4[0])) return e6.lastNeed = 0, "\uFFFD";
        if (e6.lastNeed > 1 && t4.length > 1) {
          if (128 != (192 & t4[1])) return e6.lastNeed = 1, "\uFFFD";
          if (e6.lastNeed > 2 && t4.length > 2 && 128 != (192 & t4[2])) return e6.lastNeed = 2, "\uFFFD";
        }
      }
      __name(h2, "h");
      function c3(e6) {
        var t4 = this.lastTotal - this.lastNeed, i3 = h2(this, e6);
        return void 0 !== i3 ? i3 : this.lastNeed <= e6.length ? (e6.copy(this.lastChar, t4, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e6.copy(this.lastChar, t4, 0, e6.length), void (this.lastNeed -= e6.length));
      }
      __name(c3, "c");
      function f2(e6, t4) {
        var i3 = u2(this, e6, t4);
        if (!this.lastNeed) return e6.toString("utf8", t4);
        this.lastTotal = i3;
        var r5 = e6.length - (i3 - this.lastNeed);
        return e6.copy(this.lastChar, 0, r5), e6.toString("utf8", t4, r5);
      }
      __name(f2, "f");
      function d(e6) {
        var t4 = e6 && e6.length ? this.write(e6) : "";
        return this.lastNeed ? t4 + "\uFFFD" : t4;
      }
      __name(d, "d");
      function p2(e6, t4) {
        if ((e6.length - t4) % 2 == 0) {
          var i3 = e6.toString("utf16le", t4);
          if (i3) {
            var r5 = i3.charCodeAt(i3.length - 1);
            if (r5 >= 55296 && r5 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e6[e6.length - 2], this.lastChar[1] = e6[e6.length - 1], i3.slice(0, -1);
          }
          return i3;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e6[e6.length - 1], e6.toString("utf16le", t4, e6.length - 1);
      }
      __name(p2, "p");
      function m(e6) {
        var t4 = e6 && e6.length ? this.write(e6) : "";
        if (this.lastNeed) {
          var i3 = this.lastTotal - this.lastNeed;
          return t4 + this.lastChar.toString("utf16le", 0, i3);
        }
        return t4;
      }
      __name(m, "m");
      function _2(e6, t4) {
        var i3 = (e6.length - t4) % 3;
        return 0 === i3 ? e6.toString("base64", t4) : (this.lastNeed = 3 - i3, this.lastTotal = 3, 1 === i3 ? this.lastChar[0] = e6[e6.length - 1] : (this.lastChar[0] = e6[e6.length - 2], this.lastChar[1] = e6[e6.length - 1]), e6.toString("base64", t4, e6.length - i3));
      }
      __name(_2, "_");
      function g(e6) {
        var t4 = e6 && e6.length ? this.write(e6) : "";
        return this.lastNeed ? t4 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t4;
      }
      __name(g, "g");
      function b2(e6) {
        return e6.toString(this.encoding);
      }
      __name(b2, "b");
      function y2(e6) {
        return e6 && e6.length ? this.write(e6) : "";
      }
      __name(y2, "y");
      i2.StringDecoder = s4, s4.prototype.write = function(e6) {
        if (0 === e6.length) return "";
        var t4, i3;
        if (this.lastNeed) {
          if (void 0 === (t4 = this.fillLast(e6))) return "";
          i3 = this.lastNeed, this.lastNeed = 0;
        } else i3 = 0;
        return i3 < e6.length ? t4 ? t4 + this.text(e6, i3) : this.text(e6, i3) : t4 || "";
      }, s4.prototype.end = d, s4.prototype.text = f2, s4.prototype.fillLast = function(e6) {
        if (this.lastNeed <= e6.length) return e6.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        e6.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e6.length), this.lastNeed -= e6.length;
      };
    }, { "safe-buffer": 64 }], 81: [function(e5, t3, i2) {
      (function(e6) {
        (function() {
          function i3(e7, t4) {
            if (r4("noDeprecation")) return e7;
            var i4 = false;
            function n3() {
              if (!i4) {
                if (r4("throwDeprecation")) throw new Error(t4);
                r4("traceDeprecation") ? console.trace(t4) : console.warn(t4), i4 = true;
              }
              return e7.apply(this, arguments);
            }
            __name(n3, "n");
            return n3;
          }
          __name(i3, "i");
          function r4(t4) {
            try {
              if (!e6.localStorage) return false;
            } catch (e7) {
              return false;
            }
            var i4 = e6.localStorage[t4];
            return null != i4 && "true" === String(i4).toLowerCase();
          }
          __name(r4, "r");
          t3.exports = i3;
        }).call(this);
      }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 82: [function(e5, t3, i2) {
      arguments[4][25][0].apply(i2, arguments);
    }, { dup: 25 }], 83: [function(e5, t3, i2) {
      var r4 = e5("is-arguments"), n3 = e5("is-generator-function"), a2 = e5("which-typed-array"), o3 = e5("is-typed-array");
      function s4(e6) {
        return e6.call.bind(e6);
      }
      __name(s4, "s");
      var l2 = "undefined" != typeof BigInt, u2 = "undefined" != typeof Symbol, h2 = s4(Object.prototype.toString), c3 = s4(Number.prototype.valueOf), f2 = s4(String.prototype.valueOf), d = s4(Boolean.prototype.valueOf);
      if (l2) var p2 = s4(BigInt.prototype.valueOf);
      if (u2) var m = s4(Symbol.prototype.valueOf);
      function _2(e6, t4) {
        if ("object" != typeof e6) return false;
        try {
          return t4(e6), true;
        } catch (e7) {
          return false;
        }
      }
      __name(_2, "_");
      function g(e6) {
        return "undefined" != typeof Promise && e6 instanceof Promise || null !== e6 && "object" == typeof e6 && "function" == typeof e6.then && "function" == typeof e6.catch;
      }
      __name(g, "g");
      function b2(e6) {
        return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e6) : o3(e6) || U(e6);
      }
      __name(b2, "b");
      function y2(e6) {
        return "Uint8Array" === a2(e6);
      }
      __name(y2, "y");
      function w(e6) {
        return "Uint8ClampedArray" === a2(e6);
      }
      __name(w, "w");
      function v2(e6) {
        return "Uint16Array" === a2(e6);
      }
      __name(v2, "v");
      function x2(e6) {
        return "Uint32Array" === a2(e6);
      }
      __name(x2, "x");
      function E2(e6) {
        return "Int8Array" === a2(e6);
      }
      __name(E2, "E");
      function k2(e6) {
        return "Int16Array" === a2(e6);
      }
      __name(k2, "k");
      function S2(e6) {
        return "Int32Array" === a2(e6);
      }
      __name(S2, "S");
      function A2(e6) {
        return "Float32Array" === a2(e6);
      }
      __name(A2, "A");
      function I(e6) {
        return "Float64Array" === a2(e6);
      }
      __name(I, "I");
      function M2(e6) {
        return "BigInt64Array" === a2(e6);
      }
      __name(M2, "M");
      function T2(e6) {
        return "BigUint64Array" === a2(e6);
      }
      __name(T2, "T");
      function P(e6) {
        return "[object Map]" === h2(e6);
      }
      __name(P, "P");
      function B2(e6) {
        return "undefined" != typeof Map && (P.working ? P(e6) : e6 instanceof Map);
      }
      __name(B2, "B");
      function C2(e6) {
        return "[object Set]" === h2(e6);
      }
      __name(C2, "C");
      function R2(e6) {
        return "undefined" != typeof Set && (C2.working ? C2(e6) : e6 instanceof Set);
      }
      __name(R2, "R");
      function z2(e6) {
        return "[object WeakMap]" === h2(e6);
      }
      __name(z2, "z");
      function F(e6) {
        return "undefined" != typeof WeakMap && (z2.working ? z2(e6) : e6 instanceof WeakMap);
      }
      __name(F, "F");
      function N2(e6) {
        return "[object WeakSet]" === h2(e6);
      }
      __name(N2, "N");
      function O2(e6) {
        return N2(e6);
      }
      __name(O2, "O");
      function D(e6) {
        return "[object ArrayBuffer]" === h2(e6);
      }
      __name(D, "D");
      function $(e6) {
        return "undefined" != typeof ArrayBuffer && (D.working ? D(e6) : e6 instanceof ArrayBuffer);
      }
      __name($, "$");
      function L2(e6) {
        return "[object DataView]" === h2(e6);
      }
      __name(L2, "L");
      function U(e6) {
        return "undefined" != typeof DataView && (L2.working ? L2(e6) : e6 instanceof DataView);
      }
      __name(U, "U");
      i2.isArgumentsObject = r4, i2.isGeneratorFunction = n3, i2.isTypedArray = o3, i2.isPromise = g, i2.isArrayBufferView = b2, i2.isUint8Array = y2, i2.isUint8ClampedArray = w, i2.isUint16Array = v2, i2.isUint32Array = x2, i2.isInt8Array = E2, i2.isInt16Array = k2, i2.isInt32Array = S2, i2.isFloat32Array = A2, i2.isFloat64Array = I, i2.isBigInt64Array = M2, i2.isBigUint64Array = T2, P.working = "undefined" != typeof Map && P(/* @__PURE__ */ new Map()), i2.isMap = B2, C2.working = "undefined" != typeof Set && C2(/* @__PURE__ */ new Set()), i2.isSet = R2, z2.working = "undefined" != typeof WeakMap && z2(/* @__PURE__ */ new WeakMap()), i2.isWeakMap = F, N2.working = "undefined" != typeof WeakSet && N2(/* @__PURE__ */ new WeakSet()), i2.isWeakSet = O2, D.working = "undefined" != typeof ArrayBuffer && D(new ArrayBuffer()), i2.isArrayBuffer = $, L2.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && L2(new DataView(new ArrayBuffer(1), 0, 1)), i2.isDataView = U;
      var Z = "undefined" != typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;
      function j(e6) {
        return "[object SharedArrayBuffer]" === h2(e6);
      }
      __name(j, "j");
      function G(e6) {
        return void 0 !== Z && (void 0 === j.working && (j.working = j(new Z())), j.working ? j(e6) : e6 instanceof Z);
      }
      __name(G, "G");
      function H(e6) {
        return "[object AsyncFunction]" === h2(e6);
      }
      __name(H, "H");
      function Q(e6) {
        return "[object Map Iterator]" === h2(e6);
      }
      __name(Q, "Q");
      function W(e6) {
        return "[object Set Iterator]" === h2(e6);
      }
      __name(W, "W");
      function q(e6) {
        return "[object Generator]" === h2(e6);
      }
      __name(q, "q");
      function V(e6) {
        return "[object WebAssembly.Module]" === h2(e6);
      }
      __name(V, "V");
      function Y2(e6) {
        return _2(e6, c3);
      }
      __name(Y2, "Y");
      function K(e6) {
        return _2(e6, f2);
      }
      __name(K, "K");
      function J(e6) {
        return _2(e6, d);
      }
      __name(J, "J");
      function X(e6) {
        return l2 && _2(e6, p2);
      }
      __name(X, "X");
      function ee(e6) {
        return u2 && _2(e6, m);
      }
      __name(ee, "ee");
      function te(e6) {
        return Y2(e6) || K(e6) || J(e6) || X(e6) || ee(e6);
      }
      __name(te, "te");
      function ie(e6) {
        return "undefined" != typeof Uint8Array && ($(e6) || G(e6));
      }
      __name(ie, "ie");
      i2.isSharedArrayBuffer = G, i2.isAsyncFunction = H, i2.isMapIterator = Q, i2.isSetIterator = W, i2.isGeneratorObject = q, i2.isWebAssemblyCompiledModule = V, i2.isNumberObject = Y2, i2.isStringObject = K, i2.isBooleanObject = J, i2.isBigIntObject = X, i2.isSymbolObject = ee, i2.isBoxedPrimitive = te, i2.isAnyArrayBuffer = ie, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e6) {
        Object.defineProperty(i2, e6, { enumerable: false, value: /* @__PURE__ */ __name(function() {
          throw new Error(e6 + " is not supported in userland");
        }, "value") });
      });
    }, { "is-arguments": 47, "is-generator-function": 49, "is-typed-array": 50, "which-typed-array": 85 }], 84: [function(e5, t3, i2) {
      (function(t4) {
        (function() {
          var r4 = Object.getOwnPropertyDescriptors || function(e6) {
            for (var t5 = Object.keys(e6), i3 = {}, r5 = 0; r5 < t5.length; r5++) i3[t5[r5]] = Object.getOwnPropertyDescriptor(e6, t5[r5]);
            return i3;
          }, n3 = /%[sdj%]/g;
          i2.format = function(e6) {
            if (!E2(e6)) {
              for (var t5 = [], i3 = 0; i3 < arguments.length; i3++) t5.push(l2(arguments[i3]));
              return t5.join(" ");
            }
            i3 = 1;
            for (var r5 = arguments, a3 = r5.length, o4 = String(e6).replace(n3, function(e7) {
              if ("%%" === e7) return "%";
              if (i3 >= a3) return e7;
              switch (e7) {
                case "%s":
                  return String(r5[i3++]);
                case "%d":
                  return Number(r5[i3++]);
                case "%j":
                  try {
                    return JSON.stringify(r5[i3++]);
                  } catch (e8) {
                    return "[Circular]";
                  }
                default:
                  return e7;
              }
            }), s5 = r5[i3]; i3 < a3; s5 = r5[++i3]) w(s5) || !I(s5) ? o4 += " " + s5 : o4 += " " + l2(s5);
            return o4;
          }, i2.deprecate = function(e6, r5) {
            if (void 0 !== t4 && true === t4.noDeprecation) return e6;
            if (void 0 === t4) return function() {
              return i2.deprecate(e6, r5).apply(this, arguments);
            };
            var n4 = false;
            function a3() {
              if (!n4) {
                if (t4.throwDeprecation) throw new Error(r5);
                t4.traceDeprecation ? console.trace(r5) : console.error(r5), n4 = true;
              }
              return e6.apply(this, arguments);
            }
            __name(a3, "a");
            return a3;
          };
          var a2 = {}, o3 = /^$/;
          if (t4.env.NODE_DEBUG) {
            var s4 = t4.env.NODE_DEBUG;
            s4 = s4.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), o3 = new RegExp("^" + s4 + "$", "i");
          }
          function l2(e6, t5) {
            var r5 = { seen: [], stylize: h2 };
            return arguments.length >= 3 && (r5.depth = arguments[2]), arguments.length >= 4 && (r5.colors = arguments[3]), y2(t5) ? r5.showHidden = t5 : t5 && i2._extend(r5, t5), S2(r5.showHidden) && (r5.showHidden = false), S2(r5.depth) && (r5.depth = 2), S2(r5.colors) && (r5.colors = false), S2(r5.customInspect) && (r5.customInspect = true), r5.colors && (r5.stylize = u2), f2(r5, e6, r5.depth);
          }
          __name(l2, "l");
          function u2(e6, t5) {
            var i3 = l2.styles[t5];
            return i3 ? "\x1B[" + l2.colors[i3][0] + "m" + e6 + "\x1B[" + l2.colors[i3][1] + "m" : e6;
          }
          __name(u2, "u");
          function h2(e6, t5) {
            return e6;
          }
          __name(h2, "h");
          function c3(e6) {
            var t5 = {};
            return e6.forEach(function(e7, i3) {
              t5[e7] = true;
            }), t5;
          }
          __name(c3, "c");
          function f2(e6, t5, r5) {
            if (e6.customInspect && t5 && P(t5.inspect) && t5.inspect !== i2.inspect && (!t5.constructor || t5.constructor.prototype !== t5)) {
              var n4 = t5.inspect(r5, e6);
              return E2(n4) || (n4 = f2(e6, n4, r5)), n4;
            }
            var a3 = d(e6, t5);
            if (a3) return a3;
            var o4 = Object.keys(t5), s5 = c3(o4);
            if (e6.showHidden && (o4 = Object.getOwnPropertyNames(t5)), T2(t5) && (o4.indexOf("message") >= 0 || o4.indexOf("description") >= 0)) return p2(t5);
            if (0 === o4.length) {
              if (P(t5)) {
                var l3 = t5.name ? ": " + t5.name : "";
                return e6.stylize("[Function" + l3 + "]", "special");
              }
              if (A2(t5)) return e6.stylize(RegExp.prototype.toString.call(t5), "regexp");
              if (M2(t5)) return e6.stylize(Date.prototype.toString.call(t5), "date");
              if (T2(t5)) return p2(t5);
            }
            var u3, h3 = "", y3 = false, w2 = ["{", "}"];
            return b2(t5) && (y3 = true, w2 = ["[", "]"]), P(t5) && (h3 = " [Function" + (t5.name ? ": " + t5.name : "") + "]"), A2(t5) && (h3 = " " + RegExp.prototype.toString.call(t5)), M2(t5) && (h3 = " " + Date.prototype.toUTCString.call(t5)), T2(t5) && (h3 = " " + p2(t5)), 0 !== o4.length || y3 && 0 != t5.length ? r5 < 0 ? A2(t5) ? e6.stylize(RegExp.prototype.toString.call(t5), "regexp") : e6.stylize("[Object]", "special") : (e6.seen.push(t5), u3 = y3 ? m(e6, t5, r5, s5, o4) : o4.map(function(i3) {
              return _2(e6, t5, r5, s5, i3, y3);
            }), e6.seen.pop(), g(u3, h3, w2)) : w2[0] + h3 + w2[1];
          }
          __name(f2, "f");
          function d(e6, t5) {
            if (S2(t5)) return e6.stylize("undefined", "undefined");
            if (E2(t5)) {
              var i3 = "'" + JSON.stringify(t5).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return e6.stylize(i3, "string");
            }
            return x2(t5) ? e6.stylize("" + t5, "number") : y2(t5) ? e6.stylize("" + t5, "boolean") : w(t5) ? e6.stylize("null", "null") : void 0;
          }
          __name(d, "d");
          function p2(e6) {
            return "[" + Error.prototype.toString.call(e6) + "]";
          }
          __name(p2, "p");
          function m(e6, t5, i3, r5, n4) {
            for (var a3 = [], o4 = 0, s5 = t5.length; o4 < s5; ++o4) N2(t5, String(o4)) ? a3.push(_2(e6, t5, i3, r5, String(o4), true)) : a3.push("");
            return n4.forEach(function(n5) {
              n5.match(/^\d+$/) || a3.push(_2(e6, t5, i3, r5, n5, true));
            }), a3;
          }
          __name(m, "m");
          function _2(e6, t5, i3, r5, n4, a3) {
            var o4, s5, l3;
            if ((l3 = Object.getOwnPropertyDescriptor(t5, n4) || { value: t5[n4] }).get ? s5 = l3.set ? e6.stylize("[Getter/Setter]", "special") : e6.stylize("[Getter]", "special") : l3.set && (s5 = e6.stylize("[Setter]", "special")), N2(r5, n4) || (o4 = "[" + n4 + "]"), s5 || (e6.seen.indexOf(l3.value) < 0 ? (s5 = w(i3) ? f2(e6, l3.value, null) : f2(e6, l3.value, i3 - 1)).indexOf("\n") > -1 && (s5 = a3 ? s5.split("\n").map(function(e7) {
              return "  " + e7;
            }).join("\n").slice(2) : "\n" + s5.split("\n").map(function(e7) {
              return "   " + e7;
            }).join("\n")) : s5 = e6.stylize("[Circular]", "special")), S2(o4)) {
              if (a3 && n4.match(/^\d+$/)) return s5;
              (o4 = JSON.stringify("" + n4)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o4 = o4.slice(1, -1), o4 = e6.stylize(o4, "name")) : (o4 = o4.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o4 = e6.stylize(o4, "string"));
            }
            return o4 + ": " + s5;
          }
          __name(_2, "_");
          function g(e6, t5, i3) {
            return e6.reduce(function(e7, t6) {
              return t6.indexOf("\n"), e7 + t6.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0) > 60 ? i3[0] + ("" === t5 ? "" : t5 + "\n ") + " " + e6.join(",\n  ") + " " + i3[1] : i3[0] + t5 + " " + e6.join(", ") + " " + i3[1];
          }
          __name(g, "g");
          function b2(e6) {
            return Array.isArray(e6);
          }
          __name(b2, "b");
          function y2(e6) {
            return "boolean" == typeof e6;
          }
          __name(y2, "y");
          function w(e6) {
            return null === e6;
          }
          __name(w, "w");
          function v2(e6) {
            return null == e6;
          }
          __name(v2, "v");
          function x2(e6) {
            return "number" == typeof e6;
          }
          __name(x2, "x");
          function E2(e6) {
            return "string" == typeof e6;
          }
          __name(E2, "E");
          function k2(e6) {
            return "symbol" == typeof e6;
          }
          __name(k2, "k");
          function S2(e6) {
            return void 0 === e6;
          }
          __name(S2, "S");
          function A2(e6) {
            return I(e6) && "[object RegExp]" === C2(e6);
          }
          __name(A2, "A");
          function I(e6) {
            return "object" == typeof e6 && null !== e6;
          }
          __name(I, "I");
          function M2(e6) {
            return I(e6) && "[object Date]" === C2(e6);
          }
          __name(M2, "M");
          function T2(e6) {
            return I(e6) && ("[object Error]" === C2(e6) || e6 instanceof Error);
          }
          __name(T2, "T");
          function P(e6) {
            return "function" == typeof e6;
          }
          __name(P, "P");
          function B2(e6) {
            return null === e6 || "boolean" == typeof e6 || "number" == typeof e6 || "string" == typeof e6 || "symbol" == typeof e6 || void 0 === e6;
          }
          __name(B2, "B");
          function C2(e6) {
            return Object.prototype.toString.call(e6);
          }
          __name(C2, "C");
          function R2(e6) {
            return e6 < 10 ? "0" + e6.toString(10) : e6.toString(10);
          }
          __name(R2, "R");
          i2.debuglog = function(e6) {
            if (e6 = e6.toUpperCase(), !a2[e6]) if (o3.test(e6)) {
              var r5 = t4.pid;
              a2[e6] = function() {
                var t5 = i2.format.apply(i2, arguments);
                console.error("%s %d: %s", e6, r5, t5);
              };
            } else a2[e6] = function() {
            };
            return a2[e6];
          }, i2.inspect = l2, l2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.types = e5("./support/types"), i2.isArray = b2, i2.isBoolean = y2, i2.isNull = w, i2.isNullOrUndefined = v2, i2.isNumber = x2, i2.isString = E2, i2.isSymbol = k2, i2.isUndefined = S2, i2.isRegExp = A2, i2.types.isRegExp = A2, i2.isObject = I, i2.isDate = M2, i2.types.isDate = M2, i2.isError = T2, i2.types.isNativeError = T2, i2.isFunction = P, i2.isPrimitive = B2, i2.isBuffer = e5("./support/isBuffer");
          var z2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function F() {
            var e6 = /* @__PURE__ */ new Date(), t5 = [R2(e6.getHours()), R2(e6.getMinutes()), R2(e6.getSeconds())].join(":");
            return [e6.getDate(), z2[e6.getMonth()], t5].join(" ");
          }
          __name(F, "F");
          function N2(e6, t5) {
            return Object.prototype.hasOwnProperty.call(e6, t5);
          }
          __name(N2, "N");
          i2.log = function() {
            console.log("%s - %s", F(), i2.format.apply(i2, arguments));
          }, i2.inherits = e5("inherits"), i2._extend = function(e6, t5) {
            if (!t5 || !I(t5)) return e6;
            for (var i3 = Object.keys(t5), r5 = i3.length; r5--; ) e6[i3[r5]] = t5[i3[r5]];
            return e6;
          };
          var O2 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
          function D(e6, t5) {
            if (!e6) {
              var i3 = new Error("Promise was rejected with a falsy value");
              i3.reason = e6, e6 = i3;
            }
            return t5(e6);
          }
          __name(D, "D");
          function $(e6) {
            if ("function" != typeof e6) throw new TypeError('The "original" argument must be of type Function');
            function i3() {
              for (var i4 = [], r5 = 0; r5 < arguments.length; r5++) i4.push(arguments[r5]);
              var n4 = i4.pop();
              if ("function" != typeof n4) throw new TypeError("The last argument must be of type Function");
              var a3 = this, o4 = /* @__PURE__ */ __name(function() {
                return n4.apply(a3, arguments);
              }, "o");
              e6.apply(this, i4).then(function(e7) {
                t4.nextTick(o4.bind(null, null, e7));
              }, function(e7) {
                t4.nextTick(D.bind(null, e7, o4));
              });
            }
            __name(i3, "i");
            return Object.setPrototypeOf(i3, Object.getPrototypeOf(e6)), Object.defineProperties(i3, r4(e6)), i3;
          }
          __name($, "$");
          i2.promisify = function(e6) {
            if ("function" != typeof e6) throw new TypeError('The "original" argument must be of type Function');
            if (O2 && e6[O2]) {
              var t5;
              if ("function" != typeof (t5 = e6[O2])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
              return Object.defineProperty(t5, O2, { value: t5, enumerable: false, writable: false, configurable: true }), t5;
            }
            function t5() {
              for (var t6, i3, r5 = new Promise(function(e7, r6) {
                t6 = e7, i3 = r6;
              }), n4 = [], a3 = 0; a3 < arguments.length; a3++) n4.push(arguments[a3]);
              n4.push(function(e7, r6) {
                e7 ? i3(e7) : t6(r6);
              });
              try {
                e6.apply(this, n4);
              } catch (e7) {
                i3(e7);
              }
              return r5;
            }
            __name(t5, "t");
            return Object.setPrototypeOf(t5, Object.getPrototypeOf(e6)), O2 && Object.defineProperty(t5, O2, { value: t5, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t5, r4(e6));
          }, i2.promisify.custom = O2, i2.callbackify = $;
        }).call(this);
      }).call(this, e5("_process"));
    }, { "./support/isBuffer": 82, "./support/types": 83, _process: 63, inherits: 46 }], 85: [function(e5, t3, i2) {
      (function(i3) {
        (function() {
          var r4 = e5("for-each"), n3 = e5("available-typed-arrays"), a2 = e5("call-bind/callBound"), o3 = e5("gopd"), s4 = a2("Object.prototype.toString"), l2 = e5("has-tostringtag/shams")(), u2 = "undefined" == typeof globalThis ? i3 : globalThis, h2 = n3(), c3 = a2("String.prototype.slice"), f2 = {}, d = Object.getPrototypeOf;
          l2 && o3 && d && r4(h2, function(e6) {
            if ("function" == typeof u2[e6]) {
              var t4 = new u2[e6]();
              if (Symbol.toStringTag in t4) {
                var i4 = d(t4), r5 = o3(i4, Symbol.toStringTag);
                if (!r5) {
                  var n4 = d(i4);
                  r5 = o3(n4, Symbol.toStringTag);
                }
                f2[e6] = r5.get;
              }
            }
          });
          var p2 = /* @__PURE__ */ __name(function(e6) {
            var t4 = false;
            return r4(f2, function(i4, r5) {
              if (!t4) try {
                var n4 = i4.call(e6);
                n4 === r5 && (t4 = n4);
              } catch (e7) {
              }
            }), t4;
          }, "p"), m = e5("is-typed-array");
          t3.exports = function(e6) {
            return !!m(e6) && (l2 && Symbol.toStringTag in e6 ? p2(e6) : c3(s4(e6), 8, -1));
          };
        }).call(this);
      }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, { "available-typed-arrays": 27, "call-bind/callBound": 33, "for-each": 36, gopd: 40, "has-tostringtag/shams": 43, "is-typed-array": 50 }] }, {}, [20])(20);
    browserExports = browser$1.exports;
    __name(png, "png");
    PNGFilterType2 = PNGFilterType || (PNGFilterType = {}), PNGFilterType2[PNGFilterType2.AUTO = -1] = "AUTO", PNGFilterType2[PNGFilterType2.NONE = 0] = "NONE", PNGFilterType2[PNGFilterType2.SUB = 1] = "SUB", PNGFilterType2[PNGFilterType2.UP = 2] = "UP", PNGFilterType2[PNGFilterType2.AVERAGE = 3] = "AVERAGE", PNGFilterType2[PNGFilterType2.PATH = 4] = "PATH", PNGColorType2 = PNGColorType || (PNGColorType = {}), PNGColorType2[PNGColorType2.GRAYSCALE = 0] = "GRAYSCALE", PNGColorType2[PNGColorType2.COLOR = 2] = "COLOR", PNGColorType2[PNGColorType2.GRAYSCALE_ALPHA = 4] = "GRAYSCALE_ALPHA", PNGColorType2[PNGColorType2.COLOR_ALPHA = 6] = "COLOR_ALPHA";
    UTIF = { exports: {} };
    common = {};
    __name(requireCommon, "requireCommon");
    deflate$1 = {};
    deflate = {};
    trees = {};
    __name(requireTrees, "requireTrees");
    __name(requireAdler32, "requireAdler32");
    __name(requireCrc32, "requireCrc32");
    __name(requireMessages, "requireMessages");
    __name(requireDeflate$1, "requireDeflate$1");
    strings = {};
    __name(requireStrings, "requireStrings");
    __name(requireZstream, "requireZstream");
    __name(requireDeflate, "requireDeflate");
    inflate$1 = {};
    inflate = {};
    __name(requireInffast, "requireInffast");
    __name(requireInftrees, "requireInftrees");
    __name(requireInflate$1, "requireInflate$1");
    __name(requireConstants, "requireConstants");
    __name(requireGzheader, "requireGzheader");
    __name(requireInflate, "requireInflate");
    __name(requirePako, "requirePako");
    !function(e5) {
      !function() {
        var t3 = {};
        function i2() {
          "undefined" != typeof process && false || console.log.apply(console, arguments);
        }
        __name(i2, "i");
        e5.exports = t3, function(e6, t4) {
          !function() {
            var t5 = function() {
              function e7(e8) {
                this.message = "JPEG error: " + e8;
              }
              __name(e7, "e");
              return e7.prototype = new Error(), e7.prototype.name = "JpegError", e7.constructor = e7, e7;
            }(), i3 = function() {
              var e7 = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), i4 = 4017, n3 = 799, a2 = 3406, o3 = 2276, s4 = 1567, l2 = 3784, u2 = 5793, h2 = 2896;
              function c3(e8) {
                null == e8 && (e8 = {}), null == e8.w && (e8.w = -1), this.V = e8.n, this.N = e8.w;
              }
              __name(c3, "c");
              function f2(e8, t6) {
                for (var i5, r5, n4, a3 = 0, o4 = [], s5 = 16; s5 > 0 && !e8[s5 - 1]; ) s5--;
                o4.push({ children: [], index: 0 });
                var l3 = o4[0];
                for (i5 = 0; i5 < s5; i5++) {
                  for (r5 = 0; r5 < e8[i5]; r5++) {
                    for ((l3 = o4.pop()).children[l3.index] = t6[a3]; l3.index > 0; ) l3 = o4.pop();
                    for (l3.index++, o4.push(l3); o4.length <= i5; ) o4.push(n4 = { children: [], index: 0 }), l3.children[l3.index] = n4.children, l3 = n4;
                    a3++;
                  }
                  i5 + 1 < s5 && (o4.push(n4 = { children: [], index: 0 }), l3.children[l3.index] = n4.children, l3 = n4);
                }
                return o4[0].children;
              }
              __name(f2, "f");
              function d(e8, t6, i5) {
                return 64 * ((e8.P + 1) * t6 + i5);
              }
              __name(d, "d");
              function p2(i5, n4, a3, o4, s5, l3, u3, h3, c4, f3) {
                null == f3 && (f3 = false);
                var p3, m2, _3, b2, y2, w, v2, x2, E2, k2, S2, A2 = a3.m, I = a3.Z, M2 = n4, T2 = 0, P = 0, B2 = 0, C2 = 0, R2 = 0, z2 = 0;
                function F() {
                  if (P > 0) return P--, T2 >> P & 1;
                  if (255 === (T2 = i5[n4++])) {
                    var e8 = i5[n4++];
                    if (e8) {
                      if (220 === e8 && f3) {
                        var o5 = r4(i5, n4 += 2);
                        if (n4 += 2, o5 > 0 && o5 !== a3.s) throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", o5);
                      } else if (217 === e8) {
                        if (f3) {
                          var s6 = 8 * R2;
                          if (s6 > 0 && s6 < a3.s / 10) throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", s6);
                        }
                        throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                      }
                      throw new t5("unexpected marker");
                    }
                  }
                  return P = 7, T2 >>> 7;
                }
                __name(F, "F");
                function N2(e8) {
                  for (var i6 = e8; ; ) {
                    switch (typeof (i6 = i6[F()])) {
                      case "number":
                        return i6;
                      case "object":
                        continue;
                    }
                    throw new t5("invalid huffman sequence");
                  }
                }
                __name(N2, "N");
                function O2(e8) {
                  for (var t6 = 0; e8 > 0; ) t6 = t6 << 1 | F(), e8--;
                  return t6;
                }
                __name(O2, "O");
                function D(e8) {
                  if (1 === e8) return 1 === F() ? 1 : -1;
                  var t6 = O2(e8);
                  return t6 >= 1 << e8 - 1 ? t6 : t6 + (-1 << e8) + 1;
                }
                __name(D, "D");
                function $(e8, t6, i6, r5, n5) {
                  var a4 = i6 % A2;
                  R2 = (i6 / A2 | 0) * e8.A + r5;
                  var o5 = a4 * e8.h + n5;
                  t6(e8, d(e8, R2, o5));
                }
                __name($, "$");
                function L2(e8, t6, i6) {
                  R2 = i6 / e8.P | 0;
                  var r5 = i6 % e8.P;
                  t6(e8, d(e8, R2, r5));
                }
                __name(L2, "L");
                var U = o4.length;
                for (v2 = I ? 0 === l3 ? 0 === h3 ? function(e8, t6) {
                  var i6 = N2(e8.J), r5 = 0 === i6 ? 0 : D(i6) << c4;
                  e8.D[t6] = e8.Q += r5;
                } : function(e8, t6) {
                  e8.D[t6] |= F() << c4;
                } : 0 === h3 ? function(t6, i6) {
                  if (B2 > 0) B2--;
                  else for (var r5 = l3, n5 = u3; r5 <= n5; ) {
                    var a4 = N2(t6.i), o5 = 15 & a4, s6 = a4 >> 4;
                    if (0 !== o5) {
                      var h4 = e7[r5 += s6];
                      t6.D[i6 + h4] = D(o5) * (1 << c4), r5++;
                    } else {
                      if (s6 < 15) {
                        B2 = O2(s6) + (1 << s6) - 1;
                        break;
                      }
                      r5 += 16;
                    }
                  }
                } : function(i6, r5) {
                  for (var n5, a4, o5 = l3, s6 = u3, h4 = 0; o5 <= s6; ) {
                    var f4 = r5 + e7[o5], d2 = i6.D[f4] < 0 ? -1 : 1;
                    switch (C2) {
                      case 0:
                        if (h4 = (a4 = N2(i6.i)) >> 4, 0 == (n5 = 15 & a4)) h4 < 15 ? (B2 = O2(h4) + (1 << h4), C2 = 4) : (h4 = 16, C2 = 1);
                        else {
                          if (1 !== n5) throw new t5("invalid ACn encoding");
                          p3 = D(n5), C2 = h4 ? 2 : 3;
                        }
                        continue;
                      case 1:
                      case 2:
                        i6.D[f4] ? i6.D[f4] += d2 * (F() << c4) : 0 == --h4 && (C2 = 2 === C2 ? 3 : 0);
                        break;
                      case 3:
                        i6.D[f4] ? i6.D[f4] += d2 * (F() << c4) : (i6.D[f4] = p3 << c4, C2 = 0);
                        break;
                      case 4:
                        i6.D[f4] && (i6.D[f4] += d2 * (F() << c4));
                    }
                    o5++;
                  }
                  4 === C2 && 0 == --B2 && (C2 = 0);
                } : function(t6, i6) {
                  var r5 = N2(t6.J), n5 = 0 === r5 ? 0 : D(r5), a4 = 1;
                  for (t6.D[i6] = t6.Q += n5; a4 < 64; ) {
                    var o5 = N2(t6.i), s6 = 15 & o5, l4 = o5 >> 4;
                    if (0 !== s6) {
                      var u4 = e7[a4 += l4];
                      t6.D[i6 + u4] = D(s6), a4++;
                    } else {
                      if (l4 < 15) break;
                      a4 += 16;
                    }
                  }
                }, E2 = 1 === U ? o4[0].P * o4[0].c : A2 * a3.R; z2 <= E2; ) {
                  var Z = s5 ? Math.min(E2 - z2, s5) : E2;
                  if (Z > 0) {
                    for (_3 = 0; _3 < U; _3++) o4[_3].Q = 0;
                    if (B2 = 0, 1 === U) for (m2 = o4[0], w = 0; w < Z; w++) L2(m2, v2, z2), z2++;
                    else for (w = 0; w < Z; w++) {
                      for (_3 = 0; _3 < U; _3++) for (k2 = (m2 = o4[_3]).h, S2 = m2.A, b2 = 0; b2 < S2; b2++) for (y2 = 0; y2 < k2; y2++) $(m2, v2, z2, b2, y2);
                      z2++;
                    }
                  }
                  if (P = 0, !(x2 = g(i5, n4))) break;
                  if (x2.u && (n4 = x2.offset), !(x2.M >= 65488 && x2.M <= 65495)) break;
                  n4 += 2;
                }
                return n4 - M2;
              }
              __name(p2, "p");
              function m(e8, r5, c4) {
                var f3, d2, p3, m2, _3, g2, b2, y2, w, v2, x2, E2, k2, S2, A2, I, M2, T2 = e8.$, P = e8.D;
                if (!T2) throw new t5("missing required Quantization Table.");
                for (var B2 = 0; B2 < 64; B2 += 8) w = P[r5 + B2], v2 = P[r5 + B2 + 1], x2 = P[r5 + B2 + 2], E2 = P[r5 + B2 + 3], k2 = P[r5 + B2 + 4], S2 = P[r5 + B2 + 5], A2 = P[r5 + B2 + 6], I = P[r5 + B2 + 7], w *= T2[B2], v2 | x2 | E2 | k2 | S2 | A2 | I ? (v2 *= T2[B2 + 1], x2 *= T2[B2 + 2], E2 *= T2[B2 + 3], k2 *= T2[B2 + 4], S2 *= T2[B2 + 5], A2 *= T2[B2 + 6], I *= T2[B2 + 7], d2 = (f3 = (f3 = u2 * w + 128 >> 8) + (d2 = u2 * k2 + 128 >> 8) + 1 >> 1) - d2, M2 = (p3 = x2) * l2 + (m2 = A2) * s4 + 128 >> 8, p3 = p3 * s4 - m2 * l2 + 128 >> 8, b2 = (_3 = (_3 = h2 * (v2 - I) + 128 >> 8) + (b2 = S2 << 4) + 1 >> 1) - b2, g2 = (y2 = (y2 = h2 * (v2 + I) + 128 >> 8) + (g2 = E2 << 4) + 1 >> 1) - g2, m2 = (f3 = f3 + (m2 = M2) + 1 >> 1) - m2, p3 = (d2 = d2 + p3 + 1 >> 1) - p3, M2 = _3 * o3 + y2 * a2 + 2048 >> 12, _3 = _3 * a2 - y2 * o3 + 2048 >> 12, y2 = M2, M2 = g2 * n3 + b2 * i4 + 2048 >> 12, g2 = g2 * i4 - b2 * n3 + 2048 >> 12, b2 = M2, c4[B2] = f3 + y2, c4[B2 + 7] = f3 - y2, c4[B2 + 1] = d2 + b2, c4[B2 + 6] = d2 - b2, c4[B2 + 2] = p3 + g2, c4[B2 + 5] = p3 - g2, c4[B2 + 3] = m2 + _3, c4[B2 + 4] = m2 - _3) : (M2 = u2 * w + 512 >> 10, c4[B2] = M2, c4[B2 + 1] = M2, c4[B2 + 2] = M2, c4[B2 + 3] = M2, c4[B2 + 4] = M2, c4[B2 + 5] = M2, c4[B2 + 6] = M2, c4[B2 + 7] = M2);
                for (var C2 = 0; C2 < 8; ++C2) w = c4[C2], (v2 = c4[C2 + 8]) | (x2 = c4[C2 + 16]) | (E2 = c4[C2 + 24]) | (k2 = c4[C2 + 32]) | (S2 = c4[C2 + 40]) | (A2 = c4[C2 + 48]) | (I = c4[C2 + 56]) ? (d2 = (f3 = 4112 + ((f3 = u2 * w + 2048 >> 12) + (d2 = u2 * k2 + 2048 >> 12) + 1 >> 1)) - d2, M2 = (p3 = x2) * l2 + (m2 = A2) * s4 + 2048 >> 12, p3 = p3 * s4 - m2 * l2 + 2048 >> 12, m2 = M2, b2 = (_3 = (_3 = h2 * (v2 - I) + 2048 >> 12) + (b2 = S2) + 1 >> 1) - b2, g2 = (y2 = (y2 = h2 * (v2 + I) + 2048 >> 12) + (g2 = E2) + 1 >> 1) - g2, M2 = _3 * o3 + y2 * a2 + 2048 >> 12, _3 = _3 * a2 - y2 * o3 + 2048 >> 12, y2 = M2, M2 = g2 * n3 + b2 * i4 + 2048 >> 12, g2 = g2 * i4 - b2 * n3 + 2048 >> 12, (w = (f3 = f3 + m2 + 1 >> 1) + y2) < 16 ? w = 0 : w >= 4080 ? w = 255 : w >>= 4, (v2 = (d2 = d2 + p3 + 1 >> 1) + (b2 = M2)) < 16 ? v2 = 0 : v2 >= 4080 ? v2 = 255 : v2 >>= 4, (x2 = (p3 = d2 - p3) + g2) < 16 ? x2 = 0 : x2 >= 4080 ? x2 = 255 : x2 >>= 4, (E2 = (m2 = f3 - m2) + _3) < 16 ? E2 = 0 : E2 >= 4080 ? E2 = 255 : E2 >>= 4, (k2 = m2 - _3) < 16 ? k2 = 0 : k2 >= 4080 ? k2 = 255 : k2 >>= 4, (S2 = p3 - g2) < 16 ? S2 = 0 : S2 >= 4080 ? S2 = 255 : S2 >>= 4, (A2 = d2 - b2) < 16 ? A2 = 0 : A2 >= 4080 ? A2 = 255 : A2 >>= 4, (I = f3 - y2) < 16 ? I = 0 : I >= 4080 ? I = 255 : I >>= 4, P[r5 + C2] = w, P[r5 + C2 + 8] = v2, P[r5 + C2 + 16] = x2, P[r5 + C2 + 24] = E2, P[r5 + C2 + 32] = k2, P[r5 + C2 + 40] = S2, P[r5 + C2 + 48] = A2, P[r5 + C2 + 56] = I) : (M2 = (M2 = u2 * w + 8192 >> 14) < -2040 ? 0 : M2 >= 2024 ? 255 : M2 + 2056 >> 4, P[r5 + C2] = M2, P[r5 + C2 + 8] = M2, P[r5 + C2 + 16] = M2, P[r5 + C2 + 24] = M2, P[r5 + C2 + 32] = M2, P[r5 + C2 + 40] = M2, P[r5 + C2 + 48] = M2, P[r5 + C2 + 56] = M2);
              }
              __name(m, "m");
              function _2(e8, t6) {
                for (var i5 = t6.P, r5 = t6.c, n4 = new Int16Array(64), a3 = 0; a3 < r5; a3++) for (var o4 = 0; o4 < i5; o4++) {
                  m(t6, d(t6, a3, o4), n4);
                }
                return t6.D;
              }
              __name(_2, "_");
              function g(e8, t6, i5) {
                null == i5 && (i5 = t6);
                var n4 = e8.length - 1, a3 = i5 < t6 ? i5 : t6;
                if (t6 >= n4) return null;
                var o4 = r4(e8, t6);
                if (o4 >= 65472 && o4 <= 65534) return { u: null, M: o4, offset: t6 };
                for (var s5 = r4(e8, a3); !(s5 >= 65472 && s5 <= 65534); ) {
                  if (++a3 >= n4) return null;
                  s5 = r4(e8, a3);
                }
                return { u: o4.toString(16), M: s5, offset: a3 };
              }
              __name(g, "g");
              return c3.prototype = { parse(i5, n4) {
                null == n4 && (n4 = {});
                var a3, o4, s5 = n4.F, l3 = 0, u3 = null, h3 = null, c4 = 0;
                function d2() {
                  var e8 = r4(i5, l3), t6 = (l3 += 2) + e8 - 2, n5 = g(i5, t6, l3);
                  n5 && n5.u && (t6 = n5.offset);
                  var a4 = i5.subarray(l3, t6);
                  return l3 += a4.length, a4;
                }
                __name(d2, "d");
                function m2(e8) {
                  for (var t6 = Math.ceil(e8.o / 8 / e8.X), i6 = Math.ceil(e8.s / 8 / e8.B), r5 = 0; r5 < e8.W.length; r5++) {
                    Z = e8.W[r5];
                    var n5 = Math.ceil(Math.ceil(e8.o / 8) * Z.h / e8.X), a4 = Math.ceil(Math.ceil(e8.s / 8) * Z.A / e8.B), o5 = t6 * Z.h, s6 = 64 * (i6 * Z.A) * (o5 + 1);
                    Z.D = new Int16Array(s6), Z.P = n5, Z.c = a4;
                  }
                  e8.m = t6, e8.R = i6;
                }
                __name(m2, "m");
                var b2 = [], y2 = [], w = [], v2 = r4(i5, l3);
                if (l3 += 2, 65496 !== v2) throw new t5("SOI not found");
                v2 = r4(i5, l3), l3 += 2;
                e: for (; 65497 !== v2; ) {
                  var x2, E2, k2;
                  switch (v2) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      var S2 = d2();
                      65504 === v2 && 74 === S2[0] && 70 === S2[1] && 73 === S2[2] && 70 === S2[3] && 0 === S2[4] && (u3 = { version: { d: S2[5], T: S2[6] }, K: S2[7], j: S2[8] << 8 | S2[9], H: S2[10] << 8 | S2[11], S: S2[12], I: S2[13], C: S2.subarray(14, 14 + 3 * S2[12] * S2[13]) }), 65518 === v2 && 65 === S2[0] && 100 === S2[1] && 111 === S2[2] && 98 === S2[3] && 101 === S2[4] && (h3 = { version: S2[5] << 8 | S2[6], k: S2[7] << 8 | S2[8], q: S2[9] << 8 | S2[10], a: S2[11] });
                      break;
                    case 65499:
                      for (var A2 = r4(i5, l3) + (l3 += 2) - 2; l3 < A2; ) {
                        var I = i5[l3++], M2 = new Uint16Array(64);
                        if (I >> 4) {
                          if (I >> 4 != 1) throw new t5("DQT - invalid table spec");
                          for (E2 = 0; E2 < 64; E2++) M2[e7[E2]] = r4(i5, l3), l3 += 2;
                        } else for (E2 = 0; E2 < 64; E2++) M2[e7[E2]] = i5[l3++];
                        b2[15 & I] = M2;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (a3) throw new t5("Only single frame JPEGs supported");
                      l3 += 2, (a3 = {}).G = 65473 === v2, a3.Z = 65474 === v2, a3.precision = i5[l3++];
                      var T2, P = r4(i5, l3), B2 = 0, C2 = 0;
                      l3 += 2, a3.s = s5 || P, a3.o = r4(i5, l3), l3 += 2, a3.W = [], a3._ = {};
                      var R2 = i5[l3++];
                      for (x2 = 0; x2 < R2; x2++) {
                        T2 = i5[l3];
                        var z2 = i5[l3 + 1] >> 4, F = 15 & i5[l3 + 1];
                        B2 < z2 && (B2 = z2), C2 < F && (C2 = F);
                        var N2 = i5[l3 + 2];
                        k2 = a3.W.push({ h: z2, A: F, L: N2, $: null }), a3._[T2] = k2 - 1, l3 += 3;
                      }
                      a3.X = B2, a3.B = C2, m2(a3);
                      break;
                    case 65476:
                      var O2 = r4(i5, l3);
                      for (l3 += 2, x2 = 2; x2 < O2; ) {
                        var D = i5[l3++], $ = new Uint8Array(16), L2 = 0;
                        for (E2 = 0; E2 < 16; E2++, l3++) L2 += $[E2] = i5[l3];
                        var U = new Uint8Array(L2);
                        for (E2 = 0; E2 < L2; E2++, l3++) U[E2] = i5[l3];
                        x2 += 17 + L2, (D >> 4 ? y2 : w)[15 & D] = f2($, U);
                      }
                      break;
                    case 65501:
                      o4 = r4(i5, l3 += 2), l3 += 2;
                      break;
                    case 65498:
                      var Z, j = 1 == ++c4 && !s5;
                      l3 += 2;
                      var G = i5[l3++], H = [];
                      for (x2 = 0; x2 < G; x2++) {
                        var Q = i5[l3++], W = a3._[Q];
                        (Z = a3.W[W]).index = Q;
                        var q = i5[l3++];
                        Z.J = w[q >> 4], Z.i = y2[15 & q], H.push(Z);
                      }
                      var V = i5[l3++], Y2 = i5[l3++], K = i5[l3++];
                      try {
                        var J = p2(i5, l3, a3, H, o4, V, Y2, K >> 4, 15 & K, j);
                        l3 += J;
                      } catch (e8) {
                        if (e8 instanceof DNLMarkerError) return this.parse(i5, { F: e8.s });
                        if (e8 instanceof EOIMarkerError) break e;
                        throw e8;
                      }
                      break;
                    case 65500:
                      l3 += 4;
                      break;
                    case 65535:
                      255 !== i5[l3] && l3--;
                      break;
                    default:
                      var X = g(i5, l3 - 2, l3 - 3);
                      if (X && X.u) {
                        l3 = X.offset;
                        break;
                      }
                      if (l3 >= i5.length - 1) break e;
                      throw new t5("JpegImage.parse - unknown marker: " + v2.toString(16));
                  }
                  v2 = r4(i5, l3), l3 += 2;
                }
                for (this.width = a3.o, this.height = a3.s, this.g = u3, this.b = h3, this.W = [], x2 = 0; x2 < a3.W.length; x2++) {
                  var ee = b2[(Z = a3.W[x2]).L];
                  ee && (Z.$ = ee), this.W.push({ index: Z.index, e: _2(0, Z), l: Z.h / a3.X, t: Z.A / a3.B, P: Z.P, c: Z.c });
                }
                this.p = this.W.length;
              }, Y(e8, t6, i5) {
                null == i5 && (i5 = false);
                var r5, n4, a3, o4, s5, l3, u3, h3, c4, f3, d2, p3, m2 = this.width / e8, _3 = this.height / t6, g2 = 0, b2 = this.W.length, y2 = e8 * t6 * b2, w = new Uint8ClampedArray(y2), v2 = new Uint32Array(e8), x2 = 4294967288;
                for (u3 = 0; u3 < b2; u3++) {
                  if (n4 = (r5 = this.W[u3]).l * m2, a3 = r5.t * _3, g2 = u3, d2 = r5.e, o4 = r5.P + 1 << 3, n4 !== p3) {
                    for (s5 = 0; s5 < e8; s5++) h3 = 0 | s5 * n4, v2[s5] = (h3 & x2) << 3 | 7 & h3;
                    p3 = n4;
                  }
                  for (l3 = 0; l3 < t6; l3++) for (f3 = o4 * ((h3 = 0 | l3 * a3) & x2) | (7 & h3) << 3, s5 = 0; s5 < e8; s5++) w[g2] = d2[f3 + v2[s5]], g2 += b2;
                }
                var E2 = this.V;
                if (i5 || 4 !== b2 || E2 || (E2 = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), E2) for (u3 = 0; u3 < y2; ) for (h3 = 0, c4 = 0; h3 < b2; h3++, u3++, c4 += 2) w[u3] = (w[u3] * E2[c4] >> 8) + E2[c4 + 1];
                return w;
              }, get f() {
                return this.b ? !!this.b.a : 3 === this.p ? 0 !== this.N && (82 !== this.W[0].index || 71 !== this.W[1].index || 66 !== this.W[2].index) : 1 === this.N;
              }, z: /* @__PURE__ */ __name(function(e8) {
                for (var t6, i5, r5, n4 = 0, a3 = e8.length; n4 < a3; n4 += 3) t6 = e8[n4], i5 = e8[n4 + 1], r5 = e8[n4 + 2], e8[n4] = t6 - 179.456 + 1.402 * r5, e8[n4 + 1] = t6 + 135.459 - 0.344 * i5 - 0.714 * r5, e8[n4 + 2] = t6 - 226.816 + 1.772 * i5;
                return e8;
              }, "z"), O: /* @__PURE__ */ __name(function(e8) {
                for (var t6, i5, r5, n4, a3 = 0, o4 = 0, s5 = e8.length; o4 < s5; o4 += 4) t6 = e8[o4], i5 = e8[o4 + 1], r5 = e8[o4 + 2], n4 = e8[o4 + 3], e8[a3++] = i5 * (-660635669420364e-19 * i5 + 437130475926232e-18 * r5 - 54080610064599e-18 * t6 + 48449797120281e-17 * n4 - 0.154362151871126) - 122.67195406894 + r5 * (-957964378445773e-18 * r5 + 817076911346625e-18 * t6 - 0.00477271405408747 * n4 + 1.53380253221734) + t6 * (961250184130688e-18 * t6 - 0.00266257332283933 * n4 + 0.48357088451265) + n4 * (-336197177618394e-18 * n4 + 0.484791561490776), e8[a3++] = 107.268039397724 + i5 * (219927104525741e-19 * i5 - 640992018297945e-18 * r5 + 659397001245577e-18 * t6 + 426105652938837e-18 * n4 - 0.176491792462875) + r5 * (-778269941513683e-18 * r5 + 0.00130872261408275 * t6 + 770482631801132e-18 * n4 - 0.151051492775562) + t6 * (0.00126935368114843 * t6 - 0.00265090189010898 * n4 + 0.25802910206845) + n4 * (-318913117588328e-18 * n4 - 0.213742400323665), e8[a3++] = i5 * (-570115196973677e-18 * i5 - 263409051004589e-19 * r5 + 0.0020741088115012 * t6 - 0.00288260236853442 * n4 + 0.814272968359295) - 20.810012546947 + r5 * (-153496057440975e-19 * r5 - 132689043961446e-18 * t6 + 560833691242812e-18 * n4 - 0.195152027534049) + t6 * (0.00174418132927582 * t6 - 0.00255243321439347 * n4 + 0.116935020465145) + n4 * (-343531996510555e-18 * n4 + 0.24165260232407);
                return e8.subarray(0, a3);
              }, "O"), r: /* @__PURE__ */ __name(function(e8) {
                for (var t6, i5, r5, n4 = 0, a3 = e8.length; n4 < a3; n4 += 4) t6 = e8[n4], i5 = e8[n4 + 1], r5 = e8[n4 + 2], e8[n4] = 434.456 - t6 - 1.402 * r5, e8[n4 + 1] = 119.541 - t6 + 0.344 * i5 + 0.714 * r5, e8[n4 + 2] = 481.816 - t6 - 1.772 * i5;
                return e8;
              }, "r"), U: /* @__PURE__ */ __name(function(e8) {
                for (var t6, i5, r5, n4, a3 = 0, o4 = 0, s5 = e8.length; o4 < s5; o4 += 4) t6 = e8[o4], i5 = e8[o4 + 1], r5 = e8[o4 + 2], n4 = e8[o4 + 3], e8[a3++] = 255 + t6 * (-6747147073602441e-20 * t6 + 8379262121013727e-19 * i5 + 2894718188643294e-19 * r5 + 0.003264231057537806 * n4 - 1.1185611867203937) + i5 * (26374107616089405e-21 * i5 - 8626949158638572e-20 * r5 - 2748769067499491e-19 * n4 - 0.02155688794978967) + r5 * (-3878099212869363e-20 * r5 - 3267808279485286e-19 * n4 + 0.0686742238595345) - n4 * (3361971776183937e-19 * n4 + 0.7430659151342254), e8[a3++] = 255 + t6 * (13596372813588848e-20 * t6 + 924537132573585e-18 * i5 + 10567359618683593e-20 * r5 + 4791864687436512e-19 * n4 - 0.3109689587515875) + i5 * (-23545346108370344e-20 * i5 + 2702845253534714e-19 * r5 + 0.0020200308977307156 * n4 - 0.7488052167015494) + r5 * (6834815998235662e-20 * r5 + 15168452363460973e-20 * n4 - 0.09751927774728933) - n4 * (3189131175883281e-19 * n4 + 0.7364883807733168), e8[a3++] = 255 + t6 * (13598650411385307e-21 * t6 + 12423956175490851e-20 * i5 + 4751985097583589e-19 * r5 - 36729317476630422e-22 * n4 - 0.05562186980264034) + i5 * (16141380598724676e-20 * i5 + 9692239130725186e-19 * r5 + 7782692450036253e-19 * n4 - 0.44015232367526463) + r5 * (5068882914068769e-22 * r5 + 0.0017778369011375071 * n4 - 0.7591454649749609) - n4 * (3435319965105553e-19 * n4 + 0.7063770186160144);
                return e8.subarray(0, a3);
              }, "U"), getData: /* @__PURE__ */ __name(function(e8) {
                var i5 = e8.width, r5 = e8.height, n4 = e8.forceRGB, a3 = e8.isSourcePDF;
                if (this.p > 4) throw new t5("Unsupported color mode");
                var o4 = this.Y(i5, r5, a3);
                if (1 === this.p && n4) {
                  for (var s5 = o4.length, l3 = new Uint8ClampedArray(3 * s5), u3 = 0, h3 = 0; h3 < s5; h3++) {
                    var c4 = o4[h3];
                    l3[u3++] = c4, l3[u3++] = c4, l3[u3++] = c4;
                  }
                  return l3;
                }
                if (3 === this.p && this.f) return this.z(o4);
                if (4 === this.p) {
                  if (this.f) return n4 ? this.O(o4) : this.r(o4);
                  if (n4) return this.U(o4);
                }
                return o4;
              }, "getData") }, c3;
            }();
            function r4(e7, t6) {
              return e7[t6] << 8 | e7[t6 + 1];
            }
            __name(r4, "r");
            e6.JpegDecoder = i3;
          }(), e6.encodeImage = function(t5, i3, r4, n3) {
            var a2 = { t256: [i3], t257: [r4], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1e3], t277: [4], t278: [r4], t279: [i3 * r4 * 4], t282: [[72, 1]], t283: [[72, 1]], t284: [1], t286: [[0, 1]], t287: [[0, 1]], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] };
            if (n3) for (var o3 in n3) a2[o3] = n3[o3];
            var s4 = new Uint8Array(e6.encode([a2])), l2 = new Uint8Array(t5), u2 = new Uint8Array(1e3 + i3 * r4 * 4);
            for (o3 = 0; o3 < s4.length; o3++) u2[o3] = s4[o3];
            for (o3 = 0; o3 < l2.length; o3++) u2[1e3 + o3] = l2[o3];
            return u2.buffer;
          }, e6.encode = function(t5) {
            var i3 = new Uint8Array(2e4), r4 = 4, n3 = e6._binBE;
            i3[0] = i3[1] = 77, n3.writeUshort(i3, 2, 42);
            var a2 = 8;
            n3.writeUint(i3, r4, a2), r4 += 4;
            for (var o3 = 0; o3 < t5.length; o3++) {
              var s4 = e6._writeIFD(n3, e6._types.basic, i3, a2, t5[o3]);
              a2 = s4[1], o3 < t5.length - 1 && (3 & a2 && (a2 += 4 - (3 & a2)), n3.writeUint(i3, s4[0], a2));
            }
            return i3.slice(0, a2).buffer;
          }, e6.decode = function(t5, r4) {
            null == r4 && (r4 = { parseMN: true, debug: false });
            var n3 = new Uint8Array(t5), a2 = 0, o3 = e6._binBE.readASCII(n3, a2, 2);
            a2 += 2;
            var s4 = "II" == o3 ? e6._binLE : e6._binBE;
            s4.readUshort(n3, a2), a2 += 2;
            var l2 = s4.readUint(n3, a2);
            a2 += 4;
            for (var u2 = []; ; ) {
              var h2 = s4.readUshort(n3, l2), c3 = s4.readUshort(n3, l2 + 4);
              if (0 != h2 && (c3 < 1 || 13 < c3)) {
                i2("error in TIFF");
                break;
              }
              if (e6._readIFD(s4, n3, l2, u2, 0, r4), 0 == (l2 = s4.readUint(n3, l2 + 2 + 12 * h2))) break;
            }
            return u2;
          }, e6.decodeImage = function(t5, r4, n3) {
            if (!r4.data) {
              var a2 = new Uint8Array(t5), o3 = e6._binBE.readASCII(a2, 0, 2);
              if (null != r4.t256) {
                r4.isLE = "II" == o3, r4.width = r4.t256[0], r4.height = r4.t257[0];
                var s4 = r4.t259 ? r4.t259[0] : 1, l2 = r4.t266 ? r4.t266[0] : 1;
                r4.t284 && 2 == r4.t284[0] && i2("PlanarConfiguration 2 should not be used!"), 7 == s4 && r4.t258 && r4.t258.length > 3 && (r4.t258 = r4.t258.slice(0, 3));
                var u2 = r4.t277 ? r4.t277[0] : 1, h2 = (r4.t258 ? r4.t258[0] : 1) * u2;
                1 == s4 && null != r4.t279 && r4.t278 && 32803 == r4.t262[0] && (h2 = Math.round(8 * r4.t279[0] / (r4.width * r4.t278[0]))), r4.t50885 && 4 == r4.t50885[0] && (h2 = 3 * r4.t258[0]);
                var c3 = 8 * Math.ceil(r4.width * h2 / 8), f2 = r4.t273;
                (null == f2 || r4.t322) && (f2 = r4.t324);
                var d = r4.t279;
                1 == s4 && 1 == f2.length && (d = [r4.height * (c3 >>> 3)]), (null == d || r4.t322) && (d = r4.t325);
                var p2 = new Uint8Array(r4.height * (c3 >>> 3)), m = 0;
                if (null != r4.t322) {
                  var _2 = r4.t322[0], g = r4.t323[0], b2 = Math.floor((r4.width + _2 - 1) / _2), y2 = Math.floor((r4.height + g - 1) / g), w = new Uint8Array(0 | Math.ceil(_2 * g * h2 / 8));
                  console.log("====", b2, y2);
                  for (var v2 = 0; v2 < y2; v2++) for (var x2 = 0; x2 < b2; x2++) {
                    var E2 = v2 * b2 + x2;
                    w.fill(0), e6.decode._decompress(r4, n3, a2, f2[E2], d[E2], s4, w, 0, l2, _2, g), 6 == s4 ? p2 = w : e6._copyTile(w, 0 | Math.ceil(_2 * h2 / 8), g, p2, 0 | Math.ceil(r4.width * h2 / 8), r4.height, 0 | Math.ceil(x2 * _2 * h2 / 8), v2 * g);
                  }
                  m = 8 * p2.length;
                } else {
                  if (null == f2) return;
                  var k2 = r4.t278 ? r4.t278[0] : r4.height;
                  k2 = Math.min(k2, r4.height);
                  for (E2 = 0; E2 < f2.length; E2++) e6.decode._decompress(r4, n3, a2, f2[E2], d[E2], s4, p2, 0 | Math.ceil(m / 8), l2, r4.width, k2), m += c3 * k2;
                  m = Math.min(m, 8 * p2.length);
                }
                r4.data = new Uint8Array(p2.buffer, 0, 0 | Math.ceil(m / 8));
              }
            }
          }, e6.decode._decompress = function(r4, n3, a2, o3, s4, l2, u2, h2, c3, f2, d) {
            if (r4.t271 && "Panasonic" == r4.t271[0] && r4.t45 && 6 == r4.t45[0] && (l2 = 34316), 1 == l2) for (var p2 = 0; p2 < s4; p2++) u2[h2 + p2] = a2[o3 + p2];
            else if (2 == l2) e6.decode._decodeG2(a2, o3, s4, u2, h2, f2, c3);
            else if (3 == l2) e6.decode._decodeG3(a2, o3, s4, u2, h2, f2, c3, !!r4.t292 && !(1 & ~r4.t292[0]));
            else if (4 == l2) e6.decode._decodeG4(a2, o3, s4, u2, h2, f2, c3);
            else if (5 == l2) e6.decode._decodeLZW(a2, o3, s4, u2, h2, 8);
            else if (6 == l2) e6.decode._decodeOldJPEG(r4, a2, o3, s4, u2, h2);
            else if (7 == l2 || 34892 == l2) e6.decode._decodeNewJPEG(r4, a2, o3, s4, u2, h2);
            else if (8 == l2 || 32946 == l2) {
              var m = new Uint8Array(a2.buffer, o3 + 2, s4 - 6), _2 = t4.inflateRaw(m);
              h2 + _2.length <= u2.length && u2.set(_2, h2);
            } else 9 == l2 ? e6.decode._decodeVC5(a2, o3, s4, u2, h2, r4.t33422) : 32767 == l2 ? e6.decode._decodeARW(r4, a2, o3, s4, u2, h2) : 32773 == l2 ? e6.decode._decodePackBits(a2, o3, s4, u2, h2) : 32809 == l2 ? e6.decode._decodeThunder(a2, o3, s4, u2, h2) : 34316 == l2 ? e6.decode._decodePanasonic(r4, a2, o3, s4, u2, h2) : 34713 == l2 ? e6.decode._decodeNikon(r4, n3, a2, o3, s4, u2, h2) : 34676 == l2 ? e6.decode._decodeLogLuv32(r4, a2, o3, s4, u2, h2) : i2("Unknown compression", l2);
            var g = r4.t258 ? Math.min(32, r4.t258[0]) : 1, b2 = r4.t277 ? r4.t277[0] : 1, y2 = g * b2 >>> 3, w = Math.ceil(g * b2 * f2 / 8);
            if (16 == g && !r4.isLE && null == r4.t33422) for (var v2 = 0; v2 < d; v2++) for (var x2 = h2 + v2 * w, E2 = 1; E2 < w; E2 += 2) {
              var k2 = u2[x2 + E2];
              u2[x2 + E2] = u2[x2 + E2 - 1], u2[x2 + E2 - 1] = k2;
            }
            if (r4.t317 && 2 == r4.t317[0]) for (v2 = 0; v2 < d; v2++) {
              var S2 = h2 + v2 * w;
              if (16 == g) for (p2 = y2; p2 < w; p2 += 2) {
                var A2 = (u2[S2 + p2 + 1] << 8 | u2[S2 + p2]) + (u2[S2 + p2 - y2 + 1] << 8 | u2[S2 + p2 - y2]);
                u2[S2 + p2] = 255 & A2, u2[S2 + p2 + 1] = A2 >>> 8 & 255;
              }
              else if (3 == b2) for (p2 = 3; p2 < w; p2 += 3) u2[S2 + p2] = u2[S2 + p2] + u2[S2 + p2 - 3] & 255, u2[S2 + p2 + 1] = u2[S2 + p2 + 1] + u2[S2 + p2 - 2] & 255, u2[S2 + p2 + 2] = u2[S2 + p2 + 2] + u2[S2 + p2 - 1] & 255;
              else for (p2 = y2; p2 < w; p2++) u2[S2 + p2] = u2[S2 + p2] + u2[S2 + p2 - y2] & 255;
            }
          }, e6.decode._decodePanasonic = function(e7, t5, i3, r4, n3, a2) {
            var o3, s4, l2, u2, h2, c3, f2, d, p2 = t5.buffer, m = e7.t2[0], _2 = e7.t3[0], g = e7.t10[0], b2 = e7.t45[0], y2 = 0, w = 0, v2 = 0, x2 = 0, E2 = 6 == b2 ? new Uint32Array(18) : new Uint8Array(16), k2 = [0, 0], S2 = [0, 0], A2 = 0, I = new Uint8Array(16384), M2 = new Uint16Array(n3.buffer);
            function T2(e8) {
              if (0 == v2) {
                var t6 = new Uint8Array(p2, i3 + w + 8184, 8200), r5 = new Uint8Array(p2, i3 + w, 8184);
                I.set(t6), I.set(r5, t6.length), w += 16384;
              }
              if (5 != b2) return (I[x2 = (v2 = v2 - e8 & 131071) >> 3 ^ 16368] | I[x2 + 1] << 8) >> (7 & v2) & ~(-1 << e8);
              for (o3 = 0; o3 < 16; o3++) E2[o3] = I[v2++], v2 &= 16383;
            }
            __name(T2, "T");
            function P(e8) {
              return I[v2 + 15 - e8];
            }
            __name(P, "P");
            function B2() {
              k2[0] = 0, k2[1] = 0, S2[0] = 0, S2[1] = 0;
            }
            __name(B2, "B");
            if (7 == b2) throw b2;
            if (6 == b2) {
              var C2 = 12 == g, R2 = C2 ? function() {
                E2[0] = P(0) << 4 | P(1) >> 4, E2[1] = 4095 & ((15 & P(1)) << 8 | P(2)), E2[2] = P(3) >> 6 & 3, E2[3] = (63 & P(3)) << 2 | P(4) >> 6, E2[4] = (63 & P(4)) << 2 | P(5) >> 6, E2[5] = (63 & P(5)) << 2 | P(6) >> 6, E2[6] = P(6) >> 4 & 3, E2[7] = (15 & P(6)) << 4 | P(7) >> 4, E2[8] = (15 & P(7)) << 4 | P(8) >> 4, E2[9] = (15 & P(8)) << 4 | P(9) >> 4, E2[10] = P(9) >> 2 & 3, E2[11] = (3 & P(9)) << 6 | P(10) >> 2, E2[12] = (3 & P(10)) << 6 | P(11) >> 2, E2[13] = (3 & P(11)) << 6 | P(12) >> 2, E2[14] = 3 & P(12), E2[15] = P(13), E2[16] = P(14), E2[17] = P(15), v2 += 16, x2 = 0;
              } : function() {
                E2[0] = P(0) << 6 | P(1) >> 2, E2[1] = 16383 & ((3 & P(1)) << 12 | P(2) << 4 | P(3) >> 4), E2[2] = P(3) >> 2 & 3, E2[3] = (3 & P(3)) << 8 | P(4), E2[4] = P(5) << 2 | P(6) >> 6, E2[5] = (63 & P(6)) << 4 | P(7) >> 4, E2[6] = P(7) >> 2 & 3, E2[7] = (3 & P(7)) << 8 | P(8), E2[8] = P(9) << 2 & 1020 | P(10) >> 6, E2[9] = 1023 & (P(10) << 4 | P(11) >> 4), E2[10] = P(11) >> 2 & 3, E2[11] = (3 & P(11)) << 8 | P(12), E2[12] = 1023 & (P(13) << 2 & 1020 | P(14) >> 6), E2[13] = 1023 & (P(14) << 4 | P(15) >> 4), v2 += 16, x2 = 0;
              }, z2 = C2 ? 14 : 11, F = C2 ? 128 : 512, N2 = C2 ? 2048 : 8192, O2 = C2 ? 16383 : 65535, D = C2 ? 4095 : 16383, $ = m / z2, L2 = 16 * $, U = C2 ? 18 : 14;
              for (c3 = 0; c3 < _2 - 15; c3 += 16) {
                var Z = Math.min(16, _2 - c3), j = L2 * Z;
                for (I = new Uint8Array(p2, i3 + y2, j), v2 = 0, y2 += j, d = 0, f2 = 0; d < Z; d++, f2 = 0) {
                  A2 = (c3 + d) * m;
                  for (var G = 0; G < $; G++) for (R2(), B2(), l2 = 0, h2 = 0, o3 = 0; o3 < z2; o3++) {
                    if (u2 = 1 & o3, o3 % 3 == 2) {
                      var H = x2 < U ? E2[x2++] : 0;
                      3 == H && (H = 4), h2 = F << H, l2 = 1 << H;
                    }
                    var Q = x2 < U ? E2[x2++] : 0;
                    k2[u2] ? (Q *= l2, h2 < N2 && S2[u2] > h2 && (Q += S2[u2] - h2), S2[u2] = Q) : (k2[u2] = Q, Q ? S2[u2] = Q : Q = S2[u2]), M2[A2 + f2++] = Q - 15 <= O2 ? Q - 15 & O2 : Q + 2147483633 >> 31 & D;
                  }
                }
              }
            } else if (5 == b2) {
              var W = 12 == g ? 10 : 9;
              for (c3 = 0; c3 < _2; c3++) for (f2 = 0; f2 < m; f2 += W) T2(0), 12 == g ? (M2[A2++] = ((15 & E2[1]) << 8) + E2[0], M2[A2++] = 16 * E2[2] + (E2[1] >> 4), M2[A2++] = ((15 & E2[4]) << 8) + E2[3], M2[A2++] = 16 * E2[5] + (E2[4] >> 4), M2[A2++] = ((15 & E2[7]) << 8) + E2[6], M2[A2++] = 16 * E2[8] + (E2[7] >> 4), M2[A2++] = ((15 & E2[10]) << 8) + E2[9], M2[A2++] = 16 * E2[11] + (E2[10] >> 4), M2[A2++] = ((15 & E2[13]) << 8) + E2[12], M2[A2++] = 16 * E2[14] + (E2[13] >> 4)) : 14 == g && (M2[A2++] = E2[0] + ((63 & E2[1]) << 8), M2[A2++] = (E2[1] >> 6) + 4 * E2[2] + ((15 & E2[3]) << 10), M2[A2++] = (E2[3] >> 4) + 16 * E2[4] + ((3 & E2[5]) << 12), M2[A2++] = ((252 & E2[5]) >> 2) + (E2[6] << 6), M2[A2++] = E2[7] + ((63 & E2[8]) << 8), M2[A2++] = (E2[8] >> 6) + 4 * E2[9] + ((15 & E2[10]) << 10), M2[A2++] = (E2[10] >> 4) + 16 * E2[11] + ((3 & E2[12]) << 12), M2[A2++] = ((252 & E2[12]) >> 2) + (E2[13] << 6), M2[A2++] = E2[14] + ((63 & E2[15]) << 8));
            } else {
              if (4 != b2) throw b2;
              for (c3 = 0; c3 < _2; c3++) for (f2 = 0; f2 < m; f2++) u2 = 1 & (o3 = f2 % 14), 0 == o3 && B2(), o3 % 3 == 2 && (l2 = 4 >> 3 - T2(2)), S2[u2] ? 0 != (s4 = T2(8)) && (k2[u2] -= 128 << l2, (k2[u2] < 0 || 4 == l2) && (k2[u2] &= ~(-1 << l2)), k2[u2] += s4 << l2) : (S2[u2] = T2(8), (S2[u2] || o3 > 11) && (k2[u2] = S2[u2] << 4 | T2(4))), M2[A2++] = k2[1 & f2];
            }
          }, e6.decode._decodeVC5 = /* @__PURE__ */ function() {
            var t5, i3, r4, n3 = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], a2 = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1];
            function o3(e7) {
              var t6 = e7[1], i4 = e7[0][t6 >>> 3] >>> 7 - (7 & t6) & 1;
              return e7[1]++, i4;
            }
            __name(o3, "o");
            function s4(e7, i4) {
              if (null == t5) {
                t5 = {};
                for (var r5 = 0; r5 < n3.length; r5 += 4) t5[n3[r5 + 1]] = n3.slice(r5, r5 + 4);
              }
              for (var a3 = o3(e7), s5 = t5[a3]; null == s5; ) a3 = a3 << 1 | o3(e7), s5 = t5[a3];
              var l3 = s5[3];
              0 != l3 && (l3 = 0 == o3(e7) ? l3 : -l3), i4[0] = s5[2], i4[1] = l3;
            }
            __name(s4, "s");
            function l2(e7, t6) {
              for (var i4 = 0; i4 < t6; i4++) 1 & ~e7 || e7++, e7 >>>= 1;
              return e7;
            }
            __name(l2, "l");
            function u2(e7, t6) {
              return e7 >> t6;
            }
            __name(u2, "u");
            function h2(e7, t6, i4, r5, n4, a3) {
              t6[i4] = u2(u2(11 * e7[n4] - 4 * e7[n4 + a3] + e7[n4 + a3 + a3] + 4, 3) + e7[r5], 1), t6[i4 + a3] = u2(u2(5 * e7[n4] + 4 * e7[n4 + a3] - e7[n4 + a3 + a3] + 4, 3) - e7[r5], 1);
            }
            __name(h2, "h");
            function c3(e7, t6, i4, r5, n4, a3) {
              var o4 = e7[n4 - a3] - e7[n4 + a3], s5 = e7[n4], l3 = e7[r5];
              t6[i4] = u2(u2(o4 + 4, 3) + s5 + l3, 1), t6[i4 + a3] = u2(u2(4 - o4, 3) + s5 - l3, 1);
            }
            __name(c3, "c");
            function f2(e7, t6, i4, r5, n4, a3) {
              t6[i4] = u2(u2(5 * e7[n4] + 4 * e7[n4 - a3] - e7[n4 - a3 - a3] + 4, 3) + e7[r5], 1), t6[i4 + a3] = u2(u2(11 * e7[n4] - 4 * e7[n4 - a3] + e7[n4 - a3 - a3] + 4, 3) - e7[r5], 1);
            }
            __name(f2, "f");
            function d(e7) {
              return e7 = r4[e7 = e7 < 0 ? 0 : e7 > 4095 ? 4095 : e7] >>> 2;
            }
            __name(d, "d");
            return function(t6, n4, o4, u3, p2, m) {
              u3 = new Uint16Array(u3.buffer);
              var _2, g, b2, y2, w, v2, x2, E2, k2 = Date.now(), S2 = e6._binBE, A2 = n4 + o4;
              n4 += 4;
              for (var I = 1 == m[0]; n4 < A2; ) {
                var M2 = S2.readShort(t6, n4), T2 = S2.readUshort(t6, n4 + 2);
                if (n4 += 4, 12 == M2) N2 = T2;
                else if (20 == M2) _2 = T2;
                else if (21 == M2) g = T2;
                else if (48 == M2) b2 = T2;
                else if (53 == M2) y2 = T2;
                else if (35 == M2) ;
                else if (62 == M2) w = T2;
                else if (101 == M2) ;
                else if (109 == M2) v2 = T2;
                else if (84 == M2) ;
                else if (106 == M2) ;
                else if (107 == M2) ;
                else if (108 == M2) ;
                else if (102 == M2) ;
                else if (104 == M2) ie = T2;
                else if (105 == M2) ;
                else {
                  var P = M2 < 0 ? -M2 : M2, B2 = 65280 & P, C2 = 0;
                  if (24576 & P && (8192 & P ? (C2 = 65535 & T2, C2 += (255 & P) << 16) : C2 = 65535 & T2), 24576 & ~P) {
                    if (16388 == P) n4 += 4 * C2;
                    else if (8192 != B2 && 8448 != B2 && 9216 != B2) throw P.toString(16);
                  } else {
                    if (null == x2) {
                      x2 = [];
                      for (var R2 = 0; R2 < 4; R2++) x2[R2] = new Int16Array((_2 >>> 1) * (g >>> 1));
                      E2 = new Int16Array((_2 >>> 1) * (g >>> 1)), i3 = new Int16Array(1024);
                      for (R2 = 0; R2 < 1024; R2++) {
                        var z2 = R2 - 512, F = Math.abs(z2), N2 = Math.floor(768 * F * F * F / 16581375) + F;
                        i3[R2] = Math.sign(z2) * N2;
                      }
                      r4 = new Uint16Array(4096);
                      for (R2 = 0; R2 < 4096; R2++) {
                        var O2 = R2, D = 65535 * (Math.pow(113, O2 / 4095) - 1) / 112;
                        r4[R2] = Math.min(D, 65535);
                      }
                    }
                    var $ = x2[w], L2 = l2(_2, 1 + a2[b2]), U = l2(g, 1 + a2[b2]);
                    if (0 == b2) for (var Z = 0; Z < U; Z++) for (var j = 0; j < L2; j++) {
                      var G = n4 + 2 * (Z * L2 + j);
                      $[Z * (_2 >>> 1) + j] = t6[G] << 8 | t6[G + 1];
                    }
                    else {
                      var H = [t6, 8 * n4], Q = [], W = 0, q = L2 * U, V = [0, 0], Y2 = 0;
                      for (T2 = 0; W < q; ) for (s4(H, V), Y2 = V[0], T2 = V[1]; Y2 > 0; ) Q[W++] = T2, Y2--;
                      var K = (b2 - 1) % 3, J = 1 != K ? L2 : 0, X = 0 != K ? U : 0;
                      for (Z = 0; Z < U; Z++) {
                        var ee = (Z + X) * (_2 >>> 1) + J, te = Z * L2;
                        for (j = 0; j < L2; j++) $[ee + j] = i3[Q[te + j] + 512] * y2;
                      }
                      if (2 == K) {
                        var ie = _2 >>> 1, re = 2 * L2, ne = 2 * U;
                        for (Z = 0; Z < U; Z++) for (j = 0; j < re; j++) {
                          R2 = 2 * Z * ie + j;
                          var ae = U * ie + (se = Z * ie + j);
                          0 == Z ? h2($, E2, R2, ae, se, ie) : Z == U - 1 ? f2($, E2, R2, ae, se, ie) : c3($, E2, R2, ae, se, ie);
                        }
                        var oe = $;
                        $ = E2, E2 = oe;
                        for (Z = 0; Z < ne; Z++) for (j = 0; j < L2; j++) {
                          var se;
                          R2 = Z * ie + 2 * j, ae = L2 + (se = Z * ie + j);
                          0 == j ? h2($, E2, R2, ae, se, 1) : j == L2 - 1 ? f2($, E2, R2, ae, se, 1) : c3($, E2, R2, ae, se, 1);
                        }
                        oe = $;
                        $ = E2, E2 = oe;
                        for (var le = [], ue = 2 - ~~((b2 - 1) / 3), he = 0; he < 3; he++) le[he] = v2 >> 14 - 2 * he & 3;
                        var ce = le[ue];
                        if (0 != ce) for (Z = 0; Z < ne; Z++) for (j = 0; j < re; j++) {
                          $[R2 = Z * ie + j] = $[R2] << ce;
                        }
                      }
                    }
                    if (9 == b2 && 3 == w) {
                      var fe = x2[0], de = x2[1], pe = x2[2], me = x2[3];
                      for (Z = 0; Z < g; Z += 2) for (j = 0; j < _2; j += 2) {
                        var _e = Z * _2 + j, ge = fe[G = (Z >>> 1) * (_2 >>> 1) + (j >>> 1)], be = de[G] - 2048, ye = pe[G] - 2048, we = me[G] - 2048, ve = (be << 1) + ge, xe = (ye << 1) + ge, Ee = ge + we, ke = ge - we;
                        I ? (u3[_e] = d(Ee), u3[_e + 1] = d(xe), u3[_e + _2] = d(ve), u3[_e + _2 + 1] = d(ke)) : (u3[_e] = d(ve), u3[_e + 1] = d(Ee), u3[_e + _2] = d(ke), u3[_e + _2 + 1] = d(xe));
                      }
                    }
                    n4 += 4 * C2;
                  }
                }
              }
              console.log(Date.now() - k2);
            };
          }(), e6.decode._decodeLogLuv32 = function(e7, t5, i3, r4, n3, a2) {
            for (var o3 = e7.width, s4 = 4 * o3, l2 = 0, u2 = new Uint8Array(s4); l2 < r4; ) {
              for (var h2 = 0; h2 < s4; ) {
                var c3 = t5[i3 + l2];
                if (l2++, c3 < 128) {
                  for (var f2 = 0; f2 < c3; f2++) u2[h2 + f2] = t5[i3 + l2 + f2];
                  h2 += c3, l2 += c3;
                } else {
                  c3 -= 126;
                  for (f2 = 0; f2 < c3; f2++) u2[h2 + f2] = t5[i3 + l2];
                  h2 += c3, l2++;
                }
              }
              for (var d = 0; d < o3; d++) n3[a2 + 0] = u2[d], n3[a2 + 1] = u2[d + o3], n3[a2 + 2] = u2[d + 2 * o3], n3[a2 + 4] = u2[d + 3 * o3], a2 += 6;
            }
          }, e6.decode._ljpeg_diff = function(t5, i3, r4) {
            var n3, a2, o3 = e6.decode._getbithuff;
            return n3 = o3(t5, i3, r4[0], r4), (a2 = o3(t5, i3, n3, 0)) & 1 << n3 - 1 || (a2 -= (1 << n3) - 1), a2;
          }, e6.decode._decodeARW = function(t5, i3, r4, n3, a2, o3) {
            var s4 = t5.t256[0], l2 = t5.t257[0], u2 = t5.t258[0], h2 = t5.isLE ? e6._binLE : e6._binBE;
            if (s4 * l2 == n3 || s4 * l2 * 1.5 == n3) if (s4 * l2 * 1.5 != n3) {
              var c3, f2, d, p2, m, _2, g, b2, y2 = new Uint16Array(16), w = new Uint8Array(s4 + 1);
              for (M2 = 0; M2 < l2; M2++) {
                for (var v2 = 0; v2 < s4; v2++) w[v2] = i3[r4++];
                for (b2 = 0, I = 0; I < s4 - 30; b2 += 16) {
                  for (f2 = 2047 & (c3 = h2.readUint(w, b2)), d = 2047 & c3 >>> 11, p2 = 15 & c3 >>> 22, m = 15 & c3 >>> 26, _2 = 0; _2 < 4 && 128 << _2 <= f2 - d; _2++) ;
                  for (g = 30, x2 = 0; x2 < 16; x2++) x2 == p2 ? y2[x2] = f2 : x2 == m ? y2[x2] = d : (y2[x2] = ((h2.readUshort(w, b2 + (g >> 3)) >>> (7 & g) & 127) << _2) + d, y2[x2] > 2047 && (y2[x2] = 2047), g += 7);
                  for (x2 = 0; x2 < 16; x2++, I += 2) {
                    N2 = y2[x2] << 1;
                    e6.decode._putsF(a2, (M2 * s4 + I) * u2, N2 << 16 - u2);
                  }
                  I -= 1 & I ? 1 : 31;
                }
              }
            } else for (var x2 = 0; x2 < n3; x2 += 3) {
              var E2 = i3[r4 + x2 + 0], k2 = i3[r4 + x2 + 1], S2 = i3[r4 + x2 + 2];
              a2[o3 + x2] = k2 << 4 | E2 >>> 4, a2[o3 + x2 + 1] = E2 << 4 | S2 >>> 4, a2[o3 + x2 + 2] = S2 << 4 | k2 >>> 4;
            }
            else {
              l2 += 8;
              var A2, I, M2, T2 = [r4, 0, 0, 0], P = new Uint16Array(32770), B2 = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], C2 = 0, R2 = e6.decode._ljpeg_diff;
              for (P[0] = 15, A2 = x2 = 0; x2 < 18; x2++) for (var z2 = 32768 >>> (B2[x2] >>> 8), F = 0; F < z2; F++) P[++A2] = B2[x2];
              for (I = s4; I--; ) for (M2 = 0; M2 < l2 + 1; M2 += 2) if (M2 == l2 && (M2 = 1), C2 += R2(i3, T2, P), M2 < l2) {
                var N2 = 4095 & C2;
                e6.decode._putsF(a2, (M2 * s4 + I) * u2, N2 << 16 - u2);
              }
            }
          }, e6.decode._decodeNikon = function(t5, i3, r4, n3, a2, o3, s4) {
            var l2 = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], u2 = t5.t256[0], h2 = t5.t257[0], c3 = t5.t258[0], f2 = 0, d = 0, p2 = e6.decode._make_decoder, m = e6.decode._getbithuff, _2 = i3[0].exifIFD.makerNote, g = _2.t150 ? _2.t150 : _2.t140, b2 = 0, y2 = g[b2++], w = g[b2++];
            73 != y2 && 88 != w || (b2 += 2110), 70 == y2 && (f2 = 2), 14 == c3 && (f2 += 3);
            for (var v2 = [[0, 0], [0, 0]], x2 = t5.isLE ? e6._binLE : e6._binBE, E2 = 0; E2 < 2; E2++) for (var k2 = 0; k2 < 2; k2++) v2[E2][k2] = x2.readShort(g, b2), b2 += 2;
            var S2, A2, I, M2, T2, P = 1 << c3 & 32767, B2 = 0, C2 = x2.readShort(g, b2);
            b2 += 2, C2 > 1 && (B2 = Math.floor(P / (C2 - 1))), 68 == y2 && 32 == w && B2 > 0 && (d = x2.readShort(g, 562));
            var R2 = [0, 0], z2 = p2(l2[f2]), F = [n3, 0, 0, 0];
            for (S2 = 0; S2 < h2; S2++) for (d && S2 == d && (z2 = p2(l2[f2 + 1])), A2 = 0; A2 < u2; A2++) {
              E2 = m(r4, F, z2[0], z2), (T2 = 1 + (m(r4, F, (I = 15 & E2) - (M2 = E2 >>> 4), 0) << 1) << M2 >>> 1) & 1 << I - 1 || (T2 -= (1 << I) - (0 == M2 ? 1 : 0)), A2 < 2 ? R2[A2] = v2[1 & S2][A2] += T2 : R2[1 & A2] += T2;
              var N2 = Math.min(Math.max(R2[1 & A2], 0), (1 << c3) - 1), O2 = (S2 * u2 + A2) * c3;
              e6.decode._putsF(o3, O2, N2 << 16 - c3);
            }
          }, e6.decode._putsF = function(e7, t5, i3) {
            i3 <<= 8 - (7 & t5);
            var r4 = t5 >>> 3;
            e7[r4] |= i3 >>> 16, e7[r4 + 1] |= i3 >>> 8, e7[r4 + 2] |= i3;
          }, e6.decode._getbithuff = function(t5, i3, r4, n3) {
            var a2;
            e6.decode._get_byte;
            var o3 = i3[0], s4 = i3[1], l2 = i3[2], u2 = i3[3];
            if (0 == r4 || l2 < 0) return 0;
            for (; !u2 && l2 < r4 && -1 != (a2 = t5[o3++]) && !(u2 = 0); ) s4 = (s4 << 8) + a2, l2 += 8;
            if (a2 = s4 << 32 - l2 >>> 32 - r4, n3 ? (l2 -= n3[a2 + 1] >>> 8, a2 = 255 & n3[a2 + 1]) : l2 -= r4, l2 < 0) throw "e";
            return i3[0] = o3, i3[1] = s4, i3[2] = l2, i3[3] = u2, a2;
          }, e6.decode._make_decoder = function(e7) {
            var t5, i3, r4, n3, a2, o3 = [];
            for (t5 = 16; 0 != t5 && !e7[t5]; t5--) ;
            var s4 = 17;
            for (o3[0] = t5, r4 = i3 = 1; i3 <= t5; i3++) for (n3 = 0; n3 < e7[i3]; n3++, ++s4) for (a2 = 0; a2 < 1 << t5 - i3; a2++) r4 <= 1 << t5 && (o3[r4++] = i3 << 8 | e7[s4]);
            return o3;
          }, e6.decode._decodeNewJPEG = function(t5, i3, r4, n3, a2, o3) {
            n3 = Math.min(n3, i3.length - r4);
            var s4 = t5.t347, l2 = s4 ? s4.length : 0, u2 = new Uint8Array(l2 + n3);
            if (s4) {
              for (var h2 = 0, c3 = 0; c3 < l2 - 1 && (255 != s4[c3] || 217 != s4[c3 + 1]); c3++) u2[h2++] = s4[c3];
              var f2 = i3[r4], d = i3[r4 + 1];
              255 == f2 && 216 == d || (u2[h2++] = f2, u2[h2++] = d);
              for (c3 = 2; c3 < n3; c3++) u2[h2++] = i3[r4 + c3];
            } else for (c3 = 0; c3 < n3; c3++) u2[c3] = i3[r4 + c3];
            if (32803 == t5.t262[0] || 7 == t5.t259[0] && 34892 == t5.t262[0]) {
              var p2 = t5.t258[0], m = e6.LosslessJpegDecode(u2), _2 = m.length;
              if (16 == p2) if (t5.isLE) for (c3 = 0; c3 < _2; c3++) a2[o3 + (c3 << 1)] = 255 & m[c3], a2[o3 + (c3 << 1) + 1] = m[c3] >>> 8;
              else for (c3 = 0; c3 < _2; c3++) a2[o3 + (c3 << 1)] = m[c3] >>> 8, a2[o3 + (c3 << 1) + 1] = 255 & m[c3];
              else if (14 == p2 || 12 == p2 || 10 == p2) {
                var g = 16 - p2;
                for (c3 = 0; c3 < _2; c3++) e6.decode._putsF(a2, c3 * p2, m[c3] << g);
              } else {
                if (8 != p2) throw new Error("unsupported bit depth " + p2);
                for (c3 = 0; c3 < _2; c3++) a2[o3 + c3] = m[c3];
              }
            } else {
              var b2 = new e6.JpegDecoder();
              b2.parse(u2);
              var y2 = b2.getData({ width: b2.width, height: b2.height, forceRGB: true, isSourcePDF: false });
              for (c3 = 0; c3 < y2.length; c3++) a2[o3 + c3] = y2[c3];
            }
            6 == t5.t262[0] && (t5.t262[0] = 2);
          }, e6.decode._decodeOldJPEGInit = function(e7, t5, r4, n3) {
            var a2, o3, s4, l2, u2, h2 = 216, c3 = 0, f2 = 0, d = false, p2 = e7.t513, m = p2 ? p2[0] : 0, _2 = e7.t514, g = _2 ? _2[0] : 0, b2 = e7.t324 || e7.t273 || p2, y2 = e7.t530, w = 0, v2 = 0, x2 = e7.t277 ? e7.t277[0] : 1, E2 = e7.t515;
            if (b2 && (f2 = b2[0], d = b2.length > 1), !d) {
              if (255 == t5[r4] && t5[r4 + 1] == h2) return { jpegOffset: r4 };
              if (null != p2 && (255 == t5[r4 + m] && t5[r4 + m + 1] == h2 ? c3 = r4 + m : i2("JPEGInterchangeFormat does not point to SOI"), null == _2 ? i2("JPEGInterchangeFormatLength field is missing") : (m >= f2 || m + g <= f2) && i2("JPEGInterchangeFormatLength field value is invalid"), null != c3)) return { jpegOffset: c3 };
            }
            if (null != y2 && (w = y2[0], v2 = y2[1]), null != p2 && null != _2) if (g >= 2 && m + g <= f2) {
              for (a2 = 255 == t5[r4 + m + g - 2] && t5[r4 + m + g - 1] == h2 ? new Uint8Array(g - 2) : new Uint8Array(g), s4 = 0; s4 < a2.length; s4++) a2[s4] = t5[r4 + m + s4];
              i2("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else i2("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
            if (null == a2) {
              var k2 = 0, S2 = [];
              S2[k2++] = 255, S2[k2++] = h2;
              var A2 = e7.t519;
              if (null == A2) throw new Error("JPEGQTables tag is missing");
              for (s4 = 0; s4 < A2.length; s4++) for (S2[k2++] = 255, S2[k2++] = 219, S2[k2++] = 0, S2[k2++] = 67, S2[k2++] = s4, l2 = 0; l2 < 64; l2++) S2[k2++] = t5[r4 + A2[s4] + l2];
              for (u2 = 0; u2 < 2; u2++) {
                var I = e7[0 == u2 ? "t520" : "t521"];
                if (null == I) throw new Error((0 == u2 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                for (s4 = 0; s4 < I.length; s4++) {
                  S2[k2++] = 255, S2[k2++] = 196;
                  var M2 = 19;
                  for (l2 = 0; l2 < 16; l2++) M2 += t5[r4 + I[s4] + l2];
                  for (S2[k2++] = M2 >>> 8, S2[k2++] = 255 & M2, S2[k2++] = s4 | u2 << 4, l2 = 0; l2 < 16; l2++) S2[k2++] = t5[r4 + I[s4] + l2];
                  for (l2 = 0; l2 < M2; l2++) S2[k2++] = t5[r4 + I[s4] + 16 + l2];
                }
              }
              if (S2[k2++] = 255, S2[k2++] = 192, S2[k2++] = 0, S2[k2++] = 8 + 3 * x2, S2[k2++] = 8, S2[k2++] = e7.height >>> 8 & 255, S2[k2++] = 255 & e7.height, S2[k2++] = e7.width >>> 8 & 255, S2[k2++] = 255 & e7.width, S2[k2++] = x2, 1 == x2) S2[k2++] = 1, S2[k2++] = 17, S2[k2++] = 0;
              else for (s4 = 0; s4 < 3; s4++) S2[k2++] = s4 + 1, S2[k2++] = 0 != s4 ? 17 : (15 & w) << 4 | 15 & v2, S2[k2++] = s4;
              null != E2 && 0 != E2[0] && (S2[k2++] = 255, S2[k2++] = 221, S2[k2++] = 0, S2[k2++] = 4, S2[k2++] = E2[0] >>> 8 & 255, S2[k2++] = 255 & E2[0]), a2 = new Uint8Array(S2);
            }
            var T2 = -1;
            for (s4 = 0; s4 < a2.length - 1; ) {
              if (255 == a2[s4] && 192 == a2[s4 + 1]) {
                T2 = s4;
                break;
              }
              s4++;
            }
            if (-1 == T2) {
              var P = new Uint8Array(a2.length + 10 + 3 * x2);
              P.set(a2);
              var B2 = a2.length;
              if (T2 = a2.length, (a2 = P)[B2++] = 255, a2[B2++] = 192, a2[B2++] = 0, a2[B2++] = 8 + 3 * x2, a2[B2++] = 8, a2[B2++] = e7.height >>> 8 & 255, a2[B2++] = 255 & e7.height, a2[B2++] = e7.width >>> 8 & 255, a2[B2++] = 255 & e7.width, a2[B2++] = x2, 1 == x2) a2[B2++] = 1, a2[B2++] = 17, a2[B2++] = 0;
              else for (s4 = 0; s4 < 3; s4++) a2[B2++] = s4 + 1, a2[B2++] = 0 != s4 ? 17 : (15 & w) << 4 | 15 & v2, a2[B2++] = s4;
            }
            if (255 == t5[f2] && 218 == t5[f2 + 1]) {
              var C2 = t5[f2 + 2] << 8 | t5[f2 + 3];
              for ((o3 = new Uint8Array(C2 + 2))[0] = t5[f2], o3[1] = t5[f2 + 1], o3[2] = t5[f2 + 2], o3[3] = t5[f2 + 3], s4 = 0; s4 < C2 - 2; s4++) o3[s4 + 4] = t5[f2 + s4 + 4];
            } else {
              var R2 = 0;
              if ((o3 = new Uint8Array(8 + 2 * x2))[R2++] = 255, o3[R2++] = 218, o3[R2++] = 0, o3[R2++] = 6 + 2 * x2, o3[R2++] = x2, 1 == x2) o3[R2++] = 1, o3[R2++] = 0;
              else for (s4 = 0; s4 < 3; s4++) o3[R2++] = s4 + 1, o3[R2++] = s4 << 4 | s4;
              o3[R2++] = 0, o3[R2++] = 63, o3[R2++] = 0;
            }
            return { jpegOffset: r4, tables: a2, sosMarker: o3, sofPosition: T2 };
          }, e6.decode._decodeOldJPEG = function(t5, i3, r4, n3, a2, o3) {
            var s4, l2, u2, h2, c3 = e6.decode._decodeOldJPEGInit(t5, i3, r4, n3);
            if (null != c3.jpegOffset) for (s4 = r4 + n3 - c3.jpegOffset, u2 = new Uint8Array(s4), p2 = 0; p2 < s4; p2++) u2[p2] = i3[c3.jpegOffset + p2];
            else {
              for (l2 = c3.tables.length, (u2 = new Uint8Array(l2 + c3.sosMarker.length + n3 + 2)).set(c3.tables), h2 = l2, u2[c3.sofPosition + 5] = t5.height >>> 8 & 255, u2[c3.sofPosition + 6] = 255 & t5.height, u2[c3.sofPosition + 7] = t5.width >>> 8 & 255, u2[c3.sofPosition + 8] = 255 & t5.width, 255 == i3[r4] && i3[r4 + 1] == SOS || (u2.set(c3.sosMarker, h2), h2 += sosMarker.length), p2 = 0; p2 < n3; p2++) u2[h2++] = i3[r4 + p2];
              u2[h2++] = 255, u2[h2++] = EOI;
            }
            var f2 = new e6.JpegDecoder();
            f2.parse(u2);
            for (var d = f2.getData({ width: f2.width, height: f2.height, forceRGB: true, isSourcePDF: false }), p2 = 0; p2 < d.length; p2++) a2[o3 + p2] = d[p2];
            t5.t262 && 6 == t5.t262[0] && (t5.t262[0] = 2);
          }, e6.decode._decodePackBits = function(e7, t5, i3, r4, n3) {
            for (var a2 = new Int8Array(e7.buffer), o3 = new Int8Array(r4.buffer), s4 = t5 + i3; t5 < s4; ) {
              var l2 = a2[t5];
              if (t5++, l2 >= 0 && l2 < 128) for (var u2 = 0; u2 < l2 + 1; u2++) o3[n3] = a2[t5], n3++, t5++;
              if (l2 >= -127 && l2 < 0) {
                for (u2 = 0; u2 < 1 - l2; u2++) o3[n3] = a2[t5], n3++;
                t5++;
              }
            }
            return n3;
          }, e6.decode._decodeThunder = function(e7, t5, i3, r4, n3) {
            for (var a2 = [0, 1, 0, -1], o3 = [0, 1, 2, 3, 0, -3, -2, -1], s4 = t5 + i3, l2 = 2 * n3, u2 = 0; t5 < s4; ) {
              var h2 = e7[t5], c3 = h2 >>> 6, f2 = 63 & h2;
              if (t5++, 3 == c3 && (u2 = 15 & f2, r4[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++), 0 == c3) for (var d = 0; d < f2; d++) r4[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++;
              if (2 == c3) for (d = 0; d < 2; d++) {
                4 != (p2 = f2 >>> 3 * (1 - d) & 7) && (u2 += o3[p2], r4[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++);
              }
              if (1 == c3) for (d = 0; d < 3; d++) {
                var p2;
                2 != (p2 = f2 >>> 2 * (2 - d) & 3) && (u2 += a2[p2], r4[l2 >>> 1] |= u2 << 4 * (1 - l2 & 1), l2++);
              }
            }
          }, e6.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, e6.decode._lens = function() {
            var e7 = /* @__PURE__ */ __name(function(e8, t6, i4, r5) {
              for (var n4 = 0; n4 < t6.length; n4++) e8[t6[n4]] = i4 + n4 * r5;
            }, "e"), t5 = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", i3 = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", r4 = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", n3 = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", a2 = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
            t5 = t5.split(","), i3 = i3.split(","), r4 = r4.split(","), n3 = n3.split(","), a2 = a2.split(",");
            var o3 = {}, s4 = {};
            return e7(o3, t5, 0, 1), e7(o3, r4, 64, 64), e7(o3, a2, 1792, 64), e7(s4, i3, 0, 1), e7(s4, n3, 64, 64), e7(s4, a2, 1792, 64), [o3, s4];
          }(), e6.decode._decodeG4 = function(t5, i3, r4, n3, a2, o3, s4) {
            for (var l2 = e6.decode, u2 = i3 << 3, h2 = 0, c3 = "", f2 = [], d = [], p2 = 0; p2 < o3; p2++) d.push(0);
            d = l2._makeDiff(d);
            for (var m = 0, _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0, v2 = "", x2 = 0, E2 = 8 * Math.ceil(o3 / 8); u2 >>> 3 < i3 + r4; ) {
              g = l2._findDiff(d, m + (0 == m ? 0 : 1), 1 - y2), b2 = l2._findDiff(d, g, y2);
              var k2 = 0;
              if (1 == s4 && (k2 = t5[u2 >>> 3] >>> 7 - (7 & u2) & 1), 2 == s4 && (k2 = t5[u2 >>> 3] >>> (7 & u2) & 1), u2++, c3 += k2, "H" == v2) {
                if (null != l2._lens[y2][c3]) {
                  var S2 = l2._lens[y2][c3];
                  c3 = "", h2 += S2, S2 < 64 && (l2._addNtimes(f2, h2, y2), m += h2, y2 = 1 - y2, h2 = 0, 0 == --x2 && (v2 = ""));
                }
              } else "0001" == c3 && (c3 = "", l2._addNtimes(f2, b2 - m, y2), m = b2), "001" == c3 && (c3 = "", v2 = "H", x2 = 2), null != l2._dmap[c3] && (_2 = g + l2._dmap[c3], l2._addNtimes(f2, _2 - m, y2), m = _2, c3 = "", y2 = 1 - y2);
              f2.length == o3 && "" == v2 && (l2._writeBits(f2, n3, 8 * a2 + w * E2), y2 = 0, w++, m = 0, d = l2._makeDiff(f2), f2 = []);
            }
          }, e6.decode._findDiff = function(e7, t5, i3) {
            for (var r4 = 0; r4 < e7.length; r4 += 2) if (e7[r4] >= t5 && e7[r4 + 1] == i3) return e7[r4];
          }, e6.decode._makeDiff = function(e7) {
            var t5 = [];
            1 == e7[0] && t5.push(0, 1);
            for (var i3 = 1; i3 < e7.length; i3++) e7[i3 - 1] != e7[i3] && t5.push(i3, e7[i3]);
            return t5.push(e7.length, 0, e7.length, 1), t5;
          }, e6.decode._decodeG2 = function(t5, i3, r4, n3, a2, o3, s4) {
            for (var l2 = e6.decode, u2 = i3 << 3, h2 = 0, c3 = "", f2 = [], d = 0, p2 = 0, m = 8 * Math.ceil(o3 / 8); u2 >>> 3 < i3 + r4; ) {
              var _2 = 0;
              1 == s4 && (_2 = t5[u2 >>> 3] >>> 7 - (7 & u2) & 1), 2 == s4 && (_2 = t5[u2 >>> 3] >>> (7 & u2) & 1), u2++, c3 += _2, null != (h2 = l2._lens[d][c3]) && (l2._addNtimes(f2, h2, d), c3 = "", h2 < 64 && (d = 1 - d), f2.length == o3 && (l2._writeBits(f2, n3, 8 * a2 + p2 * m), f2 = [], p2++, d = 0, 7 & u2 && (u2 += 8 - (7 & u2)), h2 >= 64 && (u2 += 8)));
            }
          }, e6.decode._decodeG3 = function(t5, i3, r4, n3, a2, o3, s4, l2) {
            for (var u2 = e6.decode, h2 = i3 << 3, c3 = 0, f2 = "", d = [], p2 = [], m = 0; m < o3; m++) d.push(0);
            for (var _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0, v2 = -1, x2 = "", E2 = 0, k2 = true, S2 = 8 * Math.ceil(o3 / 8); h2 >>> 3 < i3 + r4; ) {
              b2 = u2._findDiff(p2, _2 + (0 == _2 ? 0 : 1), 1 - w), y2 = u2._findDiff(p2, b2, w);
              var A2 = 0;
              if (1 == s4 && (A2 = t5[h2 >>> 3] >>> 7 - (7 & h2) & 1), 2 == s4 && (A2 = t5[h2 >>> 3] >>> (7 & h2) & 1), h2++, f2 += A2, k2) {
                if (null != u2._lens[w][f2]) {
                  var I = u2._lens[w][f2];
                  f2 = "", c3 += I, I < 64 && (u2._addNtimes(d, c3, w), w = 1 - w, c3 = 0);
                }
              } else if ("H" == x2) {
                if (null != u2._lens[w][f2]) {
                  I = u2._lens[w][f2];
                  f2 = "", c3 += I, I < 64 && (u2._addNtimes(d, c3, w), _2 += c3, w = 1 - w, c3 = 0, 0 == --E2 && (x2 = ""));
                }
              } else "0001" == f2 && (f2 = "", u2._addNtimes(d, y2 - _2, w), _2 = y2), "001" == f2 && (f2 = "", x2 = "H", E2 = 2), null != u2._dmap[f2] && (g = b2 + u2._dmap[f2], u2._addNtimes(d, g - _2, w), _2 = g, f2 = "", w = 1 - w);
              f2.endsWith("000000000001") && (v2 >= 0 && u2._writeBits(d, n3, 8 * a2 + v2 * S2), l2 && (1 == s4 && (k2 = 1 == (t5[h2 >>> 3] >>> 7 - (7 & h2) & 1)), 2 == s4 && (k2 = 1 == (t5[h2 >>> 3] >>> (7 & h2) & 1)), h2++), f2 = "", w = 0, v2++, _2 = 0, p2 = u2._makeDiff(d), d = []);
            }
            d.length == o3 && u2._writeBits(d, n3, 8 * a2 + v2 * S2);
          }, e6.decode._addNtimes = function(e7, t5, i3) {
            for (var r4 = 0; r4 < t5; r4++) e7.push(i3);
          }, e6.decode._writeBits = function(e7, t5, i3) {
            for (var r4 = 0; r4 < e7.length; r4++) t5[i3 + r4 >>> 3] |= e7[r4] << 7 - (i3 + r4 & 7);
          }, e6.decode._decodeLZW = e6.decode._decodeLZW = function() {
            var e7, t5, i3, r4, n3 = 0, a2 = 0, o3 = 0, s4 = 0, l2 = /* @__PURE__ */ __name(function() {
              var i4 = e7 >>> 3, r5 = (t5[i4] << 16 | t5[i4 + 1] << 8 | t5[i4 + 2]) >>> 24 - (7 & e7) - a2 & (1 << a2) - 1;
              return e7 += a2, r5;
            }, "l"), u2 = new Uint32Array(16384), h2 = 0, c3 = /* @__PURE__ */ __name(function(e8) {
              a2 = e8 + 1, n3 = s4 + 1;
            }, "c"), f2 = /* @__PURE__ */ __name(function(e8) {
              for (var t6 = e8 << 2, n4 = u2[t6 + 2], a3 = r4 + n4 - 1; 65535 != t6; ) i3[a3--] = u2[t6], t6 = u2[t6 + 1];
              r4 += n4;
            }, "f"), d = /* @__PURE__ */ __name(function(e8, t6) {
              var i4 = n3 << 2, r5 = e8 << 2;
              u2[i4] = u2[3 + (t6 << 2)], u2[i4 + 1] = r5, u2[i4 + 2] = u2[r5 + 2] + 1, u2[i4 + 3] = u2[r5 + 3], ++n3 + 1 == 1 << a2 && 12 != a2 && a2++;
            }, "d");
            return function(a3, p2, m, _2, g, b2) {
              e7 = p2 << 3, t5 = a3, i3 = _2, r4 = g;
              var y2 = p2 + m << 3, w = 0, v2 = 0;
              for (!function(e8) {
                if (e8 != h2) {
                  h2 = e8, s4 = 1 + (o3 = 1 << e8);
                  for (var t6 = 0; t6 < s4 + 1; t6++) u2[4 * t6] = u2[4 * t6 + 3] = t6, u2[4 * t6 + 1] = 65535, u2[4 * t6 + 2] = 1;
                }
              }(b2), c3(b2); e7 < y2 && (w = l2()) != s4; ) {
                if (w == o3) {
                  if (c3(b2), (w = l2()) == s4) break;
                  f2(w);
                } else w < n3 ? (f2(w), d(v2, w)) : (d(v2, v2), f2(n3 - 1));
                v2 = w;
              }
              return r4;
            };
          }(), e6.tags = {}, e6._types = function() {
            var e7 = new Array(250);
            e7.fill(0);
            return { basic: { main: e7 = e7.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), rest: { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 } }, gps: { main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9], rest: { 18: 2, 29: 2 } } };
          }(), e6._readIFD = function(t5, r4, n3, a2, o3, s4) {
            var l2 = t5.readUshort(r4, n3);
            n3 += 2;
            var u2 = {};
            s4.debug && i2("   ".repeat(o3), a2.length - 1, ">>>----------------");
            for (var h2 = 0; h2 < l2; h2++) {
              var c3 = t5.readUshort(r4, n3);
              n3 += 2;
              var f2 = t5.readUshort(r4, n3);
              n3 += 2;
              var d = t5.readUint(r4, n3);
              n3 += 4;
              var p2 = t5.readUint(r4, n3);
              n3 += 4;
              var m = [];
              if (1 == f2 || 7 == f2) {
                var _2 = d < 5 ? n3 - 4 : p2;
                _2 + d > r4.buffer.byteLength && (d = r4.buffer.byteLength - _2), m = new Uint8Array(r4.buffer, _2, d);
              }
              if (2 == f2) {
                var g = d < 5 ? n3 - 4 : p2, b2 = r4[g], y2 = Math.max(0, Math.min(d - 1, r4.length - g));
                b2 < 128 || 0 == y2 ? m.push(t5.readASCII(r4, g, y2)) : m = new Uint8Array(r4.buffer, g, y2);
              }
              if (3 == f2) for (var w = 0; w < d; w++) m.push(t5.readUshort(r4, (d < 3 ? n3 - 4 : p2) + 2 * w));
              if (4 == f2 || 13 == f2) for (w = 0; w < d; w++) m.push(t5.readUint(r4, (d < 2 ? n3 - 4 : p2) + 4 * w));
              if (5 == f2 || 10 == f2) {
                var v2 = 5 == f2 ? t5.readUint : t5.readInt;
                for (w = 0; w < d; w++) m.push([v2(r4, p2 + 8 * w), v2(r4, p2 + 8 * w + 4)]);
              }
              if (8 == f2) for (w = 0; w < d; w++) m.push(t5.readShort(r4, (d < 3 ? n3 - 4 : p2) + 2 * w));
              if (9 == f2) for (w = 0; w < d; w++) m.push(t5.readInt(r4, (d < 2 ? n3 - 4 : p2) + 4 * w));
              if (11 == f2) for (w = 0; w < d; w++) m.push(t5.readFloat(r4, p2 + 4 * w));
              if (12 == f2) for (w = 0; w < d; w++) m.push(t5.readDouble(r4, p2 + 8 * w));
              if (0 == d || 0 != m.length) {
                if (s4.debug && i2("   ".repeat(o3), c3, f2, e6.tags[c3], m), u2["t" + c3] = m, 330 == c3 && u2.t272 && "DSLR-A100" == u2.t272[0]) ;
                else if (330 == c3 || 34665 == c3 || 34853 == c3 || 50740 == c3 && t5.readUshort(r4, t5.readUint(m, 0)) < 300 || 61440 == c3) {
                  var x2 = 50740 == c3 ? [t5.readUint(m, 0)] : m, E2 = [];
                  for (w = 0; w < x2.length; w++) e6._readIFD(t5, r4, x2[w], E2, o3 + 1, s4);
                  330 == c3 && (u2.subIFD = E2), 34665 == c3 && (u2.exifIFD = E2[0]), 34853 == c3 && (u2.gpsiIFD = E2[0]), 50740 == c3 && (u2.dngPrvt = E2[0]), 61440 == c3 && (u2.fujiIFD = E2[0]);
                }
                if (37500 == c3 && s4.parseMN) {
                  var k2 = m;
                  if ("Nikon" == t5.readASCII(k2, 0, 5)) u2.makerNote = e6.decode(k2.slice(10).buffer)[0];
                  else if ("OLYMP" == t5.readASCII(k2, 0, 5) || "OM SYSTEM" == t5.readASCII(k2, 0, 9)) {
                    var S2 = [8208, 8224, 8240, 8256, 8272], A2 = [];
                    e6._readIFD(t5, k2, 77 == k2[1] ? 16 : 85 == k2[5] ? 12 : 8, A2, o3 + 1, s4);
                    var I = u2.makerNote = A2.pop();
                    for (w = 0; w < S2.length; w++) {
                      var M2 = "t" + S2[w];
                      null != I[M2] && (e6._readIFD(t5, k2, I[M2][0], A2, o3 + 1, s4), I[M2] = A2.pop());
                    }
                    I.t12288 && (e6._readIFD(t5, I.t12288, 0, A2, o3 + 1, s4), I.t12288 = A2.pop());
                  } else if (t5.readUshort(r4, p2) < 300 && t5.readUshort(r4, p2 + 4) <= 12) {
                    A2 = [];
                    e6._readIFD(t5, r4, p2, A2, o3 + 1, s4), u2.makerNote = A2[0];
                  }
                }
              } else if (i2(c3, "unknown TIFF tag type: ", f2, "num:", d), 0 == h2) return;
            }
            return a2.push(u2), s4.debug && i2("   ".repeat(o3), "<<<---------------"), n3;
          }, e6._writeIFD = function(t5, i3, r4, n3, a2) {
            var o3 = Object.keys(a2), s4 = o3.length;
            a2.exifIFD && s4--, a2.gpsiIFD && s4--, t5.writeUshort(r4, n3, s4);
            for (var l2 = (n3 += 2) + 12 * s4 + 4, u2 = 0; u2 < o3.length; u2++) {
              var h2 = o3[u2];
              if ("t34665" != h2 && "t34853" != h2) {
                "exifIFD" == h2 && (h2 = "t34665"), "gpsiIFD" == h2 && (h2 = "t34853");
                var c3 = parseInt(h2.slice(1)), f2 = i3.main[c3];
                if (null == f2 && (f2 = i3.rest[c3]), null == f2 || 0 == f2) throw new Error("unknown type of tag: " + c3);
                var d = a2[h2];
                if (34665 == c3) d = [l2], l2 = e6._writeIFD(t5, i3, r4, l2, a2.exifIFD)[1];
                if (34853 == c3) d = [l2], l2 = e6._writeIFD(t5, e6._types.gps, r4, l2, a2.gpsiIFD)[1];
                2 == f2 && (d = d[0] + "\0");
                var p2 = d.length;
                t5.writeUshort(r4, n3, c3), n3 += 2, t5.writeUshort(r4, n3, f2), n3 += 2, t5.writeUint(r4, n3, p2);
                var m = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][f2] * p2, _2 = n3 += 4;
                if (m > 4 && (t5.writeUint(r4, n3, l2), _2 = l2), 1 == f2 || 7 == f2) for (var g = 0; g < p2; g++) r4[_2 + g] = d[g];
                else if (2 == f2) t5.writeASCII(r4, _2, d);
                else if (3 == f2) for (g = 0; g < p2; g++) t5.writeUshort(r4, _2 + 2 * g, d[g]);
                else if (4 == f2) for (g = 0; g < p2; g++) t5.writeUint(r4, _2 + 4 * g, d[g]);
                else if (5 == f2 || 10 == f2) {
                  var b2 = 5 == f2 ? t5.writeUint : t5.writeInt;
                  for (g = 0; g < p2; g++) {
                    var y2 = d[g], w = y2[0], v2 = y2[1];
                    if (null == w) throw "e";
                    b2(r4, _2 + 8 * g, w), b2(r4, _2 + 8 * g + 4, v2);
                  }
                } else if (9 == f2) for (g = 0; g < p2; g++) t5.writeInt(r4, _2 + 4 * g, d[g]);
                else {
                  if (12 != f2) throw f2;
                  for (g = 0; g < p2; g++) t5.writeDouble(r4, _2 + 8 * g, d[g]);
                }
                m > 4 && (l2 += m += 1 & m), n3 += 4;
              }
            }
            return [n3, l2];
          }, e6.toRGBA8 = function(e7, t5) {
            function r4(e8) {
              return e8 < 31308e-7 ? 12.92 * e8 : 1.055 * Math.pow(e8, 1 / 2.4) - 0.055;
            }
            __name(r4, "r");
            var n3 = e7.width, a2 = e7.height, o3 = n3 * a2, s4 = e7.data, l2 = new Uint8Array(4 * o3), u2 = e7.t262 ? e7.t262[0] : 2, h2 = e7.t258 ? Math.min(32, e7.t258[0]) : 1;
            null == e7.t262 && 1 == h2 && (u2 = 0);
            var c3 = e7.t277 ? e7.t277[0] : e7.t258 ? e7.t258.length : [1, 1, 3, 1, 1, 4, 3][u2], f2 = e7.t339 ? e7.t339[0] : null;
            if (1 == u2 && 32 == h2 && 3 != f2) throw "e";
            var d = Math.ceil(c3 * h2 * n3 / 8);
            if (0 == u2) {
              t5 = 1 / 256;
              for (var p2 = 0; p2 < a2; p2++) {
                var m = p2 * d, _2 = p2 * n3;
                if (1 == h2) for (var g = 0; g < n3; g++) {
                  var b2 = _2 + g << 2, y2 = s4[m + (g >> 3)] >> 7 - (7 & g) & 1;
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 255 * (1 - y2), l2[b2 + 3] = 255;
                }
                if (4 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[m + (g >> 1)] >> 4 - 4 * (1 & g) & 15;
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 17 * (15 - y2), l2[b2 + 3] = 255;
                }
                if (8 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[m + g];
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 255 - y2, l2[b2 + 3] = 255;
                }
                if (16 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[(v2 = m + 2 * g) + 1] << 8 | s4[v2];
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = Math.min(255, 255 - ~~(y2 * t5)), l2[b2 + 3] = 255;
                }
              }
            } else if (1 == u2) {
              null == t5 && (t5 = 1 / 256);
              var w = 3 & s4.length ? null : new Float32Array(s4.buffer);
              for (p2 = 0; p2 < a2; p2++) {
                m = p2 * d, _2 = p2 * n3;
                if (1 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[m + (g >> 3)] >> 7 - (7 & g) & 1;
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 255 * y2, l2[b2 + 3] = 255;
                }
                if (2 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[m + (g >> 2)] >> 6 - 2 * (3 & g) & 3;
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = 85 * y2, l2[b2 + 3] = 255;
                }
                if (8 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[m + g * c3];
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = y2, l2[b2 + 3] = 255;
                }
                if (16 == h2) for (g = 0; g < n3; g++) {
                  b2 = _2 + g << 2, y2 = s4[(v2 = m + 2 * g) + 1] << 8 | s4[v2];
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = Math.min(255, ~~(y2 * t5)), l2[b2 + 3] = 255;
                }
                if (32 == h2) for (g = 0; g < n3; g++) {
                  var v2;
                  b2 = _2 + g << 2, y2 = w[v2 = (m >>> 2) + g];
                  l2[b2] = l2[b2 + 1] = l2[b2 + 2] = ~~(0.5 + 255 * y2), l2[b2 + 3] = 255;
                }
              }
            } else if (2 == u2) if (8 == h2) {
              if (1 == c3) for (g = 0; g < o3; g++) l2[4 * g] = l2[4 * g + 1] = l2[4 * g + 2] = s4[g], l2[4 * g + 3] = 255;
              if (3 == c3) for (g = 0; g < o3; g++) {
                var x2 = 3 * g;
                l2[b2 = g << 2] = s4[x2], l2[b2 + 1] = s4[x2 + 1], l2[b2 + 2] = s4[x2 + 2], l2[b2 + 3] = 255;
              }
              if (c3 >= 4) for (g = 0; g < o3; g++) {
                x2 = g * c3;
                l2[b2 = g << 2] = s4[x2], l2[b2 + 1] = s4[x2 + 1], l2[b2 + 2] = s4[x2 + 2], l2[b2 + 3] = s4[x2 + 3];
              }
            } else if (16 == h2) {
              if (4 == c3) for (g = 0; g < o3; g++) {
                x2 = 8 * g + 1;
                l2[b2 = g << 2] = s4[x2], l2[b2 + 1] = s4[x2 + 2], l2[b2 + 2] = s4[x2 + 4], l2[b2 + 3] = s4[x2 + 6];
              }
              if (3 == c3) for (g = 0; g < o3; g++) {
                x2 = 6 * g + 1;
                l2[b2 = g << 2] = s4[x2], l2[b2 + 1] = s4[x2 + 2], l2[b2 + 2] = s4[x2 + 4], l2[b2 + 3] = 255;
              }
            } else {
              if (32 != h2) throw h2;
              var E2 = new Float32Array(s4.buffer), k2 = 0;
              for (g = 0; g < E2.length; g++) k2 = Math.min(k2, E2[g]);
              if (k2 < 0) for (g = 0; g < s4.length; g += 4) {
                var S2 = s4[g];
                s4[g] = s4[g + 3], s4[g + 3] = S2, S2 = s4[g + 1], s4[g + 1] = s4[g + 2], s4[g + 2] = S2;
              }
              var A2 = [];
              for (g = 0; g < 65536; g++) A2.push(r4(g / 65535));
              for (g = 0; g < E2.length; g++) {
                var I = Math.max(0, Math.min(1, E2[g]));
                E2[g] = A2[~~(0.5 + 65535 * I)];
              }
              if (3 == c3) for (g = 0; g < o3; g++) {
                x2 = 3 * g;
                l2[b2 = g << 2] = ~~(0.5 + 255 * E2[x2]), l2[b2 + 1] = ~~(0.5 + 255 * E2[x2 + 1]), l2[b2 + 2] = ~~(0.5 + 255 * E2[x2 + 2]), l2[b2 + 3] = 255;
              }
              else {
                if (4 != c3) throw c3;
                for (g = 0; g < o3; g++) {
                  x2 = 4 * g;
                  l2[b2 = g << 2] = ~~(0.5 + 255 * E2[x2]), l2[b2 + 1] = ~~(0.5 + 255 * E2[x2 + 1]), l2[b2 + 2] = ~~(0.5 + 255 * E2[x2 + 2]), l2[b2 + 3] = ~~(0.5 + 255 * E2[x2 + 3]);
                }
              }
            }
            else if (3 == u2) {
              var M2 = e7.t320, T2 = 1 << h2, P = 8 == h2 && c3 > 1 && e7.t338 && 0 != e7.t338[0];
              for (p2 = 0; p2 < a2; p2++) for (var B2 = 0; B2 < n3; B2++) {
                b2 = (g = p2 * n3 + B2) << 2;
                var C2 = 0, R2 = p2 * d;
                if (1 == h2) C2 = s4[R2 + (B2 >>> 3)] >>> 7 - (7 & B2) & 1;
                else if (2 == h2) C2 = s4[R2 + (B2 >>> 2)] >>> 6 - 2 * (3 & B2) & 3;
                else if (4 == h2) C2 = s4[R2 + (B2 >>> 1)] >>> 4 - 4 * (1 & B2) & 15;
                else {
                  if (8 != h2) throw h2;
                  C2 = s4[R2 + B2 * c3];
                }
                l2[b2] = M2[C2] >> 8, l2[b2 + 1] = M2[T2 + C2] >> 8, l2[b2 + 2] = M2[T2 + T2 + C2] >> 8, l2[b2 + 3] = P ? s4[R2 + B2 * c3 + 1] : 255;
              }
            } else if (5 == u2) {
              var z2 = c3 > 4 ? 1 : 0;
              for (g = 0; g < o3; g++) {
                b2 = g << 2;
                var F = g * c3;
                if (window.UDOC) {
                  var N2 = s4[F], O2 = s4[F + 1], D = s4[F + 2], $ = s4[F + 3], L2 = UDOC.C.cmykToRgb([N2 * (1 / 255), O2 * (1 / 255), D * (1 / 255), $ * (1 / 255)]);
                  l2[b2] = ~~(0.5 + 255 * L2[0]), l2[b2 + 1] = ~~(0.5 + 255 * L2[1]), l2[b2 + 2] = ~~(0.5 + 255 * L2[2]);
                } else {
                  N2 = 255 - s4[F], O2 = 255 - s4[F + 1], D = 255 - s4[F + 2], $ = (255 - s4[F + 3]) * (1 / 255);
                  l2[b2] = ~~(N2 * $ + 0.5), l2[b2 + 1] = ~~(O2 * $ + 0.5), l2[b2 + 2] = ~~(D * $ + 0.5);
                }
                l2[b2 + 3] = 255 * (1 - z2) + s4[F + 4] * z2;
              }
            } else if (6 == u2 && e7.t278) {
              var U = e7.t278[0];
              for (p2 = 0; p2 < a2; p2 += U) {
                g = p2 * n3;
                for (var Z = U * n3, j = 0; j < Z; j++) {
                  b2 = 4 * (g + j), D = s4[(F = 3 * g + 4 * (j >>> 1)) + (1 & j)];
                  var G = s4[F + 2] - 128, H = s4[F + 3] - 128, Q = D + ((H >> 2) + (H >> 3) + (H >> 5)), W = D - ((G >> 2) + (G >> 4) + (G >> 5)) - ((H >> 1) + (H >> 3) + (H >> 4) + (H >> 5)), q = D + (G + (G >> 1) + (G >> 2) + (G >> 6));
                  l2[b2] = Math.max(0, Math.min(255, Q)), l2[b2 + 1] = Math.max(0, Math.min(255, W)), l2[b2 + 2] = Math.max(0, Math.min(255, q)), l2[b2 + 3] = 255;
                }
              }
            } else if (32845 == u2) for (p2 = 0; p2 < a2; p2++) for (B2 = 0; B2 < n3; B2++) {
              b2 = 4 * (p2 * n3 + B2);
              var V = s4[(F = 6 * (p2 * n3 + B2)) + 1] << 8 | s4[F], Y2 = (V = Math.pow(2, (V + 0.5) / 256 - 64), (s4[F + 3] + 0.5) / 410), K = (s4[F + 5] + 0.5) / 410, J = 9 * Y2 / (6 * Y2 - 16 * K + 12), X = 4 * K / (6 * Y2 - 16 * K + 12), ee = J * V / X, te = (1 - J - X) * V / X;
              Q = 2.69 * ee - 1.276 * (D = V) - 0.414 * te, W = -1.022 * ee + 1.978 * D + 0.044 * te, q = 0.061 * ee - 0.224 * D + 1.163 * te;
              l2[b2] = 255 * r4(Math.min(Q, 1)), l2[b2 + 1] = 255 * r4(Math.min(W, 1)), l2[b2 + 2] = 255 * r4(Math.min(q, 1)), l2[b2 + 3] = 255;
            }
            else i2("Unknown Photometric interpretation: " + u2);
            return l2;
          }, e6.replaceIMG = function(t5) {
            null == t5 && (t5 = document.getElementsByTagName("img"));
            for (var i3 = ["tif", "tiff", "dng", "cr2", "nef"], r4 = 0; r4 < t5.length; r4++) {
              var n3 = t5[r4], a2 = n3.getAttribute("src");
              if (null != a2) {
                var o3 = a2.split(".").pop().toLowerCase();
                if (-1 != i3.indexOf(o3)) {
                  var s4 = new XMLHttpRequest();
                  e6._xhrs.push(s4), e6._imgs.push(n3), s4.open("GET", a2), s4.responseType = "arraybuffer", s4.onload = e6._imgLoaded, s4.send();
                }
              }
            }
          }, e6._xhrs = [], e6._imgs = [], e6._imgLoaded = function(t5) {
            var i3 = e6._xhrs.indexOf(t5.target), r4 = e6._imgs[i3];
            e6._xhrs.splice(i3, 1), e6._imgs.splice(i3, 1), r4.setAttribute("src", e6.bufferToURI(t5.target.response));
          }, e6.bufferToURI = function(t5) {
            var i3 = e6.decode(t5), r4 = i3, n3 = 0, a2 = r4[0];
            i3[0].subIFD && (r4 = r4.concat(i3[0].subIFD));
            for (var o3 = 0; o3 < r4.length; o3++) {
              var s4 = r4[o3];
              if (!(null == s4.t258 || s4.t258.length < 3)) {
                var l2 = s4.t256 * s4.t257;
                l2 > n3 && (n3 = l2, a2 = s4);
              }
            }
            e6.decodeImage(t5, a2, i3);
            var u2 = e6.toRGBA8(a2), h2 = a2.width, c3 = a2.height, f2 = document.createElement("canvas");
            f2.width = h2, f2.height = c3;
            var d = f2.getContext("2d"), p2 = new ImageData(new Uint8ClampedArray(u2.buffer), h2, c3);
            return d.putImageData(p2, 0, 0), f2.toDataURL();
          }, e6._binBE = { nextZero: /* @__PURE__ */ __name(function(e7, t5) {
            for (; 0 != e7[t5]; ) t5++;
            return t5;
          }, "nextZero"), readUshort: /* @__PURE__ */ __name(function(e7, t5) {
            return e7[t5] << 8 | e7[t5 + 1];
          }, "readUshort"), readShort: /* @__PURE__ */ __name(function(t5, i3) {
            var r4 = e6._binBE.ui8;
            return r4[0] = t5[i3 + 1], r4[1] = t5[i3 + 0], e6._binBE.i16[0];
          }, "readShort"), readInt: /* @__PURE__ */ __name(function(t5, i3) {
            var r4 = e6._binBE.ui8;
            return r4[0] = t5[i3 + 3], r4[1] = t5[i3 + 2], r4[2] = t5[i3 + 1], r4[3] = t5[i3 + 0], e6._binBE.i32[0];
          }, "readInt"), readUint: /* @__PURE__ */ __name(function(t5, i3) {
            var r4 = e6._binBE.ui8;
            return r4[0] = t5[i3 + 3], r4[1] = t5[i3 + 2], r4[2] = t5[i3 + 1], r4[3] = t5[i3 + 0], e6._binBE.ui32[0];
          }, "readUint"), readASCII: /* @__PURE__ */ __name(function(e7, t5, i3) {
            for (var r4 = "", n3 = 0; n3 < i3; n3++) r4 += String.fromCharCode(e7[t5 + n3]);
            return r4;
          }, "readASCII"), readFloat: /* @__PURE__ */ __name(function(t5, i3) {
            for (var r4 = e6._binBE.ui8, n3 = 0; n3 < 4; n3++) r4[n3] = t5[i3 + 3 - n3];
            return e6._binBE.fl32[0];
          }, "readFloat"), readDouble: /* @__PURE__ */ __name(function(t5, i3) {
            for (var r4 = e6._binBE.ui8, n3 = 0; n3 < 8; n3++) r4[n3] = t5[i3 + 7 - n3];
            return e6._binBE.fl64[0];
          }, "readDouble"), writeUshort: /* @__PURE__ */ __name(function(e7, t5, i3) {
            e7[t5] = i3 >> 8 & 255, e7[t5 + 1] = 255 & i3;
          }, "writeUshort"), writeInt: /* @__PURE__ */ __name(function(t5, i3, r4) {
            var n3 = e6._binBE.ui8;
            e6._binBE.i32[0] = r4, t5[i3 + 3] = n3[0], t5[i3 + 2] = n3[1], t5[i3 + 1] = n3[2], t5[i3 + 0] = n3[3];
          }, "writeInt"), writeUint: /* @__PURE__ */ __name(function(e7, t5, i3) {
            e7[t5] = i3 >> 24 & 255, e7[t5 + 1] = i3 >> 16 & 255, e7[t5 + 2] = i3 >> 8 & 255, e7[t5 + 3] = 255 & i3;
          }, "writeUint"), writeASCII: /* @__PURE__ */ __name(function(e7, t5, i3) {
            for (var r4 = 0; r4 < i3.length; r4++) e7[t5 + r4] = i3.charCodeAt(r4);
          }, "writeASCII"), writeDouble: /* @__PURE__ */ __name(function(t5, i3, r4) {
            e6._binBE.fl64[0] = r4;
            for (var n3 = 0; n3 < 8; n3++) t5[i3 + n3] = e6._binBE.ui8[7 - n3];
          }, "writeDouble") }, e6._binBE.ui8 = new Uint8Array(8), e6._binBE.i16 = new Int16Array(e6._binBE.ui8.buffer), e6._binBE.i32 = new Int32Array(e6._binBE.ui8.buffer), e6._binBE.ui32 = new Uint32Array(e6._binBE.ui8.buffer), e6._binBE.fl32 = new Float32Array(e6._binBE.ui8.buffer), e6._binBE.fl64 = new Float64Array(e6._binBE.ui8.buffer), e6._binLE = { nextZero: e6._binBE.nextZero, readUshort: /* @__PURE__ */ __name(function(e7, t5) {
            return e7[t5 + 1] << 8 | e7[t5];
          }, "readUshort"), readShort: /* @__PURE__ */ __name(function(t5, i3) {
            var r4 = e6._binBE.ui8;
            return r4[0] = t5[i3 + 0], r4[1] = t5[i3 + 1], e6._binBE.i16[0];
          }, "readShort"), readInt: /* @__PURE__ */ __name(function(t5, i3) {
            var r4 = e6._binBE.ui8;
            return r4[0] = t5[i3 + 0], r4[1] = t5[i3 + 1], r4[2] = t5[i3 + 2], r4[3] = t5[i3 + 3], e6._binBE.i32[0];
          }, "readInt"), readUint: /* @__PURE__ */ __name(function(t5, i3) {
            var r4 = e6._binBE.ui8;
            return r4[0] = t5[i3 + 0], r4[1] = t5[i3 + 1], r4[2] = t5[i3 + 2], r4[3] = t5[i3 + 3], e6._binBE.ui32[0];
          }, "readUint"), readASCII: e6._binBE.readASCII, readFloat: /* @__PURE__ */ __name(function(t5, i3) {
            for (var r4 = e6._binBE.ui8, n3 = 0; n3 < 4; n3++) r4[n3] = t5[i3 + n3];
            return e6._binBE.fl32[0];
          }, "readFloat"), readDouble: /* @__PURE__ */ __name(function(t5, i3) {
            for (var r4 = e6._binBE.ui8, n3 = 0; n3 < 8; n3++) r4[n3] = t5[i3 + n3];
            return e6._binBE.fl64[0];
          }, "readDouble"), writeUshort: /* @__PURE__ */ __name(function(e7, t5, i3) {
            e7[t5] = 255 & i3, e7[t5 + 1] = i3 >> 8 & 255;
          }, "writeUshort"), writeInt: /* @__PURE__ */ __name(function(t5, i3, r4) {
            var n3 = e6._binBE.ui8;
            e6._binBE.i32[0] = r4, t5[i3 + 0] = n3[0], t5[i3 + 1] = n3[1], t5[i3 + 2] = n3[2], t5[i3 + 3] = n3[3];
          }, "writeInt"), writeUint: /* @__PURE__ */ __name(function(e7, t5, i3) {
            e7[t5] = i3 >>> 0 & 255, e7[t5 + 1] = i3 >>> 8 & 255, e7[t5 + 2] = i3 >>> 16 & 255, e7[t5 + 3] = i3 >>> 24 & 255;
          }, "writeUint"), writeASCII: e6._binBE.writeASCII }, e6._copyTile = function(e7, t5, i3, r4, n3, a2, o3, s4) {
            for (var l2 = Math.min(t5, n3 - o3), u2 = Math.min(i3, a2 - s4), h2 = 0; h2 < u2; h2++) for (var c3 = (s4 + h2) * n3 + o3, f2 = h2 * t5, d = 0; d < l2; d++) r4[c3 + d] = e7[f2 + d];
          }, e6.LosslessJpegDecode = /* @__PURE__ */ function() {
            var e7, t5;
            function i3() {
              return e7[t5++];
            }
            __name(i3, "i");
            function r4() {
              return e7[t5++] << 8 | e7[t5++];
            }
            __name(r4, "r");
            function n3(e8) {
              for (var t6 = i3(), r5 = [0, 0, 0, 255], n4 = [], o4 = 0; o4 < 16; o4++) n4[o4] = i3();
              for (o4 = 0; o4 < 16; o4++) for (var s5 = 0; s5 < n4[o4]; s5++) {
                r5[a2(r5, 0, o4 + 1, 1) + 3] = i3();
              }
              var l3 = new Uint8Array(256);
              e8[t6] = [new Uint8Array(r5), l3];
              for (o4 = 0; o4 < 256; o4++) {
                for (var u3 = 8, h3 = o4, c4 = 0; 255 == r5[c4 + 3] && 0 != u3; ) c4 = r5[c4 + (h3 >> --u3 & 1)];
                l3[o4] = c4;
              }
            }
            __name(n3, "n");
            function a2(e8, t6, i4, r5) {
              if (255 != e8[t6 + 3]) return 0;
              if (0 == i4) return t6;
              for (var n4 = 0; n4 < 2; n4++) {
                0 == e8[t6 + n4] && (e8[t6 + n4] = e8.length, e8.push(0, 0, r5, 255));
                var o4 = a2(e8, e8[t6 + n4], i4 - 1, r5 + 1);
                if (0 != o4) return o4;
              }
              return 0;
            }
            __name(a2, "a");
            function o3(e8) {
              for (var t6 = e8.b, i4 = e8.f; t6 < 25 && e8.a < e8.d; ) {
                var r5 = e8.data[e8.a++];
                255 != r5 || e8.c || e8.a++, i4 = i4 << 8 | r5, t6 += 8;
              }
              if (t6 < 0) throw "e";
              e8.b = t6, e8.f = i4;
            }
            __name(o3, "o");
            function s4(e8, t6) {
              return t6.b < e8 && o3(t6), t6.f >> (t6.b -= e8) & 65535 >> 16 - e8;
            }
            __name(s4, "s");
            function l2(e8, t6) {
              var i4 = e8[0], r5 = 0, n4 = 255;
              t6.b < 16 && o3(t6);
              var a3 = t6.f >> t6.b - 8 & 255;
              for (n4 = i4[(r5 = e8[1][a3]) + 3], t6.b -= i4[r5 + 2]; 255 == n4; ) n4 = i4[(r5 = i4[r5 + (t6.f >> --t6.b & 1)]) + 3];
              return n4;
            }
            __name(l2, "l");
            function u2(e8, t6) {
              return e8 < 32768 >> 16 - t6 && (e8 += 1 - (1 << t6)), e8;
            }
            __name(u2, "u");
            function h2(e8, t6) {
              var i4 = l2(e8, t6);
              return 0 == i4 ? 0 : 16 == i4 ? -32768 : u2(s4(i4, t6), i4);
            }
            __name(h2, "h");
            function c3(e8, t6, i4, r5, n4, a3) {
              for (var o4 = 0, s5 = 0; s5 < a3; s5++) {
                for (var l3 = s5 * t6, u3 = 0; u3 < t6; u3 += n4) {
                  o4++;
                  for (var c4 = 0; c4 < n4; c4++) e8[l3 + u3 + c4] = h2(r5[c4], i4);
                }
                if (0 != i4.e && o4 % i4.e == 0 && 0 != s5) {
                  for (var f3 = i4.a, d2 = i4.data; 255 != d2[f3] || !(208 <= d2[f3 + 1] && d2[f3 + 1] <= 215); ) f3--;
                  i4.a = f3 + 2, i4.f = 0, i4.b = 0;
                }
              }
            }
            __name(c3, "c");
            function f2(e8, t6) {
              return u2(s4(e8, t6), e8);
            }
            __name(f2, "f");
            function d(e8, t6, i4, r5, n4, a3, o4, s5) {
              for (var l3 = i4 * o4, u3 = n4; u3 < a3; u3++) e8[u3] += 1 << s5 - 1;
              for (var h3 = o4; h3 < l3; h3 += o4) for (u3 = n4; u3 < a3; u3++) e8[h3 + u3] += e8[h3 + u3 - o4];
              for (var c4 = 1; c4 < r5; c4++) {
                var f3 = c4 * l3;
                for (u3 = n4; u3 < a3; u3++) e8[f3 + u3] += e8[f3 + u3 - l3];
                for (h3 = o4; h3 < l3; h3 += o4) for (u3 = n4; u3 < a3; u3++) {
                  var d2 = f3 + h3 + u3, p2 = d2 - l3, m = e8[d2 - o4], _2 = 0;
                  if (0 == t6) _2 = 0;
                  else if (1 == t6) _2 = m;
                  else if (2 == t6) _2 = e8[p2];
                  else if (3 == t6) _2 = e8[p2 - o4];
                  else if (4 == t6) _2 = m + (e8[p2] - e8[p2 - o4]);
                  else if (5 == t6) _2 = m + (e8[p2] - e8[p2 - o4] >>> 1);
                  else if (6 == t6) _2 = e8[p2] + (m - e8[p2 - o4] >>> 1);
                  else {
                    if (7 != t6) throw t6;
                    _2 = m + e8[p2] >>> 1;
                  }
                  e8[d2] += _2;
                }
              }
            }
            __name(d, "d");
            return function(a3) {
              if (e7 = a3, t5 = 0, 65496 != r4()) throw "e";
              for (var o4 = [], s5 = 0, u3 = 0, h3 = 0, p2 = [], m = [], _2 = [], g = 0, b2 = 0, y2 = 0; ; ) {
                var w = r4();
                if (65535 != w) {
                  var v2 = r4();
                  if (65475 == w) {
                    u3 = i3(), b2 = r4(), y2 = r4(), g = i3();
                    for (var x2 = 0; x2 < g; x2++) {
                      var E2 = i3(), k2 = i3();
                      if (0 != i3()) throw "e";
                      o4[E2] = [x2, k2 >> 4, 15 & k2];
                    }
                  } else if (65476 == w) for (var S2 = t5 + v2 - 2; t5 < S2; ) n3(m);
                  else {
                    if (65498 == w) {
                      t5++;
                      for (x2 = 0; x2 < g; x2++) {
                        var A2 = o4[i3()];
                        _2[A2[0]] = m[i3() >>> 4], p2[A2[0]] = A2.slice(1);
                      }
                      s5 = i3(), t5 += 2;
                      break;
                    }
                    65501 == w ? h3 = r4() : t5 += v2 - 2;
                  }
                } else t5--;
              }
              var I = new (u3 > 8 ? Uint16Array : Uint8Array)(b2 * y2 * g), M2 = { b: 0, f: 0, c: 8 == s5, a: t5, data: e7, d: e7.length, e: h3 };
              if (M2.c) !function(i4, r5, n4, a4, o5) {
                for (var s6 = e7.length - t5, u4 = 0; u4 < s6; u4 += 4) {
                  var h4 = e7[t5 + u4];
                  e7[t5 + u4] = e7[t5 + u4 + 3], e7[t5 + u4 + 3] = h4, h4 = e7[t5 + u4 + 1], e7[t5 + u4 + 1] = e7[t5 + u4 + 2], e7[t5 + u4 + 2] = h4;
                }
                for (var c4 = 0; c4 < o5; c4++) for (var d2 = 32768, p3 = 32768, m2 = 0; m2 < r5; m2 += 2) {
                  var _3 = l2(a4, n4), g2 = l2(a4, n4);
                  0 != _3 && (d2 += f2(_3, n4)), 0 != g2 && (p3 += f2(g2, n4)), i4[c4 * r5 + m2] = 65535 & d2, i4[c4 * r5 + m2 + 1] = 65535 & p3;
                }
              }(I, y2 * g, M2, _2[0], b2);
              else {
                var T2 = [], P = 0, B2 = 0;
                for (x2 = 0; x2 < g; x2++) {
                  var C2 = p2[x2];
                  (Z = C2[0]) > P && (P = Z), (U = C2[1]) > B2 && (B2 = U), T2.push(Z * U);
                }
                if (1 != P || 1 != B2) {
                  if (3 != g || 1 != T2[1] || 1 != T2[2]) throw "e";
                  if (2 != P || 1 != B2 && 2 != B2) throw "e";
                  var R2 = [], z2 = 0;
                  for (x2 = 0; x2 < g; x2++) {
                    for (var F = 0; F < T2[x2]; F++) R2.push(_2[x2]);
                    z2 += T2[x2];
                  }
                  var N2 = y2 / P, O2 = b2 / B2, D = N2 * O2;
                  c3(I, N2 * z2, M2, R2, z2, O2), d(I, s5, N2, O2, z2 - 2, z2, z2, u3);
                  var $ = new Uint16Array(D * T2[0]);
                  if (2 == P && 2 == B2) {
                    for (x2 = 0; x2 < D; x2++) $[4 * x2] = I[6 * x2], $[4 * x2 + 1] = I[6 * x2 + 1], $[4 * x2 + 2] = I[6 * x2 + 2], $[4 * x2 + 3] = I[6 * x2 + 3];
                    d($, s5, 4 * N2, O2, 0, 1, 1, u3);
                    for (x2 = 0; x2 < D; x2++) I[6 * x2] = $[4 * x2], I[6 * x2 + 1] = $[4 * x2 + 1], I[6 * x2 + 2] = $[4 * x2 + 2], I[6 * x2 + 3] = $[4 * x2 + 3];
                  }
                  if (2 == P && 1 == B2) {
                    for (x2 = 0; x2 < D; x2++) $[2 * x2] = I[4 * x2], $[2 * x2 + 1] = I[4 * x2 + 1];
                    d($, s5, 2 * N2, O2, 0, 1, 1, u3);
                    for (x2 = 0; x2 < D; x2++) I[4 * x2] = $[2 * x2], I[4 * x2 + 1] = $[2 * x2 + 1];
                  }
                  for (var L2 = I.slice(0), U = 0; U < b2; U++) if (2 == B2) for (var Z = 0; Z < y2; Z++) {
                    var j = ((U >>> 1) * N2 + (Z >>> 1)) * z2, G = 2 * (1 & U) + (1 & Z);
                    I[H = (U * y2 + Z) * g] = L2[j + G], I[H + 1] = L2[j + 4], I[H + 2] = L2[j + 5];
                  }
                  else for (Z = 0; Z < y2; Z++) {
                    var H;
                    j = (U * N2 + (Z >>> 1)) * z2, G = 1 & Z;
                    I[H = (U * y2 + Z) * g] = L2[j + G], I[H + 1] = L2[j + 2], I[H + 2] = L2[j + 3];
                  }
                } else if (c3(I, y2 * g, M2, _2, g, b2), 0 == h3) d(I, s5, y2, b2, 0, g, g, u3);
                else {
                  var Q = Math.floor(h3 / y2);
                  for (U = 0; U < b2; U += Q) {
                    var W = I.slice(U * y2 * g, (U + Q) * y2 * g);
                    d(W, s5, y2, Q, 0, g, g, u3), I.set(W, U * y2 * g);
                  }
                }
              }
              return I;
            };
          }(), function() {
            var t5 = 2, i3 = 4, r4 = 5, n3 = 6, a2 = 7, o3 = 12, s4 = 13, l2 = 14, u2 = 15, h2 = 17;
            function c3(e7) {
              var t6 = { c: new Int8Array(2 << e7.u) };
              return function(e8, t7, i4) {
                var r5 = [t7, 3 * t7 + 18, 5 * t7 + 67, 7 * t7 + 276, i4];
                e8.o = t7, e8.w = (r5[4] + 2 * t7) / (2 * t7 + 1) + 1 | 0, e8.v = Math.ceil(Math.log2(e8.w)), e8.t = 9, function(e9, t8) {
                  for (var i5 = -t8[4], r6 = 0; i5 <= t8[4]; r6++, i5++) e9[r6] = i5 <= -t8[3] ? -4 : i5 <= -t8[2] ? -3 : i5 <= -t8[1] ? -2 : i5 < -t8[0] ? -1 : i5 <= t8[0] ? 0 : i5 < t8[1] ? 1 : i5 < t8[2] ? 2 : i5 < t8[3] ? 3 : 4;
                }(e8.c, r5);
              }(t6, 0, e7.g), t6;
            }
            __name(c3, "c");
            function f2(e7) {
              for (var t6 = [[], [], []], i4 = Math.max(2, e7.w + 32 >>> 6), r5 = 0; r5 < 3; r5++) for (var n4 = 0; n4 < 41; n4++) t6[r5][n4] = [i4, 1];
              return t6;
            }
            __name(f2, "f");
            function d(e7, t6) {
              var i4 = 0, r5 = 8 - e7.a;
              if (e7.j, e7.a, t6) {
                if (t6 >= r5) do {
                  i4 <<= r5, t6 -= r5, i4 |= e7[e7.j] & (1 << r5) - 1, e7.j++, r5 = 8;
                } while (t6 >= 8);
                t6 && (i4 <<= t6, r5 -= t6, i4 |= e7[e7.j] >>> r5 & (1 << t6) - 1), e7.a = 8 - r5;
              }
              return i4;
            }
            __name(d, "d");
            function p2(e7, t6, i4, r5, n4, a3, o4, s5) {
              null == s5 && (s5 = 0);
              var l3, u3, h3, c4, f3, p3, m2 = a3 + 1, _3 = m2 % 2, g2 = 0, b3 = r5[n4], y3 = r5[n4 - 1], w = r5[n4 - 2][m2], v2 = y3[m2 - 1], x2 = y3[m2], E2 = y3[m2 + 1], k2 = b3[m2 - 1], S2 = b3[m2 + 1], A2 = Math.abs;
              if (_3 && (h3 = A2(E2 - x2), c4 = A2(w - x2), f3 = A2(v2 - x2)), _3) {
                if (p3 = (p3 = h3 > f3 && c4 < h3 ? w + v2 : h3 < f3 && c4 < f3 ? w + E2 : E2 + v2) + 2 * x2 >>> 2, s5) return void (b3[m2] = p3);
                l3 = t6.t * t6.c[e7.g + x2 - w] + t6.c[e7.g + v2 - x2];
              } else p3 = x2 > v2 && x2 > E2 || x2 < v2 && x2 < E2 ? S2 + k2 + 2 * x2 >>> 2 : k2 + S2 >>> 1, l3 = t6.t * t6.c[e7.g + x2 - v2] + t6.c[e7.g + v2 - k2];
              u3 = A2(l3);
              var I = function(e8) {
                for (var t7 = -1, i5 = 0; !i5; t7++) i5 = e8[e8.j] >>> 7 - e8.a & 1, e8.a++, e8.a &= 7, e8.a || e8.j++;
                return t7;
              }(i4);
              if (I < e7.n - t6.v - 1) {
                var M2 = function(e8, t7) {
                  var i5 = 0;
                  if (t7 < e8) for (; i5 <= 14 && t7 << ++i5 < e8; ) ;
                  return i5;
                }(o4[u3][0], o4[u3][1]);
                g2 = d(i4, M2) + (I << M2);
              } else g2 = d(i4, t6.v) + 1;
              g2 = 1 & g2 ? -1 - (g2 >>> 1) : g2 >>> 1, o4[u3][0] += A2(g2), o4[u3][1] == e7.f && (o4[u3][0] >>>= 1, o4[u3][1] >>>= 1), o4[u3][1]++, p3 = l3 < 0 ? p3 - g2 : p3 + g2, e7.i && (p3 < 0 ? p3 += t6.w : p3 > e7.g && (p3 -= t6.w)), b3[m2] = p3 >= 0 ? Math.min(p3, e7.g) : 0;
            }
            __name(p2, "p");
            function m(e7, t6, i4) {
              for (var r5 = e7[0].length, n4 = t6; n4 <= i4; n4++) e7[n4][0] = e7[n4 - 1][1], e7[n4][r5 - 1] = e7[n4 - 1][r5 - 2];
            }
            __name(m, "m");
            function _2(e7) {
              m(e7, a2, o3), m(e7, t5, i3), m(e7, u2, h2);
            }
            __name(_2, "_");
            function g(e7, t6, r5, n4, a3, o4, l3, u3, h3, c4, f3, d2, m2) {
              for (var g2 = 0, b3 = 1, y3 = a3 < s4 && a3 > i3; b3 < e7.m; ) g2 < e7.m && (p2(e7, t6, r5, n4, a3, g2, l3[h3], e7.h && (y3 && c4 || !y3 && (f3 || (g2 & d2) == m2))), p2(e7, t6, r5, n4, o4, g2, l3[h3], e7.h && (!y3 && c4 || y3 && (f3 || (g2 & d2) == m2))), g2 += 2), g2 > 8 && (p2(e7, t6, r5, n4, a3, b3, u3[h3]), p2(e7, t6, r5, n4, o4, b3, u3[h3]), b3 += 2);
              _2(n4);
            }
            __name(g, "g");
            function b2(e7, r5, n4, s5, l3, c4) {
              g(e7, r5, n4, s5, t5, a2, l3, c4, 0, 0, 1, 0, 8), g(e7, r5, n4, s5, 8, u2, l3, c4, 1, 0, 1, 0, 8), g(e7, r5, n4, s5, 3, 9, l3, c4, 2, 1, 0, 3, 0), g(e7, r5, n4, s5, 10, 16, l3, c4, 0, 0, 0, 3, 2), g(e7, r5, n4, s5, i3, 11, l3, c4, 1, 0, 0, 3, 2), g(e7, r5, n4, s5, o3, h2, l3, c4, 2, 1, 0, 3, 0);
            }
            __name(b2, "b");
            function y2(e7, i4, r5, n4, o4, s5) {
              var l3 = s5.length, h3 = e7.l;
              o4 + 1 == e7.s && (h3 = e7.e - o4 * e7.l);
              for (var c4 = 6 * e7.e * n4 + o4 * e7.l, f3 = 0; f3 < 6; f3++) {
                for (var d2 = 0; d2 < h3; d2++) {
                  var p3, m2 = s5[f3 % l3][d2 % l3];
                  p3 = 0 == m2 ? t5 + (f3 >>> 1) : 2 == m2 ? u2 + (f3 >>> 1) : a2 + f3;
                  var _3 = e7.h ? (2 * d2 / 3 & 2147483646 | d2 % 3 & 1) + (d2 % 3 >>> 1) : d2 >>> 1;
                  i4[c4 + d2] = r5[p3][_3 + 1];
                }
                c4 += e7.e;
              }
            }
            __name(y2, "y");
            e6._decompressRAF = function(a3, u3) {
              var d2 = function(t6) {
                var i4 = e6._binBE.readUshort, r5 = { b: i4(t6, 0), i: t6[2], C: t6[3], u: t6[4], q: i4(t6, 5), k: i4(t6, 7), e: i4(t6, 9), l: i4(t6, 11), s: t6[13], d: i4(t6, 14) };
                if (18771 != r5.b || r5.i > 1 || r5.q < 6 || r5.q % 6 || r5.e < 768 || r5.e % 24 || 768 != r5.l || r5.k < r5.l || r5.k % r5.l || r5.k - r5.e >= r5.l || r5.s > 16 || r5.s != r5.k / r5.l || r5.s != Math.ceil(r5.e / r5.l) || r5.d != r5.q / 6 || 12 != r5.u && 14 != r5.u && 16 != r5.u || 16 != r5.C && 0 != r5.C) throw "Invalid data";
                if (0 == r5.i) throw "Not implemented. We need this file!";
                return r5.h = 16 == r5.C, r5.m = 0 | (r5.h ? 2 * r5.l / 3 : r5.l >>> 1), r5.A = r5.m + 2, r5.f = 64, r5.g = (1 << r5.u) - 1, r5.n = 4 * r5.u, r5;
              }(a3), p3 = function(t6, i4) {
                var r5 = new Array(i4.s), n4 = 4 * i4.s, a4 = 16 + n4;
                12 & n4 && (a4 += 16 - (12 & n4));
                for (var o4 = 0, s5 = 16; o4 < i4.s; s5 += 4) {
                  var l3 = e6._binBE.readUint(t6, s5);
                  r5[o4] = t6.slice(a4, a4 + l3), r5[o4].j = 0, r5[o4].a = 0, a4 += l3, o4++;
                }
                if (a4 != t6.length) throw "Invalid data";
                return r5;
              }(a3, d2), m2 = c3(d2), g2 = new Int16Array(d2.e * d2.q);
              null == u3 && (u3 = d2.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]]);
              for (var w = [[0, 3], [1, i3], [r4, 11], [n3, o3], [s4, 16], [l2, h2]], v2 = [], x2 = 0; x2 < 18; x2++) v2[x2] = new Uint16Array(d2.A);
              for (var E2 = 0; E2 < d2.s; E2++) {
                var k2 = f2(m2), S2 = f2(m2);
                for (x2 = 0; x2 < 18; x2++) for (var A2 = 0; A2 < d2.A; A2++) v2[x2][A2] = 0;
                for (var I = 0; I < d2.d; I++) {
                  b2(d2, m2, p3[E2], v2, k2, S2);
                  for (x2 = 0; x2 < 6; x2++) for (A2 = 0; A2 < d2.A; A2++) v2[w[x2][0]][A2] = v2[w[x2][1]][A2];
                  y2(d2, g2, v2, I, E2, u3);
                  for (x2 = t5; x2 < 18; x2++) if (-1 == [r4, n3, s4, l2].indexOf(x2)) for (A2 = 0; A2 < d2.A; A2++) v2[x2][A2] = 0;
                  _2(v2);
                }
              }
              return g2;
            };
          }();
        }(t3, "function" == typeof commonjsRequire ? requirePako() : self.pako);
      }();
    }(UTIF);
    UTIFExports = UTIF.exports;
    utif = getDefaultExportFromCjs(UTIFExports);
    __name(getDimensionValue, "getDimensionValue");
    __name(tiff, "tiff");
    !function(e5) {
      e5.assertEqual = (e6) => e6, e5.assertIs = function(e6) {
      }, e5.assertNever = function(e6) {
        throw new Error();
      }, e5.arrayToEnum = (e6) => {
        const t3 = {};
        for (const i2 of e6) t3[i2] = i2;
        return t3;
      }, e5.getValidEnumValues = (t3) => {
        const i2 = e5.objectKeys(t3).filter((e6) => "number" != typeof t3[t3[e6]]), r4 = {};
        for (const e6 of i2) r4[e6] = t3[e6];
        return e5.objectValues(r4);
      }, e5.objectValues = (t3) => e5.objectKeys(t3).map(function(e6) {
        return t3[e6];
      }), e5.objectKeys = "function" == typeof Object.keys ? (e6) => Object.keys(e6) : (e6) => {
        const t3 = [];
        for (const i2 in e6) Object.prototype.hasOwnProperty.call(e6, i2) && t3.push(i2);
        return t3;
      }, e5.find = (e6, t3) => {
        for (const i2 of e6) if (t3(i2)) return i2;
      }, e5.isInteger = "function" == typeof Number.isInteger ? (e6) => Number.isInteger(e6) : (e6) => "number" == typeof e6 && isFinite(e6) && Math.floor(e6) === e6, e5.joinValues = function(e6, t3 = " | ") {
        return e6.map((e7) => "string" == typeof e7 ? `'${e7}'` : e7).join(t3);
      }, e5.jsonStringifyReplacer = (e6, t3) => "bigint" == typeof t3 ? t3.toString() : t3;
    }(util$1 || (util$1 = {})), function(e5) {
      e5.mergeShapes = (e6, t3) => ({ ...e6, ...t3 });
    }(objectUtil || (objectUtil = {}));
    ZodParsedType = util$1.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
    getParsedType = /* @__PURE__ */ __name((e5) => {
      switch (typeof e5) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(e5) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          return Array.isArray(e5) ? ZodParsedType.array : null === e5 ? ZodParsedType.null : e5.then && "function" == typeof e5.then && e5.catch && "function" == typeof e5.catch ? ZodParsedType.promise : "undefined" != typeof Map && e5 instanceof Map ? ZodParsedType.map : "undefined" != typeof Set && e5 instanceof Set ? ZodParsedType.set : "undefined" != typeof Date && e5 instanceof Date ? ZodParsedType.date : ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
    ZodIssueCode = util$1.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
    quotelessJson = /* @__PURE__ */ __name((e5) => JSON.stringify(e5, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson");
    ZodError = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      constructor(e5) {
        super(), this.issues = [], this.addIssue = (e6) => {
          this.issues = [...this.issues, e6];
        }, this.addIssues = (e6 = []) => {
          this.issues = [...this.issues, ...e6];
        };
        const t3 = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t3) : this.__proto__ = t3, this.name = "ZodError", this.issues = e5;
      }
      get errors() {
        return this.issues;
      }
      format(e5) {
        const t3 = e5 || function(e6) {
          return e6.message;
        }, i2 = { _errors: [] }, r4 = /* @__PURE__ */ __name((e6) => {
          for (const n3 of e6.issues) if ("invalid_union" === n3.code) n3.unionErrors.map(r4);
          else if ("invalid_return_type" === n3.code) r4(n3.returnTypeError);
          else if ("invalid_arguments" === n3.code) r4(n3.argumentsError);
          else if (0 === n3.path.length) i2._errors.push(t3(n3));
          else {
            let e7 = i2, r5 = 0;
            for (; r5 < n3.path.length; ) {
              const i3 = n3.path[r5];
              r5 === n3.path.length - 1 ? (e7[i3] = e7[i3] || { _errors: [] }, e7[i3]._errors.push(t3(n3))) : e7[i3] = e7[i3] || { _errors: [] }, e7 = e7[i3], r5++;
            }
          }
        }, "r");
        return r4(this), i2;
      }
      static assert(e5) {
        if (!(e5 instanceof _ZodError)) throw new Error(`Not a ZodError: ${e5}`);
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util$1.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return 0 === this.issues.length;
      }
      flatten(e5 = (e6) => e6.message) {
        const t3 = {}, i2 = [];
        for (const r4 of this.issues) r4.path.length > 0 ? (t3[r4.path[0]] = t3[r4.path[0]] || [], t3[r4.path[0]].push(e5(r4))) : i2.push(e5(r4));
        return { formErrors: i2, fieldErrors: t3 };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (e5) => new ZodError(e5);
    errorMap = /* @__PURE__ */ __name((e5, t3) => {
      let i2;
      switch (e5.code) {
        case ZodIssueCode.invalid_type:
          i2 = e5.received === ZodParsedType.undefined ? "Required" : `Expected ${e5.expected}, received ${e5.received}`;
          break;
        case ZodIssueCode.invalid_literal:
          i2 = `Invalid literal value, expected ${JSON.stringify(e5.expected, util$1.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          i2 = `Unrecognized key(s) in object: ${util$1.joinValues(e5.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          i2 = "Invalid input";
          break;
        case ZodIssueCode.invalid_union_discriminator:
          i2 = `Invalid discriminator value. Expected ${util$1.joinValues(e5.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          i2 = `Invalid enum value. Expected ${util$1.joinValues(e5.options)}, received '${e5.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          i2 = "Invalid function arguments";
          break;
        case ZodIssueCode.invalid_return_type:
          i2 = "Invalid function return type";
          break;
        case ZodIssueCode.invalid_date:
          i2 = "Invalid date";
          break;
        case ZodIssueCode.invalid_string:
          "object" == typeof e5.validation ? "includes" in e5.validation ? (i2 = `Invalid input: must include "${e5.validation.includes}"`, "number" == typeof e5.validation.position && (i2 = `${i2} at one or more positions greater than or equal to ${e5.validation.position}`)) : "startsWith" in e5.validation ? i2 = `Invalid input: must start with "${e5.validation.startsWith}"` : "endsWith" in e5.validation ? i2 = `Invalid input: must end with "${e5.validation.endsWith}"` : util$1.assertNever(e5.validation) : i2 = "regex" !== e5.validation ? `Invalid ${e5.validation}` : "Invalid";
          break;
        case ZodIssueCode.too_small:
          i2 = "array" === e5.type ? `Array must contain ${e5.exact ? "exactly" : e5.inclusive ? "at least" : "more than"} ${e5.minimum} element(s)` : "string" === e5.type ? `String must contain ${e5.exact ? "exactly" : e5.inclusive ? "at least" : "over"} ${e5.minimum} character(s)` : "number" === e5.type ? `Number must be ${e5.exact ? "exactly equal to " : e5.inclusive ? "greater than or equal to " : "greater than "}${e5.minimum}` : "date" === e5.type ? `Date must be ${e5.exact ? "exactly equal to " : e5.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e5.minimum))}` : "Invalid input";
          break;
        case ZodIssueCode.too_big:
          i2 = "array" === e5.type ? `Array must contain ${e5.exact ? "exactly" : e5.inclusive ? "at most" : "less than"} ${e5.maximum} element(s)` : "string" === e5.type ? `String must contain ${e5.exact ? "exactly" : e5.inclusive ? "at most" : "under"} ${e5.maximum} character(s)` : "number" === e5.type ? `Number must be ${e5.exact ? "exactly" : e5.inclusive ? "less than or equal to" : "less than"} ${e5.maximum}` : "bigint" === e5.type ? `BigInt must be ${e5.exact ? "exactly" : e5.inclusive ? "less than or equal to" : "less than"} ${e5.maximum}` : "date" === e5.type ? `Date must be ${e5.exact ? "exactly" : e5.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e5.maximum))}` : "Invalid input";
          break;
        case ZodIssueCode.custom:
          i2 = "Invalid input";
          break;
        case ZodIssueCode.invalid_intersection_types:
          i2 = "Intersection results could not be merged";
          break;
        case ZodIssueCode.not_multiple_of:
          i2 = `Number must be a multiple of ${e5.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          i2 = "Number must be finite";
          break;
        default:
          i2 = t3.defaultError, util$1.assertNever(e5);
      }
      return { message: i2 };
    }, "errorMap");
    overrideErrorMap = errorMap;
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
    makeIssue = /* @__PURE__ */ __name((e5) => {
      const { data: t3, path: i2, errorMaps: r4, issueData: n3 } = e5, a2 = [...i2, ...n3.path || []], o3 = { ...n3, path: a2 };
      if (void 0 !== n3.message) return { ...n3, path: a2, message: n3.message };
      let s4 = "";
      const l2 = r4.filter((e6) => !!e6).slice().reverse();
      for (const e6 of l2) s4 = e6(o3, { data: t3, defaultError: s4 }).message;
      return { ...n3, path: a2, message: s4 };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        "valid" === this.value && (this.value = "dirty");
      }
      abort() {
        "aborted" !== this.value && (this.value = "aborted");
      }
      static mergeArray(e5, t3) {
        const i2 = [];
        for (const r4 of t3) {
          if ("aborted" === r4.status) return INVALID;
          "dirty" === r4.status && e5.dirty(), i2.push(r4.value);
        }
        return { status: e5.value, value: i2 };
      }
      static async mergeObjectAsync(e5, t3) {
        const i2 = [];
        for (const e6 of t3) {
          const t4 = await e6.key, r4 = await e6.value;
          i2.push({ key: t4, value: r4 });
        }
        return _ParseStatus.mergeObjectSync(e5, i2);
      }
      static mergeObjectSync(e5, t3) {
        const i2 = {};
        for (const r4 of t3) {
          const { key: t4, value: n3 } = r4;
          if ("aborted" === t4.status) return INVALID;
          if ("aborted" === n3.status) return INVALID;
          "dirty" === t4.status && e5.dirty(), "dirty" === n3.status && e5.dirty(), "__proto__" === t4.value || void 0 === n3.value && !r4.alwaysSet || (i2[t4.value] = n3.value);
        }
        return { status: e5.value, value: i2 };
      }
    };
    INVALID = Object.freeze({ status: "aborted" });
    DIRTY2 = /* @__PURE__ */ __name((e5) => ({ status: "dirty", value: e5 }), "DIRTY");
    OK = /* @__PURE__ */ __name((e5) => ({ status: "valid", value: e5 }), "OK");
    isAborted = /* @__PURE__ */ __name((e5) => "aborted" === e5.status, "isAborted");
    isDirty = /* @__PURE__ */ __name((e5) => "dirty" === e5.status, "isDirty");
    isValid = /* @__PURE__ */ __name((e5) => "valid" === e5.status, "isValid");
    isAsync = /* @__PURE__ */ __name((e5) => "undefined" != typeof Promise && e5 instanceof Promise, "isAsync");
    __name(__classPrivateFieldGet, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet, "__classPrivateFieldSet");
    "function" == typeof SuppressedError && SuppressedError, function(e5) {
      e5.errToObj = (e6) => "string" == typeof e6 ? { message: e6 } : e6 || {}, e5.toString = (e6) => "string" == typeof e6 ? e6 : null == e6 ? void 0 : e6.message;
    }(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(e5, t3, i2, r4) {
        this._cachedPath = [], this.parent = e5, this.data = t3, this._path = i2, this._key = r4;
      }
      get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((e5, t3) => {
      if (isValid(t3)) return { success: true, data: t3.value };
      if (!e5.common.issues.length) throw new Error("Validation failed but no issues detected.");
      return { success: false, get error() {
        if (this._error) return this._error;
        const t4 = new ZodError(e5.common.issues);
        return this._error = t4, this._error;
      } };
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType = class {
      static {
        __name(this, "ZodType");
      }
      constructor(e5) {
        this.spa = this.safeParseAsync, this._def = e5, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(e5) {
        return getParsedType(e5.data);
      }
      _getOrReturnCtx(e5, t3) {
        return t3 || { common: e5.parent.common, data: e5.data, parsedType: getParsedType(e5.data), schemaErrorMap: this._def.errorMap, path: e5.path, parent: e5.parent };
      }
      _processInputParams(e5) {
        return { status: new ParseStatus(), ctx: { common: e5.parent.common, data: e5.data, parsedType: getParsedType(e5.data), schemaErrorMap: this._def.errorMap, path: e5.path, parent: e5.parent } };
      }
      _parseSync(e5) {
        const t3 = this._parse(e5);
        if (isAsync(t3)) throw new Error("Synchronous parse encountered promise.");
        return t3;
      }
      _parseAsync(e5) {
        const t3 = this._parse(e5);
        return Promise.resolve(t3);
      }
      parse(e5, t3) {
        const i2 = this.safeParse(e5, t3);
        if (i2.success) return i2.data;
        throw i2.error;
      }
      safeParse(e5, t3) {
        var i2;
        const r4 = { common: { issues: [], async: null !== (i2 = null == t3 ? void 0 : t3.async) && void 0 !== i2 && i2, contextualErrorMap: null == t3 ? void 0 : t3.errorMap }, path: (null == t3 ? void 0 : t3.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e5, parsedType: getParsedType(e5) }, n3 = this._parseSync({ data: e5, path: r4.path, parent: r4 });
        return handleResult(r4, n3);
      }
      async parseAsync(e5, t3) {
        const i2 = await this.safeParseAsync(e5, t3);
        if (i2.success) return i2.data;
        throw i2.error;
      }
      async safeParseAsync(e5, t3) {
        const i2 = { common: { issues: [], contextualErrorMap: null == t3 ? void 0 : t3.errorMap, async: true }, path: (null == t3 ? void 0 : t3.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e5, parsedType: getParsedType(e5) }, r4 = this._parse({ data: e5, path: i2.path, parent: i2 }), n3 = await (isAsync(r4) ? r4 : Promise.resolve(r4));
        return handleResult(i2, n3);
      }
      refine(e5, t3) {
        const i2 = /* @__PURE__ */ __name((e6) => "string" == typeof t3 || void 0 === t3 ? { message: t3 } : "function" == typeof t3 ? t3(e6) : t3, "i");
        return this._refinement((t4, r4) => {
          const n3 = e5(t4), a2 = /* @__PURE__ */ __name(() => r4.addIssue({ code: ZodIssueCode.custom, ...i2(t4) }), "a");
          return "undefined" != typeof Promise && n3 instanceof Promise ? n3.then((e6) => !!e6 || (a2(), false)) : !!n3 || (a2(), false);
        });
      }
      refinement(e5, t3) {
        return this._refinement((i2, r4) => !!e5(i2) || (r4.addIssue("function" == typeof t3 ? t3(i2, r4) : t3), false));
      }
      _refinement(e5) {
        return new ZodEffects({ schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "refinement", refinement: e5 } });
      }
      superRefine(e5) {
        return this._refinement(e5);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(e5) {
        return ZodUnion.create([this, e5], this._def);
      }
      and(e5) {
        return ZodIntersection.create(this, e5, this._def);
      }
      transform(e5) {
        return new ZodEffects({ ...processCreateParams(this._def), schema: this, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: { type: "transform", transform: e5 } });
      }
      default(e5) {
        const t3 = "function" == typeof e5 ? e5 : () => e5;
        return new ZodDefault({ ...processCreateParams(this._def), innerType: this, defaultValue: t3, typeName: ZodFirstPartyTypeKind.ZodDefault });
      }
      brand() {
        return new ZodBranded({ typeName: ZodFirstPartyTypeKind.ZodBranded, type: this, ...processCreateParams(this._def) });
      }
      catch(e5) {
        const t3 = "function" == typeof e5 ? e5 : () => e5;
        return new ZodCatch({ ...processCreateParams(this._def), innerType: this, catchValue: t3, typeName: ZodFirstPartyTypeKind.ZodCatch });
      }
      describe(e5) {
        return new (0, this.constructor)({ ...this._def, description: e5 });
      }
      pipe(e5) {
        return ZodPipeline.create(this, e5);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    ZodString = class _ZodString extends ZodType {
      static {
        __name(this, "ZodString");
      }
      _parse(e5) {
        this._def.coerce && (e5.data = String(e5.data));
        if (this._getType(e5) !== ZodParsedType.string) {
          const t4 = this._getOrReturnCtx(e5);
          return addIssueToContext(t4, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.string, received: t4.parsedType }), INVALID;
        }
        const t3 = new ParseStatus();
        let i2;
        for (const r4 of this._def.checks) if ("min" === r4.kind) e5.data.length < r4.value && (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: r4.value, type: "string", inclusive: true, exact: false, message: r4.message }), t3.dirty());
        else if ("max" === r4.kind) e5.data.length > r4.value && (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: r4.value, type: "string", inclusive: true, exact: false, message: r4.message }), t3.dirty());
        else if ("length" === r4.kind) {
          const n3 = e5.data.length > r4.value, a2 = e5.data.length < r4.value;
          (n3 || a2) && (i2 = this._getOrReturnCtx(e5, i2), n3 ? addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: r4.value, type: "string", inclusive: true, exact: true, message: r4.message }) : a2 && addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: r4.value, type: "string", inclusive: true, exact: true, message: r4.message }), t3.dirty());
        } else if ("email" === r4.kind) emailRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "email", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("emoji" === r4.kind) emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "emoji", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("uuid" === r4.kind) uuidRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "uuid", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("nanoid" === r4.kind) nanoidRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "nanoid", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("cuid" === r4.kind) cuidRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "cuid", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("cuid2" === r4.kind) cuid2Regex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "cuid2", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("ulid" === r4.kind) ulidRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "ulid", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        else if ("url" === r4.kind) try {
          new URL(e5.data);
        } catch (n3) {
          i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "url", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty();
        }
        else if ("regex" === r4.kind) {
          r4.regex.lastIndex = 0;
          r4.regex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "regex", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty());
        } else if ("trim" === r4.kind) e5.data = e5.data.trim();
        else if ("includes" === r4.kind) e5.data.includes(r4.value, r4.position) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: { includes: r4.value, position: r4.position }, message: r4.message }), t3.dirty());
        else if ("toLowerCase" === r4.kind) e5.data = e5.data.toLowerCase();
        else if ("toUpperCase" === r4.kind) e5.data = e5.data.toUpperCase();
        else if ("startsWith" === r4.kind) e5.data.startsWith(r4.value) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: { startsWith: r4.value }, message: r4.message }), t3.dirty());
        else if ("endsWith" === r4.kind) e5.data.endsWith(r4.value) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: { endsWith: r4.value }, message: r4.message }), t3.dirty());
        else if ("datetime" === r4.kind) {
          datetimeRegex(r4).test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: "datetime", message: r4.message }), t3.dirty());
        } else if ("date" === r4.kind) {
          dateRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: "date", message: r4.message }), t3.dirty());
        } else if ("time" === r4.kind) {
          timeRegex(r4).test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.invalid_string, validation: "time", message: r4.message }), t3.dirty());
        } else "duration" === r4.kind ? durationRegex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "duration", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty()) : "ip" === r4.kind ? isValidIP(e5.data, r4.version) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "ip", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty()) : "base64" === r4.kind ? base64Regex.test(e5.data) || (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { validation: "base64", code: ZodIssueCode.invalid_string, message: r4.message }), t3.dirty()) : util$1.assertNever(r4);
        return { status: t3.value, value: e5.data };
      }
      _regex(e5, t3, i2) {
        return this.refinement((t4) => e5.test(t4), { validation: t3, code: ZodIssueCode.invalid_string, ...errorUtil.errToObj(i2) });
      }
      _addCheck(e5) {
        return new _ZodString({ ...this._def, checks: [...this._def.checks, e5] });
      }
      email(e5) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(e5) });
      }
      url(e5) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(e5) });
      }
      emoji(e5) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(e5) });
      }
      uuid(e5) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(e5) });
      }
      nanoid(e5) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(e5) });
      }
      cuid(e5) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(e5) });
      }
      cuid2(e5) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(e5) });
      }
      ulid(e5) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(e5) });
      }
      base64(e5) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(e5) });
      }
      ip(e5) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(e5) });
      }
      datetime(e5) {
        var t3, i2;
        return "string" == typeof e5 ? this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: e5 }) : this._addCheck({ kind: "datetime", precision: void 0 === (null == e5 ? void 0 : e5.precision) ? null : null == e5 ? void 0 : e5.precision, offset: null !== (t3 = null == e5 ? void 0 : e5.offset) && void 0 !== t3 && t3, local: null !== (i2 = null == e5 ? void 0 : e5.local) && void 0 !== i2 && i2, ...errorUtil.errToObj(null == e5 ? void 0 : e5.message) });
      }
      date(e5) {
        return this._addCheck({ kind: "date", message: e5 });
      }
      time(e5) {
        return "string" == typeof e5 ? this._addCheck({ kind: "time", precision: null, message: e5 }) : this._addCheck({ kind: "time", precision: void 0 === (null == e5 ? void 0 : e5.precision) ? null : null == e5 ? void 0 : e5.precision, ...errorUtil.errToObj(null == e5 ? void 0 : e5.message) });
      }
      duration(e5) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(e5) });
      }
      regex(e5, t3) {
        return this._addCheck({ kind: "regex", regex: e5, ...errorUtil.errToObj(t3) });
      }
      includes(e5, t3) {
        return this._addCheck({ kind: "includes", value: e5, position: null == t3 ? void 0 : t3.position, ...errorUtil.errToObj(null == t3 ? void 0 : t3.message) });
      }
      startsWith(e5, t3) {
        return this._addCheck({ kind: "startsWith", value: e5, ...errorUtil.errToObj(t3) });
      }
      endsWith(e5, t3) {
        return this._addCheck({ kind: "endsWith", value: e5, ...errorUtil.errToObj(t3) });
      }
      min(e5, t3) {
        return this._addCheck({ kind: "min", value: e5, ...errorUtil.errToObj(t3) });
      }
      max(e5, t3) {
        return this._addCheck({ kind: "max", value: e5, ...errorUtil.errToObj(t3) });
      }
      length(e5, t3) {
        return this._addCheck({ kind: "length", value: e5, ...errorUtil.errToObj(t3) });
      }
      nonempty(e5) {
        return this.min(1, errorUtil.errToObj(e5));
      }
      trim() {
        return new _ZodString({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
      }
      toLowerCase() {
        return new _ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
      }
      toUpperCase() {
        return new _ZodString({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
      }
      get isDatetime() {
        return !!this._def.checks.find((e5) => "datetime" === e5.kind);
      }
      get isDate() {
        return !!this._def.checks.find((e5) => "date" === e5.kind);
      }
      get isTime() {
        return !!this._def.checks.find((e5) => "time" === e5.kind);
      }
      get isDuration() {
        return !!this._def.checks.find((e5) => "duration" === e5.kind);
      }
      get isEmail() {
        return !!this._def.checks.find((e5) => "email" === e5.kind);
      }
      get isURL() {
        return !!this._def.checks.find((e5) => "url" === e5.kind);
      }
      get isEmoji() {
        return !!this._def.checks.find((e5) => "emoji" === e5.kind);
      }
      get isUUID() {
        return !!this._def.checks.find((e5) => "uuid" === e5.kind);
      }
      get isNANOID() {
        return !!this._def.checks.find((e5) => "nanoid" === e5.kind);
      }
      get isCUID() {
        return !!this._def.checks.find((e5) => "cuid" === e5.kind);
      }
      get isCUID2() {
        return !!this._def.checks.find((e5) => "cuid2" === e5.kind);
      }
      get isULID() {
        return !!this._def.checks.find((e5) => "ulid" === e5.kind);
      }
      get isIP() {
        return !!this._def.checks.find((e5) => "ip" === e5.kind);
      }
      get isBase64() {
        return !!this._def.checks.find((e5) => "base64" === e5.kind);
      }
      get minLength() {
        let e5 = null;
        for (const t3 of this._def.checks) "min" === t3.kind && (null === e5 || t3.value > e5) && (e5 = t3.value);
        return e5;
      }
      get maxLength() {
        let e5 = null;
        for (const t3 of this._def.checks) "max" === t3.kind && (null === e5 || t3.value < e5) && (e5 = t3.value);
        return e5;
      }
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    ZodString.create = (e5) => {
      var t3;
      return new ZodString({ checks: [], typeName: ZodFirstPartyTypeKind.ZodString, coerce: null !== (t3 = null == e5 ? void 0 : e5.coerce) && void 0 !== t3 && t3, ...processCreateParams(e5) });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
      }
      _parse(e5) {
        this._def.coerce && (e5.data = Number(e5.data));
        if (this._getType(e5) !== ZodParsedType.number) {
          const t4 = this._getOrReturnCtx(e5);
          return addIssueToContext(t4, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.number, received: t4.parsedType }), INVALID;
        }
        let t3;
        const i2 = new ParseStatus();
        for (const r4 of this._def.checks) if ("int" === r4.kind) util$1.isInteger(e5.data) || (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: "integer", received: "float", message: r4.message }), i2.dirty());
        else if ("min" === r4.kind) {
          (r4.inclusive ? e5.data < r4.value : e5.data <= r4.value) && (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.too_small, minimum: r4.value, type: "number", inclusive: r4.inclusive, exact: false, message: r4.message }), i2.dirty());
        } else if ("max" === r4.kind) {
          (r4.inclusive ? e5.data > r4.value : e5.data >= r4.value) && (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.too_big, maximum: r4.value, type: "number", inclusive: r4.inclusive, exact: false, message: r4.message }), i2.dirty());
        } else "multipleOf" === r4.kind ? 0 !== floatSafeRemainder(e5.data, r4.value) && (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.not_multiple_of, multipleOf: r4.value, message: r4.message }), i2.dirty()) : "finite" === r4.kind ? Number.isFinite(e5.data) || (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.not_finite, message: r4.message }), i2.dirty()) : util$1.assertNever(r4);
        return { status: i2.value, value: e5.data };
      }
      gte(e5, t3) {
        return this.setLimit("min", e5, true, errorUtil.toString(t3));
      }
      gt(e5, t3) {
        return this.setLimit("min", e5, false, errorUtil.toString(t3));
      }
      lte(e5, t3) {
        return this.setLimit("max", e5, true, errorUtil.toString(t3));
      }
      lt(e5, t3) {
        return this.setLimit("max", e5, false, errorUtil.toString(t3));
      }
      setLimit(e5, t3, i2, r4) {
        return new _ZodNumber({ ...this._def, checks: [...this._def.checks, { kind: e5, value: t3, inclusive: i2, message: errorUtil.toString(r4) }] });
      }
      _addCheck(e5) {
        return new _ZodNumber({ ...this._def, checks: [...this._def.checks, e5] });
      }
      int(e5) {
        return this._addCheck({ kind: "int", message: errorUtil.toString(e5) });
      }
      positive(e5) {
        return this._addCheck({ kind: "min", value: 0, inclusive: false, message: errorUtil.toString(e5) });
      }
      negative(e5) {
        return this._addCheck({ kind: "max", value: 0, inclusive: false, message: errorUtil.toString(e5) });
      }
      nonpositive(e5) {
        return this._addCheck({ kind: "max", value: 0, inclusive: true, message: errorUtil.toString(e5) });
      }
      nonnegative(e5) {
        return this._addCheck({ kind: "min", value: 0, inclusive: true, message: errorUtil.toString(e5) });
      }
      multipleOf(e5, t3) {
        return this._addCheck({ kind: "multipleOf", value: e5, message: errorUtil.toString(t3) });
      }
      finite(e5) {
        return this._addCheck({ kind: "finite", message: errorUtil.toString(e5) });
      }
      safe(e5) {
        return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: errorUtil.toString(e5) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: errorUtil.toString(e5) });
      }
      get minValue() {
        let e5 = null;
        for (const t3 of this._def.checks) "min" === t3.kind && (null === e5 || t3.value > e5) && (e5 = t3.value);
        return e5;
      }
      get maxValue() {
        let e5 = null;
        for (const t3 of this._def.checks) "max" === t3.kind && (null === e5 || t3.value < e5) && (e5 = t3.value);
        return e5;
      }
      get isInt() {
        return !!this._def.checks.find((e5) => "int" === e5.kind || "multipleOf" === e5.kind && util$1.isInteger(e5.value));
      }
      get isFinite() {
        let e5 = null, t3 = null;
        for (const i2 of this._def.checks) {
          if ("finite" === i2.kind || "int" === i2.kind || "multipleOf" === i2.kind) return true;
          "min" === i2.kind ? (null === t3 || i2.value > t3) && (t3 = i2.value) : "max" === i2.kind && (null === e5 || i2.value < e5) && (e5 = i2.value);
        }
        return Number.isFinite(t3) && Number.isFinite(e5);
      }
    };
    ZodNumber.create = (e5) => new ZodNumber({ checks: [], typeName: ZodFirstPartyTypeKind.ZodNumber, coerce: (null == e5 ? void 0 : e5.coerce) || false, ...processCreateParams(e5) });
    ZodBigInt = class _ZodBigInt extends ZodType {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte;
      }
      _parse(e5) {
        this._def.coerce && (e5.data = BigInt(e5.data));
        if (this._getType(e5) !== ZodParsedType.bigint) {
          const t4 = this._getOrReturnCtx(e5);
          return addIssueToContext(t4, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.bigint, received: t4.parsedType }), INVALID;
        }
        let t3;
        const i2 = new ParseStatus();
        for (const r4 of this._def.checks) if ("min" === r4.kind) {
          (r4.inclusive ? e5.data < r4.value : e5.data <= r4.value) && (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.too_small, type: "bigint", minimum: r4.value, inclusive: r4.inclusive, message: r4.message }), i2.dirty());
        } else if ("max" === r4.kind) {
          (r4.inclusive ? e5.data > r4.value : e5.data >= r4.value) && (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.too_big, type: "bigint", maximum: r4.value, inclusive: r4.inclusive, message: r4.message }), i2.dirty());
        } else "multipleOf" === r4.kind ? e5.data % r4.value !== BigInt(0) && (t3 = this._getOrReturnCtx(e5, t3), addIssueToContext(t3, { code: ZodIssueCode.not_multiple_of, multipleOf: r4.value, message: r4.message }), i2.dirty()) : util$1.assertNever(r4);
        return { status: i2.value, value: e5.data };
      }
      gte(e5, t3) {
        return this.setLimit("min", e5, true, errorUtil.toString(t3));
      }
      gt(e5, t3) {
        return this.setLimit("min", e5, false, errorUtil.toString(t3));
      }
      lte(e5, t3) {
        return this.setLimit("max", e5, true, errorUtil.toString(t3));
      }
      lt(e5, t3) {
        return this.setLimit("max", e5, false, errorUtil.toString(t3));
      }
      setLimit(e5, t3, i2, r4) {
        return new _ZodBigInt({ ...this._def, checks: [...this._def.checks, { kind: e5, value: t3, inclusive: i2, message: errorUtil.toString(r4) }] });
      }
      _addCheck(e5) {
        return new _ZodBigInt({ ...this._def, checks: [...this._def.checks, e5] });
      }
      positive(e5) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: errorUtil.toString(e5) });
      }
      negative(e5) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: errorUtil.toString(e5) });
      }
      nonpositive(e5) {
        return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: errorUtil.toString(e5) });
      }
      nonnegative(e5) {
        return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: errorUtil.toString(e5) });
      }
      multipleOf(e5, t3) {
        return this._addCheck({ kind: "multipleOf", value: e5, message: errorUtil.toString(t3) });
      }
      get minValue() {
        let e5 = null;
        for (const t3 of this._def.checks) "min" === t3.kind && (null === e5 || t3.value > e5) && (e5 = t3.value);
        return e5;
      }
      get maxValue() {
        let e5 = null;
        for (const t3 of this._def.checks) "max" === t3.kind && (null === e5 || t3.value < e5) && (e5 = t3.value);
        return e5;
      }
    };
    ZodBigInt.create = (e5) => {
      var t3;
      return new ZodBigInt({ checks: [], typeName: ZodFirstPartyTypeKind.ZodBigInt, coerce: null !== (t3 = null == e5 ? void 0 : e5.coerce) && void 0 !== t3 && t3, ...processCreateParams(e5) });
    };
    ZodBoolean = class extends ZodType {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(e5) {
        this._def.coerce && (e5.data = Boolean(e5.data));
        if (this._getType(e5) !== ZodParsedType.boolean) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.boolean, received: t3.parsedType }), INVALID;
        }
        return OK(e5.data);
      }
    };
    ZodBoolean.create = (e5) => new ZodBoolean({ typeName: ZodFirstPartyTypeKind.ZodBoolean, coerce: (null == e5 ? void 0 : e5.coerce) || false, ...processCreateParams(e5) });
    ZodDate = class _ZodDate extends ZodType {
      static {
        __name(this, "ZodDate");
      }
      _parse(e5) {
        this._def.coerce && (e5.data = new Date(e5.data));
        if (this._getType(e5) !== ZodParsedType.date) {
          const t4 = this._getOrReturnCtx(e5);
          return addIssueToContext(t4, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.date, received: t4.parsedType }), INVALID;
        }
        if (isNaN(e5.data.getTime())) {
          return addIssueToContext(this._getOrReturnCtx(e5), { code: ZodIssueCode.invalid_date }), INVALID;
        }
        const t3 = new ParseStatus();
        let i2;
        for (const r4 of this._def.checks) "min" === r4.kind ? e5.data.getTime() < r4.value && (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.too_small, message: r4.message, inclusive: true, exact: false, minimum: r4.value, type: "date" }), t3.dirty()) : "max" === r4.kind ? e5.data.getTime() > r4.value && (i2 = this._getOrReturnCtx(e5, i2), addIssueToContext(i2, { code: ZodIssueCode.too_big, message: r4.message, inclusive: true, exact: false, maximum: r4.value, type: "date" }), t3.dirty()) : util$1.assertNever(r4);
        return { status: t3.value, value: new Date(e5.data.getTime()) };
      }
      _addCheck(e5) {
        return new _ZodDate({ ...this._def, checks: [...this._def.checks, e5] });
      }
      min(e5, t3) {
        return this._addCheck({ kind: "min", value: e5.getTime(), message: errorUtil.toString(t3) });
      }
      max(e5, t3) {
        return this._addCheck({ kind: "max", value: e5.getTime(), message: errorUtil.toString(t3) });
      }
      get minDate() {
        let e5 = null;
        for (const t3 of this._def.checks) "min" === t3.kind && (null === e5 || t3.value > e5) && (e5 = t3.value);
        return null != e5 ? new Date(e5) : null;
      }
      get maxDate() {
        let e5 = null;
        for (const t3 of this._def.checks) "max" === t3.kind && (null === e5 || t3.value < e5) && (e5 = t3.value);
        return null != e5 ? new Date(e5) : null;
      }
    };
    ZodDate.create = (e5) => new ZodDate({ checks: [], coerce: (null == e5 ? void 0 : e5.coerce) || false, typeName: ZodFirstPartyTypeKind.ZodDate, ...processCreateParams(e5) });
    ZodSymbol = class extends ZodType {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(e5) {
        if (this._getType(e5) !== ZodParsedType.symbol) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.symbol, received: t3.parsedType }), INVALID;
        }
        return OK(e5.data);
      }
    };
    ZodSymbol.create = (e5) => new ZodSymbol({ typeName: ZodFirstPartyTypeKind.ZodSymbol, ...processCreateParams(e5) });
    ZodUndefined = class extends ZodType {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(e5) {
        if (this._getType(e5) !== ZodParsedType.undefined) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.undefined, received: t3.parsedType }), INVALID;
        }
        return OK(e5.data);
      }
    };
    ZodUndefined.create = (e5) => new ZodUndefined({ typeName: ZodFirstPartyTypeKind.ZodUndefined, ...processCreateParams(e5) });
    ZodNull = class extends ZodType {
      static {
        __name(this, "ZodNull");
      }
      _parse(e5) {
        if (this._getType(e5) !== ZodParsedType.null) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.null, received: t3.parsedType }), INVALID;
        }
        return OK(e5.data);
      }
    };
    ZodNull.create = (e5) => new ZodNull({ typeName: ZodFirstPartyTypeKind.ZodNull, ...processCreateParams(e5) });
    ZodAny = class extends ZodType {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments), this._any = true;
      }
      _parse(e5) {
        return OK(e5.data);
      }
    };
    ZodAny.create = (e5) => new ZodAny({ typeName: ZodFirstPartyTypeKind.ZodAny, ...processCreateParams(e5) });
    ZodUnknown = class extends ZodType {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments), this._unknown = true;
      }
      _parse(e5) {
        return OK(e5.data);
      }
    };
    ZodUnknown.create = (e5) => new ZodUnknown({ typeName: ZodFirstPartyTypeKind.ZodUnknown, ...processCreateParams(e5) });
    ZodNever = class extends ZodType {
      static {
        __name(this, "ZodNever");
      }
      _parse(e5) {
        const t3 = this._getOrReturnCtx(e5);
        return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.never, received: t3.parsedType }), INVALID;
      }
    };
    ZodNever.create = (e5) => new ZodNever({ typeName: ZodFirstPartyTypeKind.ZodNever, ...processCreateParams(e5) });
    ZodVoid = class extends ZodType {
      static {
        __name(this, "ZodVoid");
      }
      _parse(e5) {
        if (this._getType(e5) !== ZodParsedType.undefined) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.void, received: t3.parsedType }), INVALID;
        }
        return OK(e5.data);
      }
    };
    ZodVoid.create = (e5) => new ZodVoid({ typeName: ZodFirstPartyTypeKind.ZodVoid, ...processCreateParams(e5) });
    ZodArray = class _ZodArray extends ZodType {
      static {
        __name(this, "ZodArray");
      }
      _parse(e5) {
        const { ctx: t3, status: i2 } = this._processInputParams(e5), r4 = this._def;
        if (t3.parsedType !== ZodParsedType.array) return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: t3.parsedType }), INVALID;
        if (null !== r4.exactLength) {
          const e6 = t3.data.length > r4.exactLength.value, n4 = t3.data.length < r4.exactLength.value;
          (e6 || n4) && (addIssueToContext(t3, { code: e6 ? ZodIssueCode.too_big : ZodIssueCode.too_small, minimum: n4 ? r4.exactLength.value : void 0, maximum: e6 ? r4.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: r4.exactLength.message }), i2.dirty());
        }
        if (null !== r4.minLength && t3.data.length < r4.minLength.value && (addIssueToContext(t3, { code: ZodIssueCode.too_small, minimum: r4.minLength.value, type: "array", inclusive: true, exact: false, message: r4.minLength.message }), i2.dirty()), null !== r4.maxLength && t3.data.length > r4.maxLength.value && (addIssueToContext(t3, { code: ZodIssueCode.too_big, maximum: r4.maxLength.value, type: "array", inclusive: true, exact: false, message: r4.maxLength.message }), i2.dirty()), t3.common.async) return Promise.all([...t3.data].map((e6, i3) => r4.type._parseAsync(new ParseInputLazyPath(t3, e6, t3.path, i3)))).then((e6) => ParseStatus.mergeArray(i2, e6));
        const n3 = [...t3.data].map((e6, i3) => r4.type._parseSync(new ParseInputLazyPath(t3, e6, t3.path, i3)));
        return ParseStatus.mergeArray(i2, n3);
      }
      get element() {
        return this._def.type;
      }
      min(e5, t3) {
        return new _ZodArray({ ...this._def, minLength: { value: e5, message: errorUtil.toString(t3) } });
      }
      max(e5, t3) {
        return new _ZodArray({ ...this._def, maxLength: { value: e5, message: errorUtil.toString(t3) } });
      }
      length(e5, t3) {
        return new _ZodArray({ ...this._def, exactLength: { value: e5, message: errorUtil.toString(t3) } });
      }
      nonempty(e5) {
        return this.min(1, e5);
      }
    };
    __name(deepPartialify, "deepPartialify");
    ZodArray.create = (e5, t3) => new ZodArray({ type: e5, minLength: null, maxLength: null, exactLength: null, typeName: ZodFirstPartyTypeKind.ZodArray, ...processCreateParams(t3) });
    ZodObject = class _ZodObject extends ZodType {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
      }
      _getCached() {
        if (null !== this._cached) return this._cached;
        const e5 = this._def.shape(), t3 = util$1.objectKeys(e5);
        return this._cached = { shape: e5, keys: t3 };
      }
      _parse(e5) {
        if (this._getType(e5) !== ZodParsedType.object) {
          const t4 = this._getOrReturnCtx(e5);
          return addIssueToContext(t4, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: t4.parsedType }), INVALID;
        }
        const { status: t3, ctx: i2 } = this._processInputParams(e5), { shape: r4, keys: n3 } = this._getCached(), a2 = [];
        if (!(this._def.catchall instanceof ZodNever && "strip" === this._def.unknownKeys)) for (const e6 in i2.data) n3.includes(e6) || a2.push(e6);
        const o3 = [];
        for (const e6 of n3) {
          const t4 = r4[e6], n4 = i2.data[e6];
          o3.push({ key: { status: "valid", value: e6 }, value: t4._parse(new ParseInputLazyPath(i2, n4, i2.path, e6)), alwaysSet: e6 in i2.data });
        }
        if (this._def.catchall instanceof ZodNever) {
          const e6 = this._def.unknownKeys;
          if ("passthrough" === e6) for (const e7 of a2) o3.push({ key: { status: "valid", value: e7 }, value: { status: "valid", value: i2.data[e7] } });
          else if ("strict" === e6) a2.length > 0 && (addIssueToContext(i2, { code: ZodIssueCode.unrecognized_keys, keys: a2 }), t3.dirty());
          else if ("strip" !== e6) throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
          const e6 = this._def.catchall;
          for (const t4 of a2) {
            const r5 = i2.data[t4];
            o3.push({ key: { status: "valid", value: t4 }, value: e6._parse(new ParseInputLazyPath(i2, r5, i2.path, t4)), alwaysSet: t4 in i2.data });
          }
        }
        return i2.common.async ? Promise.resolve().then(async () => {
          const e6 = [];
          for (const t4 of o3) {
            const i3 = await t4.key, r5 = await t4.value;
            e6.push({ key: i3, value: r5, alwaysSet: t4.alwaysSet });
          }
          return e6;
        }).then((e6) => ParseStatus.mergeObjectSync(t3, e6)) : ParseStatus.mergeObjectSync(t3, o3);
      }
      get shape() {
        return this._def.shape();
      }
      strict(e5) {
        return errorUtil.errToObj, new _ZodObject({ ...this._def, unknownKeys: "strict", ...void 0 !== e5 ? { errorMap: /* @__PURE__ */ __name((t3, i2) => {
          var r4, n3, a2, o3;
          const s4 = null !== (a2 = null === (n3 = (r4 = this._def).errorMap) || void 0 === n3 ? void 0 : n3.call(r4, t3, i2).message) && void 0 !== a2 ? a2 : i2.defaultError;
          return "unrecognized_keys" === t3.code ? { message: null !== (o3 = errorUtil.errToObj(e5).message) && void 0 !== o3 ? o3 : s4 } : { message: s4 };
        }, "errorMap") } : {} });
      }
      strip() {
        return new _ZodObject({ ...this._def, unknownKeys: "strip" });
      }
      passthrough() {
        return new _ZodObject({ ...this._def, unknownKeys: "passthrough" });
      }
      extend(e5) {
        return new _ZodObject({ ...this._def, shape: /* @__PURE__ */ __name(() => ({ ...this._def.shape(), ...e5 }), "shape") });
      }
      merge(e5) {
        return new _ZodObject({ unknownKeys: e5._def.unknownKeys, catchall: e5._def.catchall, shape: /* @__PURE__ */ __name(() => ({ ...this._def.shape(), ...e5._def.shape() }), "shape"), typeName: ZodFirstPartyTypeKind.ZodObject });
      }
      setKey(e5, t3) {
        return this.augment({ [e5]: t3 });
      }
      catchall(e5) {
        return new _ZodObject({ ...this._def, catchall: e5 });
      }
      pick(e5) {
        const t3 = {};
        return util$1.objectKeys(e5).forEach((i2) => {
          e5[i2] && this.shape[i2] && (t3[i2] = this.shape[i2]);
        }), new _ZodObject({ ...this._def, shape: /* @__PURE__ */ __name(() => t3, "shape") });
      }
      omit(e5) {
        const t3 = {};
        return util$1.objectKeys(this.shape).forEach((i2) => {
          e5[i2] || (t3[i2] = this.shape[i2]);
        }), new _ZodObject({ ...this._def, shape: /* @__PURE__ */ __name(() => t3, "shape") });
      }
      deepPartial() {
        return deepPartialify(this);
      }
      partial(e5) {
        const t3 = {};
        return util$1.objectKeys(this.shape).forEach((i2) => {
          const r4 = this.shape[i2];
          e5 && !e5[i2] ? t3[i2] = r4 : t3[i2] = r4.optional();
        }), new _ZodObject({ ...this._def, shape: /* @__PURE__ */ __name(() => t3, "shape") });
      }
      required(e5) {
        const t3 = {};
        return util$1.objectKeys(this.shape).forEach((i2) => {
          if (e5 && !e5[i2]) t3[i2] = this.shape[i2];
          else {
            let e6 = this.shape[i2];
            for (; e6 instanceof ZodOptional; ) e6 = e6._def.innerType;
            t3[i2] = e6;
          }
        }), new _ZodObject({ ...this._def, shape: /* @__PURE__ */ __name(() => t3, "shape") });
      }
      keyof() {
        return createZodEnum(util$1.objectKeys(this.shape));
      }
    };
    ZodObject.create = (e5, t3) => new ZodObject({ shape: /* @__PURE__ */ __name(() => e5, "shape"), unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t3) }), ZodObject.strictCreate = (e5, t3) => new ZodObject({ shape: /* @__PURE__ */ __name(() => e5, "shape"), unknownKeys: "strict", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t3) }), ZodObject.lazycreate = (e5, t3) => new ZodObject({ shape: e5, unknownKeys: "strip", catchall: ZodNever.create(), typeName: ZodFirstPartyTypeKind.ZodObject, ...processCreateParams(t3) });
    ZodUnion = class extends ZodType {
      static {
        __name(this, "ZodUnion");
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5), i2 = this._def.options;
        if (t3.common.async) return Promise.all(i2.map(async (e6) => {
          const i3 = { ...t3, common: { ...t3.common, issues: [] }, parent: null };
          return { result: await e6._parseAsync({ data: t3.data, path: t3.path, parent: i3 }), ctx: i3 };
        })).then(function(e6) {
          for (const t4 of e6) if ("valid" === t4.result.status) return t4.result;
          for (const i4 of e6) if ("dirty" === i4.result.status) return t3.common.issues.push(...i4.ctx.common.issues), i4.result;
          const i3 = e6.map((e7) => new ZodError(e7.ctx.common.issues));
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_union, unionErrors: i3 }), INVALID;
        });
        {
          let e6;
          const r4 = [];
          for (const n4 of i2) {
            const i3 = { ...t3, common: { ...t3.common, issues: [] }, parent: null }, a2 = n4._parseSync({ data: t3.data, path: t3.path, parent: i3 });
            if ("valid" === a2.status) return a2;
            "dirty" !== a2.status || e6 || (e6 = { result: a2, ctx: i3 }), i3.common.issues.length && r4.push(i3.common.issues);
          }
          if (e6) return t3.common.issues.push(...e6.ctx.common.issues), e6.result;
          const n3 = r4.map((e7) => new ZodError(e7));
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_union, unionErrors: n3 }), INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (e5, t3) => new ZodUnion({ options: e5, typeName: ZodFirstPartyTypeKind.ZodUnion, ...processCreateParams(t3) });
    getDiscriminator = /* @__PURE__ */ __name((e5) => e5 instanceof ZodLazy ? getDiscriminator(e5.schema) : e5 instanceof ZodEffects ? getDiscriminator(e5.innerType()) : e5 instanceof ZodLiteral ? [e5.value] : e5 instanceof ZodEnum ? e5.options : e5 instanceof ZodNativeEnum ? util$1.objectValues(e5.enum) : e5 instanceof ZodDefault ? getDiscriminator(e5._def.innerType) : e5 instanceof ZodUndefined ? [void 0] : e5 instanceof ZodNull ? [null] : e5 instanceof ZodOptional ? [void 0, ...getDiscriminator(e5.unwrap())] : e5 instanceof ZodNullable ? [null, ...getDiscriminator(e5.unwrap())] : e5 instanceof ZodBranded || e5 instanceof ZodReadonly ? getDiscriminator(e5.unwrap()) : e5 instanceof ZodCatch ? getDiscriminator(e5._def.innerType) : [], "getDiscriminator");
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5);
        if (t3.parsedType !== ZodParsedType.object) return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: t3.parsedType }), INVALID;
        const i2 = this.discriminator, r4 = t3.data[i2], n3 = this.optionsMap.get(r4);
        return n3 ? t3.common.async ? n3._parseAsync({ data: t3.data, path: t3.path, parent: t3 }) : n3._parseSync({ data: t3.data, path: t3.path, parent: t3 }) : (addIssueToContext(t3, { code: ZodIssueCode.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [i2] }), INVALID);
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(e5, t3, i2) {
        const r4 = /* @__PURE__ */ new Map();
        for (const i3 of t3) {
          const t4 = getDiscriminator(i3.shape[e5]);
          if (!t4.length) throw new Error(`A discriminator value for key \`${e5}\` could not be extracted from all schema options`);
          for (const n3 of t4) {
            if (r4.has(n3)) throw new Error(`Discriminator property ${String(e5)} has duplicate value ${String(n3)}`);
            r4.set(n3, i3);
          }
        }
        return new _ZodDiscriminatedUnion({ typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion, discriminator: e5, options: t3, optionsMap: r4, ...processCreateParams(i2) });
      }
    };
    __name(mergeValues, "mergeValues");
    ZodIntersection = class extends ZodType {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5), r4 = /* @__PURE__ */ __name((e6, r5) => {
          if (isAborted(e6) || isAborted(r5)) return INVALID;
          const n3 = mergeValues(e6.value, r5.value);
          return n3.valid ? ((isDirty(e6) || isDirty(r5)) && t3.dirty(), { status: t3.value, value: n3.data }) : (addIssueToContext(i2, { code: ZodIssueCode.invalid_intersection_types }), INVALID);
        }, "r");
        return i2.common.async ? Promise.all([this._def.left._parseAsync({ data: i2.data, path: i2.path, parent: i2 }), this._def.right._parseAsync({ data: i2.data, path: i2.path, parent: i2 })]).then(([e6, t4]) => r4(e6, t4)) : r4(this._def.left._parseSync({ data: i2.data, path: i2.path, parent: i2 }), this._def.right._parseSync({ data: i2.data, path: i2.path, parent: i2 }));
      }
    };
    ZodIntersection.create = (e5, t3, i2) => new ZodIntersection({ left: e5, right: t3, typeName: ZodFirstPartyTypeKind.ZodIntersection, ...processCreateParams(i2) });
    ZodTuple = class _ZodTuple extends ZodType {
      static {
        __name(this, "ZodTuple");
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5);
        if (i2.parsedType !== ZodParsedType.array) return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.array, received: i2.parsedType }), INVALID;
        if (i2.data.length < this._def.items.length) return addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), INVALID;
        !this._def.rest && i2.data.length > this._def.items.length && (addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), t3.dirty());
        const r4 = [...i2.data].map((e6, t4) => {
          const r5 = this._def.items[t4] || this._def.rest;
          return r5 ? r5._parse(new ParseInputLazyPath(i2, e6, i2.path, t4)) : null;
        }).filter((e6) => !!e6);
        return i2.common.async ? Promise.all(r4).then((e6) => ParseStatus.mergeArray(t3, e6)) : ParseStatus.mergeArray(t3, r4);
      }
      get items() {
        return this._def.items;
      }
      rest(e5) {
        return new _ZodTuple({ ...this._def, rest: e5 });
      }
    };
    ZodTuple.create = (e5, t3) => {
      if (!Array.isArray(e5)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      return new ZodTuple({ items: e5, typeName: ZodFirstPartyTypeKind.ZodTuple, rest: null, ...processCreateParams(t3) });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5);
        if (i2.parsedType !== ZodParsedType.object) return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.object, received: i2.parsedType }), INVALID;
        const r4 = [], n3 = this._def.keyType, a2 = this._def.valueType;
        for (const e6 in i2.data) r4.push({ key: n3._parse(new ParseInputLazyPath(i2, e6, i2.path, e6)), value: a2._parse(new ParseInputLazyPath(i2, i2.data[e6], i2.path, e6)), alwaysSet: e6 in i2.data });
        return i2.common.async ? ParseStatus.mergeObjectAsync(t3, r4) : ParseStatus.mergeObjectSync(t3, r4);
      }
      get element() {
        return this._def.valueType;
      }
      static create(e5, t3, i2) {
        return new _ZodRecord(t3 instanceof ZodType ? { keyType: e5, valueType: t3, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(i2) } : { keyType: ZodString.create(), valueType: e5, typeName: ZodFirstPartyTypeKind.ZodRecord, ...processCreateParams(t3) });
      }
    };
    ZodMap = class extends ZodType {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5);
        if (i2.parsedType !== ZodParsedType.map) return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.map, received: i2.parsedType }), INVALID;
        const r4 = this._def.keyType, n3 = this._def.valueType, a2 = [...i2.data.entries()].map(([e6, t4], a3) => ({ key: r4._parse(new ParseInputLazyPath(i2, e6, i2.path, [a3, "key"])), value: n3._parse(new ParseInputLazyPath(i2, t4, i2.path, [a3, "value"])) }));
        if (i2.common.async) {
          const e6 = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const i3 of a2) {
              const r5 = await i3.key, n4 = await i3.value;
              if ("aborted" === r5.status || "aborted" === n4.status) return INVALID;
              "dirty" !== r5.status && "dirty" !== n4.status || t3.dirty(), e6.set(r5.value, n4.value);
            }
            return { status: t3.value, value: e6 };
          });
        }
        {
          const e6 = /* @__PURE__ */ new Map();
          for (const i3 of a2) {
            const r5 = i3.key, n4 = i3.value;
            if ("aborted" === r5.status || "aborted" === n4.status) return INVALID;
            "dirty" !== r5.status && "dirty" !== n4.status || t3.dirty(), e6.set(r5.value, n4.value);
          }
          return { status: t3.value, value: e6 };
        }
      }
    };
    ZodMap.create = (e5, t3, i2) => new ZodMap({ valueType: t3, keyType: e5, typeName: ZodFirstPartyTypeKind.ZodMap, ...processCreateParams(i2) });
    ZodSet = class _ZodSet extends ZodType {
      static {
        __name(this, "ZodSet");
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5);
        if (i2.parsedType !== ZodParsedType.set) return addIssueToContext(i2, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.set, received: i2.parsedType }), INVALID;
        const r4 = this._def;
        null !== r4.minSize && i2.data.size < r4.minSize.value && (addIssueToContext(i2, { code: ZodIssueCode.too_small, minimum: r4.minSize.value, type: "set", inclusive: true, exact: false, message: r4.minSize.message }), t3.dirty()), null !== r4.maxSize && i2.data.size > r4.maxSize.value && (addIssueToContext(i2, { code: ZodIssueCode.too_big, maximum: r4.maxSize.value, type: "set", inclusive: true, exact: false, message: r4.maxSize.message }), t3.dirty());
        const n3 = this._def.valueType;
        function a2(e6) {
          const i3 = /* @__PURE__ */ new Set();
          for (const r5 of e6) {
            if ("aborted" === r5.status) return INVALID;
            "dirty" === r5.status && t3.dirty(), i3.add(r5.value);
          }
          return { status: t3.value, value: i3 };
        }
        __name(a2, "a");
        const o3 = [...i2.data.values()].map((e6, t4) => n3._parse(new ParseInputLazyPath(i2, e6, i2.path, t4)));
        return i2.common.async ? Promise.all(o3).then((e6) => a2(e6)) : a2(o3);
      }
      min(e5, t3) {
        return new _ZodSet({ ...this._def, minSize: { value: e5, message: errorUtil.toString(t3) } });
      }
      max(e5, t3) {
        return new _ZodSet({ ...this._def, maxSize: { value: e5, message: errorUtil.toString(t3) } });
      }
      size(e5, t3) {
        return this.min(e5, t3).max(e5, t3);
      }
      nonempty(e5) {
        return this.min(1, e5);
      }
    };
    ZodSet.create = (e5, t3) => new ZodSet({ valueType: e5, minSize: null, maxSize: null, typeName: ZodFirstPartyTypeKind.ZodSet, ...processCreateParams(t3) });
    ZodFunction = class _ZodFunction extends ZodType {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments), this.validate = this.implement;
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5);
        if (t3.parsedType !== ZodParsedType.function) return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.function, received: t3.parsedType }), INVALID;
        function i2(e6, i3) {
          return makeIssue({ data: e6, path: t3.path, errorMaps: [t3.common.contextualErrorMap, t3.schemaErrorMap, getErrorMap(), errorMap].filter((e7) => !!e7), issueData: { code: ZodIssueCode.invalid_arguments, argumentsError: i3 } });
        }
        __name(i2, "i");
        function r4(e6, i3) {
          return makeIssue({ data: e6, path: t3.path, errorMaps: [t3.common.contextualErrorMap, t3.schemaErrorMap, getErrorMap(), errorMap].filter((e7) => !!e7), issueData: { code: ZodIssueCode.invalid_return_type, returnTypeError: i3 } });
        }
        __name(r4, "r");
        const n3 = { errorMap: t3.common.contextualErrorMap }, a2 = t3.data;
        if (this._def.returns instanceof ZodPromise) {
          const e6 = this;
          return OK(async function(...t4) {
            const o3 = new ZodError([]), s4 = await e6._def.args.parseAsync(t4, n3).catch((e7) => {
              throw o3.addIssue(i2(t4, e7)), o3;
            }), l2 = await Reflect.apply(a2, this, s4), u2 = await e6._def.returns._def.type.parseAsync(l2, n3).catch((e7) => {
              throw o3.addIssue(r4(l2, e7)), o3;
            });
            return u2;
          });
        }
        {
          const e6 = this;
          return OK(function(...t4) {
            const o3 = e6._def.args.safeParse(t4, n3);
            if (!o3.success) throw new ZodError([i2(t4, o3.error)]);
            const s4 = Reflect.apply(a2, this, o3.data), l2 = e6._def.returns.safeParse(s4, n3);
            if (!l2.success) throw new ZodError([r4(s4, l2.error)]);
            return l2.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...e5) {
        return new _ZodFunction({ ...this._def, args: ZodTuple.create(e5).rest(ZodUnknown.create()) });
      }
      returns(e5) {
        return new _ZodFunction({ ...this._def, returns: e5 });
      }
      implement(e5) {
        return this.parse(e5);
      }
      strictImplement(e5) {
        return this.parse(e5);
      }
      static create(e5, t3, i2) {
        return new _ZodFunction({ args: e5 || ZodTuple.create([]).rest(ZodUnknown.create()), returns: t3 || ZodUnknown.create(), typeName: ZodFirstPartyTypeKind.ZodFunction, ...processCreateParams(i2) });
      }
    };
    ZodLazy = class extends ZodType {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5);
        return this._def.getter()._parse({ data: t3.data, path: t3.path, parent: t3 });
      }
    };
    ZodLazy.create = (e5, t3) => new ZodLazy({ getter: e5, typeName: ZodFirstPartyTypeKind.ZodLazy, ...processCreateParams(t3) });
    ZodLiteral = class extends ZodType {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(e5) {
        if (e5.data !== this._def.value) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { received: t3.data, code: ZodIssueCode.invalid_literal, expected: this._def.value }), INVALID;
        }
        return { status: "valid", value: e5.data };
      }
      get value() {
        return this._def.value;
      }
    };
    __name(createZodEnum, "createZodEnum");
    ZodLiteral.create = (e5, t3) => new ZodLiteral({ value: e5, typeName: ZodFirstPartyTypeKind.ZodLiteral, ...processCreateParams(t3) });
    ZodEnum = class _ZodEnum extends ZodType {
      static {
        __name(this, "ZodEnum");
      }
      constructor() {
        super(...arguments), _ZodEnum_cache.set(this, void 0);
      }
      _parse(e5) {
        if ("string" != typeof e5.data) {
          const t3 = this._getOrReturnCtx(e5), i2 = this._def.values;
          return addIssueToContext(t3, { expected: util$1.joinValues(i2), received: t3.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
        }
        if (__classPrivateFieldGet(this, _ZodEnum_cache) || __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values)), !__classPrivateFieldGet(this, _ZodEnum_cache).has(e5.data)) {
          const t3 = this._getOrReturnCtx(e5), i2 = this._def.values;
          return addIssueToContext(t3, { received: t3.data, code: ZodIssueCode.invalid_enum_value, options: i2 }), INVALID;
        }
        return OK(e5.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const e5 = {};
        for (const t3 of this._def.values) e5[t3] = t3;
        return e5;
      }
      get Values() {
        const e5 = {};
        for (const t3 of this._def.values) e5[t3] = t3;
        return e5;
      }
      get Enum() {
        const e5 = {};
        for (const t3 of this._def.values) e5[t3] = t3;
        return e5;
      }
      extract(e5, t3 = this._def) {
        return _ZodEnum.create(e5, { ...this._def, ...t3 });
      }
      exclude(e5, t3 = this._def) {
        return _ZodEnum.create(this.options.filter((t4) => !e5.includes(t4)), { ...this._def, ...t3 });
      }
    };
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap(), ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      static {
        __name(this, "ZodNativeEnum");
      }
      constructor() {
        super(...arguments), _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(e5) {
        const t3 = util$1.getValidEnumValues(this._def.values), i2 = this._getOrReturnCtx(e5);
        if (i2.parsedType !== ZodParsedType.string && i2.parsedType !== ZodParsedType.number) {
          const e6 = util$1.objectValues(t3);
          return addIssueToContext(i2, { expected: util$1.joinValues(e6), received: i2.parsedType, code: ZodIssueCode.invalid_type }), INVALID;
        }
        if (__classPrivateFieldGet(this, _ZodNativeEnum_cache) || __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util$1.getValidEnumValues(this._def.values))), !__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(e5.data)) {
          const e6 = util$1.objectValues(t3);
          return addIssueToContext(i2, { received: i2.data, code: ZodIssueCode.invalid_enum_value, options: e6 }), INVALID;
        }
        return OK(e5.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap(), ZodNativeEnum.create = (e5, t3) => new ZodNativeEnum({ values: e5, typeName: ZodFirstPartyTypeKind.ZodNativeEnum, ...processCreateParams(t3) });
    ZodPromise = class extends ZodType {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5);
        if (t3.parsedType !== ZodParsedType.promise && false === t3.common.async) return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.promise, received: t3.parsedType }), INVALID;
        const i2 = t3.parsedType === ZodParsedType.promise ? t3.data : Promise.resolve(t3.data);
        return OK(i2.then((e6) => this._def.type.parseAsync(e6, { path: t3.path, errorMap: t3.common.contextualErrorMap })));
      }
    };
    ZodPromise.create = (e5, t3) => new ZodPromise({ type: e5, typeName: ZodFirstPartyTypeKind.ZodPromise, ...processCreateParams(t3) });
    ZodEffects = class extends ZodType {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5), r4 = this._def.effect || null, n3 = { addIssue: /* @__PURE__ */ __name((e6) => {
          addIssueToContext(i2, e6), e6.fatal ? t3.abort() : t3.dirty();
        }, "addIssue"), get path() {
          return i2.path;
        } };
        if (n3.addIssue = n3.addIssue.bind(n3), "preprocess" === r4.type) {
          const e6 = r4.transform(i2.data, n3);
          if (i2.common.async) return Promise.resolve(e6).then(async (e7) => {
            if ("aborted" === t3.value) return INVALID;
            const r5 = await this._def.schema._parseAsync({ data: e7, path: i2.path, parent: i2 });
            return "aborted" === r5.status ? INVALID : "dirty" === r5.status || "dirty" === t3.value ? DIRTY2(r5.value) : r5;
          });
          {
            if ("aborted" === t3.value) return INVALID;
            const r5 = this._def.schema._parseSync({ data: e6, path: i2.path, parent: i2 });
            return "aborted" === r5.status ? INVALID : "dirty" === r5.status || "dirty" === t3.value ? DIRTY2(r5.value) : r5;
          }
        }
        if ("refinement" === r4.type) {
          const e6 = /* @__PURE__ */ __name((e7) => {
            const t4 = r4.refinement(e7, n3);
            if (i2.common.async) return Promise.resolve(t4);
            if (t4 instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            return e7;
          }, "e");
          if (false === i2.common.async) {
            const r5 = this._def.schema._parseSync({ data: i2.data, path: i2.path, parent: i2 });
            return "aborted" === r5.status ? INVALID : ("dirty" === r5.status && t3.dirty(), e6(r5.value), { status: t3.value, value: r5.value });
          }
          return this._def.schema._parseAsync({ data: i2.data, path: i2.path, parent: i2 }).then((i3) => "aborted" === i3.status ? INVALID : ("dirty" === i3.status && t3.dirty(), e6(i3.value).then(() => ({ status: t3.value, value: i3.value }))));
        }
        if ("transform" === r4.type) {
          if (false === i2.common.async) {
            const e6 = this._def.schema._parseSync({ data: i2.data, path: i2.path, parent: i2 });
            if (!isValid(e6)) return e6;
            const a2 = r4.transform(e6.value, n3);
            if (a2 instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return { status: t3.value, value: a2 };
          }
          return this._def.schema._parseAsync({ data: i2.data, path: i2.path, parent: i2 }).then((e6) => isValid(e6) ? Promise.resolve(r4.transform(e6.value, n3)).then((e7) => ({ status: t3.value, value: e7 })) : e6);
        }
        util$1.assertNever(r4);
      }
    };
    ZodEffects.create = (e5, t3, i2) => new ZodEffects({ schema: e5, typeName: ZodFirstPartyTypeKind.ZodEffects, effect: t3, ...processCreateParams(i2) }), ZodEffects.createWithPreprocess = (e5, t3, i2) => new ZodEffects({ schema: t3, effect: { type: "preprocess", transform: e5 }, typeName: ZodFirstPartyTypeKind.ZodEffects, ...processCreateParams(i2) });
    ZodOptional = class extends ZodType {
      static {
        __name(this, "ZodOptional");
      }
      _parse(e5) {
        return this._getType(e5) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(e5);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (e5, t3) => new ZodOptional({ innerType: e5, typeName: ZodFirstPartyTypeKind.ZodOptional, ...processCreateParams(t3) });
    ZodNullable = class extends ZodType {
      static {
        __name(this, "ZodNullable");
      }
      _parse(e5) {
        return this._getType(e5) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(e5);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (e5, t3) => new ZodNullable({ innerType: e5, typeName: ZodFirstPartyTypeKind.ZodNullable, ...processCreateParams(t3) });
    ZodDefault = class extends ZodType {
      static {
        __name(this, "ZodDefault");
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5);
        let i2 = t3.data;
        return t3.parsedType === ZodParsedType.undefined && (i2 = this._def.defaultValue()), this._def.innerType._parse({ data: i2, path: t3.path, parent: t3 });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (e5, t3) => new ZodDefault({ innerType: e5, typeName: ZodFirstPartyTypeKind.ZodDefault, defaultValue: "function" == typeof t3.default ? t3.default : () => t3.default, ...processCreateParams(t3) });
    ZodCatch = class extends ZodType {
      static {
        __name(this, "ZodCatch");
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5), i2 = { ...t3, common: { ...t3.common, issues: [] } }, r4 = this._def.innerType._parse({ data: i2.data, path: i2.path, parent: { ...i2 } });
        return isAsync(r4) ? r4.then((e6) => ({ status: "valid", value: "valid" === e6.status ? e6.value : this._def.catchValue({ get error() {
          return new ZodError(i2.common.issues);
        }, input: i2.data }) })) : { status: "valid", value: "valid" === r4.status ? r4.value : this._def.catchValue({ get error() {
          return new ZodError(i2.common.issues);
        }, input: i2.data }) };
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (e5, t3) => new ZodCatch({ innerType: e5, typeName: ZodFirstPartyTypeKind.ZodCatch, catchValue: "function" == typeof t3.catch ? t3.catch : () => t3.catch, ...processCreateParams(t3) });
    ZodNaN = class extends ZodType {
      static {
        __name(this, "ZodNaN");
      }
      _parse(e5) {
        if (this._getType(e5) !== ZodParsedType.nan) {
          const t3 = this._getOrReturnCtx(e5);
          return addIssueToContext(t3, { code: ZodIssueCode.invalid_type, expected: ZodParsedType.nan, received: t3.parsedType }), INVALID;
        }
        return { status: "valid", value: e5.data };
      }
    };
    ZodNaN.create = (e5) => new ZodNaN({ typeName: ZodFirstPartyTypeKind.ZodNaN, ...processCreateParams(e5) });
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      static {
        __name(this, "ZodBranded");
      }
      _parse(e5) {
        const { ctx: t3 } = this._processInputParams(e5), i2 = t3.data;
        return this._def.type._parse({ data: i2, path: t3.path, parent: t3 });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(e5) {
        const { status: t3, ctx: i2 } = this._processInputParams(e5);
        if (i2.common.async) {
          return (async () => {
            const e6 = await this._def.in._parseAsync({ data: i2.data, path: i2.path, parent: i2 });
            return "aborted" === e6.status ? INVALID : "dirty" === e6.status ? (t3.dirty(), DIRTY2(e6.value)) : this._def.out._parseAsync({ data: e6.value, path: i2.path, parent: i2 });
          })();
        }
        {
          const e6 = this._def.in._parseSync({ data: i2.data, path: i2.path, parent: i2 });
          return "aborted" === e6.status ? INVALID : "dirty" === e6.status ? (t3.dirty(), { status: "dirty", value: e6.value }) : this._def.out._parseSync({ data: e6.value, path: i2.path, parent: i2 });
        }
      }
      static create(e5, t3) {
        return new _ZodPipeline({ in: e5, out: t3, typeName: ZodFirstPartyTypeKind.ZodPipeline });
      }
    };
    ZodReadonly = class extends ZodType {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(e5) {
        const t3 = this._def.innerType._parse(e5), i2 = /* @__PURE__ */ __name((e6) => (isValid(e6) && (e6.value = Object.freeze(e6.value)), e6), "i");
        return isAsync(t3) ? t3.then((e6) => i2(e6)) : i2(t3);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    __name(custom, "custom");
    ZodReadonly.create = (e5, t3) => new ZodReadonly({ innerType: e5, typeName: ZodFirstPartyTypeKind.ZodReadonly, ...processCreateParams(t3) });
    late = { object: ZodObject.lazycreate };
    !function(e5) {
      e5.ZodString = "ZodString", e5.ZodNumber = "ZodNumber", e5.ZodNaN = "ZodNaN", e5.ZodBigInt = "ZodBigInt", e5.ZodBoolean = "ZodBoolean", e5.ZodDate = "ZodDate", e5.ZodSymbol = "ZodSymbol", e5.ZodUndefined = "ZodUndefined", e5.ZodNull = "ZodNull", e5.ZodAny = "ZodAny", e5.ZodUnknown = "ZodUnknown", e5.ZodNever = "ZodNever", e5.ZodVoid = "ZodVoid", e5.ZodArray = "ZodArray", e5.ZodObject = "ZodObject", e5.ZodUnion = "ZodUnion", e5.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e5.ZodIntersection = "ZodIntersection", e5.ZodTuple = "ZodTuple", e5.ZodRecord = "ZodRecord", e5.ZodMap = "ZodMap", e5.ZodSet = "ZodSet", e5.ZodFunction = "ZodFunction", e5.ZodLazy = "ZodLazy", e5.ZodLiteral = "ZodLiteral", e5.ZodEnum = "ZodEnum", e5.ZodEffects = "ZodEffects", e5.ZodNativeEnum = "ZodNativeEnum", e5.ZodOptional = "ZodOptional", e5.ZodNullable = "ZodNullable", e5.ZodDefault = "ZodDefault", e5.ZodCatch = "ZodCatch", e5.ZodPromise = "ZodPromise", e5.ZodBranded = "ZodBranded", e5.ZodPipeline = "ZodPipeline", e5.ZodReadonly = "ZodReadonly";
    }(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((e5, t3 = { message: `Input not instance of ${e5.name}` }) => custom((t4) => t4 instanceof e5, t3), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = { string: /* @__PURE__ */ __name((e5) => ZodString.create({ ...e5, coerce: true }), "string"), number: /* @__PURE__ */ __name((e5) => ZodNumber.create({ ...e5, coerce: true }), "number"), boolean: /* @__PURE__ */ __name((e5) => ZodBoolean.create({ ...e5, coerce: true }), "boolean"), bigint: /* @__PURE__ */ __name((e5) => ZodBigInt.create({ ...e5, coerce: true }), "bigint"), date: /* @__PURE__ */ __name((e5) => ZodDate.create({ ...e5, coerce: true }), "date") };
    NEVER = INVALID;
    z = Object.freeze({ __proto__: null, defaultErrorMap: errorMap, setErrorMap, getErrorMap, makeIssue, EMPTY_PATH, addIssueToContext, ParseStatus, INVALID, DIRTY: DIRTY2, OK, isAborted, isDirty, isValid, isAsync, get util() {
      return util$1;
    }, get objectUtil() {
      return objectUtil;
    }, ZodParsedType, getParsedType, ZodType, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodTransformer: ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, custom, Schema: ZodType, ZodSchema: ZodType, late, get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    }, coerce, any: anyType, array: arrayType, bigint: bigIntType, boolean: booleanType, date: dateType, discriminatedUnion: discriminatedUnionType, effect: effectsType, enum: enumType, function: functionType, instanceof: instanceOfType, intersection: intersectionType, lazy: lazyType, literal: literalType, map: mapType, nan: nanType, nativeEnum: nativeEnumType, never: neverType, null: nullType, nullable: nullableType, number: numberType, object: objectType, oboolean, onumber, optional: optionalType, ostring, pipeline: pipelineType, preprocess: preprocessType, promise: promiseType, record: recordType, set: setType, strictObject: strictObjectType, string: stringType, symbol: symbolType, transformer: effectsType, tuple: tupleType, undefined: undefinedType, union: unionType, unknown: unknownType, void: voidType, NEVER, ZodIssueCode, quotelessJson, ZodError });
    Edge2 = Edge || (Edge = {}), Edge2[Edge2.EXTEND = 1] = "EXTEND", Edge2[Edge2.WRAP = 2] = "WRAP", Edge2[Edge2.CROP = 3] = "CROP";
    JimpClassSchema = z.object({ bitmap: z.object({ data: z.union([z.instanceof(Buffer2), z.instanceof(Uint8Array)]), width: z.number(), height: z.number() }) });
    BlitOptionsSchemaComplex = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional(), srcX: z.number().optional(), srcY: z.number().optional(), srcW: z.number().optional(), srcH: z.number().optional() });
    BlitOptionsSchema = z.union([JimpClassSchema, BlitOptionsSchemaComplex]);
    methods$h = { blit(e5, t3) {
      const i2 = BlitOptionsSchema.parse(t3);
      let { src: r4, x: n3 = 0, y: a2 = 0, srcX: o3 = 0, srcY: s4 = 0, srcW: l2 = r4.bitmap.width, srcH: u2 = r4.bitmap.height } = "bitmap" in i2 ? { src: i2 } : i2;
      if (!("bitmap" in r4)) throw new Error("The source must be a Jimp image");
      if ("number" != typeof n3 || "number" != typeof a2) throw new Error("x and y must be numbers");
      n3 = Math.round(n3), a2 = Math.round(a2), o3 = Math.round(o3), s4 = Math.round(s4), l2 = Math.round(l2), u2 = Math.round(u2);
      const h2 = e5.bitmap.width, c3 = e5.bitmap.height;
      return scan(r4, o3, s4, l2, u2, function(t4, i3, l3) {
        const u3 = n3 + t4 - o3, f2 = a2 + i3 - s4;
        if (u3 >= 0 && f2 >= 0 && h2 - u3 > 0 && c3 - f2 > 0) {
          const t5 = e5.getPixelIndex(u3, f2), i4 = { r: r4.bitmap.data[l3] || 0, g: r4.bitmap.data[l3 + 1] || 0, b: r4.bitmap.data[l3 + 2] || 0, a: r4.bitmap.data[l3 + 3] || 0 }, n4 = { r: e5.bitmap.data[t5] || 0, g: e5.bitmap.data[t5 + 1] || 0, b: e5.bitmap.data[t5 + 2] || 0, a: e5.bitmap.data[t5 + 3] || 0 };
          e5.bitmap.data[t5] = (i4.a * (i4.r - n4.r) - n4.r + 255 >> 8) + n4.r, e5.bitmap.data[t5 + 1] = (i4.a * (i4.g - n4.g) - n4.g + 255 >> 8) + n4.g, e5.bitmap.data[t5 + 2] = (i4.a * (i4.b - n4.b) - n4.b + 255 >> 8) + n4.b, e5.bitmap.data[t5 + 3] = limit255(n4.a + i4.a);
        }
      }), e5;
    } };
    mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
    shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
    methods$g = { blur(e5, t3) {
      if ("number" != typeof t3) throw new Error("r must be a number");
      if (t3 < 1) throw new Error("r must be greater than 0");
      let i2, r4, n3, a2, o3, s4, l2, u2, h2, c3, f2, d, p2;
      const m = e5.bitmap.width - 1, _2 = e5.bitmap.height - 1, g = t3 + 1, b2 = mulTable[t3], y2 = shgTable[t3], w = [], v2 = [], x2 = [], E2 = [], k2 = [], S2 = [];
      let A2 = 2;
      for (; A2-- > 0; ) {
        for (d = 0, p2 = 0, s4 = 0; s4 < e5.bitmap.height; s4++) {
          for (i2 = e5.bitmap.data[p2] * g, r4 = e5.bitmap.data[p2 + 1] * g, n3 = e5.bitmap.data[p2 + 2] * g, a2 = e5.bitmap.data[p2 + 3] * g, l2 = 1; l2 <= t3; l2++) u2 = p2 + ((l2 > m ? m : l2) << 2), i2 += e5.bitmap.data[u2++], r4 += e5.bitmap.data[u2++], n3 += e5.bitmap.data[u2++], a2 += e5.bitmap.data[u2];
          for (o3 = 0; o3 < e5.bitmap.width; o3++) w[d] = i2, v2[d] = r4, x2[d] = n3, E2[d] = a2, 0 === s4 && (k2[o3] = ((u2 = o3 + g) < m ? u2 : m) << 2, S2[o3] = (u2 = o3 - t3) > 0 ? u2 << 2 : 0), h2 = p2 + k2[o3], c3 = p2 + S2[o3], i2 += e5.bitmap.data[h2++] - e5.bitmap.data[c3++], r4 += e5.bitmap.data[h2++] - e5.bitmap.data[c3++], n3 += e5.bitmap.data[h2++] - e5.bitmap.data[c3++], a2 += e5.bitmap.data[h2] - e5.bitmap.data[c3++], d++;
          p2 += e5.bitmap.width << 2;
        }
        for (o3 = 0; o3 < e5.bitmap.width; o3++) {
          for (f2 = o3, i2 = w[f2] * g, r4 = v2[f2] * g, n3 = x2[f2] * g, a2 = E2[f2] * g, l2 = 1; l2 <= t3; l2++) f2 += l2 > _2 ? 0 : e5.bitmap.width, i2 += w[f2], r4 += v2[f2], n3 += x2[f2], a2 += E2[f2];
          for (d = o3 << 2, s4 = 0; s4 < e5.bitmap.height; s4++) e5.bitmap.data[d] = limit255(i2 * b2 >>> y2), e5.bitmap.data[d + 1] = limit255(r4 * b2 >>> y2), e5.bitmap.data[d + 2] = limit255(n3 * b2 >>> y2), e5.bitmap.data[d + 3] = limit255(a2 * b2 >>> y2), 0 === o3 && (k2[s4] = ((u2 = s4 + g) < _2 ? u2 : _2) * e5.bitmap.width, S2[s4] = (u2 = s4 - t3) > 0 ? u2 * e5.bitmap.width : 0), h2 = o3 + k2[s4], c3 = o3 + S2[s4], i2 += w[h2] - w[c3], r4 += v2[h2] - v2[c3], n3 += x2[h2] - x2[c3], a2 += E2[h2] - E2[c3], d += e5.bitmap.width << 2;
        }
      }
      return e5;
    }, gaussian(e5, t3) {
      if ("number" != typeof t3) throw new Error("r must be a number");
      if (t3 < 1) throw new Error("r must be greater than 0");
      const i2 = Math.ceil(2.57 * t3), r4 = 2 * i2 + 1, n3 = t3 * t3 * 2, a2 = n3 * Math.PI, o3 = [];
      for (let e6 = 0; e6 < r4; e6++) {
        const t4 = [];
        for (let o4 = 0; o4 < r4; o4++) {
          const r5 = (o4 - i2) ** 2 + (e6 - i2) ** 2;
          t4[o4] = Math.exp(-r5 / n3) / a2;
        }
        o3.push(t4);
      }
      for (let t4 = 0; t4 < e5.bitmap.height; t4++) for (let n4 = 0; n4 < e5.bitmap.width; n4++) {
        let a3 = 0, s4 = 0, l2 = 0, u2 = 0, h2 = 0;
        for (let c3 = 0; c3 < r4; c3++) {
          for (let f3 = 0; f3 < r4; f3++) {
            const r5 = Math.min(e5.bitmap.width - 1, Math.max(0, f3 + n4 - i2)), d = Math.min(e5.bitmap.height - 1, Math.max(0, c3 + t4 - i2)), p2 = o3[c3][f3], m = d * e5.bitmap.width + r5 << 2;
            a3 += e5.bitmap.data[m] * p2, s4 += e5.bitmap.data[m + 1] * p2, l2 += e5.bitmap.data[m + 2] * p2, u2 += e5.bitmap.data[m + 3] * p2, h2 += p2;
          }
          const f2 = t4 * e5.bitmap.width + n4 << 2;
          e5.bitmap.data[f2] = Math.round(a3 / h2), e5.bitmap.data[f2 + 1] = Math.round(s4 / h2), e5.bitmap.data[f2 + 2] = Math.round(l2 / h2), e5.bitmap.data[f2 + 3] = Math.round(u2 / h2);
        }
      }
      return e5;
    } };
    CircleOptionsSchema = z.object({ x: z.number().optional(), y: z.number().optional(), radius: z.number().min(0).optional() });
    methods$f = { circle(e5, t3 = {}) {
      const i2 = CircleOptionsSchema.parse(t3), r4 = i2.radius || (e5.bitmap.width > e5.bitmap.height ? e5.bitmap.height : e5.bitmap.width) / 2, n3 = "number" == typeof i2.x ? i2.x : e5.bitmap.width / 2, a2 = "number" == typeof i2.y ? i2.y : e5.bitmap.height / 2;
      return e5.scan((t4, i3, o3) => {
        const s4 = Math.sqrt(Math.pow(t4 - n3, 2) + Math.pow(i3 - a2, 2));
        r4 - s4 <= 0 ? e5.bitmap.data[o3 + 3] = 0 : r4 - s4 < 1 && (e5.bitmap.data[o3 + 3] = 255 * (r4 - s4));
      }), e5;
    } };
    ConvolutionMatrixSchema = z.array(z.number()).min(1).array();
    ConvolutionComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, edgeHandling: z.nativeEnum(Edge).optional() });
    ConvolutionOptionsSchema = z.union([ConvolutionMatrixSchema, ConvolutionComplexOptionsSchema]);
    ConvoluteComplexOptionsSchema = z.object({ kernel: ConvolutionMatrixSchema, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() });
    ConvoluteOptionsSchema = z.union([ConvolutionMatrixSchema, ConvoluteComplexOptionsSchema]);
    PixelateSize = z.number().min(1).max(1 / 0);
    PixelateComplexOptionsSchema = z.object({ size: PixelateSize, x: z.number().optional(), y: z.number().optional(), w: z.number().optional(), h: z.number().optional() });
    PixelateOptionsSchema = z.union([PixelateSize, PixelateComplexOptionsSchema]);
    __name(applyKernel, "applyKernel");
    __name(mix, "mix");
    HueActionSchema = z.object({ apply: z.literal("hue"), params: z.tuple([z.number().min(-360).max(360)]) });
    SpinActionSchema = z.object({ apply: z.literal("spin"), params: z.tuple([z.number().min(-360).max(360)]) });
    LightenActionSchema = z.object({ apply: z.literal("lighten"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    RGBColorSchema = z.object({ r: z.number().min(0).max(255), g: z.number().min(0).max(255), b: z.number().min(0).max(255) });
    MixActionSchema = z.object({ apply: z.literal("mix"), params: z.union([z.tuple([RGBColorSchema]), z.tuple([RGBColorSchema, z.number().min(0).max(100)])]) });
    TintActionSchema = z.object({ apply: z.literal("tint"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    ShadeActionSchema = z.object({ apply: z.literal("shade"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    XorActionSchema = z.object({ apply: z.literal("xor"), params: z.tuple([RGBColorSchema]) });
    RedActionSchema = z.object({ apply: z.literal("red"), params: z.tuple([z.number().min(-255).max(255)]) });
    GreenActionSchema = z.object({ apply: z.literal("green"), params: z.tuple([z.number().min(-255).max(255)]) });
    BlueActionSchema = z.object({ apply: z.literal("blue"), params: z.tuple([z.number().min(-255).max(255)]) });
    BrightenActionSchema = z.object({ apply: z.literal("brighten"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    DarkenActionSchema = z.object({ apply: z.literal("darken"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    DesaturateActionSchema = z.object({ apply: z.literal("desaturate"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    SaturateActionSchema = z.object({ apply: z.literal("saturate"), params: z.tuple([z.number().min(0).max(100)]).optional() });
    GrayscaleActionSchema = z.object({ apply: z.literal("greyscale"), params: z.tuple([]).optional() });
    ColorActionNameSchema = z.union([HueActionSchema, SpinActionSchema, LightenActionSchema, MixActionSchema, TintActionSchema, ShadeActionSchema, XorActionSchema, RedActionSchema, GreenActionSchema, BlueActionSchema, BrightenActionSchema, DarkenActionSchema, DesaturateActionSchema, SaturateActionSchema, GrayscaleActionSchema]);
    __name(histogram, "histogram");
    normalizeValue = /* @__PURE__ */ __name(function(e5, t3, i2) {
      return 255 * (e5 - t3) / (i2 - t3);
    }, "normalizeValue");
    getBounds = /* @__PURE__ */ __name(function(e5) {
      return [e5.findIndex((e6) => e6 > 0), 255 - e5.slice().reverse().findIndex((e6) => e6 > 0)];
    }, "getBounds");
    methods$e = { normalize(e5) {
      const t3 = histogram(e5), i2 = { r: getBounds(t3.r), g: getBounds(t3.g), b: getBounds(t3.b) };
      return e5.scan((t4, r4, n3) => {
        const a2 = e5.bitmap.data[n3 + 0], o3 = e5.bitmap.data[n3 + 1], s4 = e5.bitmap.data[n3 + 2];
        e5.bitmap.data[n3 + 0] = normalizeValue(a2, i2.r[0], i2.r[1]), e5.bitmap.data[n3 + 1] = normalizeValue(o3, i2.g[0], i2.g[1]), e5.bitmap.data[n3 + 2] = normalizeValue(s4, i2.b[0], i2.b[1]);
      }), e5;
    }, invert: /* @__PURE__ */ __name((e5) => (e5.scan((t3, i2, r4) => {
      e5.bitmap.data[r4] = 255 - e5.bitmap.data[r4], e5.bitmap.data[r4 + 1] = 255 - e5.bitmap.data[r4 + 1], e5.bitmap.data[r4 + 2] = 255 - e5.bitmap.data[r4 + 2];
    }), e5), "invert"), brightness(e5, t3) {
      if ("number" != typeof t3) throw new Error("val must be numbers");
      return e5.scan((i2, r4, n3) => {
        e5.bitmap.data[n3] = limit255(e5.bitmap.data[n3] * t3), e5.bitmap.data[n3 + 1] = limit255(e5.bitmap.data[n3 + 1] * t3), e5.bitmap.data[n3 + 2] = limit255(e5.bitmap.data[n3 + 2] * t3);
      }), e5;
    }, contrast(e5, t3) {
      if ("number" != typeof t3) throw new Error("val must be numbers");
      if (t3 < -1 || t3 > 1) throw new Error("val must be a number between -1 and +1");
      const i2 = (t3 + 1) / (1 - t3);
      function r4(e6) {
        return (e6 = Math.floor(i2 * (e6 - 127) + 127)) < 0 ? 0 : e6 > 255 ? 255 : e6;
      }
      __name(r4, "r");
      return e5.scan((t4, i3, n3) => {
        e5.bitmap.data[n3] = r4(e5.bitmap.data[n3]), e5.bitmap.data[n3 + 1] = r4(e5.bitmap.data[n3 + 1]), e5.bitmap.data[n3 + 2] = r4(e5.bitmap.data[n3 + 2]);
      }), e5;
    }, posterize(e5, t3) {
      if ("number" != typeof t3) throw new Error("n must be numbers");
      return t3 < 2 && (t3 = 2), e5.scan((i2, r4, n3) => {
        const a2 = e5.bitmap.data[n3], o3 = e5.bitmap.data[n3 + 1], s4 = e5.bitmap.data[n3 + 2];
        e5.bitmap.data[n3] = Math.floor(a2 / 255 * (t3 - 1)) / (t3 - 1) * 255, e5.bitmap.data[n3 + 1] = Math.floor(o3 / 255 * (t3 - 1)) / (t3 - 1) * 255, e5.bitmap.data[n3 + 2] = Math.floor(s4 / 255 * (t3 - 1)) / (t3 - 1) * 255;
      }), e5;
    }, greyscale: /* @__PURE__ */ __name((e5) => (e5.scan((t3, i2, r4) => {
      const n3 = 0.2126 * e5.bitmap.data[r4] + 0.7152 * e5.bitmap.data[r4 + 1] + 0.0722 * e5.bitmap.data[r4 + 2];
      e5.bitmap.data[r4] = n3, e5.bitmap.data[r4 + 1] = n3, e5.bitmap.data[r4 + 2] = n3;
    }), e5), "greyscale"), opacity(e5, t3) {
      if ("number" != typeof t3) throw new Error("f must be a number");
      if (t3 < 0 || t3 > 1) throw new Error("f must be a number from 0 to 1");
      return e5.scan((i2, r4, n3) => {
        const a2 = e5.bitmap.data[n3 + 3] * t3;
        e5.bitmap.data[n3 + 3] = a2;
      }), e5;
    }, sepia: /* @__PURE__ */ __name((e5) => (e5.scan((t3, i2, r4) => {
      let n3 = e5.bitmap.data[r4], a2 = e5.bitmap.data[r4 + 1], o3 = e5.bitmap.data[r4 + 2];
      n3 = 0.393 * n3 + 0.769 * a2 + 0.189 * o3, a2 = 0.349 * n3 + 0.686 * a2 + 0.168 * o3, o3 = 0.272 * n3 + 0.534 * a2 + 0.131 * o3, e5.bitmap.data[r4] = n3 < 255 ? n3 : 255, e5.bitmap.data[r4 + 1] = a2 < 255 ? a2 : 255, e5.bitmap.data[r4 + 2] = o3 < 255 ? o3 : 255;
    }), e5), "sepia"), fade(e5, t3) {
      if ("number" != typeof t3) throw new Error("f must be a number");
      if (t3 < 0 || t3 > 1) throw new Error("f must be a number from 0 to 1");
      return this.opacity(e5, 1 - t3);
    }, convolution(e5, t3) {
      const i2 = ConvolutionOptionsSchema.parse(t3), { kernel: r4, edgeHandling: n3 = Edge.EXTEND } = "kernel" in i2 ? i2 : { kernel: i2, edgeHandling: void 0 };
      if (!r4[0]) throw new Error("kernel must be a matrix");
      const a2 = Buffer2.from(e5.bitmap.data), o3 = r4.length, s4 = r4[0].length, l2 = Math.floor(o3 / 2), u2 = Math.floor(s4 / 2), h2 = -l2, c3 = -u2;
      let f2, d, p2, m, _2, g, b2, y2, w, v2;
      return e5.scan((t4, i3, o4) => {
        m = 0, p2 = 0, d = 0;
        for (let a3 = h2; a3 <= l2; a3++) for (let o5 = c3; o5 <= u2; o5++) y2 = t4 + o5, w = i3 + a3, f2 = r4[a3 + l2][o5 + u2], v2 = e5.getPixelIndex(y2, w, n3), -1 === v2 ? (b2 = 0, g = 0, _2 = 0) : (_2 = e5.bitmap.data[v2 + 0], g = e5.bitmap.data[v2 + 1], b2 = e5.bitmap.data[v2 + 2]), d += f2 * _2, p2 += f2 * g, m += f2 * b2;
        d < 0 && (d = 0), p2 < 0 && (p2 = 0), m < 0 && (m = 0), d > 255 && (d = 255), p2 > 255 && (p2 = 255), m > 255 && (m = 255), a2[o4 + 0] = d, a2[o4 + 1] = p2, a2[o4 + 2] = m;
      }), e5.bitmap.data = a2, e5;
    }, opaque: /* @__PURE__ */ __name((e5) => (e5.scan((t3, i2, r4) => {
      e5.bitmap.data[r4 + 3] = 255;
    }), e5), "opaque"), pixelate(e5, t3) {
      const i2 = PixelateOptionsSchema.parse(t3), { size: r4, x: n3 = 0, y: a2 = 0, w: o3 = e5.bitmap.width - n3, h: s4 = e5.bitmap.height - a2 } = "number" == typeof i2 ? { size: i2 } : i2, l2 = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 0.25, 2 / 16], [1 / 16, 2 / 16, 1 / 16]], u2 = clone(e5);
      return scan(u2, n3, a2, o3, s4, (t4, i3, n4) => {
        t4 = r4 * Math.floor(t4 / r4), i3 = r4 * Math.floor(i3 / r4);
        const a3 = applyKernel(u2, l2, t4, i3);
        e5.bitmap.data[n4] = a3[0], e5.bitmap.data[n4 + 1] = a3[1], e5.bitmap.data[n4 + 2] = a3[2], e5.bitmap.data[n4 + 3] = a3[3];
      }), e5;
    }, convolute(e5, t3) {
      const i2 = ConvoluteOptionsSchema.parse(t3), { kernel: r4, x: n3 = 0, y: a2 = 0, w: o3 = e5.bitmap.width - n3, h: s4 = e5.bitmap.height - a2 } = "kernel" in i2 ? i2 : { kernel: i2 }, l2 = clone(e5);
      return scan(l2, n3, a2, o3, s4, (t4, i3, n4) => {
        const a3 = applyKernel(l2, r4, t4, i3);
        e5.bitmap.data[n4] = limit255(a3[0]), e5.bitmap.data[n4 + 1] = limit255(a3[1]), e5.bitmap.data[n4 + 2] = limit255(a3[2]), e5.bitmap.data[n4 + 3] = limit255(a3[3]);
      }), e5;
    }, color(e5, t3) {
      if (!t3 || !Array.isArray(t3)) throw new Error("actions must be an array");
      return t3.forEach((e6) => ColorActionNameSchema.parse(e6)), t3 = t3.map((e6) => ("xor" !== e6.apply && "mix" !== e6.apply || (e6.params[0] = tinycolor(e6.params[0]).toRgb()), e6)), e5.scan((i2, r4, n3) => {
        let a2 = { r: e5.bitmap.data[n3], g: e5.bitmap.data[n3 + 1], b: e5.bitmap.data[n3 + 2] };
        const o3 = /* @__PURE__ */ __name((e6, t4) => limit255(a2[e6] + t4), "o");
        t3.forEach((e6) => {
          if ("mix" === e6.apply) a2 = mix(a2, e6.params[0], e6.params[1]);
          else if ("tint" === e6.apply) a2 = mix(a2, { r: 255, g: 255, b: 255 }, e6.params?.[0]);
          else if ("shade" === e6.apply) a2 = mix(a2, { r: 0, g: 0, b: 0 }, e6.params?.[0]);
          else if ("xor" === e6.apply) a2 = { r: a2.r ^ e6.params[0].r, g: a2.g ^ e6.params[0].g, b: a2.b ^ e6.params[0].b };
          else if ("red" === e6.apply) a2.r = o3("r", e6.params[0]);
          else if ("green" === e6.apply) a2.g = o3("g", e6.params[0]);
          else if ("blue" === e6.apply) a2.b = o3("b", e6.params[0]);
          else {
            "hue" === e6.apply && (e6.apply = "spin");
            const t4 = tinycolor(a2), i3 = t4[e6.apply].bind(t4);
            if (!i3) throw new Error("action " + e6.apply + " not supported");
            a2 = i3(...e6.params || []).toRgb();
          }
        }), e5.bitmap.data[n3] = a2.r, e5.bitmap.data[n3 + 1] = a2.g, e5.bitmap.data[n3 + 2] = a2.b;
      }), e5;
    } };
    lib$1 = {};
    ieee754 = {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      read: /* @__PURE__ */ __name(function(e5, t3, i2, r4, n3) {
        var a2, o3, s4 = 8 * n3 - r4 - 1, l2 = (1 << s4) - 1, u2 = l2 >> 1, h2 = -7, c3 = i2 ? n3 - 1 : 0, f2 = i2 ? -1 : 1, d = e5[t3 + c3];
        for (c3 += f2, a2 = d & (1 << -h2) - 1, d >>= -h2, h2 += s4; h2 > 0; a2 = 256 * a2 + e5[t3 + c3], c3 += f2, h2 -= 8) ;
        for (o3 = a2 & (1 << -h2) - 1, a2 >>= -h2, h2 += r4; h2 > 0; o3 = 256 * o3 + e5[t3 + c3], c3 += f2, h2 -= 8) ;
        if (0 === a2) a2 = 1 - u2;
        else {
          if (a2 === l2) return o3 ? NaN : 1 / 0 * (d ? -1 : 1);
          o3 += Math.pow(2, r4), a2 -= u2;
        }
        return (d ? -1 : 1) * o3 * Math.pow(2, a2 - r4);
      }, "read"),
      write: /* @__PURE__ */ __name(function(e5, t3, i2, r4, n3, a2) {
        var o3, s4, l2, u2 = 8 * a2 - n3 - 1, h2 = (1 << u2) - 1, c3 = h2 >> 1, f2 = 23 === n3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = r4 ? 0 : a2 - 1, p2 = r4 ? 1 : -1, m = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
        for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (s4 = isNaN(t3) ? 1 : 0, o3 = h2) : (o3 = Math.floor(Math.log(t3) / Math.LN2), t3 * (l2 = Math.pow(2, -o3)) < 1 && (o3--, l2 *= 2), (t3 += o3 + c3 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - c3)) * l2 >= 2 && (o3++, l2 /= 2), o3 + c3 >= h2 ? (s4 = 0, o3 = h2) : o3 + c3 >= 1 ? (s4 = (t3 * l2 - 1) * Math.pow(2, n3), o3 += c3) : (s4 = t3 * Math.pow(2, c3 - 1) * Math.pow(2, n3), o3 = 0)); n3 >= 8; e5[i2 + d] = 255 & s4, d += p2, s4 /= 256, n3 -= 8) ;
        for (o3 = o3 << n3 | s4, u2 += n3; u2 > 0; e5[i2 + d] = 255 & o3, d += p2, o3 /= 256, u2 -= 8) ;
        e5[i2 + d - p2] |= 128 * m;
      }, "write")
    };
    !function(e5) {
      Object.defineProperty(e5, "__esModule", { value: true }), e5.AnsiStringType = e5.StringType = e5.BufferType = e5.Uint8ArrayType = e5.IgnoreType = e5.Float80_LE = e5.Float80_BE = e5.Float64_LE = e5.Float64_BE = e5.Float32_LE = e5.Float32_BE = e5.Float16_LE = e5.Float16_BE = e5.INT64_BE = e5.UINT64_BE = e5.INT64_LE = e5.UINT64_LE = e5.INT32_LE = e5.INT32_BE = e5.INT24_BE = e5.INT24_LE = e5.INT16_LE = e5.INT16_BE = e5.INT8 = e5.UINT32_BE = e5.UINT32_LE = e5.UINT24_BE = e5.UINT24_LE = e5.UINT16_BE = e5.UINT16_LE = e5.UINT8 = void 0;
      const t3 = ieee754;
      function i2(e6) {
        return new DataView(e6.buffer, e6.byteOffset);
      }
      __name(i2, "i");
      e5.UINT8 = { len: 1, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getUint8(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setUint8(t4, r5), t4 + 1), "put") }, e5.UINT16_LE = { len: 2, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getUint16(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setUint16(t4, r5, true), t4 + 2), "put") }, e5.UINT16_BE = { len: 2, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getUint16(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setUint16(t4, r5), t4 + 2), "put") }, e5.UINT24_LE = { len: 3, get(e6, t4) {
        const r5 = i2(e6);
        return r5.getUint8(t4) + (r5.getUint16(t4 + 1, true) << 8);
      }, put(e6, t4, r5) {
        const n3 = i2(e6);
        return n3.setUint8(t4, 255 & r5), n3.setUint16(t4 + 1, r5 >> 8, true), t4 + 3;
      } }, e5.UINT24_BE = { len: 3, get(e6, t4) {
        const r5 = i2(e6);
        return (r5.getUint16(t4) << 8) + r5.getUint8(t4 + 2);
      }, put(e6, t4, r5) {
        const n3 = i2(e6);
        return n3.setUint16(t4, r5 >> 8), n3.setUint8(t4 + 2, 255 & r5), t4 + 3;
      } }, e5.UINT32_LE = { len: 4, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getUint32(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setUint32(t4, r5, true), t4 + 4), "put") }, e5.UINT32_BE = { len: 4, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getUint32(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setUint32(t4, r5), t4 + 4), "put") }, e5.INT8 = { len: 1, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getInt8(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setInt8(t4, r5), t4 + 1), "put") }, e5.INT16_BE = { len: 2, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getInt16(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setInt16(t4, r5), t4 + 2), "put") }, e5.INT16_LE = { len: 2, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getInt16(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setInt16(t4, r5, true), t4 + 2), "put") }, e5.INT24_LE = { len: 3, get(t4, i3) {
        const r5 = e5.UINT24_LE.get(t4, i3);
        return r5 > 8388607 ? r5 - 16777216 : r5;
      }, put(e6, t4, r5) {
        const n3 = i2(e6);
        return n3.setUint8(t4, 255 & r5), n3.setUint16(t4 + 1, r5 >> 8, true), t4 + 3;
      } }, e5.INT24_BE = { len: 3, get(t4, i3) {
        const r5 = e5.UINT24_BE.get(t4, i3);
        return r5 > 8388607 ? r5 - 16777216 : r5;
      }, put(e6, t4, r5) {
        const n3 = i2(e6);
        return n3.setUint16(t4, r5 >> 8), n3.setUint8(t4 + 2, 255 & r5), t4 + 3;
      } }, e5.INT32_BE = { len: 4, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getInt32(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setInt32(t4, r5), t4 + 4), "put") }, e5.INT32_LE = { len: 4, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getInt32(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setInt32(t4, r5, true), t4 + 4), "put") }, e5.UINT64_LE = { len: 8, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getBigUint64(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setBigUint64(t4, r5, true), t4 + 8), "put") }, e5.INT64_LE = { len: 8, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getBigInt64(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setBigInt64(t4, r5, true), t4 + 8), "put") }, e5.UINT64_BE = { len: 8, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getBigUint64(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setBigUint64(t4, r5), t4 + 8), "put") }, e5.INT64_BE = { len: 8, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getBigInt64(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setBigInt64(t4, r5), t4 + 8), "put") }, e5.Float16_BE = { len: 2, get(e6, i3) {
        return t3.read(e6, i3, false, 10, this.len);
      }, put(e6, i3, r5) {
        return t3.write(e6, r5, i3, false, 10, this.len), i3 + this.len;
      } }, e5.Float16_LE = { len: 2, get(e6, i3) {
        return t3.read(e6, i3, true, 10, this.len);
      }, put(e6, i3, r5) {
        return t3.write(e6, r5, i3, true, 10, this.len), i3 + this.len;
      } }, e5.Float32_BE = { len: 4, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getFloat32(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setFloat32(t4, r5), t4 + 4), "put") }, e5.Float32_LE = { len: 4, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getFloat32(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setFloat32(t4, r5, true), t4 + 4), "put") }, e5.Float64_BE = { len: 8, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getFloat64(t4), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setFloat64(t4, r5), t4 + 8), "put") }, e5.Float64_LE = { len: 8, get: /* @__PURE__ */ __name((e6, t4) => i2(e6).getFloat64(t4, true), "get"), put: /* @__PURE__ */ __name((e6, t4, r5) => (i2(e6).setFloat64(t4, r5, true), t4 + 8), "put") }, e5.Float80_BE = { len: 10, get(e6, i3) {
        return t3.read(e6, i3, false, 63, this.len);
      }, put(e6, i3, r5) {
        return t3.write(e6, r5, i3, false, 63, this.len), i3 + this.len;
      } }, e5.Float80_LE = { len: 10, get(e6, i3) {
        return t3.read(e6, i3, true, 63, this.len);
      }, put(e6, i3, r5) {
        return t3.write(e6, r5, i3, true, 63, this.len), i3 + this.len;
      } };
      e5.IgnoreType = class {
        constructor(e6) {
          this.len = e6;
        }
        get(e6, t4) {
        }
      };
      e5.Uint8ArrayType = class {
        constructor(e6) {
          this.len = e6;
        }
        get(e6, t4) {
          return e6.subarray(t4, t4 + this.len);
        }
      };
      e5.BufferType = class {
        constructor(e6) {
          this.len = e6;
        }
        get(e6, t4) {
          return Buffer2.from(e6.subarray(t4, t4 + this.len));
        }
      };
      e5.StringType = class {
        constructor(e6, t4) {
          this.len = e6, this.encoding = t4;
        }
        get(e6, t4) {
          return Buffer2.from(e6).toString(this.encoding, t4, t4 + this.len);
        }
      };
      class r4 {
        static {
          __name(this, "r");
        }
        constructor(e6) {
          this.len = e6;
        }
        static decode(e6, t4, i3) {
          let n3 = "";
          for (let a2 = t4; a2 < i3; ++a2) n3 += r4.codePointToString(r4.singleByteDecoder(e6[a2]));
          return n3;
        }
        static inRange(e6, t4, i3) {
          return t4 <= e6 && e6 <= i3;
        }
        static codePointToString(e6) {
          return e6 <= 65535 ? String.fromCharCode(e6) : (e6 -= 65536, String.fromCharCode(55296 + (e6 >> 10), 56320 + (1023 & e6)));
        }
        static singleByteDecoder(e6) {
          if (r4.inRange(e6, 0, 127)) return e6;
          const t4 = r4.windows1252[e6 - 128];
          if (null === t4) throw Error("invaliding encoding");
          return t4;
        }
        get(e6, t4 = 0) {
          return r4.decode(e6, t4, t4 + this.len);
        }
      }
      e5.AnsiStringType = r4, r4.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
    }(lib$1);
    core$1 = {};
    ReadStreamTokenizer$1 = {};
    AbstractTokenizer$1 = {};
    lib = {};
    EndOfFileStream = {};
    !function(e5) {
      Object.defineProperty(e5, "__esModule", { value: true }), e5.EndOfStreamError = e5.defaultMessages = void 0, e5.defaultMessages = "End-Of-Stream";
      class t3 extends Error {
        static {
          __name(this, "t");
        }
        constructor() {
          super(e5.defaultMessages);
        }
      }
      e5.EndOfStreamError = t3;
    }(EndOfFileStream);
    StreamReader = {};
    Deferred$1 = {};
    Object.defineProperty(Deferred$1, "__esModule", { value: true }), Deferred$1.Deferred = void 0;
    Deferred = class {
      static {
        __name(this, "Deferred");
      }
      constructor() {
        this.resolve = () => null, this.reject = () => null, this.promise = new Promise((e5, t3) => {
          this.reject = t3, this.resolve = e5;
        });
      }
    };
    Deferred$1.Deferred = Deferred, function(e5) {
      Object.defineProperty(e5, "__esModule", { value: true }), e5.StreamReader = e5.EndOfStreamError = void 0;
      const t3 = EndOfFileStream, i2 = Deferred$1;
      var r4 = EndOfFileStream;
      Object.defineProperty(e5, "EndOfStreamError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return r4.EndOfStreamError;
      }, "get") });
      e5.StreamReader = class {
        constructor(e6) {
          if (this.s = e6, this.deferred = null, this.endOfStream = false, this.peekQueue = [], !e6.read || !e6.once) throw new Error("Expected an instance of stream.Readable");
          this.s.once("end", () => this.reject(new t3.EndOfStreamError())), this.s.once("error", (e7) => this.reject(e7)), this.s.once("close", () => this.reject(new Error("Stream closed")));
        }
        async peek(e6, t4, i3) {
          const r5 = await this.read(e6, t4, i3);
          return this.peekQueue.push(e6.subarray(t4, t4 + r5)), r5;
        }
        async read(e6, i3, r5) {
          if (0 === r5) return 0;
          if (0 === this.peekQueue.length && this.endOfStream) throw new t3.EndOfStreamError();
          let n3 = r5, a2 = 0;
          for (; this.peekQueue.length > 0 && n3 > 0; ) {
            const t4 = this.peekQueue.pop();
            if (!t4) throw new Error("peekData should be defined");
            const r6 = Math.min(t4.length, n3);
            e6.set(t4.subarray(0, r6), i3 + a2), a2 += r6, n3 -= r6, r6 < t4.length && this.peekQueue.push(t4.subarray(r6));
          }
          for (; n3 > 0 && !this.endOfStream; ) {
            const t4 = Math.min(n3, 1048576), r6 = await this.readFromStream(e6, i3 + a2, t4);
            if (a2 += r6, r6 < t4) break;
            n3 -= r6;
          }
          return a2;
        }
        async readFromStream(e6, t4, r5) {
          const n3 = this.s.read(r5);
          if (n3) return e6.set(n3, t4), n3.length;
          {
            const n4 = { buffer: e6, offset: t4, length: r5, deferred: new i2.Deferred() };
            return this.deferred = n4.deferred, this.s.once("readable", () => {
              this.readDeferred(n4);
            }), n4.deferred.promise;
          }
        }
        readDeferred(e6) {
          const t4 = this.s.read(e6.length);
          t4 ? (e6.buffer.set(t4, e6.offset), e6.deferred.resolve(t4.length), this.deferred = null) : this.s.once("readable", () => {
            this.readDeferred(e6);
          });
        }
        reject(e6) {
          this.endOfStream = true, this.deferred && (this.deferred.reject(e6), this.deferred = null);
        }
      };
    }(StreamReader), function(e5) {
      Object.defineProperty(e5, "__esModule", { value: true }), e5.StreamReader = e5.EndOfStreamError = void 0;
      var t3 = EndOfFileStream;
      Object.defineProperty(e5, "EndOfStreamError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return t3.EndOfStreamError;
      }, "get") });
      var i2 = StreamReader;
      Object.defineProperty(e5, "StreamReader", { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return i2.StreamReader;
      }, "get") });
    }(lib), Object.defineProperty(AbstractTokenizer$1, "__esModule", { value: true }), AbstractTokenizer$1.AbstractTokenizer = void 0;
    peek_readable_1$2 = lib;
    AbstractTokenizer = class {
      static {
        __name(this, "AbstractTokenizer");
      }
      constructor(e5) {
        this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = e5 || {};
      }
      async readToken(e5, t3 = this.position) {
        const i2 = Buffer2.alloc(e5.len);
        if (await this.readBuffer(i2, { position: t3 }) < e5.len) throw new peek_readable_1$2.EndOfStreamError();
        return e5.get(i2, 0);
      }
      async peekToken(e5, t3 = this.position) {
        const i2 = Buffer2.alloc(e5.len);
        if (await this.peekBuffer(i2, { position: t3 }) < e5.len) throw new peek_readable_1$2.EndOfStreamError();
        return e5.get(i2, 0);
      }
      async readNumber(e5) {
        if (await this.readBuffer(this.numBuffer, { length: e5.len }) < e5.len) throw new peek_readable_1$2.EndOfStreamError();
        return e5.get(this.numBuffer, 0);
      }
      async peekNumber(e5) {
        if (await this.peekBuffer(this.numBuffer, { length: e5.len }) < e5.len) throw new peek_readable_1$2.EndOfStreamError();
        return e5.get(this.numBuffer, 0);
      }
      async ignore(e5) {
        if (void 0 !== this.fileInfo.size) {
          const t3 = this.fileInfo.size - this.position;
          if (e5 > t3) return this.position += t3, t3;
        }
        return this.position += e5, e5;
      }
      async close() {
      }
      normalizeOptions(e5, t3) {
        if (t3 && void 0 !== t3.position && t3.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        return t3 ? { mayBeLess: true === t3.mayBeLess, offset: t3.offset ? t3.offset : 0, length: t3.length ? t3.length : e5.length - (t3.offset ? t3.offset : 0), position: t3.position ? t3.position : this.position } : { mayBeLess: false, offset: 0, length: e5.length, position: this.position };
      }
    };
    AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer, Object.defineProperty(ReadStreamTokenizer$1, "__esModule", { value: true }), ReadStreamTokenizer$1.ReadStreamTokenizer = void 0;
    AbstractTokenizer_1$1 = AbstractTokenizer$1;
    peek_readable_1$1 = lib;
    maxBufferSize = 256e3;
    ReadStreamTokenizer = class extends AbstractTokenizer_1$1.AbstractTokenizer {
      static {
        __name(this, "ReadStreamTokenizer");
      }
      constructor(e5, t3) {
        super(t3), this.streamReader = new peek_readable_1$1.StreamReader(e5);
      }
      async getFileInfo() {
        return this.fileInfo;
      }
      async readBuffer(e5, t3) {
        const i2 = this.normalizeOptions(e5, t3), r4 = i2.position - this.position;
        if (r4 > 0) return await this.ignore(r4), this.readBuffer(e5, t3);
        if (r4 < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        if (0 === i2.length) return 0;
        const n3 = await this.streamReader.read(e5, i2.offset, i2.length);
        if (this.position += n3, (!t3 || !t3.mayBeLess) && n3 < i2.length) throw new peek_readable_1$1.EndOfStreamError();
        return n3;
      }
      async peekBuffer(e5, t3) {
        const i2 = this.normalizeOptions(e5, t3);
        let r4 = 0;
        if (i2.position) {
          const t4 = i2.position - this.position;
          if (t4 > 0) {
            const n3 = new Uint8Array(i2.length + t4);
            return r4 = await this.peekBuffer(n3, { mayBeLess: i2.mayBeLess }), e5.set(n3.subarray(t4), i2.offset), r4 - t4;
          }
          if (t4 < 0) throw new Error("Cannot peek from a negative offset in a stream");
        }
        if (i2.length > 0) {
          try {
            r4 = await this.streamReader.peek(e5, i2.offset, i2.length);
          } catch (e6) {
            if (t3 && t3.mayBeLess && e6 instanceof peek_readable_1$1.EndOfStreamError) return 0;
            throw e6;
          }
          if (!i2.mayBeLess && r4 < i2.length) throw new peek_readable_1$1.EndOfStreamError();
        }
        return r4;
      }
      async ignore(e5) {
        const t3 = Math.min(maxBufferSize, e5), i2 = new Uint8Array(t3);
        let r4 = 0;
        for (; r4 < e5; ) {
          const n3 = e5 - r4, a2 = await this.readBuffer(i2, { length: Math.min(t3, n3) });
          if (a2 < 0) return a2;
          r4 += a2;
        }
        return r4;
      }
    };
    ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer;
    BufferTokenizer$1 = {};
    Object.defineProperty(BufferTokenizer$1, "__esModule", { value: true }), BufferTokenizer$1.BufferTokenizer = void 0;
    peek_readable_1 = lib;
    AbstractTokenizer_1 = AbstractTokenizer$1;
    BufferTokenizer = class extends AbstractTokenizer_1.AbstractTokenizer {
      static {
        __name(this, "BufferTokenizer");
      }
      constructor(e5, t3) {
        super(t3), this.uint8Array = e5, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : e5.length;
      }
      async readBuffer(e5, t3) {
        if (t3 && t3.position) {
          if (t3.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          this.position = t3.position;
        }
        const i2 = await this.peekBuffer(e5, t3);
        return this.position += i2, i2;
      }
      async peekBuffer(e5, t3) {
        const i2 = this.normalizeOptions(e5, t3), r4 = Math.min(this.uint8Array.length - i2.position, i2.length);
        if (!i2.mayBeLess && r4 < i2.length) throw new peek_readable_1.EndOfStreamError();
        return e5.set(this.uint8Array.subarray(i2.position, i2.position + r4), i2.offset), r4;
      }
      async close() {
      }
    };
    BufferTokenizer$1.BufferTokenizer = BufferTokenizer, function(e5) {
      Object.defineProperty(e5, "__esModule", { value: true }), e5.fromBuffer = e5.fromStream = e5.EndOfStreamError = void 0;
      const t3 = ReadStreamTokenizer$1, i2 = BufferTokenizer$1;
      var r4 = lib;
      Object.defineProperty(e5, "EndOfStreamError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return r4.EndOfStreamError;
      }, "get") }), e5.fromStream = function(e6, i3) {
        return i3 = i3 || {}, new t3.ReadStreamTokenizer(e6, i3);
      }, e5.fromBuffer = function(e6, t4) {
        return new i2.BufferTokenizer(e6, t4);
      };
    }(core$1);
    util = { stringToBytes: /* @__PURE__ */ __name((e5) => [...e5].map((e6) => e6.charCodeAt(0)), "stringToBytes"), tarHeaderChecksumMatches: /* @__PURE__ */ __name((e5, t3 = 0) => {
      const i2 = parseInt(e5.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(i2)) return false;
      let r4 = 256;
      for (let i3 = t3; i3 < t3 + 148; i3++) r4 += e5[i3];
      for (let i3 = t3 + 156; i3 < t3 + 512; i3++) r4 += e5[i3];
      return i2 === r4;
    }, "tarHeaderChecksumMatches"), uint32SyncSafeToken: { get: /* @__PURE__ */ __name((e5, t3) => 127 & e5[t3 + 3] | e5[t3 + 2] << 7 | e5[t3 + 1] << 14 | e5[t3] << 21, "get"), len: 4 } };
    supported$1 = { extensions: ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "ai", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf"], mimeTypes: ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-apache-arrow", "video/mp4", "audio/midi", "video/x-matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/vnd.wave", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "audio/opus", "video/ogg", "audio/ogg", "application/ogg", "audio/x-flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd"] };
    Token = lib$1;
    strtok3 = core$1;
    ({ stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = util);
    supported = supported$1;
    minimumBytes = 4100;
    __name(fromStream, "fromStream");
    __name(fromBuffer, "fromBuffer");
    __name(_check, "_check");
    __name(fromTokenizer, "fromTokenizer");
    __name(_fromTokenizer, "_fromTokenizer");
    stream2 = /* @__PURE__ */ __name((readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.on("error", reject), readableStream.once("readable", async () => {
        const e5 = new stream.PassThrough();
        let t3;
        t3 = stream.pipeline ? stream.pipeline(readableStream, e5, () => {
        }) : readableStream.pipe(e5);
        const i2 = readableStream.read(minimumBytes) || readableStream.read() || Buffer2.alloc(0);
        try {
          const t4 = await fromBuffer(i2);
          e5.fileType = t4;
        } catch (e6) {
          reject(e6);
        }
        resolve(t3);
      });
    }), "stream");
    fileType = { fromStream, fromTokenizer, fromBuffer, stream: stream2 };
    Object.defineProperty(fileType, "extensions", { get: /* @__PURE__ */ __name(() => new Set(supported.extensions), "get") }), Object.defineProperty(fileType, "mimeTypes", { get: /* @__PURE__ */ __name(() => new Set(supported.mimeTypes), "get") });
    core = fileType;
    fileType$1 = getDefaultExportFromCjs(core);
    __name(to, "to");
    writeFile = /* @__PURE__ */ __name(async () => {
      throw new Error("Not supported");
    }, "writeFile");
    __name(Mime$1, "Mime$1");
    Mime$1.prototype.define = function(e5, t3) {
      for (let i2 in e5) {
        let r4 = e5[i2].map(function(e6) {
          return e6.toLowerCase();
        });
        i2 = i2.toLowerCase();
        for (let e6 = 0; e6 < r4.length; e6++) {
          const n3 = r4[e6];
          if ("*" !== n3[0]) {
            if (!t3 && n3 in this._types) throw new Error('Attempt to change mapping for "' + n3 + '" extension from "' + this._types[n3] + '" to "' + i2 + '". Pass `force=true` to allow this, otherwise remove "' + n3 + '" from the list of extensions for "' + i2 + '".');
            this._types[n3] = i2;
          }
        }
        if (t3 || !this._extensions[i2]) {
          const e6 = r4[0];
          this._extensions[i2] = "*" !== e6[0] ? e6 : e6.substr(1);
        }
      }
    }, Mime$1.prototype.getType = function(e5) {
      let t3 = (e5 = String(e5)).replace(/^.*[/\\]/, "").toLowerCase(), i2 = t3.replace(/^.*\./, "").toLowerCase(), r4 = t3.length < e5.length;
      return (i2.length < t3.length - 1 || !r4) && this._types[i2] || null;
    }, Mime$1.prototype.getExtension = function(e5) {
      return (e5 = /^\s*([^;\s]*)/.test(e5) && RegExp.$1) && this._extensions[e5.toLowerCase()] || null;
    };
    Mime_1 = Mime$1;
    standard = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
    Mime = Mime_1;
    lite = new Mime(standard);
    mime = getDefaultExportFromCjs(lite);
    __name(srcOver, "srcOver");
    __name(dstOver, "dstOver");
    __name(multiply, "multiply");
    __name(add, "add");
    __name(screen, "screen");
    __name(overlay, "overlay");
    __name(darken, "darken");
    __name(lighten, "lighten");
    __name(hardLight, "hardLight");
    __name(difference, "difference");
    __name(exclusion, "exclusion");
    HorizontalAlign2 = HorizontalAlign || (HorizontalAlign = {}), HorizontalAlign2[HorizontalAlign2.LEFT = 1] = "LEFT", HorizontalAlign2[HorizontalAlign2.CENTER = 2] = "CENTER", HorizontalAlign2[HorizontalAlign2.RIGHT = 4] = "RIGHT", VerticalAlign2 = VerticalAlign || (VerticalAlign = {}), VerticalAlign2[VerticalAlign2.TOP = 8] = "TOP", VerticalAlign2[VerticalAlign2.MIDDLE = 16] = "MIDDLE", VerticalAlign2[VerticalAlign2.BOTTOM = 32] = "BOTTOM", BlendMode2 = BlendMode || (BlendMode = {}), BlendMode2.SRC_OVER = "srcOver", BlendMode2.DST_OVER = "dstOver", BlendMode2.MULTIPLY = "multiply", BlendMode2.ADD = "add", BlendMode2.SCREEN = "screen", BlendMode2.OVERLAY = "overlay", BlendMode2.DARKEN = "darken", BlendMode2.LIGHTEN = "lighten", BlendMode2.HARD_LIGHT = "hardLight", BlendMode2.DIFFERENCE = "difference", BlendMode2.EXCLUSION = "exclusion";
    names = [srcOver, dstOver, multiply, add, screen, overlay, darken, lighten, hardLight, difference, exclusion];
    compositeModes = Object.freeze({ __proto__: null, add, darken, difference, dstOver, exclusion, hardLight, lighten, multiply, names, overlay, screen, srcOver });
    __name(composite, "composite");
    jpeg$1 = { parseSections: /* @__PURE__ */ __name(function(e5, t3) {
      var i2, r4;
      for (e5.setBigEndian(true); e5.remainingLength() > 0 && 218 !== r4; ) {
        if (255 !== e5.nextUInt8()) throw new Error("Invalid JPEG section offset");
        i2 = (r4 = e5.nextUInt8()) >= 208 && r4 <= 217 || 218 === r4 ? 0 : e5.nextUInt16() - 2, t3(r4, e5.branch(0, i2)), e5.skip(i2);
      }
    }, "parseSections"), getSizeFromSOFSection: /* @__PURE__ */ __name(function(e5) {
      return e5.skip(1), { height: e5.nextUInt16(), width: e5.nextUInt16() };
    }, "getSizeFromSOFSection"), getSectionName: /* @__PURE__ */ __name(function(e5) {
      var t3, i2;
      switch (e5) {
        case 216:
          t3 = "SOI";
          break;
        case 196:
          t3 = "DHT";
          break;
        case 219:
          t3 = "DQT";
          break;
        case 221:
          t3 = "DRI";
          break;
        case 218:
          t3 = "SOS";
          break;
        case 254:
          t3 = "COM";
          break;
        case 217:
          t3 = "EOI";
          break;
        default:
          e5 >= 224 && e5 <= 239 ? (t3 = "APP", i2 = e5 - 224) : e5 >= 192 && e5 <= 207 && 196 !== e5 && 200 !== e5 && 204 !== e5 ? (t3 = "SOF", i2 = e5 - 192) : e5 >= 208 && e5 <= 215 && (t3 = "RST", i2 = e5 - 208);
      }
      var r4 = { name: t3 };
      return "number" == typeof i2 && (r4.index = i2), r4;
    }, "getSectionName") };
    __name(readExifValue, "readExifValue");
    __name(getBytesPerComponent, "getBytesPerComponent");
    __name(readExifTag, "readExifTag");
    __name(readIFDSection, "readIFDSection");
    __name(readHeader, "readHeader");
    exif$2 = { IFD0: 1, IFD1: 2, GPSIFD: 3, SubIFD: 4, InteropIFD: 5, parseTags: /* @__PURE__ */ __name(function(e5, t3) {
      var i2, r4, n3, a2;
      try {
        i2 = readHeader(e5);
      } catch (e6) {
        return false;
      }
      var o3 = i2.openWithOffset(e5.nextUInt32()), s4 = this.IFD0;
      readIFDSection(i2, o3, function(e6, i3, a3) {
        switch (e6) {
          case 34853:
            n3 = i3[0];
            break;
          case 34665:
            r4 = i3[0];
            break;
          default:
            t3(s4, e6, i3, a3);
        }
      });
      var l2 = o3.nextUInt32();
      if (0 !== l2) {
        var u2 = i2.openWithOffset(l2);
        readIFDSection(i2, u2, t3.bind(null, this.IFD1));
      }
      if (n3) {
        var h2 = i2.openWithOffset(n3);
        readIFDSection(i2, h2, t3.bind(null, this.GPSIFD));
      }
      if (r4) {
        var c3 = i2.openWithOffset(r4), f2 = this.InteropIFD;
        readIFDSection(i2, c3, function(e6, i3, r5) {
          40965 === e6 ? a2 = i3[0] : t3(f2, e6, i3, r5);
        });
      }
      if (a2) {
        var d = i2.openWithOffset(a2);
        readIFDSection(i2, d, t3.bind(null, this.InteropIFD));
      }
      return true;
    }, "parseTags") };
    __name(parseNumber, "parseNumber");
    hours = 3600;
    minutes = 60;
    __name(parseDateTimeParts, "parseDateTimeParts");
    __name(parseDateWithTimezoneFormat, "parseDateWithTimezoneFormat");
    __name(parseDateWithSpecFormat, "parseDateWithSpecFormat");
    __name(parseExifDate, "parseExifDate");
    date$1 = { parseDateWithSpecFormat, parseDateWithTimezoneFormat, parseExifDate };
    exif$1 = exif$2;
    date = date$1;
    degreeTags = [{ section: exif$1.GPSIFD, type: 2, name: "GPSLatitude", refType: 1, refName: "GPSLatitudeRef", posVal: "N" }, { section: exif$1.GPSIFD, type: 4, name: "GPSLongitude", refType: 3, refName: "GPSLongitudeRef", posVal: "E" }];
    dateTags = [{ section: exif$1.SubIFD, type: 306, name: "ModifyDate" }, { section: exif$1.SubIFD, type: 36867, name: "DateTimeOriginal" }, { section: exif$1.SubIFD, type: 36868, name: "CreateDate" }, { section: exif$1.SubIFD, type: 306, name: "ModifyDate" }];
    simplify$1 = { castDegreeValues: /* @__PURE__ */ __name(function(e5, t3) {
      degreeTags.forEach(function(i2) {
        var r4 = e5(i2);
        if (r4) {
          var n3 = e5({ section: i2.section, type: i2.refType, name: i2.refName }) === i2.posVal ? 1 : -1, a2 = (r4[0] + r4[1] / 60 + r4[2] / 3600) * n3;
          t3(i2, a2);
        }
      });
    }, "castDegreeValues"), castDateValues: /* @__PURE__ */ __name(function(e5, t3) {
      dateTags.forEach(function(i2) {
        var r4 = e5(i2);
        if (r4) {
          var n3 = date.parseExifDate(r4);
          void 0 !== n3 && t3(i2, n3);
        }
      });
    }, "castDateValues"), simplifyValue: /* @__PURE__ */ __name(function(e5, t3) {
      return Array.isArray(e5) && 1 === (e5 = e5.map(function(e6) {
        return 10 === t3 || 5 === t3 ? e6[0] / e6[1] : e6;
      })).length && (e5 = e5[0]), e5;
    }, "simplifyValue") };
    __name(requireExifTags, "requireExifTags");
    jpeg = jpeg$1;
    exif = exif$2;
    simplify = simplify$1;
    __name(ExifResult, "ExifResult");
    __name(Parser$1, "Parser$1");
    ExifResult.prototype = { hasThumbnail: /* @__PURE__ */ __name(function(e5) {
      return !(!this.thumbnailOffset || !this.thumbnailLength) && ("string" != typeof e5 || ("image/jpeg" === e5.toLowerCase().trim() ? 6 === this.thumbnailType : "image/tiff" === e5.toLowerCase().trim() && 1 === this.thumbnailType));
    }, "hasThumbnail"), getThumbnailOffset: /* @__PURE__ */ __name(function() {
      return this.app1Offset + 6 + this.thumbnailOffset;
    }, "getThumbnailOffset"), getThumbnailLength: /* @__PURE__ */ __name(function() {
      return this.thumbnailLength;
    }, "getThumbnailLength"), getThumbnailBuffer: /* @__PURE__ */ __name(function() {
      return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
    }, "getThumbnailBuffer"), _getThumbnailStream: /* @__PURE__ */ __name(function() {
      return this.startMarker.openWithOffset(this.getThumbnailOffset());
    }, "_getThumbnailStream"), getImageSize: /* @__PURE__ */ __name(function() {
      return this.imageSize;
    }, "getImageSize"), getThumbnailSize: /* @__PURE__ */ __name(function() {
      var e5, t3 = this._getThumbnailStream();
      return jpeg.parseSections(t3, function(t4, i2) {
        "SOF" === jpeg.getSectionName(t4).name && (e5 = jpeg.getSizeFromSOFSection(i2));
      }), e5;
    }, "getThumbnailSize") }, Parser$1.prototype = { enableBinaryFields: /* @__PURE__ */ __name(function(e5) {
      return this.flags.readBinaryTags = !!e5, this;
    }, "enableBinaryFields"), enablePointers: /* @__PURE__ */ __name(function(e5) {
      return this.flags.hidePointers = !e5, this;
    }, "enablePointers"), enableTagNames: /* @__PURE__ */ __name(function(e5) {
      return this.flags.resolveTagNames = !!e5, this;
    }, "enableTagNames"), enableImageSize: /* @__PURE__ */ __name(function(e5) {
      return this.flags.imageSize = !!e5, this;
    }, "enableImageSize"), enableReturnTags: /* @__PURE__ */ __name(function(e5) {
      return this.flags.returnTags = !!e5, this;
    }, "enableReturnTags"), enableSimpleValues: /* @__PURE__ */ __name(function(e5) {
      return this.flags.simplifyValues = !!e5, this;
    }, "enableSimpleValues"), parse: /* @__PURE__ */ __name(function() {
      var e5, t3, i2, r4, n3, a2, o3, s4, l2, u2 = this.stream.mark(), h2 = u2.openWithOffset(0), c3 = this.flags;
      return c3.resolveTagNames && (o3 = requireExifTags()), c3.resolveTagNames ? (e5 = {}, s4 = /* @__PURE__ */ __name(function(t4) {
        return e5[t4.name];
      }, "s"), l2 = /* @__PURE__ */ __name(function(t4, i3) {
        e5[t4.name] = i3;
      }, "l")) : (e5 = [], s4 = /* @__PURE__ */ __name(function(t4) {
        var i3;
        for (i3 = 0; i3 < e5.length; ++i3) if (e5[i3].type === t4.type && e5[i3].section === t4.section) return e5.value;
      }, "s"), l2 = /* @__PURE__ */ __name(function(t4, i3) {
        var r5;
        for (r5 = 0; r5 < e5.length; ++r5) if (e5[r5].type === t4.type && e5[r5].section === t4.section) return void (e5.value = i3);
      }, "l")), jpeg.parseSections(h2, function(s5, l3) {
        var h3 = l3.offsetFrom(u2);
        225 === s5 ? exif.parseTags(l3, function(t4, a3, s6, l4) {
          if (c3.readBinaryTags || 7 !== l4) {
            if (513 === a3) {
              if (i2 = s6[0], c3.hidePointers) return;
            } else if (514 === a3) {
              if (r4 = s6[0], c3.hidePointers) return;
            } else if (259 === a3 && (n3 = s6[0], c3.hidePointers)) return;
            if (c3.returnTags) if (c3.simplifyValues && (s6 = simplify.simplifyValue(s6, l4)), c3.resolveTagNames) {
              var u3 = (t4 === exif.GPSIFD ? o3.gps : o3.exif)[a3];
              u3 || (u3 = o3.exif[a3]), e5.hasOwnProperty(u3) || (e5[u3] = s6);
            } else e5.push({ section: t4, type: a3, value: s6 });
          }
        }) && (a2 = h3) : c3.imageSize && "SOF" === jpeg.getSectionName(s5).name && (t3 = jpeg.getSizeFromSOFSection(l3));
      }), c3.simplifyValues && (simplify.castDegreeValues(s4, l2), simplify.castDateValues(s4, l2)), new ExifResult(u2, e5, t3, i2, r4, n3, a2);
    }, "parse") };
    parser = Parser$1;
    __name(requireDomBufferstream, "requireDomBufferstream");
    __name(requireBufferstream, "requireBufferstream");
    Parser = parser;
    __name(getGlobal, "getGlobal");
    exifParser = { create: /* @__PURE__ */ __name(function(e5, t3) {
      if (e5 instanceof (t3 = t3 || getGlobal()).ArrayBuffer) {
        var i2 = requireDomBufferstream();
        return new Parser(new i2(e5, 0, e5.byteLength, true, t3));
      }
      var r4 = requireBufferstream();
      return new Parser(new r4(e5, 0, e5.length, true));
    }, "create") };
    EXIFParser = getDefaultExportFromCjs(exifParser);
    __name(getExifOrientation, "getExifOrientation");
    __name(getExifOrientationTransformation, "getExifOrientationTransformation");
    __name(transformBitmap, "transformBitmap");
    __name(exifRotate, "exifRotate");
    __name(attemptExifRotate, "attemptExifRotate");
    __defProp$2 = Object.defineProperty;
    __defNormalProp$2 = /* @__PURE__ */ __name((e5, t3, i2) => t3 in e5 ? __defProp$2(e5, t3, { enumerable: true, configurable: true, writable: true, value: i2 }) : e5[t3] = i2, "__defNormalProp$2");
    __publicField$2 = /* @__PURE__ */ __name((e5, t3, i2) => __defNormalProp$2(e5, "symbol" != typeof t3 ? t3 + "" : t3, i2), "__publicField$2");
    emptyBitmap = { data: Buffer2.alloc(0), width: 0, height: 0 };
    __name(bufferFromArrayBuffer, "bufferFromArrayBuffer");
    __name(createJimp, "createJimp");
    __name(Resize, "Resize");
    ResizeStrategy2 = ResizeStrategy || (ResizeStrategy = {}), ResizeStrategy2.NEAREST_NEIGHBOR = "nearestNeighbor", ResizeStrategy2.BILINEAR = "bilinearInterpolation", ResizeStrategy2.BICUBIC = "bicubicInterpolation", ResizeStrategy2.HERMITE = "hermiteInterpolation", ResizeStrategy2.BEZIER = "bezierInterpolation", Resize.prototype.initialize = function() {
      if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)) throw console.log(this), new Error("Invalid settings specified for the resizer.");
      this.configurePasses();
    }, Resize.prototype.configurePasses = function() {
      this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(true), this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(false), this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(true), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(false), this.resizeHeight = 4 === this.colorChannels ? this.resizeHeightRGBA : this.resizeHeightRGB));
    }, Resize.prototype._resizeWidthInterpolatedRGBChannels = function(e5, t3) {
      const i2 = t3 ? 4 : 3, r4 = this.ratioWeightWidthPass, n3 = this.widthBuffer;
      let a2, o3, s4 = 0, l2 = 0, u2 = 0, h2 = 0, c3 = 0;
      for (a2 = 0; s4 < 1 / 3; a2 += i2, s4 += r4) for (l2 = a2, u2 = 0; l2 < this.widthPassResultSize; u2 += this.originalWidthMultipliedByChannels, l2 += this.targetWidthMultipliedByChannels) n3[l2] = e5[u2], n3[l2 + 1] = e5[u2 + 1], n3[l2 + 2] = e5[u2 + 2], t3 && (n3[l2 + 3] = e5[u2 + 3]);
      for (s4 -= 1 / 3, o3 = this.widthOriginal - 1; s4 < o3; a2 += i2, s4 += r4) for (c3 = s4 % 1, h2 = 1 - c3, l2 = a2, u2 = Math.floor(s4) * i2; l2 < this.widthPassResultSize; u2 += this.originalWidthMultipliedByChannels, l2 += this.targetWidthMultipliedByChannels) n3[l2 + 0] = e5[u2 + 0] * h2 + e5[u2 + i2 + 0] * c3, n3[l2 + 1] = e5[u2 + 1] * h2 + e5[u2 + i2 + 1] * c3, n3[l2 + 2] = e5[u2 + 2] * h2 + e5[u2 + i2 + 2] * c3, t3 && (n3[l2 + 3] = e5[u2 + 3] * h2 + e5[u2 + i2 + 3] * c3);
      for (o3 = this.originalWidthMultipliedByChannels - i2; a2 < this.targetWidthMultipliedByChannels; a2 += i2) for (l2 = a2, u2 = o3; l2 < this.widthPassResultSize; u2 += this.originalWidthMultipliedByChannels, l2 += this.targetWidthMultipliedByChannels) n3[l2] = e5[u2], n3[l2 + 1] = e5[u2 + 1], n3[l2 + 2] = e5[u2 + 2], t3 && (n3[l2 + 3] = e5[u2 + 3]);
      return n3;
    }, Resize.prototype._resizeWidthRGBChannels = function(e5, t3) {
      const i2 = t3 ? 4 : 3, r4 = this.ratioWeightWidthPass, n3 = 1 / r4, a2 = this.originalWidthMultipliedByChannels - i2 + 1, o3 = this.targetWidthMultipliedByChannels - i2 + 1, s4 = this.outputWidthWorkBench, l2 = this.widthBuffer, u2 = this.outputWidthWorkBenchOpaquePixelsCount;
      let h2 = 0, c3 = 0, f2 = 0, d = 0, p2 = 0, m = 0, _2 = 0, g = 1, b2 = 0, y2 = 0, w = 0, v2 = 0;
      do {
        for (p2 = 0; p2 < this.originalHeightMultipliedByChannels; ) s4[p2++] = 0, s4[p2++] = 0, s4[p2++] = 0, t3 && (s4[p2++] = 0, u2[p2 / i2 - 1] = 0);
        h2 = r4;
        do {
          for (c3 = 1 + f2 - d, g = Math.min(h2, c3), p2 = 0, m = f2; p2 < this.originalHeightMultipliedByChannels; m += a2) b2 = e5[m], y2 = e5[++m], w = e5[++m], v2 = t3 ? e5[++m] : 255, s4[p2++] += (v2 ? b2 : 0) * g, s4[p2++] += (v2 ? y2 : 0) * g, s4[p2++] += (v2 ? w : 0) * g, t3 && (s4[p2++] += v2 * g, u2[p2 / i2 - 1] += v2 ? g : 0);
          if (!(h2 >= c3)) {
            d += h2;
            break;
          }
          f2 += i2, d = f2, h2 -= c3;
        } while (h2 > 0 && f2 < this.originalWidthMultipliedByChannels);
        for (p2 = 0, m = _2; p2 < this.originalHeightMultipliedByChannels; m += o3) h2 = t3 ? u2[p2 / i2] : 1, g = t3 ? h2 ? 1 / h2 : 0 : n3, l2[m] = s4[p2++] * g, l2[++m] = s4[p2++] * g, l2[++m] = s4[p2++] * g, t3 && (l2[++m] = s4[p2++] * n3);
        _2 += i2;
      } while (_2 < this.targetWidthMultipliedByChannels);
      return l2;
    }, Resize.prototype._resizeHeightRGBChannels = function(e5, t3) {
      const i2 = this.ratioWeightHeightPass, r4 = 1 / i2, n3 = this.outputHeightWorkBench, a2 = this.heightBuffer, o3 = this.outputHeightWorkBenchOpaquePixelsCount;
      let s4 = 0, l2 = 0, u2 = 0, h2 = 0, c3 = 0, f2 = 0, d = 0, p2 = 1, m = 0, _2 = 0, g = 0, b2 = 0;
      do {
        for (c3 = 0; c3 < this.targetWidthMultipliedByChannels; ) n3[c3++] = 0, n3[c3++] = 0, n3[c3++] = 0, t3 && (n3[c3++] = 0, o3[c3 / 4 - 1] = 0);
        s4 = i2;
        do {
          for (l2 = 1 + u2 - h2, p2 = Math.min(s4, l2), d = u2, c3 = 0; c3 < this.targetWidthMultipliedByChannels; ) m = e5[d++], _2 = e5[d++], g = e5[d++], b2 = t3 ? e5[d++] : 255, n3[c3++] += (b2 ? m : 0) * p2, n3[c3++] += (b2 ? _2 : 0) * p2, n3[c3++] += (b2 ? g : 0) * p2, t3 && (n3[c3++] += b2 * p2, o3[c3 / 4 - 1] += b2 ? p2 : 0);
          if (!(s4 >= l2)) {
            h2 += s4;
            break;
          }
          u2 = d, h2 = u2, s4 -= l2;
        } while (s4 > 0 && u2 < this.widthPassResultSize);
        for (c3 = 0; c3 < this.targetWidthMultipliedByChannels; ) s4 = t3 ? o3[c3 / 4] : 1, p2 = t3 ? s4 ? 1 / s4 : 0 : r4, a2[f2++] = Math.round(n3[c3++] * p2), a2[f2++] = Math.round(n3[c3++] * p2), a2[f2++] = Math.round(n3[c3++] * p2), t3 && (a2[f2++] = Math.round(n3[c3++] * r4));
      } while (f2 < this.finalResultSize);
      return a2;
    }, Resize.prototype.resizeWidthInterpolatedRGB = function(e5) {
      return this._resizeWidthInterpolatedRGBChannels(e5, false);
    }, Resize.prototype.resizeWidthInterpolatedRGBA = function(e5) {
      return this._resizeWidthInterpolatedRGBChannels(e5, true);
    }, Resize.prototype.resizeWidthRGB = function(e5) {
      return this._resizeWidthRGBChannels(e5, false);
    }, Resize.prototype.resizeWidthRGBA = function(e5) {
      return this._resizeWidthRGBChannels(e5, true);
    }, Resize.prototype.resizeHeightInterpolated = function(e5) {
      const t3 = this.ratioWeightHeightPass, i2 = this.heightBuffer;
      let r4, n3 = 0, a2 = 0, o3 = 0, s4 = 0, l2 = 0, u2 = 0, h2 = 0;
      for (; n3 < 1 / 3; n3 += t3) for (o3 = 0; o3 < this.targetWidthMultipliedByChannels; ) i2[a2++] = Math.round(e5[o3++]);
      for (n3 -= 1 / 3, r4 = this.heightOriginal - 1; n3 < r4; n3 += t3) for (h2 = n3 % 1, u2 = 1 - h2, s4 = Math.floor(n3) * this.targetWidthMultipliedByChannels, l2 = s4 + this.targetWidthMultipliedByChannels, o3 = 0; o3 < this.targetWidthMultipliedByChannels; ++o3) i2[a2++] = Math.round(e5[s4++] * u2 + e5[l2++] * h2);
      for (; a2 < this.finalResultSize; ) for (o3 = 0, s4 = r4 * this.targetWidthMultipliedByChannels; o3 < this.targetWidthMultipliedByChannels; ++o3) i2[a2++] = Math.round(e5[s4++]);
      return i2;
    }, Resize.prototype.resizeHeightRGB = function(e5) {
      return this._resizeHeightRGBChannels(e5, false);
    }, Resize.prototype.resizeHeightRGBA = function(e5) {
      return this._resizeHeightRGBChannels(e5, true);
    }, Resize.prototype.resize = function(e5) {
      this.resizeCallback(this.resizeHeight(this.resizeWidth(e5)));
    }, Resize.prototype.bypassResizer = function(e5) {
      return e5;
    }, Resize.prototype.initializeFirstPassBuffers = function(e5) {
      this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), e5 || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
    }, Resize.prototype.initializeSecondPassBuffers = function(e5) {
      this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), e5 || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
    }, Resize.prototype.generateFloatBuffer = function(e5) {
      try {
        return new Float32Array(e5);
      } catch (e6) {
        return console.error(e6), [];
      }
    }, Resize.prototype.generateFloat64Buffer = function(e5) {
      try {
        return new Float64Array(e5);
      } catch (e6) {
        return console.error(e6), [];
      }
    }, Resize.prototype.generateUint8Buffer = function(e5) {
      try {
        return new Uint8Array(e5);
      } catch (e6) {
        return console.error(e6), [];
      }
    };
    operations = { nearestNeighbor(e5, t3) {
      const i2 = e5.width, r4 = e5.height, n3 = t3.width, a2 = t3.height, o3 = e5.data, s4 = t3.data;
      for (let e6 = 0; e6 < a2; e6++) for (let t4 = 0; t4 < n3; t4++) {
        let l2 = 4 * (e6 * n3 + t4);
        let u2 = 4 * (Math.floor(e6 * r4 / a2) * i2 + Math.floor(t4 * i2 / n3));
        s4[l2++] = o3[u2++], s4[l2++] = o3[u2++], s4[l2++] = o3[u2++], s4[l2++] = o3[u2++];
      }
    }, bilinearInterpolation(e5, t3) {
      const i2 = e5.width, r4 = e5.height, n3 = t3.width, a2 = t3.height, o3 = e5.data, s4 = t3.data, l2 = /* @__PURE__ */ __name(function(e6, t4, i3, r5, n4) {
        return t4 === r5 ? i3 : Math.round((e6 - t4) * n4 + (r5 - e6) * i3);
      }, "l"), u2 = /* @__PURE__ */ __name(function(e6, t4, r5, n4, a3, u3, h2, c3) {
        let f2 = 4 * (h2 * i2 + n4) + t4, d = 4 * (h2 * i2 + a3) + t4;
        const p2 = l2(r5, n4, o3[f2], a3, o3[d]);
        if (c3 === h2) s4[e6 + t4] = p2;
        else {
          f2 = 4 * (c3 * i2 + n4) + t4, d = 4 * (c3 * i2 + a3) + t4;
          const m = l2(r5, n4, o3[f2], a3, o3[d]);
          s4[e6 + t4] = l2(u3, h2, p2, c3, m);
        }
      }, "u");
      for (let e6 = 0; e6 < a2; e6++) for (let t4 = 0; t4 < n3; t4++) {
        const o4 = 4 * (e6 * n3 + t4), s5 = t4 * i2 / n3, l3 = Math.floor(s5), h2 = Math.min(Math.ceil(s5), i2 - 1), c3 = e6 * r4 / a2, f2 = Math.floor(c3), d = Math.min(Math.ceil(c3), r4 - 1);
        u2(o4, 0, s5, l3, h2, c3, f2, d), u2(o4, 1, s5, l3, h2, c3, f2, d), u2(o4, 2, s5, l3, h2, c3, f2, d), u2(o4, 3, s5, l3, h2, c3, f2, d);
      }
    }, _interpolate2D(e5, t3, i2, r4) {
      const n3 = e5.data, a2 = t3.data, o3 = e5.width, s4 = e5.height, l2 = t3.width, u2 = t3.height, h2 = Math.max(1, Math.floor(o3 / l2)), c3 = l2 * h2, f2 = Math.max(1, Math.floor(s4 / u2)), d = u2 * f2, p2 = Buffer2.alloc(c3 * s4 * 4);
      for (let e6 = 0; e6 < s4; e6++) for (let t4 = 0; t4 < c3; t4++) {
        const i3 = t4 * (o3 - 1) / c3, a3 = Math.floor(i3), s5 = i3 - a3, l3 = 4 * (e6 * o3 + a3), u3 = 4 * (e6 * c3 + t4);
        for (let e7 = 0; e7 < 4; e7++) {
          const t5 = l3 + e7, i4 = a3 > 0 ? n3[t5 - 4] : 2 * n3[t5] - n3[t5 + 4], h3 = n3[t5], c4 = n3[t5 + 4], f3 = a3 < o3 - 2 ? n3[t5 + 8] : 2 * n3[t5 + 4] - n3[t5];
          p2[u3 + e7] = r4(i4, h3, c4, f3, s5);
        }
      }
      const m = Buffer2.alloc(c3 * d * 4);
      for (let e6 = 0; e6 < d; e6++) for (let t4 = 0; t4 < c3; t4++) {
        const i3 = e6 * (s4 - 1) / d, n4 = Math.floor(i3), a3 = i3 - n4, o4 = 4 * (n4 * c3 + t4), l3 = 4 * (e6 * c3 + t4);
        for (let e7 = 0; e7 < 4; e7++) {
          const t5 = o4 + e7, i4 = n4 > 0 ? p2[t5 - 4 * c3] : 2 * p2[t5] - p2[t5 + 4 * c3], u3 = p2[t5], h3 = p2[t5 + 4 * c3], f3 = n4 < s4 - 2 ? p2[t5 + 8 * c3] : 2 * p2[t5 + 4 * c3] - p2[t5];
          m[l3 + e7] = r4(i4, u3, h3, f3, a3);
        }
      }
      const _2 = h2 * f2;
      if (_2 > 1) for (let e6 = 0; e6 < u2; e6++) for (let t4 = 0; t4 < l2; t4++) {
        let i3 = 0, r5 = 0, n4 = 0, o4 = 0, s5 = 0;
        for (let a3 = 0; a3 < f2; a3++) {
          const l3 = e6 * f2 + a3;
          for (let e7 = 0; e7 < h2; e7++) {
            const a4 = 4 * (l3 * c3 + (t4 * h2 + e7)), u4 = m[a4 + 3];
            u4 && (i3 += m[a4], r5 += m[a4 + 1], n4 += m[a4 + 2], s5++), o4 += u4;
          }
        }
        const u3 = 4 * (e6 * l2 + t4);
        a2[u3] = s5 ? Math.round(i3 / s5) : 0, a2[u3 + 1] = s5 ? Math.round(r5 / s5) : 0, a2[u3 + 2] = s5 ? Math.round(n4 / s5) : 0, a2[u3 + 3] = Math.round(o4 / _2);
      }
      else t3.data = m;
    }, bicubicInterpolation(e5, t3, i2) {
      return this._interpolate2D(e5, t3, i2, function(e6, t4, i3, r4, n3) {
        const a2 = r4 - i3 - e6 + t4, o3 = e6 - t4 - a2, s4 = i3 - e6, l2 = t4;
        return Math.max(0, Math.min(255, a2 * (n3 * n3 * n3) + o3 * (n3 * n3) + s4 * n3 + l2));
      });
    }, hermiteInterpolation(e5, t3, i2) {
      return this._interpolate2D(e5, t3, i2, function(e6, t4, i3, r4, n3) {
        const a2 = t4, o3 = 0.5 * (i3 - e6), s4 = e6 - 2.5 * t4 + 2 * i3 - 0.5 * r4, l2 = 0.5 * (r4 - e6) + 1.5 * (t4 - i3);
        return Math.max(0, Math.min(255, Math.round(((l2 * n3 + s4) * n3 + o3) * n3 + a2)));
      });
    }, bezierInterpolation(e5, t3, i2) {
      return this._interpolate2D(e5, t3, i2, function(e6, t4, i3, r4, n3) {
        const a2 = 1 - n3, o3 = t4 * a2 * a2 * a2, s4 = 3 * (t4 + (i3 - e6) / 4) * a2 * a2 * n3, l2 = 3 * (i3 - (r4 - t4) / 4) * a2 * n3 * n3, u2 = i3 * n3 * n3 * n3;
        return Math.max(0, Math.min(255, Math.round(o3 + s4 + l2 + u2)));
      });
    } };
    ResizeOptionsSchema = z.union([z.object({ w: z.number().min(0), h: z.number().min(0).optional(), mode: z.nativeEnum(ResizeStrategy).optional() }), z.object({ w: z.number().min(0).optional(), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() })]);
    ScaleToFitOptionsSchema = z.object({ w: z.number().min(0), h: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() });
    ScaleComplexOptionsSchema = z.object({ f: z.number().min(0), mode: z.nativeEnum(ResizeStrategy).optional() });
    methods$d = { resize(e5, t3) {
      const { mode: i2 } = ResizeOptionsSchema.parse(t3);
      let r4, n3;
      if ("number" == typeof t3.w) r4 = t3.w, n3 = t3.h ?? e5.bitmap.height * (r4 / e5.bitmap.width);
      else {
        if ("number" != typeof t3.h) throw new Error("w must be a number");
        n3 = t3.h, r4 = t3.w ?? e5.bitmap.width * (n3 / e5.bitmap.height);
      }
      if (r4 = Math.round(r4) || 1, n3 = Math.round(n3) || 1, i2 && "function" == typeof operations[i2]) {
        const t4 = { data: Buffer2.alloc(r4 * n3 * 4), width: r4, height: n3 };
        operations[i2](e5.bitmap, t4), e5.bitmap = t4;
      } else {
        new Resize(e5.bitmap.width, e5.bitmap.height, r4, n3, true, true, (t4) => {
          e5.bitmap.data = Buffer2.from(t4), e5.bitmap.width = r4, e5.bitmap.height = n3;
        }).resize(e5.bitmap.data);
      }
      return e5;
    }, scale(e5, t3) {
      const { f: i2, mode: r4 } = "number" == typeof t3 ? { f: t3 } : ScaleComplexOptionsSchema.parse(t3), n3 = e5.bitmap.width * i2, a2 = e5.bitmap.height * i2;
      return this.resize(e5, { w: n3, h: a2, mode: r4 });
    }, scaleToFit(e5, t3) {
      const { h: i2, w: r4, mode: n3 } = ScaleToFitOptionsSchema.parse(t3), a2 = r4 / i2 > e5.bitmap.width / e5.bitmap.height ? i2 / e5.bitmap.height : r4 / e5.bitmap.width;
      return this.scale(e5, { f: a2, mode: n3 });
    } };
    ContainOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() });
    methods$c = { contain(e5, t3) {
      const { w: i2, h: r4, align: n3 = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: a2 } = ContainOptionsSchema.parse(t3), o3 = 7 & n3, s4 = n3 >> 3;
      if ((0 === o3 || o3 & o3 - 1) && (0 === s4 || s4 & s4 - 1)) throw new Error("only use one flag per alignment direction");
      const l2 = o3 >> 1, u2 = s4 >> 1, h2 = i2 / r4 > e5.bitmap.width / e5.bitmap.height ? r4 / e5.bitmap.height : i2 / e5.bitmap.width, c3 = methods$d.scale(clone(e5), { f: h2, mode: a2 });
      return (e5 = methods$d.resize(e5, { w: i2, h: r4, mode: a2 })).scan((t4, i3, r5) => {
        e5.bitmap.data.writeUInt32BE(e5.background, r5);
      }), e5 = methods$h.blit(e5, { src: c3, x: (e5.bitmap.width - c3.bitmap.width) / 2 * l2, y: (e5.bitmap.height - c3.bitmap.height) / 2 * u2 });
    } };
    CropOptionsSchema = z.object({ x: z.number(), y: z.number(), w: z.number(), h: z.number() });
    AutocropComplexOptionsSchema = z.object({ tolerance: z.number().min(0).max(1).optional(), cropOnlyFrames: z.boolean().optional(), cropSymmetric: z.boolean().optional(), leaveBorder: z.number().optional(), ignoreSides: z.object({ north: z.boolean().optional(), south: z.boolean().optional(), east: z.boolean().optional(), west: z.boolean().optional() }).optional() });
    methods$b = { crop(e5, t3) {
      let { x: i2, y: r4, w: n3, h: a2 } = CropOptionsSchema.parse(t3);
      if (i2 = Math.round(i2), r4 = Math.round(r4), n3 = Math.round(n3), a2 = Math.round(a2), 0 === i2 && n3 === e5.bitmap.width) {
        const t4 = n3 * r4 + i2 << 2, o3 = t4 + (a2 * n3 << 2);
        e5.bitmap.data = e5.bitmap.data.slice(t4, o3);
      } else {
        const t4 = Buffer2.allocUnsafe(n3 * a2 * 4);
        let o3 = 0;
        scan(e5, i2, r4, n3, a2, function(i3, r5, n4) {
          const a3 = e5.bitmap.data.readUInt32BE(n4);
          t4.writeUInt32BE(a3, o3), o3 += 4;
        }), e5.bitmap.data = t4;
      }
      return e5.bitmap.width = n3, e5.bitmap.height = a2, e5;
    }, autocrop(e5, t3 = {}) {
      const { tolerance: i2 = 2e-4, cropOnlyFrames: r4 = true, cropSymmetric: n3 = false, leaveBorder: a2 = 0, ignoreSides: o3 } = "number" == typeof t3 ? { tolerance: t3 } : AutocropComplexOptionsSchema.parse(t3), s4 = e5.bitmap.width, l2 = e5.bitmap.height, u2 = { north: false, south: false, east: false, west: false, ...o3 };
      let h2 = e5.getPixelColor(0, 0);
      const c3 = intToRGBA$1(h2);
      let f2 = 0, d = 0, p2 = 0, m = 0;
      if (h2 = e5.getPixelColor(0, 0), !u2.north) e: for (let t4 = 0; t4 < l2 - 1; t4++) {
        for (let r5 = 0; r5 < s4; r5++) {
          if (colorDiff(c3, intToRGBA$1(e5.getPixelColor(r5, t4))) > i2) break e;
        }
        f2++;
      }
      if (h2 = e5.getPixelColor(s4, 0), !u2.west) e: for (let t4 = 0; t4 < s4 - 1; t4++) {
        for (let r5 = 0 + f2; r5 < l2; r5++) {
          if (colorDiff(c3, intToRGBA$1(e5.getPixelColor(t4, r5))) > i2) break e;
        }
        m++;
      }
      if (h2 = e5.getPixelColor(0, l2), !u2.south) e: for (let t4 = l2 - 1; t4 >= f2 + 1; t4--) {
        for (let r5 = s4 - d - 1; r5 >= 0; r5--) {
          if (colorDiff(c3, intToRGBA$1(e5.getPixelColor(r5, t4))) > i2) break e;
        }
        p2++;
      }
      if (h2 = e5.getPixelColor(s4, l2), !u2.east) e: for (let t4 = s4 - 1; t4 >= 0 + m + 1; t4--) {
        for (let r5 = l2 - 1; r5 >= 0 + f2; r5--) {
          if (colorDiff(c3, intToRGBA$1(e5.getPixelColor(t4, r5))) > i2) break e;
        }
        d++;
      }
      let _2 = false;
      if (m -= a2, d -= a2, f2 -= a2, p2 -= a2, n3) {
        const e6 = Math.min(d, m), t4 = Math.min(f2, p2);
        m = e6, d = e6, f2 = t4, p2 = t4;
      }
      m = m >= 0 ? m : 0, d = d >= 0 ? d : 0, f2 = f2 >= 0 ? f2 : 0, p2 = p2 >= 0 ? p2 : 0;
      const g = s4 - (m + d), b2 = l2 - (p2 + f2);
      return _2 = r4 ? 0 !== d && 0 !== f2 && 0 !== m && 0 !== p2 : 0 !== d || 0 !== f2 || 0 !== m || 0 !== p2, _2 && this.crop(e5, { x: m, y: f2, w: g, h: b2 }), e5;
    } };
    CoverOptionsSchema = z.object({ w: z.number(), h: z.number(), align: z.number().optional(), mode: z.nativeEnum(ResizeStrategy).optional() });
    methods$a = { cover(e5, t3) {
      const { w: i2, h: r4, align: n3 = HorizontalAlign.CENTER | VerticalAlign.MIDDLE, mode: a2 } = CoverOptionsSchema.parse(t3), o3 = 7 & n3, s4 = n3 >> 3;
      if ((0 === o3 || o3 & o3 - 1) && (0 === s4 || s4 & s4 - 1)) throw new Error("only use one flag per alignment direction");
      const l2 = o3 >> 1, u2 = s4 >> 1, h2 = i2 / r4 > e5.bitmap.width / e5.bitmap.height ? i2 / e5.bitmap.width : r4 / e5.bitmap.height;
      return e5 = methods$d.scale(e5, { f: h2, mode: a2 }), e5 = methods$b.crop(e5, { x: (e5.bitmap.width - i2) / 2 * l2, y: (e5.bitmap.height - r4) / 2 * u2, w: i2, h: r4 });
    } };
    DisplaceOptionsSchema = z.object({ map: JimpClassSchema, offset: z.number() });
    methods$9 = { displace(e5, t3) {
      const { map: i2, offset: r4 } = DisplaceOptionsSchema.parse(t3), n3 = clone(e5);
      return e5.scan((t4, a2, o3) => {
        let s4 = i2.bitmap.data[o3] / 256 * r4;
        s4 = Math.round(s4);
        const l2 = e5.getPixelIndex(t4 + s4, a2);
        e5.bitmap.data[l2] = n3.bitmap.data[o3], e5.bitmap.data[l2 + 1] = n3.bitmap.data[o3 + 1], e5.bitmap.data[l2 + 2] = n3.bitmap.data[o3 + 2];
      }), e5;
    } };
    methods$8 = { dither(e5) {
      const t3 = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
      return e5.scan((i2, r4, n3) => {
        const a2 = t3[((3 & r4) << 2) + i2 % 4];
        e5.bitmap.data[n3] = Math.min(e5.bitmap.data[n3] + a2, 255), e5.bitmap.data[n3 + 1] = Math.min(e5.bitmap.data[n3 + 1] + a2, 255), e5.bitmap.data[n3 + 2] = Math.min(e5.bitmap.data[n3 + 2] + a2, 255);
      }), e5;
    } };
    FisheyeOptionsSchema = z.object({ radius: z.number().min(0).optional() });
    methods$7 = { fisheye(e5, t3 = {}) {
      const { radius: i2 = 2.5 } = FisheyeOptionsSchema.parse(t3), r4 = clone(e5), { width: n3, height: a2 } = r4.bitmap;
      return r4.scan((t4, o3) => {
        const s4 = t4 / n3, l2 = o3 / a2, u2 = Math.sqrt(Math.pow(s4 - 0.5, 2) + Math.pow(l2 - 0.5, 2)), h2 = 2 * Math.pow(u2, i2), c3 = (s4 - 0.5) / u2, f2 = (l2 - 0.5) / u2, d = Math.round((h2 * c3 + 0.5) * n3), p2 = Math.round((h2 * f2 + 0.5) * a2), m = r4.getPixelColor(d, p2);
        e5.setPixelColor(m, t4, o3);
      }), e5.setPixelColor(r4.getPixelColor(n3 / 2, a2 / 2), n3 / 2, a2 / 2), e5;
    } };
    FlipOptionsSchema = z.object({ horizontal: z.boolean().optional(), vertical: z.boolean().optional() });
    methods$6 = { flip(e5, t3) {
      const { horizontal: i2, vertical: r4 } = FlipOptionsSchema.parse(t3), n3 = Buffer2.alloc(e5.bitmap.data.length);
      return e5.scan((t4, a2, o3) => {
        const s4 = i2 ? e5.bitmap.width - 1 - t4 : t4, l2 = r4 ? e5.bitmap.height - 1 - a2 : a2, u2 = e5.bitmap.width * l2 + s4 << 2, h2 = e5.bitmap.data.readUInt32BE(o3);
        n3.writeUInt32BE(h2, u2);
      }), e5.bitmap.data = Buffer2.from(n3), e5;
    } };
    __name(Converter$1, "Converter$1");
    Converter$1.prototype.convert = function(e5) {
      var t3, i2, r4, n3 = {}, a2 = this.srcAlphabet.length, o3 = this.dstAlphabet.length, s4 = e5.length, l2 = "string" == typeof e5 ? "" : [];
      if (!this.isValid(e5)) throw new Error('Number "' + e5 + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
      if (this.srcAlphabet === this.dstAlphabet) return e5;
      for (t3 = 0; t3 < s4; t3++) n3[t3] = this.srcAlphabet.indexOf(e5[t3]);
      do {
        for (i2 = 0, r4 = 0, t3 = 0; t3 < s4; t3++) (i2 = i2 * a2 + n3[t3]) >= o3 ? (n3[r4++] = parseInt(i2 / o3, 10), i2 %= o3) : r4 > 0 && (n3[r4++] = 0);
        s4 = r4, l2 = this.dstAlphabet.slice(i2, i2 + 1).concat(l2);
      } while (0 !== r4);
      return l2;
    }, Converter$1.prototype.isValid = function(e5) {
      for (var t3 = 0; t3 < e5.length; ++t3) if (-1 === this.srcAlphabet.indexOf(e5[t3])) return false;
      return true;
    };
    converter = Converter$1;
    Converter = converter;
    __name(anyBase, "anyBase");
    anyBase.BIN = "01", anyBase.OCT = "01234567", anyBase.DEC = "0123456789", anyBase.HEX = "0123456789abcdef";
    anyBase_1 = anyBase;
    anyBase$1 = getDefaultExportFromCjs(anyBase_1);
    __defProp$1 = Object.defineProperty;
    __defNormalProp$1 = /* @__PURE__ */ __name((e5, t3, i2) => t3 in e5 ? __defProp$1(e5, t3, { enumerable: true, configurable: true, writable: true, value: i2 }) : e5[t3] = i2, "__defNormalProp$1");
    __publicField$1 = /* @__PURE__ */ __name((e5, t3, i2) => __defNormalProp$1(e5, "symbol" != typeof t3 ? t3 + "" : t3, i2), "__publicField$1");
    ImagePHash = class {
      static {
        __name(this, "ImagePHash");
      }
      constructor(e5, t3) {
        __publicField$1(this, "size"), __publicField$1(this, "smallerSize"), this.size = e5 || 32, this.smallerSize = t3 || 8, initCoefficients(this.size);
      }
      distance(e5, t3) {
        let i2 = 0;
        for (let r4 = 0; r4 < e5.length; r4++) e5[r4] !== t3[r4] && i2++;
        return i2 / e5.length;
      }
      getHash(e5) {
        e5 = methods$d.resize(clone(e5), { w: this.size, h: this.size }), e5 = methods$e.greyscale(e5);
        const t3 = [];
        for (let i3 = 0; i3 < e5.bitmap.width; i3++) {
          const r5 = [];
          for (let t4 = 0; t4 < e5.bitmap.height; t4++) r5[t4] = intToRGBA(e5.getPixelColor(i3, t4)).b;
          t3[i3] = r5;
        }
        const i2 = applyDCT(t3, this.size);
        let r4 = 0;
        for (let e6 = 0; e6 < this.smallerSize; e6++) for (let t4 = 0; t4 < this.smallerSize; t4++) r4 += i2[e6][t4];
        const n3 = r4 / (this.smallerSize * this.smallerSize);
        let a2 = "";
        for (let e6 = 0; e6 < this.smallerSize; e6++) for (let t4 = 0; t4 < this.smallerSize; t4++) a2 += i2[e6][t4] > n3 ? "1" : "0";
        return a2;
      }
    };
    __name(intToRGBA, "intToRGBA");
    c$1 = [];
    __name(initCoefficients, "initCoefficients");
    __name(applyDCT, "applyDCT");
    alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
    maxHashLength = [NaN, NaN];
    for (let e5 = 2; e5 < 65; e5++) {
      const t3 = anyBase$1(anyBase$1.BIN, alphabet.slice(0, e5))(new Array(65).join("1"));
      maxHashLength.push(t3.length);
    }
    methods$5 = { pHash: /* @__PURE__ */ __name((e5) => new ImagePHash().getHash(e5), "pHash"), hash(e5, t3 = 64) {
      if (t3 < 2 || t3 > 64) throw new Error("base must be a number between 2 and 64");
      const i2 = alphabet.slice(0, t3), r4 = this.pHash(e5), n3 = maxHashLength[t3];
      return anyBase$1(anyBase$1.BIN, i2)(r4).padStart(n3, "0");
    }, distanceFromHash(e5, t3) {
      const i2 = new ImagePHash(), r4 = i2.getHash(e5);
      return i2.distance(r4, t3);
    } };
    __name(distance, "distance");
    __name(compareHashes, "compareHashes");
    MaskOptionsObjectSchema = z.object({ src: JimpClassSchema, x: z.number().optional(), y: z.number().optional() });
    MaskOptionsSchema = z.union([JimpClassSchema, MaskOptionsObjectSchema]);
    methods$4 = { mask(e5, t3) {
      let i2, r4, n3;
      MaskOptionsSchema.parse(t3), "bitmap" in t3 ? (i2 = t3, r4 = 0, n3 = 0) : (i2 = t3.src, r4 = t3.x ?? 0, n3 = t3.y ?? 0), r4 = Math.round(r4), n3 = Math.round(n3);
      const a2 = e5.bitmap.width, o3 = e5.bitmap.height;
      return i2.scan(function(t4, s4, l2) {
        const u2 = r4 + t4, h2 = n3 + s4;
        if (u2 >= 0 && h2 >= 0 && u2 < a2 && h2 < o3) {
          const t5 = e5.getPixelIndex(u2, h2), { data: r5 } = i2.bitmap, n4 = (r5[l2 + 0] + r5[l2 + 1] + r5[l2 + 2]) / 3;
          e5.bitmap.data[t5 + 3] *= n4 / 255;
        }
      }), e5;
    } };
    __name(measureText, "measureText");
    __name(splitLines, "splitLines");
    __name(measureTextHeight, "measureTextHeight");
    PrintOptionsSchema = z.object({ x: z.number(), y: z.number(), text: z.union([z.union([z.string(), z.number()]), z.object({ text: z.union([z.string(), z.number()]), alignmentX: z.nativeEnum(HorizontalAlign).optional(), alignmentY: z.nativeEnum(VerticalAlign).optional() })]), maxWidth: z.number().optional(), maxHeight: z.number().optional(), cb: z.function(z.tuple([z.object({ x: z.number(), y: z.number() })])).optional() });
    __name(xOffsetBasedOnAlignment, "xOffsetBasedOnAlignment");
    __name(drawCharacter, "drawCharacter");
    __name(printText, "printText");
    methods$3 = { print(e5, { font: t3, ...i2 }) {
      let r4, n3, { x: a2, y: o3, text: s4, maxWidth: l2 = 1 / 0, maxHeight: u2 = 1 / 0, cb: h2 = /* @__PURE__ */ __name(() => {
      }, "h") } = PrintOptionsSchema.parse(i2);
      "object" == typeof s4 && null !== s4.text && void 0 !== s4.text ? (r4 = s4.alignmentX || HorizontalAlign.LEFT, n3 = s4.alignmentY || VerticalAlign.TOP, { text: s4 } = s4) : (r4 = HorizontalAlign.LEFT, n3 = VerticalAlign.TOP, s4 = s4.toString()), "number" == typeof s4 && (s4 = s4.toString()), u2 !== 1 / 0 && n3 === VerticalAlign.BOTTOM ? o3 += u2 - measureTextHeight(t3, s4, l2) : u2 !== 1 / 0 && n3 === VerticalAlign.MIDDLE && (o3 += u2 / 2 - measureTextHeight(t3, s4, l2) / 2);
      const c3 = Object.entries(t3.chars).find((e6) => e6[1].xadvance)?.[1].xadvance;
      if ("number" != typeof c3) throw new Error("Could not find default character width");
      const { lines: f2, longestLine: d } = splitLines(t3, s4, l2);
      return f2.forEach((i3) => {
        const n4 = i3.join(" "), s5 = xOffsetBasedOnAlignment(t3, n4, l2, r4);
        printText(e5, t3, a2 + s5, o3, n4, c3), o3 += t3.common.lineHeight;
      }), h2.bind(e5)({ x: a2 + d, y: o3 }), e5;
    } };
    RotateOptionsSchema = z.union([z.number(), z.object({ deg: z.number(), mode: z.union([z.boolean(), z.nativeEnum(ResizeStrategy)]).optional() })]);
    __name(createIdxTranslationFunction, "createIdxTranslationFunction");
    __name(matrixRotate, "matrixRotate");
    __name(createTranslationFunction, "createTranslationFunction");
    __name(advancedRotate, "advancedRotate");
    methods$2 = { rotate(e5, t3) {
      const i2 = RotateOptionsSchema.parse(t3), r4 = "number" == typeof i2 ? { deg: i2 } : i2, { mode: n3 = true } = r4;
      let { deg: a2 } = r4;
      if (a2 %= 360, a2 % 360 == 0) return e5;
      return a2 % 90 == 0 && (n3 || e5.bitmap.width === e5.bitmap.height || a2 % 180 == 0) ? matrixRotate(e5, a2) : advancedRotate(e5, a2, n3), e5;
    } };
    ThresholdOptionsSchema = z.object({ max: z.number().min(0).max(255), replace: z.number().min(0).max(255).optional(), autoGreyscale: z.boolean().optional() });
    methods$1 = { threshold(e5, t3) {
      let { max: i2, replace: r4 = 255, autoGreyscale: n3 = true } = ThresholdOptionsSchema.parse(t3);
      return i2 = limit255(i2), r4 = limit255(r4), n3 && methods$e.greyscale(e5), e5.scan((t4, n4, a2) => {
        const o3 = e5.bitmap.data[a2] < i2 ? e5.bitmap.data[a2] : r4;
        e5.bitmap.data[a2] = o3, e5.bitmap.data[a2 + 1] = o3, e5.bitmap.data[a2 + 2] = o3;
      }), e5;
    } };
    __defProp2 = Object.defineProperty;
    __defNormalProp = /* @__PURE__ */ __name((e5, t3, i2) => t3 in e5 ? __defProp2(e5, t3, { enumerable: true, configurable: true, writable: true, value: i2 }) : e5[t3] = i2, "__defNormalProp");
    __export2 = /* @__PURE__ */ __name((e5, t3) => {
      for (var i2 in t3) __defProp2(e5, i2, { get: t3[i2], enumerable: true });
    }, "__export");
    __publicField = /* @__PURE__ */ __name((e5, t3, i2) => (__defNormalProp(e5, "symbol" != typeof t3 ? t3 + "" : t3, i2), i2), "__publicField");
    constants_exports = {};
    __export2(constants_exports, { bt709: /* @__PURE__ */ __name(() => bt709_exports, "bt709") });
    bt709_exports = {};
    __export2(bt709_exports, { Y: /* @__PURE__ */ __name(() => Y, "Y"), x: /* @__PURE__ */ __name(() => x$1, "x"), y: /* @__PURE__ */ __name(() => y$1, "y") });
    Y = ((e5) => (e5[e5.RED = 0.2126] = "RED", e5[e5.GREEN = 0.7152] = "GREEN", e5[e5.BLUE = 0.0722] = "BLUE", e5[e5.WHITE = 1] = "WHITE", e5))(Y || {});
    x$1 = ((e5) => (e5[e5.RED = 0.64] = "RED", e5[e5.GREEN = 0.3] = "GREEN", e5[e5.BLUE = 0.15] = "BLUE", e5[e5.WHITE = 0.3127] = "WHITE", e5))(x$1 || {});
    y$1 = ((e5) => (e5[e5.RED = 0.33] = "RED", e5[e5.GREEN = 0.6] = "GREEN", e5[e5.BLUE = 0.06] = "BLUE", e5[e5.WHITE = 0.329] = "WHITE", e5))(y$1 || {});
    conversion_exports = {};
    __name(correctGamma, "correctGamma");
    __name(rgb2xyz, "rgb2xyz");
    __export2(conversion_exports, { lab2rgb: /* @__PURE__ */ __name(() => lab2rgb, "lab2rgb"), lab2xyz: /* @__PURE__ */ __name(() => lab2xyz, "lab2xyz"), rgb2hsl: /* @__PURE__ */ __name(() => rgb2hsl, "rgb2hsl"), rgb2lab: /* @__PURE__ */ __name(() => rgb2lab, "rgb2lab"), rgb2xyz: /* @__PURE__ */ __name(() => rgb2xyz, "rgb2xyz"), xyz2lab: /* @__PURE__ */ __name(() => xyz2lab, "xyz2lab"), xyz2rgb: /* @__PURE__ */ __name(() => xyz2rgb, "xyz2rgb") });
    arithmetic_exports = {};
    __name(degrees2radians, "degrees2radians");
    __name(max3, "max3");
    __name(min3, "min3");
    __name(intInRange, "intInRange");
    __name(inRange0to255Rounded, "inRange0to255Rounded");
    __name(inRange0to255, "inRange0to255");
    __name(stableSort, "stableSort");
    __name(rgb2hsl, "rgb2hsl");
    __export2(arithmetic_exports, { degrees2radians: /* @__PURE__ */ __name(() => degrees2radians, "degrees2radians"), inRange0to255: /* @__PURE__ */ __name(() => inRange0to255, "inRange0to255"), inRange0to255Rounded: /* @__PURE__ */ __name(() => inRange0to255Rounded, "inRange0to255Rounded"), intInRange: /* @__PURE__ */ __name(() => intInRange, "intInRange"), max3: /* @__PURE__ */ __name(() => max3, "max3"), min3: /* @__PURE__ */ __name(() => min3, "min3"), stableSort: /* @__PURE__ */ __name(() => stableSort, "stableSort") });
    refX = 0.95047;
    refY = 1;
    refZ = 1.08883;
    __name(pivot, "pivot");
    __name(xyz2lab, "xyz2lab");
    __name(rgb2lab, "rgb2lab");
    refX2 = 0.95047;
    refY2 = 1;
    refZ2 = 1.08883;
    __name(pivot2, "pivot2");
    __name(lab2xyz, "lab2xyz");
    __name(correctGamma2, "correctGamma2");
    __name(xyz2rgb, "xyz2rgb");
    __name(lab2rgb, "lab2rgb");
    distance_exports = {};
    __export2(distance_exports, { AbstractDistanceCalculator: /* @__PURE__ */ __name(() => AbstractDistanceCalculator, "AbstractDistanceCalculator"), AbstractEuclidean: /* @__PURE__ */ __name(() => AbstractEuclidean, "AbstractEuclidean"), AbstractManhattan: /* @__PURE__ */ __name(() => AbstractManhattan, "AbstractManhattan"), CIE94GraphicArts: /* @__PURE__ */ __name(() => CIE94GraphicArts, "CIE94GraphicArts"), CIE94Textiles: /* @__PURE__ */ __name(() => CIE94Textiles, "CIE94Textiles"), CIEDE2000: /* @__PURE__ */ __name(() => CIEDE2000, "CIEDE2000"), CMetric: /* @__PURE__ */ __name(() => CMetric, "CMetric"), Euclidean: /* @__PURE__ */ __name(() => Euclidean, "Euclidean"), EuclideanBT709: /* @__PURE__ */ __name(() => EuclideanBT709, "EuclideanBT709"), EuclideanBT709NoAlpha: /* @__PURE__ */ __name(() => EuclideanBT709NoAlpha, "EuclideanBT709NoAlpha"), Manhattan: /* @__PURE__ */ __name(() => Manhattan, "Manhattan"), ManhattanBT709: /* @__PURE__ */ __name(() => ManhattanBT709, "ManhattanBT709"), ManhattanNommyde: /* @__PURE__ */ __name(() => ManhattanNommyde, "ManhattanNommyde"), PNGQuant: /* @__PURE__ */ __name(() => PNGQuant, "PNGQuant") });
    AbstractDistanceCalculator = class {
      static {
        __name(this, "AbstractDistanceCalculator");
      }
      constructor() {
        __publicField(this, "_maxDistance"), __publicField(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
      }
      setWhitePoint(e5, t3, i2, r4) {
        this._whitePoint = { r: e5 > 0 ? 255 / e5 : 0, g: t3 > 0 ? 255 / t3 : 0, b: i2 > 0 ? 255 / i2 : 0, a: r4 > 0 ? 255 / r4 : 0 }, this._maxDistance = this.calculateRaw(e5, t3, i2, r4, 0, 0, 0, 0);
      }
      calculateNormalized(e5, t3) {
        return this.calculateRaw(e5.r, e5.g, e5.b, e5.a, t3.r, t3.g, t3.b, t3.a) / this._maxDistance;
      }
    };
    AbstractCIE94 = class extends AbstractDistanceCalculator {
      static {
        __name(this, "AbstractCIE94");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = rgb2lab(inRange0to255(e5 * this._whitePoint.r), inRange0to255(t3 * this._whitePoint.g), inRange0to255(i2 * this._whitePoint.b)), u2 = rgb2lab(inRange0to255(n3 * this._whitePoint.r), inRange0to255(a2 * this._whitePoint.g), inRange0to255(o3 * this._whitePoint.b)), h2 = l2.L - u2.L, c3 = l2.a - u2.a, f2 = l2.b - u2.b, d = Math.sqrt(l2.a * l2.a + l2.b * l2.b), p2 = d - Math.sqrt(u2.a * u2.a + u2.b * u2.b);
        let m = c3 * c3 + f2 * f2 - p2 * p2;
        m = m < 0 ? 0 : Math.sqrt(m);
        const _2 = (s4 - r4) * this._whitePoint.a * this._kA;
        return Math.sqrt((h2 / this._Kl) ** 2 + (p2 / (1 + this._K1 * d)) ** 2 + (m / (1 + this._K2 * d)) ** 2 + _2 ** 2);
      }
    };
    CIE94Textiles = class extends AbstractCIE94 {
      static {
        __name(this, "CIE94Textiles");
      }
      _setDefaults() {
        this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
      }
    };
    CIE94GraphicArts = class extends AbstractCIE94 {
      static {
        __name(this, "CIE94GraphicArts");
      }
      _setDefaults() {
        this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
      }
    };
    _CIEDE2000 = class extends AbstractDistanceCalculator {
      static {
        __name(this, "_CIEDE2000");
      }
      _setDefaults() {
      }
      static _calculatehp(e5, t3) {
        const i2 = Math.atan2(e5, t3);
        return i2 >= 0 ? i2 : i2 + _CIEDE2000._deg360InRad;
      }
      static _calculateRT(e5, t3) {
        const i2 = t3 ** 7, r4 = 2 * Math.sqrt(i2 / (i2 + _CIEDE2000._pow25to7)), n3 = _CIEDE2000._deg30InRad * Math.exp(-(((e5 - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
        return -Math.sin(2 * n3) * r4;
      }
      static _calculateT(e5) {
        return 1 - 0.17 * Math.cos(e5 - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(2 * e5) + 0.32 * Math.cos(3 * e5 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(4 * e5 - _CIEDE2000._deg63InRad);
      }
      static _calculate_ahp(e5, t3, i2, r4) {
        const n3 = i2 + r4;
        return 0 === e5 ? n3 : t3 <= _CIEDE2000._deg180InRad ? n3 / 2 : n3 < _CIEDE2000._deg360InRad ? (n3 + _CIEDE2000._deg360InRad) / 2 : (n3 - _CIEDE2000._deg360InRad) / 2;
      }
      static _calculate_dHp(e5, t3, i2, r4) {
        let n3;
        return n3 = 0 === e5 ? 0 : t3 <= _CIEDE2000._deg180InRad ? i2 - r4 : i2 <= r4 ? i2 - r4 + _CIEDE2000._deg360InRad : i2 - r4 - _CIEDE2000._deg360InRad, 2 * Math.sqrt(e5) * Math.sin(n3 / 2);
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = rgb2lab(inRange0to255(e5 * this._whitePoint.r), inRange0to255(t3 * this._whitePoint.g), inRange0to255(i2 * this._whitePoint.b)), u2 = rgb2lab(inRange0to255(n3 * this._whitePoint.r), inRange0to255(a2 * this._whitePoint.g), inRange0to255(o3 * this._whitePoint.b)), h2 = (s4 - r4) * this._whitePoint.a * _CIEDE2000._kA, c3 = this.calculateRawInLab(l2, u2);
        return Math.sqrt(c3 + h2 * h2);
      }
      calculateRawInLab(e5, t3) {
        const i2 = e5.L, r4 = e5.a, n3 = e5.b, a2 = t3.L, o3 = t3.a, s4 = t3.b, l2 = ((Math.sqrt(r4 * r4 + n3 * n3) + Math.sqrt(o3 * o3 + s4 * s4)) / 2) ** 7, u2 = 0.5 * (1 - Math.sqrt(l2 / (l2 + _CIEDE2000._pow25to7))), h2 = (1 + u2) * r4, c3 = (1 + u2) * o3, f2 = Math.sqrt(h2 * h2 + n3 * n3), d = Math.sqrt(c3 * c3 + s4 * s4), p2 = f2 * d, m = _CIEDE2000._calculatehp(n3, h2), _2 = _CIEDE2000._calculatehp(s4, c3), g = Math.abs(m - _2), b2 = a2 - i2, y2 = d - f2, w = _CIEDE2000._calculate_dHp(p2, g, _2, m), v2 = _CIEDE2000._calculate_ahp(p2, g, m, _2), x2 = (f2 + d) / 2, E2 = ((i2 + a2) / 2 - 50) ** 2, k2 = y2 / (1 + 0.045 * x2), S2 = w / (1 + 0.015 * _CIEDE2000._calculateT(v2) * x2);
        return (b2 / (1 + 0.015 * E2 / Math.sqrt(20 + E2))) ** 2 + k2 ** 2 + S2 ** 2 + _CIEDE2000._calculateRT(v2, x2) * k2 * S2;
      }
    };
    CIEDE2000 = _CIEDE2000;
    __publicField(CIEDE2000, "_kA", 25 / 255), __publicField(CIEDE2000, "_pow25to7", 25 ** 7), __publicField(CIEDE2000, "_deg360InRad", degrees2radians(360)), __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180)), __publicField(CIEDE2000, "_deg30InRad", degrees2radians(30)), __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6)), __publicField(CIEDE2000, "_deg63InRad", degrees2radians(63)), __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275)), __publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));
    CMetric = class extends AbstractDistanceCalculator {
      static {
        __name(this, "CMetric");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = (e5 + n3) / 2 * this._whitePoint.r, u2 = (e5 - n3) * this._whitePoint.r, h2 = (t3 - a2) * this._whitePoint.g, c3 = (i2 - o3) * this._whitePoint.b, f2 = ((512 + l2) * u2 * u2 >> 8) + 4 * h2 * h2 + ((767 - l2) * c3 * c3 >> 8), d = (s4 - r4) * this._whitePoint.a;
        return Math.sqrt(f2 + d * d);
      }
      _setDefaults() {
      }
    };
    AbstractEuclidean = class extends AbstractDistanceCalculator {
      static {
        __name(this, "AbstractEuclidean");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = n3 - e5, u2 = a2 - t3, h2 = o3 - i2, c3 = s4 - r4;
        return Math.sqrt(this._kR * l2 * l2 + this._kG * u2 * u2 + this._kB * h2 * h2 + this._kA * c3 * c3);
      }
    };
    Euclidean = class extends AbstractEuclidean {
      static {
        __name(this, "Euclidean");
      }
      _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
      }
    };
    EuclideanBT709 = class extends AbstractEuclidean {
      static {
        __name(this, "EuclideanBT709");
      }
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
      }
    };
    EuclideanBT709NoAlpha = class extends AbstractEuclidean {
      static {
        __name(this, "EuclideanBT709NoAlpha");
      }
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
      }
    };
    AbstractManhattan = class extends AbstractDistanceCalculator {
      static {
        __name(this, "AbstractManhattan");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        let l2 = n3 - e5, u2 = a2 - t3, h2 = o3 - i2, c3 = s4 - r4;
        return l2 < 0 && (l2 = 0 - l2), u2 < 0 && (u2 = 0 - u2), h2 < 0 && (h2 = 0 - h2), c3 < 0 && (c3 = 0 - c3), this._kR * l2 + this._kG * u2 + this._kB * h2 + this._kA * c3;
      }
    };
    Manhattan = class extends AbstractManhattan {
      static {
        __name(this, "Manhattan");
      }
      _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
      }
    };
    ManhattanNommyde = class extends AbstractManhattan {
      static {
        __name(this, "ManhattanNommyde");
      }
      _setDefaults() {
        this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
      }
    };
    ManhattanBT709 = class extends AbstractManhattan {
      static {
        __name(this, "ManhattanBT709");
      }
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
      }
    };
    PNGQuant = class extends AbstractDistanceCalculator {
      static {
        __name(this, "PNGQuant");
      }
      calculateRaw(e5, t3, i2, r4, n3, a2, o3, s4) {
        const l2 = (s4 - r4) * this._whitePoint.a;
        return this._colordifferenceCh(e5 * this._whitePoint.r, n3 * this._whitePoint.r, l2) + this._colordifferenceCh(t3 * this._whitePoint.g, a2 * this._whitePoint.g, l2) + this._colordifferenceCh(i2 * this._whitePoint.b, o3 * this._whitePoint.b, l2);
      }
      _colordifferenceCh(e5, t3, i2) {
        const r4 = e5 - t3, n3 = r4 + i2;
        return r4 * r4 + n3 * n3;
      }
      _setDefaults() {
      }
    };
    palette_exports = {};
    __export2(palette_exports, { AbstractPaletteQuantizer: /* @__PURE__ */ __name(() => AbstractPaletteQuantizer, "AbstractPaletteQuantizer"), ColorHistogram: /* @__PURE__ */ __name(() => ColorHistogram, "ColorHistogram"), NeuQuant: /* @__PURE__ */ __name(() => NeuQuant, "NeuQuant"), NeuQuantFloat: /* @__PURE__ */ __name(() => NeuQuantFloat, "NeuQuantFloat"), RGBQuant: /* @__PURE__ */ __name(() => RGBQuant, "RGBQuant"), WuColorCube: /* @__PURE__ */ __name(() => WuColorCube, "WuColorCube"), WuQuant: /* @__PURE__ */ __name(() => WuQuant, "WuQuant") });
    AbstractPaletteQuantizer = class {
      static {
        __name(this, "AbstractPaletteQuantizer");
      }
      quantizeSync() {
        for (const e5 of this.quantize()) if (e5.palette) return e5.palette;
        throw new Error("unreachable");
      }
    };
    Point = class {
      static {
        __name(this, "Point");
      }
      constructor() {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), __publicField(this, "uint32"), __publicField(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
      }
      static createByQuadruplet(e5) {
        const t3 = new Point();
        return t3.r = 0 | e5[0], t3.g = 0 | e5[1], t3.b = 0 | e5[2], t3.a = 0 | e5[3], t3._loadUINT32(), t3._loadQuadruplet(), t3;
      }
      static createByRGBA(e5, t3, i2, r4) {
        const n3 = new Point();
        return n3.r = 0 | e5, n3.g = 0 | t3, n3.b = 0 | i2, n3.a = 0 | r4, n3._loadUINT32(), n3._loadQuadruplet(), n3;
      }
      static createByUint32(e5) {
        const t3 = new Point();
        return t3.uint32 = e5 >>> 0, t3._loadRGBA(), t3._loadQuadruplet(), t3;
      }
      from(e5) {
        this.r = e5.r, this.g = e5.g, this.b = e5.b, this.a = e5.a, this.uint32 = e5.uint32, this.rgba[0] = e5.r, this.rgba[1] = e5.g, this.rgba[2] = e5.b, this.rgba[3] = e5.a;
      }
      getLuminosity(e5) {
        let t3 = this.r, i2 = this.g, r4 = this.b;
        return e5 && (t3 = Math.min(255, 255 - this.a + this.a * t3 / 255), i2 = Math.min(255, 255 - this.a + this.a * i2 / 255), r4 = Math.min(255, 255 - this.a + this.a * r4 / 255)), 0.2126 * t3 + 0.7152 * i2 + 0.0722 * r4;
      }
      _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
      }
      _loadRGBA() {
        this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
      }
      _loadQuadruplet() {
        this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
      }
    };
    PointContainer = class {
      static {
        __name(this, "PointContainer");
      }
      constructor() {
        __publicField(this, "_pointArray"), __publicField(this, "_width"), __publicField(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
      }
      getWidth() {
        return this._width;
      }
      getHeight() {
        return this._height;
      }
      setWidth(e5) {
        this._width = e5;
      }
      setHeight(e5) {
        this._height = e5;
      }
      getPointArray() {
        return this._pointArray;
      }
      clone() {
        const e5 = new PointContainer();
        e5._width = this._width, e5._height = this._height;
        for (let t3 = 0, i2 = this._pointArray.length; t3 < i2; t3++) e5._pointArray[t3] = Point.createByUint32(0 | this._pointArray[t3].uint32);
        return e5;
      }
      toUint32Array() {
        const e5 = this._pointArray.length, t3 = new Uint32Array(e5);
        for (let i2 = 0; i2 < e5; i2++) t3[i2] = this._pointArray[i2].uint32;
        return t3;
      }
      toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
      }
      static fromHTMLImageElement(e5) {
        const t3 = e5.naturalWidth, i2 = e5.naturalHeight, r4 = document.createElement("canvas");
        r4.width = t3, r4.height = i2;
        return r4.getContext("2d").drawImage(e5, 0, 0, t3, i2, 0, 0, t3, i2), PointContainer.fromHTMLCanvasElement(r4);
      }
      static fromHTMLCanvasElement(e5) {
        const t3 = e5.width, i2 = e5.height, r4 = e5.getContext("2d").getImageData(0, 0, t3, i2);
        return PointContainer.fromImageData(r4);
      }
      static fromImageData(e5) {
        const t3 = e5.width, i2 = e5.height;
        return PointContainer.fromUint8Array(e5.data, t3, i2);
      }
      static fromUint8Array(e5, t3, i2) {
        switch (Object.prototype.toString.call(e5)) {
          case "[object Uint8ClampedArray]":
          case "[object Uint8Array]":
            break;
          default:
            e5 = new Uint8Array(e5);
        }
        const r4 = new Uint32Array(e5.buffer);
        return PointContainer.fromUint32Array(r4, t3, i2);
      }
      static fromUint32Array(e5, t3, i2) {
        const r4 = new PointContainer();
        r4._width = t3, r4._height = i2;
        for (let t4 = 0, i3 = e5.length; t4 < i3; t4++) r4._pointArray[t4] = Point.createByUint32(0 | e5[t4]);
        return r4;
      }
      static fromBuffer(e5, t3, i2) {
        const r4 = new Uint32Array(e5.buffer, e5.byteOffset, e5.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return PointContainer.fromUint32Array(r4, t3, i2);
      }
    };
    hueGroups = 10;
    __name(hueGroup, "hueGroup");
    Palette = class {
      static {
        __name(this, "Palette");
      }
      constructor() {
        __publicField(this, "_pointContainer"), __publicField(this, "_pointArray", []), __publicField(this, "_i32idx", {}), this._pointContainer = new PointContainer(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
      }
      add(e5) {
        this._pointArray.push(e5), this._pointContainer.setWidth(this._pointArray.length);
      }
      has(e5) {
        for (let t3 = this._pointArray.length - 1; t3 >= 0; t3--) if (e5.uint32 === this._pointArray[t3].uint32) return true;
        return false;
      }
      getNearestColor(e5, t3) {
        return this._pointArray[0 | this._getNearestIndex(e5, t3)];
      }
      getPointContainer() {
        return this._pointContainer;
      }
      _nearestPointFromCache(e5) {
        return "number" == typeof this._i32idx[e5] ? this._i32idx[e5] : -1;
      }
      _getNearestIndex(e5, t3) {
        let i2 = this._nearestPointFromCache("" + t3.uint32);
        if (i2 >= 0) return i2;
        let r4 = Number.MAX_VALUE;
        i2 = 0;
        for (let n3 = 0, a2 = this._pointArray.length; n3 < a2; n3++) {
          const a3 = this._pointArray[n3], o3 = e5.calculateRaw(t3.r, t3.g, t3.b, t3.a, a3.r, a3.g, a3.b, a3.a);
          o3 < r4 && (r4 = o3, i2 = n3);
        }
        return this._i32idx[t3.uint32] = i2, i2;
      }
      sort() {
        this._i32idx = {}, this._pointArray.sort((e5, t3) => {
          const i2 = rgb2hsl(e5.r, e5.g, e5.b), r4 = rgb2hsl(t3.r, t3.g, t3.b), n3 = e5.r === e5.g && e5.g === e5.b ? 0 : 1 + hueGroup(i2.h, hueGroups), a2 = (t3.r === t3.g && t3.g === t3.b ? 0 : 1 + hueGroup(r4.h, hueGroups)) - n3;
          if (a2) return -a2;
          const o3 = e5.getLuminosity(true), s4 = t3.getLuminosity(true);
          if (s4 - o3 != 0) return s4 - o3;
          const l2 = (100 * r4.s | 0) - (100 * i2.s | 0);
          return l2 ? -l2 : 0;
        });
      }
    };
    utils_exports = {};
    __export2(utils_exports, { HueStatistics: /* @__PURE__ */ __name(() => HueStatistics, "HueStatistics"), Palette: /* @__PURE__ */ __name(() => Palette, "Palette"), Point: /* @__PURE__ */ __name(() => Point, "Point"), PointContainer: /* @__PURE__ */ __name(() => PointContainer, "PointContainer"), ProgressTracker: /* @__PURE__ */ __name(() => ProgressTracker, "ProgressTracker"), arithmetic: /* @__PURE__ */ __name(() => arithmetic_exports, "arithmetic") });
    HueGroup = class {
      static {
        __name(this, "HueGroup");
      }
      constructor() {
        __publicField(this, "num", 0), __publicField(this, "cols", []);
      }
    };
    HueStatistics = class {
      static {
        __name(this, "HueStatistics");
      }
      constructor(e5, t3) {
        __publicField(this, "_numGroups"), __publicField(this, "_minCols"), __publicField(this, "_stats"), __publicField(this, "_groupsFull"), this._numGroups = e5, this._minCols = t3, this._stats = [];
        for (let t4 = 0; t4 <= e5; t4++) this._stats[t4] = new HueGroup();
        this._groupsFull = 0;
      }
      check(e5) {
        this._groupsFull === this._numGroups + 1 && (this.check = () => {
        });
        const t3 = 255 & e5, i2 = e5 >>> 8 & 255, r4 = e5 >>> 16 & 255, n3 = t3 === i2 && i2 === r4 ? 0 : 1 + hueGroup(rgb2hsl(t3, i2, r4).h, this._numGroups), a2 = this._stats[n3], o3 = this._minCols;
        a2.num++, a2.num > o3 || (a2.num === o3 && this._groupsFull++, a2.num <= o3 && this._stats[n3].cols.push(e5));
      }
      injectIntoDictionary(e5) {
        for (let t3 = 0; t3 <= this._numGroups; t3++) this._stats[t3].num <= this._minCols && this._stats[t3].cols.forEach((t4) => {
          e5[t4] ? e5[t4]++ : e5[t4] = 1;
        });
      }
      injectIntoArray(e5) {
        for (let t3 = 0; t3 <= this._numGroups; t3++) this._stats[t3].num <= this._minCols && this._stats[t3].cols.forEach((t4) => {
          -1 === e5.indexOf(t4) && e5.push(t4);
        });
      }
    };
    _ProgressTracker = class {
      static {
        __name(this, "_ProgressTracker");
      }
      constructor(e5, t3) {
        __publicField(this, "progress"), __publicField(this, "_step"), __publicField(this, "_range"), __publicField(this, "_last"), __publicField(this, "_progressRange"), this._range = e5, this._progressRange = t3, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), this._last = -this._step, this.progress = 0;
      }
      shouldNotify(e5) {
        return e5 - this._last >= this._step && (this._last = e5, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), true);
      }
    };
    ProgressTracker = _ProgressTracker;
    __publicField(ProgressTracker, "steps", 100);
    networkBiasShift = 3;
    Neuron = class {
      static {
        __name(this, "Neuron");
      }
      constructor(e5) {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = e5;
      }
      toPoint() {
        return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
      }
      subtract(e5, t3, i2, r4) {
        this.r -= 0 | e5, this.g -= 0 | t3, this.b -= 0 | i2, this.a -= 0 | r4;
      }
    };
    _NeuQuant = class extends AbstractPaletteQuantizer {
      static {
        __name(this, "_NeuQuant");
      }
      constructor(e5, t3 = 256) {
        super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = e5, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t3, this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
      }
      sample(e5) {
        this._pointArray = this._pointArray.concat(e5.getPointArray());
      }
      *quantize() {
        this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
      }
      _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let e5 = 0; e5 < this._networkSize; e5++) this._network[e5] = new Neuron((e5 << networkBiasShift + 8) / this._networkSize | 0), this._freq[e5] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[e5] = 0;
      }
      *_learn() {
        let e5 = this._sampleFactor;
        const t3 = this._pointArray.length;
        t3 < _NeuQuant._minpicturebytes && (e5 = 1);
        const i2 = 30 + (e5 - 1) / 3 | 0, r4 = t3 / e5 | 0;
        let n3, a2 = r4 / _NeuQuant._nCycles | 0, o3 = _NeuQuant._initAlpha, s4 = (this._networkSize >> 3) * _NeuQuant._radiusBias, l2 = s4 >> _NeuQuant._radiusBiasShift;
        l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++) this._radPower[e6] = o3 * ((l2 * l2 - e6 * e6) * _NeuQuant._radBias / (l2 * l2)) >>> 0;
        n3 = t3 < _NeuQuant._minpicturebytes ? 1 : t3 % _NeuQuant._prime1 != 0 ? _NeuQuant._prime1 : t3 % _NeuQuant._prime2 != 0 ? _NeuQuant._prime2 : t3 % _NeuQuant._prime3 != 0 ? _NeuQuant._prime3 : _NeuQuant._prime4;
        const u2 = new ProgressTracker(r4, 99);
        for (let e6 = 0, h2 = 0; e6 < r4; ) {
          u2.shouldNotify(e6) && (yield { progress: u2.progress });
          const r5 = this._pointArray[h2], c3 = r5.b << networkBiasShift, f2 = r5.g << networkBiasShift, d = r5.r << networkBiasShift, p2 = r5.a << networkBiasShift, m = this._contest(c3, f2, d, p2);
          if (this._alterSingle(o3, m, c3, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c3, f2, d, p2), h2 += n3, h2 >= t3 && (h2 -= t3), e6++, 0 === a2 && (a2 = 1), e6 % a2 == 0) {
            o3 -= o3 / i2 | 0, s4 -= s4 / _NeuQuant._radiusDecrease | 0, l2 = s4 >> _NeuQuant._radiusBiasShift, l2 <= 1 && (l2 = 0);
            for (let e7 = 0; e7 < l2; e7++) this._radPower[e7] = o3 * ((l2 * l2 - e7 * e7) * _NeuQuant._radBias / (l2 * l2)) >>> 0;
          }
        }
      }
      _buildPalette() {
        const e5 = new Palette();
        return this._network.forEach((t3) => {
          e5.add(t3.toPoint());
        }), e5.sort(), e5;
      }
      _alterNeighbour(e5, t3, i2, r4, n3, a2) {
        let o3 = t3 - e5;
        o3 < -1 && (o3 = -1);
        let s4 = t3 + e5;
        s4 > this._networkSize && (s4 = this._networkSize);
        let l2 = t3 + 1, u2 = t3 - 1, h2 = 1;
        for (; l2 < s4 || u2 > o3; ) {
          const e6 = this._radPower[h2++] / _NeuQuant._alphaRadBias;
          if (l2 < s4) {
            const t4 = this._network[l2++];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
          if (u2 > o3) {
            const t4 = this._network[u2--];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
        }
      }
      _alterSingle(e5, t3, i2, r4, n3, a2) {
        e5 /= _NeuQuant._initAlpha;
        const o3 = this._network[t3];
        o3.subtract(e5 * (o3.r - n3), e5 * (o3.g - r4), e5 * (o3.b - i2), e5 * (o3.a - a2));
      }
      _contest(e5, t3, i2, r4) {
        const n3 = 1020 << networkBiasShift;
        let a2 = ~(1 << 31), o3 = a2, s4 = -1, l2 = s4;
        for (let u2 = 0; u2 < this._networkSize; u2++) {
          const h2 = this._network[u2], c3 = this._distance.calculateNormalized(h2, { r: i2, g: t3, b: e5, a: r4 }) * n3 | 0;
          c3 < a2 && (a2 = c3, s4 = u2);
          const f2 = c3 - (this._bias[u2] >> _NeuQuant._initialBiasShift - networkBiasShift);
          f2 < o3 && (o3 = f2, l2 = u2);
          const d = this._freq[u2] >> _NeuQuant._betaShift;
          this._freq[u2] -= d, this._bias[u2] += d << _NeuQuant._gammaShift;
        }
        return this._freq[s4] += _NeuQuant._beta, this._bias[s4] -= _NeuQuant._betaGamma, l2;
      }
    };
    NeuQuant = _NeuQuant;
    __publicField(NeuQuant, "_prime1", 499), __publicField(NeuQuant, "_prime2", 491), __publicField(NeuQuant, "_prime3", 487), __publicField(NeuQuant, "_prime4", 503), __publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4), __publicField(NeuQuant, "_nCycles", 100), __publicField(NeuQuant, "_initialBiasShift", 16), __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift), __publicField(NeuQuant, "_gammaShift", 10), __publicField(NeuQuant, "_betaShift", 10), __publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift), __publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift), __publicField(NeuQuant, "_radiusBiasShift", 6), __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift), __publicField(NeuQuant, "_radiusDecrease", 30), __publicField(NeuQuant, "_alphaBiasShift", 10), __publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift), __publicField(NeuQuant, "_radBiasShift", 8), __publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);
    networkBiasShift2 = 3;
    NeuronFloat = class {
      static {
        __name(this, "NeuronFloat");
      }
      constructor(e5) {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), this.r = this.g = this.b = this.a = e5;
      }
      toPoint() {
        return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);
      }
      subtract(e5, t3, i2, r4) {
        this.r -= e5, this.g -= t3, this.b -= i2, this.a -= r4;
      }
    };
    _NeuQuantFloat = class extends AbstractPaletteQuantizer {
      static {
        __name(this, "_NeuQuantFloat");
      }
      constructor(e5, t3 = 256) {
        super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), this._distance = e5, this._pointArray = [], this._sampleFactor = 1, this._networkSize = t3, this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);
      }
      sample(e5) {
        this._pointArray = this._pointArray.concat(e5.getPointArray());
      }
      *quantize() {
        this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
      }
      _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let e5 = 0; e5 < this._networkSize; e5++) this._network[e5] = new NeuronFloat((e5 << networkBiasShift2 + 8) / this._networkSize), this._freq[e5] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[e5] = 0;
      }
      *_learn() {
        let e5 = this._sampleFactor;
        const t3 = this._pointArray.length;
        t3 < _NeuQuantFloat._minpicturebytes && (e5 = 1);
        const i2 = 30 + (e5 - 1) / 3, r4 = t3 / e5;
        let n3, a2 = r4 / _NeuQuantFloat._nCycles | 0, o3 = _NeuQuantFloat._initAlpha, s4 = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, l2 = s4 >> _NeuQuantFloat._radiusBiasShift;
        l2 <= 1 && (l2 = 0);
        for (let e6 = 0; e6 < l2; e6++) this._radPower[e6] = o3 * ((l2 * l2 - e6 * e6) * _NeuQuantFloat._radBias / (l2 * l2));
        n3 = t3 < _NeuQuantFloat._minpicturebytes ? 1 : t3 % _NeuQuantFloat._prime1 != 0 ? _NeuQuantFloat._prime1 : t3 % _NeuQuantFloat._prime2 != 0 ? _NeuQuantFloat._prime2 : t3 % _NeuQuantFloat._prime3 != 0 ? _NeuQuantFloat._prime3 : _NeuQuantFloat._prime4;
        const u2 = new ProgressTracker(r4, 99);
        for (let e6 = 0, h2 = 0; e6 < r4; ) {
          u2.shouldNotify(e6) && (yield { progress: u2.progress });
          const r5 = this._pointArray[h2], c3 = r5.b << networkBiasShift2, f2 = r5.g << networkBiasShift2, d = r5.r << networkBiasShift2, p2 = r5.a << networkBiasShift2, m = this._contest(c3, f2, d, p2);
          if (this._alterSingle(o3, m, c3, f2, d, p2), 0 !== l2 && this._alterNeighbour(l2, m, c3, f2, d, p2), h2 += n3, h2 >= t3 && (h2 -= t3), e6++, 0 === a2 && (a2 = 1), e6 % a2 == 0) {
            o3 -= o3 / i2, s4 -= s4 / _NeuQuantFloat._radiusDecrease, l2 = s4 >> _NeuQuantFloat._radiusBiasShift, l2 <= 1 && (l2 = 0);
            for (let e7 = 0; e7 < l2; e7++) this._radPower[e7] = o3 * ((l2 * l2 - e7 * e7) * _NeuQuantFloat._radBias / (l2 * l2));
          }
        }
      }
      _buildPalette() {
        const e5 = new Palette();
        return this._network.forEach((t3) => {
          e5.add(t3.toPoint());
        }), e5.sort(), e5;
      }
      _alterNeighbour(e5, t3, i2, r4, n3, a2) {
        let o3 = t3 - e5;
        o3 < -1 && (o3 = -1);
        let s4 = t3 + e5;
        s4 > this._networkSize && (s4 = this._networkSize);
        let l2 = t3 + 1, u2 = t3 - 1, h2 = 1;
        for (; l2 < s4 || u2 > o3; ) {
          const e6 = this._radPower[h2++] / _NeuQuantFloat._alphaRadBias;
          if (l2 < s4) {
            const t4 = this._network[l2++];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
          if (u2 > o3) {
            const t4 = this._network[u2--];
            t4.subtract(e6 * (t4.r - n3), e6 * (t4.g - r4), e6 * (t4.b - i2), e6 * (t4.a - a2));
          }
        }
      }
      _alterSingle(e5, t3, i2, r4, n3, a2) {
        e5 /= _NeuQuantFloat._initAlpha;
        const o3 = this._network[t3];
        o3.subtract(e5 * (o3.r - n3), e5 * (o3.g - r4), e5 * (o3.b - i2), e5 * (o3.a - a2));
      }
      _contest(e5, t3, i2, r4) {
        const n3 = 1020 << networkBiasShift2;
        let a2 = ~(1 << 31), o3 = a2, s4 = -1, l2 = s4;
        for (let u2 = 0; u2 < this._networkSize; u2++) {
          const h2 = this._network[u2], c3 = this._distance.calculateNormalized(h2, { r: i2, g: t3, b: e5, a: r4 }) * n3;
          c3 < a2 && (a2 = c3, s4 = u2);
          const f2 = c3 - (this._bias[u2] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);
          f2 < o3 && (o3 = f2, l2 = u2);
          const d = this._freq[u2] >> _NeuQuantFloat._betaShift;
          this._freq[u2] -= d, this._bias[u2] += d << _NeuQuantFloat._gammaShift;
        }
        return this._freq[s4] += _NeuQuantFloat._beta, this._bias[s4] -= _NeuQuantFloat._betaGamma, l2;
      }
    };
    NeuQuantFloat = _NeuQuantFloat;
    __publicField(NeuQuantFloat, "_prime1", 499), __publicField(NeuQuantFloat, "_prime2", 491), __publicField(NeuQuantFloat, "_prime3", 487), __publicField(NeuQuantFloat, "_prime4", 503), __publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4), __publicField(NeuQuantFloat, "_nCycles", 100), __publicField(NeuQuantFloat, "_initialBiasShift", 16), __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift), __publicField(NeuQuantFloat, "_gammaShift", 10), __publicField(NeuQuantFloat, "_betaShift", 10), __publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift), __publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift), __publicField(NeuQuantFloat, "_radiusBiasShift", 6), __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift), __publicField(NeuQuantFloat, "_radiusDecrease", 30), __publicField(NeuQuantFloat, "_alphaBiasShift", 10), __publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift), __publicField(NeuQuantFloat, "_radBiasShift", 8), __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift), __publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift), __publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);
    _ColorHistogram = class {
      static {
        __name(this, "_ColorHistogram");
      }
      constructor(e5, t3) {
        __publicField(this, "_method"), __publicField(this, "_hueStats"), __publicField(this, "_histogram"), __publicField(this, "_initColors"), __publicField(this, "_minHueCols"), this._method = e5, this._minHueCols = t3 << 2, this._initColors = t3 << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
      }
      sample(e5) {
        switch (this._method) {
          case 1:
            this._colorStats1D(e5);
            break;
          case 2:
            this._colorStats2D(e5);
        }
      }
      getImportanceSortedColorsIDXI32() {
        const e5 = stableSort(Object.keys(this._histogram), (e6, t4) => this._histogram[t4] - this._histogram[e6]);
        if (0 === e5.length) return [];
        let t3;
        switch (this._method) {
          case 1:
            const i2 = Math.min(e5.length, this._initColors), r4 = e5[i2 - 1], n3 = this._histogram[r4];
            t3 = e5.slice(0, i2);
            let a2 = i2;
            const o3 = e5.length;
            for (; a2 < o3 && this._histogram[e5[a2]] === n3; ) t3.push(e5[a2++]);
            this._hueStats.injectIntoArray(t3);
            break;
          case 2:
            t3 = e5;
            break;
          default:
            throw new Error("Incorrect method");
        }
        return t3.map((e6) => +e6);
      }
      _colorStats1D(e5) {
        const t3 = this._histogram, i2 = e5.getPointArray(), r4 = i2.length;
        for (let e6 = 0; e6 < r4; e6++) {
          const r5 = i2[e6].uint32;
          this._hueStats.check(r5), r5 in t3 ? t3[r5]++ : t3[r5] = 1;
        }
      }
      _colorStats2D(e5) {
        const t3 = e5.getWidth(), i2 = e5.getHeight(), r4 = e5.getPointArray(), n3 = _ColorHistogram._boxSize[0], a2 = _ColorHistogram._boxSize[1], o3 = n3 * a2, s4 = this._makeBoxes(t3, i2, n3, a2), l2 = this._histogram;
        s4.forEach((e6) => {
          let i3 = Math.round(e6.w * e6.h / o3) * _ColorHistogram._boxPixels;
          i3 < 2 && (i3 = 2);
          const n4 = {};
          this._iterateBox(e6, t3, (e7) => {
            const t4 = r4[e7].uint32;
            this._hueStats.check(t4), t4 in l2 ? l2[t4]++ : t4 in n4 ? ++n4[t4] >= i3 && (l2[t4] = n4[t4]) : n4[t4] = 1;
          });
        }), this._hueStats.injectIntoDictionary(l2);
      }
      _iterateBox(e5, t3, i2) {
        const r4 = e5, n3 = r4.y * t3 + r4.x, a2 = (r4.y + r4.h - 1) * t3 + (r4.x + r4.w - 1), o3 = t3 - r4.w + 1;
        let s4 = 0, l2 = n3;
        do {
          i2.call(this, l2), l2 += ++s4 % r4.w == 0 ? o3 : 1;
        } while (l2 <= a2);
      }
      _makeBoxes(e5, t3, i2, r4) {
        const n3 = e5 % i2, a2 = t3 % r4, o3 = e5 - n3, s4 = t3 - a2, l2 = [];
        for (let u2 = 0; u2 < t3; u2 += r4) for (let t4 = 0; t4 < e5; t4 += i2) l2.push({ x: t4, y: u2, w: t4 === o3 ? n3 : i2, h: u2 === s4 ? a2 : r4 });
        return l2;
      }
    };
    ColorHistogram = _ColorHistogram;
    __publicField(ColorHistogram, "_boxSize", [64, 64]), __publicField(ColorHistogram, "_boxPixels", 2), __publicField(ColorHistogram, "_hueGroups", 10);
    RemovedColor = class {
      static {
        __name(this, "RemovedColor");
      }
      constructor(e5, t3, i2) {
        __publicField(this, "index"), __publicField(this, "color"), __publicField(this, "distance"), this.index = e5, this.color = t3, this.distance = i2;
      }
    };
    RGBQuant = class extends AbstractPaletteQuantizer {
      static {
        __name(this, "RGBQuant");
      }
      constructor(e5, t3 = 256, i2 = 2) {
        super(), __publicField(this, "_colors"), __publicField(this, "_initialDistance"), __publicField(this, "_distanceIncrement"), __publicField(this, "_histogram"), __publicField(this, "_distance"), this._distance = e5, this._colors = t3, this._histogram = new ColorHistogram(i2, t3), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
      }
      sample(e5) {
        this._histogram.sample(e5);
      }
      *quantize() {
        const e5 = this._histogram.getImportanceSortedColorsIDXI32();
        if (0 === e5.length) throw new Error("No colors in image");
        yield* this._buildPalette(e5);
      }
      *_buildPalette(e5) {
        const t3 = new Palette(), i2 = t3.getPointContainer().getPointArray(), r4 = new Array(e5.length);
        for (let t4 = 0; t4 < e5.length; t4++) i2.push(Point.createByUint32(e5[t4])), r4[t4] = 1;
        const n3 = i2.length, a2 = [];
        let o3 = n3, s4 = this._initialDistance;
        const l2 = new ProgressTracker(o3 - this._colors, 99);
        for (; o3 > this._colors; ) {
          a2.length = 0;
          for (let e6 = 0; e6 < n3; e6++) {
            if (l2.shouldNotify(n3 - o3) && (yield { progress: l2.progress }), 0 === r4[e6]) continue;
            const t4 = i2[e6];
            for (let l3 = e6 + 1; l3 < n3; l3++) {
              if (0 === r4[l3]) continue;
              const e7 = i2[l3], n4 = this._distance.calculateNormalized(t4, e7);
              n4 < s4 && (a2.push(new RemovedColor(l3, e7, n4)), r4[l3] = 0, o3--);
            }
          }
          s4 += o3 > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
        }
        if (o3 < this._colors) {
          stableSort(a2, (e7, t4) => t4.distance - e7.distance);
          let e6 = 0;
          for (; o3 < this._colors && e6 < a2.length; ) {
            r4[a2[e6].index] = 1, o3++, e6++;
          }
        }
        let u2 = i2.length;
        for (let e6 = u2 - 1; e6 >= 0; e6--) 0 === r4[e6] && (e6 !== u2 - 1 && (i2[e6] = i2[u2 - 1]), --u2);
        i2.length = u2, t3.sort(), yield { palette: t3, progress: 100 };
      }
    };
    __name(createArray1D, "createArray1D");
    __name(createArray4D, "createArray4D");
    __name(createArray3D, "createArray3D");
    __name(fillArray3D, "fillArray3D");
    __name(fillArray1D, "fillArray1D");
    WuColorCube = class {
      static {
        __name(this, "WuColorCube");
      }
      constructor() {
        __publicField(this, "redMinimum"), __publicField(this, "redMaximum"), __publicField(this, "greenMinimum"), __publicField(this, "greenMaximum"), __publicField(this, "blueMinimum"), __publicField(this, "blueMaximum"), __publicField(this, "volume"), __publicField(this, "alphaMinimum"), __publicField(this, "alphaMaximum");
      }
    };
    _WuQuant = class extends AbstractPaletteQuantizer {
      static {
        __name(this, "_WuQuant");
      }
      constructor(e5, t3 = 256, i2 = 5) {
        super(), __publicField(this, "_reds"), __publicField(this, "_greens"), __publicField(this, "_blues"), __publicField(this, "_alphas"), __publicField(this, "_sums"), __publicField(this, "_weights"), __publicField(this, "_momentsRed"), __publicField(this, "_momentsGreen"), __publicField(this, "_momentsBlue"), __publicField(this, "_momentsAlpha"), __publicField(this, "_moments"), __publicField(this, "_table"), __publicField(this, "_pixels"), __publicField(this, "_cubes"), __publicField(this, "_colors"), __publicField(this, "_significantBitsPerChannel"), __publicField(this, "_maxSideIndex"), __publicField(this, "_alphaMaxSideIndex"), __publicField(this, "_sideSize"), __publicField(this, "_alphaSideSize"), __publicField(this, "_distance"), this._distance = e5, this._setQuality(i2), this._initialize(t3);
      }
      sample(e5) {
        const t3 = e5.getPointArray();
        for (let e6 = 0, i2 = t3.length; e6 < i2; e6++) this._addColor(t3[e6]);
        this._pixels = this._pixels.concat(t3);
      }
      *quantize() {
        yield* this._preparePalette();
        const e5 = new Palette();
        for (let t3 = 0; t3 < this._colors; t3++) if (this._sums[t3] > 0) {
          const i2 = this._sums[t3], r4 = this._reds[t3] / i2, n3 = this._greens[t3] / i2, a2 = this._blues[t3] / i2, o3 = this._alphas[t3] / i2, s4 = Point.createByRGBA(0 | r4, 0 | n3, 0 | a2, 0 | o3);
          e5.add(s4);
        }
        e5.sort(), yield { palette: e5, progress: 100 };
      }
      *_preparePalette() {
        yield* this._calculateMoments();
        let e5 = 0;
        const t3 = createArray1D(this._colors);
        for (let i3 = 1; i3 < this._colors; ++i3) {
          this._cut(this._cubes[e5], this._cubes[i3]) ? (t3[e5] = this._cubes[e5].volume > 1 ? this._calculateVariance(this._cubes[e5]) : 0, t3[i3] = this._cubes[i3].volume > 1 ? this._calculateVariance(this._cubes[i3]) : 0) : (t3[e5] = 0, i3--), e5 = 0;
          let r5 = t3[0];
          for (let n4 = 1; n4 <= i3; ++n4) t3[n4] > r5 && (r5 = t3[n4], e5 = n4);
          if (r5 <= 0) {
            this._colors = i3 + 1;
            break;
          }
        }
        const i2 = [], r4 = [], n3 = [], a2 = [];
        for (let e6 = 0; e6 < this._colors; ++e6) {
          const t4 = _WuQuant._volume(this._cubes[e6], this._weights);
          t4 > 0 ? (i2[e6] = _WuQuant._volume(this._cubes[e6], this._momentsRed) / t4 | 0, r4[e6] = _WuQuant._volume(this._cubes[e6], this._momentsGreen) / t4 | 0, n3[e6] = _WuQuant._volume(this._cubes[e6], this._momentsBlue) / t4 | 0, a2[e6] = _WuQuant._volume(this._cubes[e6], this._momentsAlpha) / t4 | 0) : (i2[e6] = 0, r4[e6] = 0, n3[e6] = 0, a2[e6] = 0);
        }
        this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), this._sums = createArray1D(this._colors + 1);
        for (let e6 = 0, t4 = this._pixels.length; e6 < t4; e6++) {
          const t5 = this._pixels[e6];
          let o3 = -1, s4 = Number.MAX_VALUE;
          for (let e7 = 0; e7 < this._colors; e7++) {
            const l2 = i2[e7], u2 = r4[e7], h2 = n3[e7], c3 = a2[e7], f2 = this._distance.calculateRaw(l2, u2, h2, c3, t5.r, t5.g, t5.b, t5.a);
            f2 < s4 && (s4 = f2, o3 = e7);
          }
          this._reds[o3] += t5.r, this._greens[o3] += t5.g, this._blues[o3] += t5.b, this._alphas[o3] += t5.a, this._sums[o3]++;
        }
      }
      _addColor(e5) {
        const t3 = 8 - this._significantBitsPerChannel, i2 = 1 + (e5.r >> t3), r4 = 1 + (e5.g >> t3), n3 = 1 + (e5.b >> t3), a2 = 1 + (e5.a >> t3);
        this._weights[a2][i2][r4][n3]++, this._momentsRed[a2][i2][r4][n3] += e5.r, this._momentsGreen[a2][i2][r4][n3] += e5.g, this._momentsBlue[a2][i2][r4][n3] += e5.b, this._momentsAlpha[a2][i2][r4][n3] += e5.a, this._moments[a2][i2][r4][n3] += this._table[e5.r] + this._table[e5.g] + this._table[e5.b] + this._table[e5.a];
      }
      *_calculateMoments() {
        const e5 = [], t3 = [], i2 = [], r4 = [], n3 = [], a2 = [], o3 = createArray3D(this._sideSize, this._sideSize, this._sideSize), s4 = createArray3D(this._sideSize, this._sideSize, this._sideSize), l2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), u2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), h2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), c3 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        let f2 = 0;
        const d = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let p2 = 1; p2 <= this._alphaMaxSideIndex; ++p2) {
          fillArray3D(o3, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(s4, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(l2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(u2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(h2, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(c3, this._sideSize, this._sideSize, this._sideSize, 0);
          for (let m = 1; m <= this._maxSideIndex; ++m, ++f2) {
            d.shouldNotify(f2) && (yield { progress: d.progress }), fillArray1D(e5, this._sideSize, 0), fillArray1D(t3, this._sideSize, 0), fillArray1D(i2, this._sideSize, 0), fillArray1D(r4, this._sideSize, 0), fillArray1D(n3, this._sideSize, 0), fillArray1D(a2, this._sideSize, 0);
            for (let f3 = 1; f3 <= this._maxSideIndex; ++f3) {
              let d2 = 0, _2 = 0, g = 0, b2 = 0, y2 = 0, w = 0;
              for (let v2 = 1; v2 <= this._maxSideIndex; ++v2) d2 += this._weights[p2][m][f3][v2], _2 += this._momentsRed[p2][m][f3][v2], g += this._momentsGreen[p2][m][f3][v2], b2 += this._momentsBlue[p2][m][f3][v2], y2 += this._momentsAlpha[p2][m][f3][v2], w += this._moments[p2][m][f3][v2], e5[v2] += d2, t3[v2] += _2, i2[v2] += g, r4[v2] += b2, n3[v2] += y2, a2[v2] += w, o3[m][f3][v2] = o3[m - 1][f3][v2] + e5[v2], s4[m][f3][v2] = s4[m - 1][f3][v2] + t3[v2], l2[m][f3][v2] = l2[m - 1][f3][v2] + i2[v2], u2[m][f3][v2] = u2[m - 1][f3][v2] + r4[v2], h2[m][f3][v2] = h2[m - 1][f3][v2] + n3[v2], c3[m][f3][v2] = c3[m - 1][f3][v2] + a2[v2], this._weights[p2][m][f3][v2] = this._weights[p2 - 1][m][f3][v2] + o3[m][f3][v2], this._momentsRed[p2][m][f3][v2] = this._momentsRed[p2 - 1][m][f3][v2] + s4[m][f3][v2], this._momentsGreen[p2][m][f3][v2] = this._momentsGreen[p2 - 1][m][f3][v2] + l2[m][f3][v2], this._momentsBlue[p2][m][f3][v2] = this._momentsBlue[p2 - 1][m][f3][v2] + u2[m][f3][v2], this._momentsAlpha[p2][m][f3][v2] = this._momentsAlpha[p2 - 1][m][f3][v2] + h2[m][f3][v2], this._moments[p2][m][f3][v2] = this._moments[p2 - 1][m][f3][v2] + c3[m][f3][v2];
            }
          }
        }
      }
      static _volumeFloat(e5, t3) {
        return t3[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] - t3[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] - t3[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] + t3[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - t3[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] + t3[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] + t3[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] - t3[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (t3[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] - t3[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] - t3[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + t3[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] - t3[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + t3[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + t3[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] - t3[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
      }
      static _volume(e5, t3) {
        return 0 | _WuQuant._volumeFloat(e5, t3);
      }
      static _top(e5, t3, i2, r4) {
        let n3;
        switch (t3) {
          case _WuQuant._alpha:
            n3 = r4[i2][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] - r4[i2][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] - r4[i2][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] + r4[i2][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (r4[i2][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] - r4[i2][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] - r4[i2][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + r4[i2][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
            break;
          case _WuQuant._red:
            n3 = r4[e5.alphaMaximum][i2][e5.greenMaximum][e5.blueMaximum] - r4[e5.alphaMaximum][i2][e5.greenMinimum][e5.blueMaximum] - r4[e5.alphaMinimum][i2][e5.greenMaximum][e5.blueMaximum] + r4[e5.alphaMinimum][i2][e5.greenMinimum][e5.blueMaximum] - (r4[e5.alphaMaximum][i2][e5.greenMaximum][e5.blueMinimum] - r4[e5.alphaMaximum][i2][e5.greenMinimum][e5.blueMinimum] - r4[e5.alphaMinimum][i2][e5.greenMaximum][e5.blueMinimum] + r4[e5.alphaMinimum][i2][e5.greenMinimum][e5.blueMinimum]);
            break;
          case _WuQuant._green:
            n3 = r4[e5.alphaMaximum][e5.redMaximum][i2][e5.blueMaximum] - r4[e5.alphaMaximum][e5.redMinimum][i2][e5.blueMaximum] - r4[e5.alphaMinimum][e5.redMaximum][i2][e5.blueMaximum] + r4[e5.alphaMinimum][e5.redMinimum][i2][e5.blueMaximum] - (r4[e5.alphaMaximum][e5.redMaximum][i2][e5.blueMinimum] - r4[e5.alphaMaximum][e5.redMinimum][i2][e5.blueMinimum] - r4[e5.alphaMinimum][e5.redMaximum][i2][e5.blueMinimum] + r4[e5.alphaMinimum][e5.redMinimum][i2][e5.blueMinimum]);
            break;
          case _WuQuant._blue:
            n3 = r4[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][i2] - r4[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][i2] - r4[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][i2] + r4[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][i2] - (r4[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][i2] - r4[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][i2] - r4[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][i2] + r4[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][i2]);
            break;
          default:
            throw new Error("impossible");
        }
        return 0 | n3;
      }
      static _bottom(e5, t3, i2) {
        switch (t3) {
          case _WuQuant._alpha:
            return -i2[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (-i2[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          case _WuQuant._red:
            return -i2[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMaximum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (-i2[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          case _WuQuant._green:
            return -i2[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMaximum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMaximum] - (-i2[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          case _WuQuant._blue:
            return -i2[e5.alphaMaximum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMaximum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMaximum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum] - (-i2[e5.alphaMinimum][e5.redMaximum][e5.greenMaximum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMaximum][e5.greenMinimum][e5.blueMinimum] + i2[e5.alphaMinimum][e5.redMinimum][e5.greenMaximum][e5.blueMinimum] - i2[e5.alphaMinimum][e5.redMinimum][e5.greenMinimum][e5.blueMinimum]);
          default:
            return 0;
        }
      }
      _calculateVariance(e5) {
        const t3 = _WuQuant._volume(e5, this._momentsRed), i2 = _WuQuant._volume(e5, this._momentsGreen), r4 = _WuQuant._volume(e5, this._momentsBlue), n3 = _WuQuant._volume(e5, this._momentsAlpha);
        return _WuQuant._volumeFloat(e5, this._moments) - (t3 * t3 + i2 * i2 + r4 * r4 + n3 * n3) / _WuQuant._volume(e5, this._weights);
      }
      _maximize(e5, t3, i2, r4, n3, a2, o3, s4, l2) {
        const u2 = 0 | _WuQuant._bottom(e5, t3, this._momentsRed), h2 = 0 | _WuQuant._bottom(e5, t3, this._momentsGreen), c3 = 0 | _WuQuant._bottom(e5, t3, this._momentsBlue), f2 = 0 | _WuQuant._bottom(e5, t3, this._momentsAlpha), d = 0 | _WuQuant._bottom(e5, t3, this._weights);
        let p2 = 0, m = -1;
        for (let _2 = i2; _2 < r4; ++_2) {
          let i3 = u2 + _WuQuant._top(e5, t3, _2, this._momentsRed), r5 = h2 + _WuQuant._top(e5, t3, _2, this._momentsGreen), g = c3 + _WuQuant._top(e5, t3, _2, this._momentsBlue), b2 = f2 + _WuQuant._top(e5, t3, _2, this._momentsAlpha), y2 = d + _WuQuant._top(e5, t3, _2, this._weights);
          if (0 !== y2) {
            let e6 = i3 * i3 + r5 * r5 + g * g + b2 * b2, t4 = e6 / y2;
            i3 = n3 - i3, r5 = a2 - r5, g = o3 - g, b2 = s4 - b2, y2 = l2 - y2, 0 !== y2 && (e6 = i3 * i3 + r5 * r5 + g * g + b2 * b2, t4 += e6 / y2, t4 > p2 && (p2 = t4, m = _2));
          }
        }
        return { max: p2, position: m };
      }
      _cut(e5, t3) {
        let i2;
        const r4 = _WuQuant._volume(e5, this._momentsRed), n3 = _WuQuant._volume(e5, this._momentsGreen), a2 = _WuQuant._volume(e5, this._momentsBlue), o3 = _WuQuant._volume(e5, this._momentsAlpha), s4 = _WuQuant._volume(e5, this._weights), l2 = this._maximize(e5, _WuQuant._red, e5.redMinimum + 1, e5.redMaximum, r4, n3, a2, o3, s4), u2 = this._maximize(e5, _WuQuant._green, e5.greenMinimum + 1, e5.greenMaximum, r4, n3, a2, o3, s4), h2 = this._maximize(e5, _WuQuant._blue, e5.blueMinimum + 1, e5.blueMaximum, r4, n3, a2, o3, s4), c3 = this._maximize(e5, _WuQuant._alpha, e5.alphaMinimum + 1, e5.alphaMaximum, r4, n3, a2, o3, s4);
        if (c3.max >= l2.max && c3.max >= u2.max && c3.max >= h2.max) {
          if (i2 = _WuQuant._alpha, c3.position < 0) return false;
        } else i2 = l2.max >= c3.max && l2.max >= u2.max && l2.max >= h2.max ? _WuQuant._red : u2.max >= c3.max && u2.max >= l2.max && u2.max >= h2.max ? _WuQuant._green : _WuQuant._blue;
        switch (t3.redMaximum = e5.redMaximum, t3.greenMaximum = e5.greenMaximum, t3.blueMaximum = e5.blueMaximum, t3.alphaMaximum = e5.alphaMaximum, i2) {
          case _WuQuant._red:
            t3.redMinimum = e5.redMaximum = l2.position, t3.greenMinimum = e5.greenMinimum, t3.blueMinimum = e5.blueMinimum, t3.alphaMinimum = e5.alphaMinimum;
            break;
          case _WuQuant._green:
            t3.greenMinimum = e5.greenMaximum = u2.position, t3.redMinimum = e5.redMinimum, t3.blueMinimum = e5.blueMinimum, t3.alphaMinimum = e5.alphaMinimum;
            break;
          case _WuQuant._blue:
            t3.blueMinimum = e5.blueMaximum = h2.position, t3.redMinimum = e5.redMinimum, t3.greenMinimum = e5.greenMinimum, t3.alphaMinimum = e5.alphaMinimum;
            break;
          case _WuQuant._alpha:
            t3.alphaMinimum = e5.alphaMaximum = c3.position, t3.blueMinimum = e5.blueMinimum, t3.redMinimum = e5.redMinimum, t3.greenMinimum = e5.greenMinimum;
        }
        return e5.volume = (e5.redMaximum - e5.redMinimum) * (e5.greenMaximum - e5.greenMinimum) * (e5.blueMaximum - e5.blueMinimum) * (e5.alphaMaximum - e5.alphaMinimum), t3.volume = (t3.redMaximum - t3.redMinimum) * (t3.greenMaximum - t3.greenMinimum) * (t3.blueMaximum - t3.blueMinimum) * (t3.alphaMaximum - t3.alphaMinimum), true;
      }
      _initialize(e5) {
        this._colors = e5, this._cubes = [];
        for (let t3 = 0; t3 < e5; t3++) this._cubes[t3] = new WuColorCube();
        this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
        for (let e6 = 0; e6 < 256; ++e6) this._table[e6] = e6 * e6;
        this._pixels = [];
      }
      _setQuality(e5 = 5) {
        this._significantBitsPerChannel = e5, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
      }
    };
    WuQuant = _WuQuant;
    __publicField(WuQuant, "_alpha", 3), __publicField(WuQuant, "_red", 2), __publicField(WuQuant, "_green", 1), __publicField(WuQuant, "_blue", 0);
    image_exports = {};
    __export2(image_exports, { AbstractImageQuantizer: /* @__PURE__ */ __name(() => AbstractImageQuantizer, "AbstractImageQuantizer"), ErrorDiffusionArray: /* @__PURE__ */ __name(() => ErrorDiffusionArray, "ErrorDiffusionArray"), ErrorDiffusionArrayKernel: /* @__PURE__ */ __name(() => ErrorDiffusionArrayKernel, "ErrorDiffusionArrayKernel"), ErrorDiffusionRiemersma: /* @__PURE__ */ __name(() => ErrorDiffusionRiemersma, "ErrorDiffusionRiemersma"), NearestColor: /* @__PURE__ */ __name(() => NearestColor, "NearestColor") });
    AbstractImageQuantizer = class {
      static {
        __name(this, "AbstractImageQuantizer");
      }
      quantizeSync(e5, t3) {
        for (const i2 of this.quantize(e5, t3)) if (i2.pointContainer) return i2.pointContainer;
        throw new Error("unreachable");
      }
    };
    NearestColor = class extends AbstractImageQuantizer {
      static {
        __name(this, "NearestColor");
      }
      constructor(e5) {
        super(), __publicField(this, "_distance"), this._distance = e5;
      }
      *quantize(e5, t3) {
        const i2 = e5.getPointArray(), r4 = e5.getWidth(), n3 = e5.getHeight(), a2 = new ProgressTracker(n3, 99);
        for (let e6 = 0; e6 < n3; e6++) {
          a2.shouldNotify(e6) && (yield { progress: a2.progress });
          for (let n4 = 0, a3 = e6 * r4; n4 < r4; n4++, a3++) {
            const e7 = i2[a3];
            e7.from(t3.getNearestColor(this._distance, e7));
          }
        }
        yield { pointContainer: e5, progress: 100 };
      }
    };
    ErrorDiffusionArrayKernel = ((e5) => (e5[e5.FloydSteinberg = 0] = "FloydSteinberg", e5[e5.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", e5[e5.Stucki = 2] = "Stucki", e5[e5.Atkinson = 3] = "Atkinson", e5[e5.Jarvis = 4] = "Jarvis", e5[e5.Burkes = 5] = "Burkes", e5[e5.Sierra = 6] = "Sierra", e5[e5.TwoSierra = 7] = "TwoSierra", e5[e5.SierraLite = 8] = "SierraLite", e5))(ErrorDiffusionArrayKernel || {});
    ErrorDiffusionArray = class extends AbstractImageQuantizer {
      static {
        __name(this, "ErrorDiffusionArray");
      }
      constructor(e5, t3, i2 = true, r4 = 0, n3 = false) {
        super(), __publicField(this, "_minColorDistance"), __publicField(this, "_serpentine"), __publicField(this, "_kernel"), __publicField(this, "_calculateErrorLikeGIMP"), __publicField(this, "_distance"), this._setKernel(t3), this._distance = e5, this._minColorDistance = r4, this._serpentine = i2, this._calculateErrorLikeGIMP = n3;
      }
      *quantize(e5, t3) {
        const i2 = e5.getPointArray(), r4 = new Point(), n3 = e5.getWidth(), a2 = e5.getHeight(), o3 = [];
        let s4 = 1, l2 = 1;
        for (const e6 of this._kernel) {
          const t4 = e6[2] + 1;
          l2 < t4 && (l2 = t4);
        }
        for (let e6 = 0; e6 < l2; e6++) this._fillErrorLine(o3[e6] = [], n3);
        const u2 = new ProgressTracker(a2, 99);
        for (let e6 = 0; e6 < a2; e6++) {
          u2.shouldNotify(e6) && (yield { progress: u2.progress }), this._serpentine && (s4 *= -1);
          const l3 = e6 * n3, h2 = 1 === s4 ? 0 : n3 - 1, c3 = 1 === s4 ? n3 : -1;
          this._fillErrorLine(o3[0], n3), o3.push(o3.shift());
          const f2 = o3[0];
          for (let u3 = h2, d = l3 + h2; u3 !== c3; u3 += s4, d += s4) {
            const l4 = i2[d], h3 = f2[u3];
            r4.from(l4);
            const c4 = Point.createByRGBA(inRange0to255Rounded(l4.r + h3[0]), inRange0to255Rounded(l4.g + h3[1]), inRange0to255Rounded(l4.b + h3[2]), inRange0to255Rounded(l4.a + h3[3])), p2 = t3.getNearestColor(this._distance, c4);
            if (l4.from(p2), this._minColorDistance) {
              if (this._distance.calculateNormalized(r4, p2) < this._minColorDistance) continue;
            }
            let m, _2, g, b2;
            this._calculateErrorLikeGIMP ? (m = c4.r - p2.r, _2 = c4.g - p2.g, g = c4.b - p2.b, b2 = c4.a - p2.a) : (m = r4.r - p2.r, _2 = r4.g - p2.g, g = r4.b - p2.b, b2 = r4.a - p2.a);
            const y2 = 1 === s4 ? 0 : this._kernel.length - 1, w = 1 === s4 ? this._kernel.length : -1;
            for (let t4 = y2; t4 !== w; t4 += s4) {
              const i3 = this._kernel[t4][1] * s4, r5 = this._kernel[t4][2];
              if (i3 + u3 >= 0 && i3 + u3 < n3 && r5 + e6 >= 0 && r5 + e6 < a2) {
                const e7 = this._kernel[t4][0], n4 = o3[r5][i3 + u3];
                n4[0] += m * e7, n4[1] += _2 * e7, n4[2] += g * e7, n4[3] += b2 * e7;
              }
            }
          }
        }
        yield { pointContainer: e5, progress: 100 };
      }
      _fillErrorLine(e5, t3) {
        e5.length > t3 && (e5.length = t3);
        const i2 = e5.length;
        for (let t4 = 0; t4 < i2; t4++) {
          const i3 = e5[t4];
          i3[0] = i3[1] = i3[2] = i3[3] = 0;
        }
        for (let r4 = i2; r4 < t3; r4++) e5[r4] = [0, 0, 0, 0];
      }
      _setKernel(e5) {
        switch (e5) {
          case 0:
            this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
            break;
          case 1:
            this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
            break;
          case 2:
            this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
            break;
          case 3:
            this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
            break;
          case 4:
            this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
            break;
          case 5:
            this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
            break;
          case 6:
            this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
            break;
          case 7:
            this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
            break;
          case 8:
            this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
            break;
          default:
            throw new Error(`ErrorDiffusionArray: unknown kernel = ${e5}`);
        }
      }
    };
    __name(hilbertCurve, "hilbertCurve");
    __name(walkHilbert, "walkHilbert");
    __name(visit, "visit");
    ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
      static {
        __name(this, "ErrorDiffusionRiemersma");
      }
      constructor(e5, t3 = 16, i2 = 1) {
        super(), __publicField(this, "_distance"), __publicField(this, "_weights"), __publicField(this, "_errorQueueSize"), this._distance = e5, this._errorQueueSize = t3, this._weights = ErrorDiffusionRiemersma._createWeights(i2, t3);
      }
      *quantize(e5, t3) {
        const i2 = e5.getPointArray(), r4 = e5.getWidth(), n3 = e5.getHeight(), a2 = [];
        let o3 = 0;
        for (let e6 = 0; e6 < this._errorQueueSize; e6++) a2[e6] = { r: 0, g: 0, b: 0, a: 0 };
        yield* hilbertCurve(r4, n3, (e6, n4) => {
          const s4 = i2[e6 + n4 * r4];
          let { r: l2, g: u2, b: h2, a: c3 } = s4;
          for (let e7 = 0; e7 < this._errorQueueSize; e7++) {
            const t4 = this._weights[e7], i3 = a2[(e7 + o3) % this._errorQueueSize];
            l2 += i3.r * t4, u2 += i3.g * t4, h2 += i3.b * t4, c3 += i3.a * t4;
          }
          const f2 = Point.createByRGBA(inRange0to255Rounded(l2), inRange0to255Rounded(u2), inRange0to255Rounded(h2), inRange0to255Rounded(c3)), d = t3.getNearestColor(this._distance, f2);
          o3 = (o3 + 1) % this._errorQueueSize;
          const p2 = (o3 + this._errorQueueSize - 1) % this._errorQueueSize;
          a2[p2].r = s4.r - d.r, a2[p2].g = s4.g - d.g, a2[p2].b = s4.b - d.b, a2[p2].a = s4.a - d.a, s4.from(d);
        }), yield { pointContainer: e5, progress: 100 };
      }
      static _createWeights(e5, t3) {
        const i2 = [], r4 = Math.exp(Math.log(t3) / (t3 - 1));
        for (let n3 = 0, a2 = 1; n3 < t3; n3++) i2[n3] = (a2 + 0.5 | 0) / t3 * e5, a2 *= r4;
        return i2;
      }
    };
    quality_exports = {};
    __export2(quality_exports, { ssim: /* @__PURE__ */ __name(() => ssim, "ssim") });
    K1 = 0.01;
    K2 = 0.03;
    __name(ssim, "ssim");
    __name(iterate, "iterate");
    __name(calculateLumaValuesForWindow, "calculateLumaValuesForWindow");
    __name(calculateAverageLuma, "calculateAverageLuma");
    __name(buildPaletteSync, "buildPaletteSync");
    __name(applyPaletteSync, "applyPaletteSync");
    __name(colorDistanceFormulaToColorDistance, "colorDistanceFormulaToColorDistance");
    __name(imageQuantizationToImageQuantizer, "imageQuantizationToImageQuantizer");
    __name(paletteQuantizationToPaletteQuantizer, "paletteQuantizationToPaletteQuantizer");
    "function" == typeof setImmediate ? setImmediate : "undefined" != typeof process && (null == process || process.nextTick);
    QuantizeOptionsSchema = z.object({ colors: z.number().optional(), colorDistanceFormula: z.union([z.literal("cie94-textiles"), z.literal("cie94-graphic-arts"), z.literal("ciede2000"), z.literal("color-metric"), z.literal("euclidean"), z.literal("euclidean-bt709-noalpha"), z.literal("euclidean-bt709"), z.literal("manhattan"), z.literal("manhattan-bt709"), z.literal("manhattan-nommyde"), z.literal("pngquant")]).optional(), paletteQuantization: z.union([z.literal("neuquant"), z.literal("neuquant-float"), z.literal("rgbquant"), z.literal("wuquant")]).optional(), imageQuantization: z.union([z.literal("nearest"), z.literal("riemersma"), z.literal("floyd-steinberg"), z.literal("false-floyd-steinberg"), z.literal("stucki"), z.literal("atkinson"), z.literal("jarvis"), z.literal("burkes"), z.literal("sierra"), z.literal("two-sierra"), z.literal("sierra-lite")]).optional() });
    methods = { quantize(e5, t3) {
      const { colors: i2, colorDistanceFormula: r4, paletteQuantization: n3, imageQuantization: a2 } = QuantizeOptionsSchema.parse(t3), o3 = utils_exports.PointContainer.fromUint8Array(e5.bitmap.data, e5.bitmap.width, e5.bitmap.height), s4 = applyPaletteSync(o3, buildPaletteSync([o3], { colors: i2, colorDistanceFormula: r4, paletteQuantization: n3 }), { colorDistanceFormula: r4, imageQuantization: a2 });
      return e5.bitmap.data = Buffer2.from(s4.toUint8Array()), e5;
    } };
    parseBmfontAscii = /* @__PURE__ */ __name(function(e5) {
      if (!e5) throw new Error("no data provided");
      var t3 = { pages: [], chars: [], kernings: [] }, i2 = (e5 = e5.toString().trim()).split(/\r\n?|\n/g);
      if (0 === i2.length) throw new Error("no data in BMFont file");
      for (var r4 = 0; r4 < i2.length; r4++) {
        var n3 = splitLine(i2[r4], r4);
        if (n3) if ("page" === n3.key) {
          if ("number" != typeof n3.data.id) throw new Error("malformed file at line " + r4 + " -- needs page id=N");
          if ("string" != typeof n3.data.file) throw new Error("malformed file at line " + r4 + ' -- needs page file="path"');
          t3.pages[n3.data.id] = n3.data.file;
        } else "chars" === n3.key || "kernings" === n3.key || ("char" === n3.key ? t3.chars.push(n3.data) : "kerning" === n3.key ? t3.kernings.push(n3.data) : t3[n3.key] = n3.data);
      }
      return t3;
    }, "parseBmfontAscii");
    __name(splitLine, "splitLine");
    __name(parseData, "parseData");
    __name(parseIntList$1, "parseIntList$1");
    parseASCII = getDefaultExportFromCjs(parseBmfontAscii);
    GLYPH_DESIGNER_ERROR = "chasrset";
    parseAttribs = /* @__PURE__ */ __name(function(e5) {
      for (var t3 in e5 = Object.assign({}, e5), GLYPH_DESIGNER_ERROR in e5 && (e5.charset = e5[GLYPH_DESIGNER_ERROR], delete e5[GLYPH_DESIGNER_ERROR]), e5) "face" !== t3 && "charset" !== t3 && (e5[t3] = "padding" === t3 || "spacing" === t3 ? parseIntList(e5[t3]) : parseInt(e5[t3], 10));
      return e5;
    }, "parseAttribs");
    __name(parseIntList, "parseIntList");
    xmlParseFromString = void 0 !== self.DOMParser ? function(e5) {
      return new self.DOMParser().parseFromString(e5, "application/xml");
    } : void 0 !== self.ActiveXObject && new self.ActiveXObject("Microsoft.XMLDOM") ? function(e5) {
      var t3 = new self.ActiveXObject("Microsoft.XMLDOM");
      return t3.async = "false", t3.loadXML(e5), t3;
    } : function(e5) {
      var t3 = document.createElement("div");
      return t3.innerHTML = e5, t3;
    };
    parseAttributes = parseAttribs;
    parseFromString = xmlParseFromString;
    NAME_MAP = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" };
    browser = /* @__PURE__ */ __name(function(e5) {
      e5 = e5.toString();
      var t3 = parseFromString(e5), i2 = { pages: [], chars: [], kernings: [] };
      ["info", "common"].forEach(function(e6) {
        var r5 = t3.getElementsByTagName(e6)[0];
        r5 && (i2[e6] = parseAttributes(getAttribs(r5)));
      });
      var r4 = t3.getElementsByTagName("pages")[0];
      if (!r4) throw new Error("malformed file -- no <pages> element");
      for (var n3 = r4.getElementsByTagName("page"), a2 = 0; a2 < n3.length; a2++) {
        var o3 = n3[a2], s4 = parseInt(o3.getAttribute("id"), 10), l2 = o3.getAttribute("file");
        if (isNaN(s4)) throw new Error('malformed file -- page "id" attribute is NaN');
        if (!l2) throw new Error('malformed file -- needs page "file" attribute');
        i2.pages[parseInt(s4, 10)] = l2;
      }
      return ["chars", "kernings"].forEach(function(e6) {
        var r5 = t3.getElementsByTagName(e6)[0];
        if (r5) for (var n4 = e6.substring(0, e6.length - 1), a3 = r5.getElementsByTagName(n4), o4 = 0; o4 < a3.length; o4++) {
          var s5 = a3[o4];
          i2[e6].push(parseAttributes(getAttribs(s5)));
        }
      }), i2;
    }, "browser");
    __name(getAttribs, "getAttribs");
    __name(getAttribList, "getAttribList");
    __name(mapName, "mapName");
    parseXML = getDefaultExportFromCjs(browser);
    HEADER$1 = [66, 77, 70];
    parseBmfontBinary = /* @__PURE__ */ __name(function(e5) {
      if (e5.length < 6) throw new Error("invalid buffer length for BMFont");
      var t3 = HEADER$1.every(function(t4, i3) {
        return e5.readUInt8(i3) === t4;
      });
      if (!t3) throw new Error("BMFont missing BMF byte header");
      var i2 = 3;
      if (e5.readUInt8(i2++) > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
      for (var r4 = { kernings: [], chars: [] }, n3 = 0; n3 < 5; n3++) i2 += readBlock(r4, e5, i2);
      return r4;
    }, "parseBmfontBinary");
    __name(readBlock, "readBlock");
    __name(readInfo, "readInfo");
    __name(readCommon, "readCommon");
    __name(readPages, "readPages");
    __name(readChars, "readChars");
    __name(readKernings, "readKernings");
    __name(readNameNT, "readNameNT");
    __name(readStringNT, "readStringNT");
    readBinary = getDefaultExportFromCjs(parseBmfontBinary);
    __name(normalizeArray, "normalizeArray");
    splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
    splitPath = /* @__PURE__ */ __name(function(e5) {
      return splitPathRe.exec(e5).slice(1);
    }, "splitPath");
    __name(resolve3, "resolve");
    __name(normalize, "normalize");
    __name(isAbsolute, "isAbsolute");
    __name(join, "join");
    __name(relative2, "relative");
    sep = "/";
    delimiter = ":";
    __name(dirname, "dirname");
    __name(basename, "basename");
    __name(extname, "extname");
    path = { extname, basename, dirname, sep, delimiter, relative: relative2, join, isAbsolute, normalize, resolve: resolve3 };
    __name(filter, "filter");
    substr = "b" === "ab".substr(-1) ? function(e5, t3, i2) {
      return e5.substr(t3, i2);
    } : function(e5, t3, i2) {
      return t3 < 0 && (t3 = e5.length + t3), e5.substr(t3, i2);
    };
    __name(e3, "e");
    t = /* @__PURE__ */ __name((e5) => {
      if (!e5) return null;
      const i2 = {};
      switch (e5.type) {
        case "ELEMENT": {
          let n3 = {};
          const a2 = E(e5.value.attributes), o3 = t(e5.value.children);
          if (a2 && (n3 = Object.assign(n3, a2)), o3) {
            const t3 = r2(e5.value.children);
            n3 = Object.assign(n3, t3);
          }
          i2[e5.value.type] = n3;
          break;
        }
        case "ATTRIBUTE": {
          const t3 = e5.value;
          i2[t3.name] = t3.value;
          break;
        }
        case "CONTENT":
          return { content: e5.value };
      }
      return i2;
    }, "t");
    r2 = /* @__PURE__ */ __name((e5) => e5 && Array.isArray(e5) && 0 !== e5.length ? n(e5) ? { content: e5[0].value } : { children: e5.map(t) } : null, "r");
    n = /* @__PURE__ */ __name((e5) => e5 && Array.isArray(e5) && 1 === e5.length && "CONTENT" === e5[0].type, "n");
    E = /* @__PURE__ */ __name((e5) => e5 && Array.isArray(e5) ? e5.map(t).reduce((e6, t3) => Object.assign(e6, t3), {}) : null, "E");
    s2 = { convert: /* @__PURE__ */ __name((e5) => t(e5.value.children[0]), "convert") };
    a = { Token: /* @__PURE__ */ __name((e5, t3) => ({ type: e5, value: t3 }), "Token"), TOKEN_TYPE: { OPEN_BRACKET: "OPEN_BRACKET", ELEMENT_TYPE: "ELEMENT_TYPE", CLOSE_ELEMENT: "CLOSE_ELEMENT", ATTRIB_NAME: "ATTRIB_NAME", ATTRIB_VALUE: "ATTRIB_VALUE", ASSIGN: "ASSIGN", CLOSE_BRACKET: "CLOSE_BRACKET", CONTENT: "CONTENT", EOF: "EOF" } };
    ({ Token: T, TOKEN_TYPE: u } = a);
    c = T("EOF");
    l = /* @__PURE__ */ __name((e5) => " " === e5 || "\n" === e5 || "\r" === e5 || "	" === e5, "l");
    o = /* @__PURE__ */ __name((e5) => e5.replace(/'/g, '"'), "o");
    N = { createLexer: /* @__PURE__ */ __name(function(e5) {
      let t3 = null, i2 = ((e6) => {
        let t4 = 0;
        for (; t4 < e6.length && l(e6[t4]); ) t4++;
        return ((e7, t5) => {
          if (e7.startsWith("<?xml", t5)) {
            const i3 = e7.length;
            for (; t5 < i3; ) if ("?" !== e7[t5]) t5++;
            else {
              if (">" === e7[t5 + 1]) return t5 + 2;
              t5++;
            }
          }
          return t5;
        })(e6, t4);
      })(e5), r4 = [];
      const n3 = /* @__PURE__ */ __name(() => e5[i2], "n"), a2 = /* @__PURE__ */ __name(() => t3 !== c && i2 < e5.length, "a"), s4 = /* @__PURE__ */ __name((e6) => '"' === e6 || "'" === e6, "s"), h2 = /* @__PURE__ */ __name(() => {
        for (; a2() && l(e5[i2]); ) i2++;
      }, "h"), f2 = /* @__PURE__ */ __name((t4) => {
        if (a2()) {
          if ("<" === e5[i2]) {
            let t5 = "<";
            return i2++, a2() && "/" === e5[i2] ? (i2++, t5 = "</") : a2() && "!" === e5[i2] && "-" === e5[i2 + 1] && "-" === e5[i2 + 2] && (i2++, i2++, i2++, t5 = "<!--"), t5;
          }
          if ("/" === n3()) {
            let e6 = "/";
            return i2++, a2() && ">" === n3() && (i2++, e6 = "/>"), e6;
          }
          if ("=" === e5[i2] || ">" === e5[i2]) {
            const t5 = e5[i2];
            return i2++, t5;
          }
        }
        return d(!!t4);
      }, "f"), d = /* @__PURE__ */ __name((t4) => {
        const r5 = t4 ? /[^>=<]/u : /[a-zA-Z0-9_:-]/;
        let n4 = i2;
        for (; a2() && e5[i2].match(r5); ) i2++;
        return o(e5.substring(n4, i2));
      }, "d"), p2 = /* @__PURE__ */ __name(() => {
        const l2 = i2;
        h2();
        const m = i2 - l2;
        if (a2()) if (t3 && t3.type === u.OPEN_BRACKET) {
          h2();
          const e6 = f2(false);
          t3 = T(u.ELEMENT_TYPE, e6), r4.push(e6);
        } else if (t3 && t3.type === u.ASSIGN) {
          a2() && s4(n3()) && i2++;
          let r5 = i2;
          for (; a2() && !s4(n3()); ) i2++;
          const l3 = o(e5.substring(r5, i2));
          i2++, t3 = T(u.ATTRIB_VALUE, l3);
        } else {
          h2();
          let o3 = f2(true);
          switch (o3) {
            case "=":
              t3 = t3.type === u.ATTRIB_NAME ? T(u.ASSIGN) : T(u.CONTENT, o3);
              break;
            case "</": {
              const n4 = i2;
              for (; ">" !== e5[i2]; ) i2++;
              t3 = T(u.CLOSE_ELEMENT, e5.substring(n4, i2)), i2++, r4.pop();
              break;
            }
            case "/>": {
              const e6 = r4.pop();
              t3 = T(u.CLOSE_ELEMENT, e6);
              break;
            }
            case "<!--": {
              const t4 = ["!", "-", "-"];
              for (; a2() && (">" !== t4[2] || "-" !== t4[1] || "-" !== t4[0]); ) t4.shift(), t4.push(e5[i2]), i2++;
              return p2();
            }
            case ">":
              t3 = T(u.CLOSE_BRACKET);
              break;
            case "<":
              t3 = T(u.OPEN_BRACKET);
              break;
            default:
              if (o3 && o3.length > 0) {
                if (t3.type === u.CLOSE_BRACKET) {
                  let e6 = "";
                  "<" !== n3() && (e6 = d(true)), t3 = T(u.CONTENT, o3 + e6);
                } else if (t3.type !== u.ATTRIB_NAME && t3.type !== u.CONTENT) t3.type === u.CLOSE_ELEMENT ? (o3 = " ".repeat(m) + o3, t3 = T(u.CONTENT, o3)) : t3 = T(u.ATTRIB_NAME, o3);
                else {
                  const e6 = " ".repeat(m) + o3;
                  t3 = T(u.CONTENT, e6);
                }
                break;
              }
              {
                const t4 = 'Unknown Syntax : "' + e5[i2] + '"';
                throw new Error(t4);
              }
          }
        }
        else t3 = c;
        return t3;
      }, "p");
      return { peek: n3, next: p2, hasNext: a2 };
    }, "createLexer") };
    ({ createLexer: i } = N);
    ({ Token: p, TOKEN_TYPE: O } = a);
    [A, f, C, h] = ["ROOT", "ELEMENT", "ATTRIBUTE", "CONTENT"];
    _ = /* @__PURE__ */ __name((e5, t3) => ({ type: e5, value: t3 }), "_");
    L = /* @__PURE__ */ __name((e5) => _(h, e5), "L");
    y = /* @__PURE__ */ __name((e5, t3, i2) => _(f, { type: e5, attributes: t3, children: i2 }), "y");
    v = /* @__PURE__ */ __name((e5, t3) => _(C, { name: e5, value: t3 }), "v");
    S = /* @__PURE__ */ __name((e5, t3) => {
      const i2 = [];
      for (; e5.hasNext(); ) {
        const r4 = e5.next();
        switch (r4.type) {
          case O.OPEN_BRACKET: {
            const t4 = e5.next(), [r5, n3] = R(e5);
            let a2 = [];
            n3.type !== O.CLOSE_ELEMENT && (a2 = S(e5, t4)), a2 && a2.length > 0 && a2[0].type === O.CONTENT && (a2 = b(a2)), i2.push(y(t4.value, r5, a2));
            break;
          }
          case O.CLOSE_ELEMENT:
            if (r4.value === t3.value) return i2;
            break;
          case O.CONTENT:
            i2.push(L(r4.value));
            break;
          case O.EOF:
            return i2;
          default:
            throw new Error(`Unknown Lexem type: ${r4.type} "${r4.value}, scoping element: ${t3.value}"`);
        }
      }
      return i2;
    }, "S");
    R = /* @__PURE__ */ __name((e5) => {
      const t3 = [];
      let i2 = e5.peek();
      if (!e5.hasNext() || i2 && i2.type === O.CLOSE_BRACKET || i2 && i2.type === O.CLOSE_ELEMENT) return [t3, i2];
      for (i2 = e5.next(); e5.hasNext() && i2 && i2.type !== O.CLOSE_BRACKET && i2.type !== O.CLOSE_ELEMENT; ) {
        const r4 = i2;
        e5.next();
        const n3 = e5.next(), a2 = v(r4.value, n3.value);
        t3.push(a2), i2 = e5.next();
      }
      return [t3, i2];
    }, "R");
    __name(b, "b");
    B = { transpile: /* @__PURE__ */ __name(function(e5, t3) {
      const r4 = ((e6) => _(A, { children: S(e6, p(A, "ROOT")) }))(i(e5));
      return t3 ? t3.convert(r4) : r4;
    }, "transpile"), Node: _, ElementNode: y, AttribNode: v };
    M = s2;
    ({ transpile: x } = B);
    k = e3({ convertXML: /* @__PURE__ */ __name(function(e5, t3) {
      return x(e5, t3 || M);
    }, "convertXML"), createAST: /* @__PURE__ */ __name(function(e5) {
      return x(e5);
    }, "createAST") });
    simpleXmlToJson_min = k;
    xmlPackage = getDefaultExportFromCjs(simpleXmlToJson_min);
    ({ convertXML } = xmlPackage);
    isWebWorker = "undefined" != typeof self && void 0 === self.document;
    CharacterJimp = createJimp({ formats: [png] });
    HEADER = Buffer2.from([66, 77, 70, 3]);
    __name(isBinary, "isBinary");
    __name(parseFont, "parseFont");
    __name(parseNumbersInObject, "parseNumbersInObject");
    __name(loadBitmapFontData, "loadBitmapFontData");
    __name(processBitmapFont, "processBitmapFont");
    __name(loadFont, "loadFont");
    pixelmatch_1 = pixelmatch;
    defaultOptions = { threshold: 0.1, includeAA: false, alpha: 0.1, aaColor: [255, 255, 0], diffColor: [255, 0, 0], diffColorAlt: null, diffMask: false };
    __name(pixelmatch, "pixelmatch");
    __name(isPixelData, "isPixelData");
    __name(antialiased, "antialiased");
    __name(hasManySiblings, "hasManySiblings");
    __name(colorDelta, "colorDelta");
    __name(rgb2y, "rgb2y");
    __name(rgb2i, "rgb2i");
    __name(rgb2q, "rgb2q");
    __name(blend, "blend");
    __name(drawPixel, "drawPixel");
    __name(drawGrayPixel, "drawGrayPixel");
    pixelMatch = getDefaultExportFromCjs(pixelmatch_1);
    __name(diff, "diff");
    defaultPlugins = [methods$h, methods$g, methods$f, methods$e, methods$c, methods$a, methods$b, methods$9, methods$8, methods$7, methods$6, methods$5, methods$4, methods$3, methods$d, methods$2, methods$1, methods];
    defaultFormats = [bmp, msBmp, gif, jpeg$2, png, tiff];
    JimpMime = { bmp: bmp().mime, gif: gif().mime, jpeg: jpeg$2().mime, png: png().mime, tiff: tiff().mime };
    Jimp = createJimp({ formats: defaultFormats, plugins: defaultPlugins });
  }
});

// .svelte-kit/output/server/entries/endpoints/api/profile-picture/_server.ts.js
var server_ts_exports = {};
__export(server_ts_exports, {
  POST: () => POST
});
async function subscribeAndWait(connection, queries) {
  return new Promise((resolve4, reject2) => {
    let settled = false;
    connection.subscriptionBuilder().onApplied(() => {
      if (settled) return;
      settled = true;
      resolve4();
    }).onError((errorContext) => {
      if (settled) return;
      settled = true;
      const errorMessage = errorContext instanceof Error ? errorContext.message : JSON.stringify(errorContext);
      console.error("[Profile] Subscription error:", errorMessage);
      reject2(new Error(`Failed to subscribe: ${errorMessage}`));
    }).subscribe(queries);
  });
}
async function connectToSpacetimeDb(env3) {
  const host = env3.SPACETIMEDB_HOST;
  const moduleName = env3.SPACETIMEDB_DB_NAME;
  const token = env3.SPACETIMEDB_ADMIN_TOKEN;
  if (!host || !moduleName) {
    console.error("[Profile] SpacetimeDB connection is not configured:", host, moduleName);
    throw error3(500, "SpacetimeDB connection is not configured");
  }
  if (!token) {
    console.error("[Profile] No admin token available for server-side SpacetimeDB connection");
    throw error3(500, "SpacetimeDB admin token is not configured");
  }
  console.log("[Profile] Connecting to SpacetimeDB:", host, moduleName, "(using admin token)");
  return new Promise((resolve4, reject2) => {
    let settled = false;
    const builder = DbConnection.builder().withUri(host).withModuleName(moduleName).withToken(token).onConnect((connection, identity) => {
      if (identity === void 0) {
        if (!settled) {
          settled = true;
          reject2(new Error("Unable to resolve account identity"));
        }
        return;
      }
      if (!settled) {
        settled = true;
        resolve4({ connection, identity });
      }
    }).onConnectError((_ctx, err) => {
      if (!settled) {
        settled = true;
        reject2(err ?? new Error("Failed to connect to SpacetimeDB"));
      }
    }).onDisconnect((_ctx, err) => {
      if (!settled) {
        settled = true;
        reject2(err ?? new Error("Disconnected before connecting to SpacetimeDB"));
      }
    });
    builder.build();
  });
}
async function resolveAccountData(connection, identity) {
  console.log(`[Profile] Starting resolve account data for identity: ${identity.toHexString()}`);
  await subscribeAndWait(connection, [`SELECT * FROM Account`]);
  console.log("[Profile] After subscribe and wait");
  const allAccounts = Array.from(connection.db.account.iter());
  console.log(`[Profile] Accounts in cache: ${allAccounts.length}`);
  for (const acc of allAccounts) {
    console.log(`[Profile]   Account ${acc.id}: identity=${acc.identity.toHexString()}`);
  }
  const accountRow = connection.db.account.identity.find(identity);
  if (!accountRow) {
    console.error(
      `[Profile] No account is associated with this identity: ${identity.toHexString()}`
    );
    throw error3(469, "No account is associated with this identity");
  }
  const accountId = accountRow.id;
  const query = `SELECT * FROM AccountCustomization`;
  console.log("Starting subscribe for account_customization with Query: ", query);
  await subscribeAndWait(connection, [query]);
  console.log("After subscribe and wait for account_customization");
  const customization = connection.db.accountCustomization.accountId.find(accountId);
  const currentVersion = customization ? Number(customization.pfpVersion) : 0;
  return { accountId, currentVersion };
}
async function uploadProfilePictureToR2(bucket, objectKey, body2, contentType) {
  console.log(
    `[Profile] Uploading to R2 bucket, key: ${objectKey}, size: ${body2.byteLength} bytes`
  );
  const result = await bucket.put(objectKey, body2, {
    httpMetadata: {
      contentType,
      cacheControl: "public, max-age=31536000, immutable"
    }
  });
  if (!result) {
    throw new Error("R2 put returned null - upload may have failed");
  }
  console.log(`[Profile] R2 upload successful, etag: ${result.etag}`);
}
function buildProfilePictureUrl(baseUrl, accountId, version2, extension) {
  console.log("[PFP] Base URL:", baseUrl);
  if (!baseUrl?.trim() || version2 <= 0) {
    return null;
  }
  const normalizedBase = baseUrl.trim().replace(/\/$/, "");
  return `${normalizedBase}/pfp/${accountId.toString()}.${extension}?v=${version2}`;
}
async function downloadImageFromUrl(imageUrl) {
  console.log(`[Profile] Downloading image from URL: ${imageUrl}`);
  const response = await fetch(imageUrl);
  if (!response.ok) {
    throw new Error(`Failed to download image: ${response.status}`);
  }
  const contentType = response.headers.get("content-type") ?? "image/jpeg";
  const buffer = await response.arrayBuffer();
  console.log(`[Profile] Downloaded ${buffer.byteLength} bytes, content-type: ${contentType}`);
  return { bytes: new Uint8Array(buffer), contentType };
}
function detectImageType(bytes) {
  if (bytes.length >= 8) {
    if (bytes[0] === 137 && bytes[1] === 80 && bytes[2] === 78 && bytes[3] === 71) {
      return "png";
    }
    if (bytes[0] === 255 && bytes[1] === 216 && bytes[2] === 255) {
      return "jpeg";
    }
    if (bytes[0] === 71 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 56) {
      return "gif";
    }
    if (bytes[0] === 82 && bytes[1] === 73 && bytes[2] === 70 && bytes[3] === 70 && bytes[8] === 87 && bytes[9] === 69 && bytes[10] === 66 && bytes[11] === 80) {
      return "webp";
    }
    if (bytes[0] === 66 && bytes[1] === 77) {
      return "bmp";
    }
    if (bytes[0] === 73 && bytes[1] === 73 && bytes[2] === 42 && bytes[3] === 0 || bytes[0] === 77 && bytes[1] === 77 && bytes[2] === 0 && bytes[3] === 42) {
      return "tiff";
    }
  }
  return "unknown";
}
async function convertToPng(imageBytes) {
  console.log(`[Profile] Converting image (${imageBytes.length} bytes) to PNG`);
  const image = await Jimp.read(Buffer.from(imageBytes));
  const pngBuffer = await image.getBuffer("image/png");
  console.log(`[Profile] Converted to PNG: ${pngBuffer.length} bytes`);
  return new Uint8Array(pngBuffer);
}
var _cached_ClockSchedule_type_value, ClockSchedule, _cached_ClockUpdate_type_value, ClockUpdate, _cached_CloseAndCycleGameTile_type_value, CloseAndCycleGameTile, _cached_Connect_type_value, Connect, _cached_Disconnect_type_value, Disconnect, _cached_IncrementPfpVersion_type_value, IncrementPfpVersion, _cached_SetUsername_type_value, SetUsername, _cached_Account_type_value, Account, _cached_UpsertAccount_type_value, UpsertAccount, _cached_AccountSeq_type_value, AccountSeq, _cached_UpsertAccountSeq_type_value, UpsertAccountSeq, _cached_InputFrame_type_value, InputFrame, _cached_AuthFrame_type_value, AuthFrame, _cached_UpsertAuthFrame_type_value, UpsertAuthFrame, _cached_BaseCfg_type_value, BaseCfg, _cached_UpsertBaseCfg_type_value, UpsertBaseCfg, _cached_InputCollector_type_value, InputCollector, _cached_UpsertInputCollector_type_value, UpsertInputCollector, _cached_UpsertInputFrame_type_value, UpsertInputFrame, _cached_LevelFileData_type_value, LevelFileData, _cached_UpsertLevelFileData_type_value, UpsertLevelFileData, AccountTableHandle, _cached_AccountCustomization_type_value, AccountCustomization, AccountCustomizationTableHandle, AccountSeqTableHandle, _cached_Admin_type_value, Admin, AdminTableHandle, AuthFrameTableHandle, BaseCfgTableHandle, _cached_Clock_type_value, Clock, ClockTableHandle, ClockScheduleTableHandle, _cached_DeterminismCheck_type_value, DeterminismCheck, DeterminismCheckTableHandle, _cached_GameCoreSnap_type_value, GameCoreSnap, GameCoreSnapTableHandle, InputCollectorTableHandle, InputFrameTableHandle, _cached_LastAuthFrameTimestamp_type_value, LastAuthFrameTimestamp, LastAuthFrameTimestampTableHandle, LevelFileDataTableHandle, _cached_Seq_type_value, Seq, SeqTableHandle, _cached_StepsSinceLastAuthFrame_type_value, StepsSinceLastAuthFrame, StepsSinceLastAuthFrameTableHandle, _cached_StepsSinceLastBatch_type_value, StepsSinceLastBatch, StepsSinceLastBatchTableHandle, REMOTE_MODULE, RemoteReducers, SetReducerFlags, RemoteTables, SubscriptionBuilder, DbConnection, PROFILE_STORAGE_PREFIX, MAX_PROFILE_VERSION, PFP_MAX_BYTES, ACCEPTED_IMAGE_TYPES, POST;
var init_server_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/profile-picture/_server.ts.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_exports();
    init_index_browser();
    init_browser();
    _cached_ClockSchedule_type_value = null;
    ClockSchedule = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_ClockSchedule_type_value) return _cached_ClockSchedule_type_value;
        _cached_ClockSchedule_type_value = AlgebraicType.Product({ elements: [] });
        _cached_ClockSchedule_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U64 },
          { name: "scheduledAt", algebraicType: AlgebraicType.createScheduleAtType() }
        );
        return _cached_ClockSchedule_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, ClockSchedule.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, ClockSchedule.getTypeScriptAlgebraicType());
      }
    };
    _cached_ClockUpdate_type_value = null;
    ClockUpdate = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_ClockUpdate_type_value) return _cached_ClockUpdate_type_value;
        _cached_ClockUpdate_type_value = AlgebraicType.Product({ elements: [] });
        _cached_ClockUpdate_type_value.value.elements.push(
          { name: "schedule", algebraicType: ClockSchedule.getTypeScriptAlgebraicType() }
        );
        return _cached_ClockUpdate_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, ClockUpdate.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, ClockUpdate.getTypeScriptAlgebraicType());
      }
    };
    _cached_CloseAndCycleGameTile_type_value = null;
    CloseAndCycleGameTile = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_CloseAndCycleGameTile_type_value) return _cached_CloseAndCycleGameTile_type_value;
        _cached_CloseAndCycleGameTile_type_value = AlgebraicType.Product({ elements: [] });
        _cached_CloseAndCycleGameTile_type_value.value.elements.push(
          { name: "worldId", algebraicType: AlgebraicType.U8 }
        );
        return _cached_CloseAndCycleGameTile_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, CloseAndCycleGameTile.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, CloseAndCycleGameTile.getTypeScriptAlgebraicType());
      }
    };
    _cached_Connect_type_value = null;
    Connect = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_Connect_type_value) return _cached_Connect_type_value;
        _cached_Connect_type_value = AlgebraicType.Product({ elements: [] });
        _cached_Connect_type_value.value.elements.push();
        return _cached_Connect_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, Connect.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, Connect.getTypeScriptAlgebraicType());
      }
    };
    _cached_Disconnect_type_value = null;
    Disconnect = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_Disconnect_type_value) return _cached_Disconnect_type_value;
        _cached_Disconnect_type_value = AlgebraicType.Product({ elements: [] });
        _cached_Disconnect_type_value.value.elements.push();
        return _cached_Disconnect_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, Disconnect.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, Disconnect.getTypeScriptAlgebraicType());
      }
    };
    _cached_IncrementPfpVersion_type_value = null;
    IncrementPfpVersion = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_IncrementPfpVersion_type_value) return _cached_IncrementPfpVersion_type_value;
        _cached_IncrementPfpVersion_type_value = AlgebraicType.Product({ elements: [] });
        _cached_IncrementPfpVersion_type_value.value.elements.push();
        return _cached_IncrementPfpVersion_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, IncrementPfpVersion.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, IncrementPfpVersion.getTypeScriptAlgebraicType());
      }
    };
    _cached_SetUsername_type_value = null;
    SetUsername = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_SetUsername_type_value) return _cached_SetUsername_type_value;
        _cached_SetUsername_type_value = AlgebraicType.Product({ elements: [] });
        _cached_SetUsername_type_value.value.elements.push(
          { name: "username", algebraicType: AlgebraicType.String },
          { name: "overwriteExisting", algebraicType: AlgebraicType.Bool }
        );
        return _cached_SetUsername_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, SetUsername.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, SetUsername.getTypeScriptAlgebraicType());
      }
    };
    _cached_Account_type_value = null;
    Account = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_Account_type_value) return _cached_Account_type_value;
        _cached_Account_type_value = AlgebraicType.Product({ elements: [] });
        _cached_Account_type_value.value.elements.push(
          { name: "identity", algebraicType: AlgebraicType.createIdentityType() },
          { name: "id", algebraicType: AlgebraicType.U64 },
          { name: "isConnected", algebraicType: AlgebraicType.Bool },
          { name: "marbles", algebraicType: AlgebraicType.U32 },
          { name: "points", algebraicType: AlgebraicType.U32 },
          { name: "gold", algebraicType: AlgebraicType.U32 },
          { name: "firstLoginBonusClaimed", algebraicType: AlgebraicType.Bool },
          { name: "isMember", algebraicType: AlgebraicType.Bool },
          { name: "dailyRewardClaimStreak", algebraicType: AlgebraicType.I64 },
          { name: "lastDailyRewardClaimDay", algebraicType: AlgebraicType.I64 }
        );
        return _cached_Account_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, Account.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, Account.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertAccount_type_value = null;
    UpsertAccount = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertAccount_type_value) return _cached_UpsertAccount_type_value;
        _cached_UpsertAccount_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertAccount_type_value.value.elements.push(
          { name: "row", algebraicType: Account.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertAccount_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertAccount.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertAccount.getTypeScriptAlgebraicType());
      }
    };
    _cached_AccountSeq_type_value = null;
    AccountSeq = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_AccountSeq_type_value) return _cached_AccountSeq_type_value;
        _cached_AccountSeq_type_value = AlgebraicType.Product({ elements: [] });
        _cached_AccountSeq_type_value.value.elements.push(
          { name: "idS", algebraicType: AlgebraicType.U64 },
          { name: "seq", algebraicType: AlgebraicType.U64 }
        );
        return _cached_AccountSeq_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, AccountSeq.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, AccountSeq.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertAccountSeq_type_value = null;
    UpsertAccountSeq = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertAccountSeq_type_value) return _cached_UpsertAccountSeq_type_value;
        _cached_UpsertAccountSeq_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertAccountSeq_type_value.value.elements.push(
          { name: "row", algebraicType: AccountSeq.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertAccountSeq_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertAccountSeq.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertAccountSeq.getTypeScriptAlgebraicType());
      }
    };
    _cached_InputFrame_type_value = null;
    InputFrame = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_InputFrame_type_value) return _cached_InputFrame_type_value;
        _cached_InputFrame_type_value = AlgebraicType.Product({ elements: [] });
        _cached_InputFrame_type_value.value.elements.push(
          { name: "seq", algebraicType: AlgebraicType.U16 },
          { name: "inputEventsList", algebraicType: AlgebraicType.Array(AlgebraicType.U8) }
        );
        return _cached_InputFrame_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, InputFrame.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, InputFrame.getTypeScriptAlgebraicType());
      }
    };
    _cached_AuthFrame_type_value = null;
    AuthFrame = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_AuthFrame_type_value) return _cached_AuthFrame_type_value;
        _cached_AuthFrame_type_value = AlgebraicType.Product({ elements: [] });
        _cached_AuthFrame_type_value.value.elements.push(
          { name: "seq", algebraicType: AlgebraicType.U16 },
          { name: "frames", algebraicType: AlgebraicType.Array(InputFrame.getTypeScriptAlgebraicType()) }
        );
        return _cached_AuthFrame_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, AuthFrame.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, AuthFrame.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertAuthFrame_type_value = null;
    UpsertAuthFrame = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertAuthFrame_type_value) return _cached_UpsertAuthFrame_type_value;
        _cached_UpsertAuthFrame_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertAuthFrame_type_value.value.elements.push(
          { name: "row", algebraicType: AuthFrame.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertAuthFrame_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertAuthFrame.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertAuthFrame.getTypeScriptAlgebraicType());
      }
    };
    _cached_BaseCfg_type_value = null;
    BaseCfg = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_BaseCfg_type_value) return _cached_BaseCfg_type_value;
        _cached_BaseCfg_type_value = AlgebraicType.Product({ elements: [] });
        _cached_BaseCfg_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "clockIntervalSec", algebraicType: AlgebraicType.F64 },
          { name: "targetStepsPerSecond", algebraicType: AlgebraicType.U16 },
          { name: "physicsStepsPerBatch", algebraicType: AlgebraicType.U16 },
          { name: "stepsPerAuthFrame", algebraicType: AlgebraicType.U16 },
          { name: "authFrameTimeErrorThresholdSec", algebraicType: AlgebraicType.F64 },
          { name: "logInputFrameTimes", algebraicType: AlgebraicType.Bool },
          { name: "logAuthFrameTimeDiffs", algebraicType: AlgebraicType.Bool },
          { name: "gcCacheAccountTimeoutMinutes", algebraicType: AlgebraicType.F64 }
        );
        return _cached_BaseCfg_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, BaseCfg.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, BaseCfg.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertBaseCfg_type_value = null;
    UpsertBaseCfg = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertBaseCfg_type_value) return _cached_UpsertBaseCfg_type_value;
        _cached_UpsertBaseCfg_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertBaseCfg_type_value.value.elements.push(
          { name: "row", algebraicType: BaseCfg.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertBaseCfg_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertBaseCfg.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertBaseCfg.getTypeScriptAlgebraicType());
      }
    };
    _cached_InputCollector_type_value = null;
    InputCollector = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_InputCollector_type_value) return _cached_InputCollector_type_value;
        _cached_InputCollector_type_value = AlgebraicType.Product({ elements: [] });
        _cached_InputCollector_type_value.value.elements.push(
          { name: "delaySeqs", algebraicType: AlgebraicType.U16 },
          { name: "inputEventData", algebraicType: AlgebraicType.Array(AlgebraicType.U8) }
        );
        return _cached_InputCollector_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, InputCollector.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, InputCollector.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertInputCollector_type_value = null;
    UpsertInputCollector = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertInputCollector_type_value) return _cached_UpsertInputCollector_type_value;
        _cached_UpsertInputCollector_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertInputCollector_type_value.value.elements.push(
          { name: "row", algebraicType: InputCollector.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertInputCollector_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertInputCollector.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertInputCollector.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertInputFrame_type_value = null;
    UpsertInputFrame = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertInputFrame_type_value) return _cached_UpsertInputFrame_type_value;
        _cached_UpsertInputFrame_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertInputFrame_type_value.value.elements.push(
          { name: "row", algebraicType: InputFrame.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertInputFrame_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertInputFrame.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertInputFrame.getTypeScriptAlgebraicType());
      }
    };
    _cached_LevelFileData_type_value = null;
    LevelFileData = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_LevelFileData_type_value) return _cached_LevelFileData_type_value;
        _cached_LevelFileData_type_value = AlgebraicType.Product({ elements: [] });
        _cached_LevelFileData_type_value.value.elements.push(
          { name: "unityPrefabGuid", algebraicType: AlgebraicType.String },
          { name: "levelFileBinary", algebraicType: AlgebraicType.Array(AlgebraicType.U8) }
        );
        return _cached_LevelFileData_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, LevelFileData.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, LevelFileData.getTypeScriptAlgebraicType());
      }
    };
    _cached_UpsertLevelFileData_type_value = null;
    UpsertLevelFileData = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_UpsertLevelFileData_type_value) return _cached_UpsertLevelFileData_type_value;
        _cached_UpsertLevelFileData_type_value = AlgebraicType.Product({ elements: [] });
        _cached_UpsertLevelFileData_type_value.value.elements.push(
          { name: "levelFileData", algebraicType: LevelFileData.getTypeScriptAlgebraicType() }
        );
        return _cached_UpsertLevelFileData_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, UpsertLevelFileData.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, UpsertLevelFileData.getTypeScriptAlgebraicType());
      }
    };
    AccountTableHandle = class {
      static {
        __name(this, "AccountTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `identity` unique index on the table `Account`,
       * which allows point queries on the field of the same name
       * via the [`AccountIdentityUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.account.identity().find(...)`.
       *
       * Get a handle on the `identity` unique index on the table `Account`.
       */
      identity = {
        // Find the subscribed row whose `identity` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.identity, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      /**
       * Access to the `id` unique index on the table `Account`,
       * which allows point queries on the field of the same name
       * via the [`AccountIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.account.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `Account`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_AccountCustomization_type_value = null;
    AccountCustomization = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_AccountCustomization_type_value) return _cached_AccountCustomization_type_value;
        _cached_AccountCustomization_type_value = AlgebraicType.Product({ elements: [] });
        _cached_AccountCustomization_type_value.value.elements.push(
          { name: "accountId", algebraicType: AlgebraicType.U64 },
          { name: "username", algebraicType: AlgebraicType.String },
          { name: "pfpVersion", algebraicType: AlgebraicType.U8 }
        );
        return _cached_AccountCustomization_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, AccountCustomization.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, AccountCustomization.getTypeScriptAlgebraicType());
      }
    };
    AccountCustomizationTableHandle = class {
      static {
        __name(this, "AccountCustomizationTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `accountId` unique index on the table `AccountCustomization`,
       * which allows point queries on the field of the same name
       * via the [`AccountCustomizationAccountIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.accountCustomization.accountId().find(...)`.
       *
       * Get a handle on the `accountId` unique index on the table `AccountCustomization`.
       */
      accountId = {
        // Find the subscribed row whose `accountId` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.accountId, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    AccountSeqTableHandle = class {
      static {
        __name(this, "AccountSeqTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `idS` unique index on the table `AccountSeq`,
       * which allows point queries on the field of the same name
       * via the [`AccountSeqIdSUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.accountSeq.idS().find(...)`.
       *
       * Get a handle on the `idS` unique index on the table `AccountSeq`.
       */
      idS = {
        // Find the subscribed row whose `idS` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.idS, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_Admin_type_value = null;
    Admin = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_Admin_type_value) return _cached_Admin_type_value;
        _cached_Admin_type_value = AlgebraicType.Product({ elements: [] });
        _cached_Admin_type_value.value.elements.push(
          { name: "adminIdentity", algebraicType: AlgebraicType.createIdentityType() }
        );
        return _cached_Admin_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, Admin.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, Admin.getTypeScriptAlgebraicType());
      }
    };
    AdminTableHandle = class {
      static {
        __name(this, "AdminTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `adminIdentity` unique index on the table `Admin`,
       * which allows point queries on the field of the same name
       * via the [`AdminAdminIdentityUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.admin.adminIdentity().find(...)`.
       *
       * Get a handle on the `adminIdentity` unique index on the table `Admin`.
       */
      adminIdentity = {
        // Find the subscribed row whose `adminIdentity` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.adminIdentity, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    AuthFrameTableHandle = class {
      static {
        __name(this, "AuthFrameTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `seq` unique index on the table `AuthFrame`,
       * which allows point queries on the field of the same name
       * via the [`AuthFrameSeqUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.authFrame.seq().find(...)`.
       *
       * Get a handle on the `seq` unique index on the table `AuthFrame`.
       */
      seq = {
        // Find the subscribed row whose `seq` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.seq, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    BaseCfgTableHandle = class {
      static {
        __name(this, "BaseCfgTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `BaseCfg`,
       * which allows point queries on the field of the same name
       * via the [`BaseCfgIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.baseCfg.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `BaseCfg`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_Clock_type_value = null;
    Clock = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_Clock_type_value) return _cached_Clock_type_value;
        _cached_Clock_type_value = AlgebraicType.Product({ elements: [] });
        _cached_Clock_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "prevClockUpdate", algebraicType: AlgebraicType.createTimestampType() },
          { name: "tickTimeAccumulatorSec", algebraicType: AlgebraicType.F32 }
        );
        return _cached_Clock_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, Clock.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, Clock.getTypeScriptAlgebraicType());
      }
    };
    ClockTableHandle = class {
      static {
        __name(this, "ClockTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `Clock`,
       * which allows point queries on the field of the same name
       * via the [`ClockIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.clock.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `Clock`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    ClockScheduleTableHandle = class {
      static {
        __name(this, "ClockScheduleTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `ClockSchedule`,
       * which allows point queries on the field of the same name
       * via the [`ClockScheduleIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.clockSchedule.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `ClockSchedule`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_DeterminismCheck_type_value = null;
    DeterminismCheck = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_DeterminismCheck_type_value) return _cached_DeterminismCheck_type_value;
        _cached_DeterminismCheck_type_value = AlgebraicType.Product({ elements: [] });
        _cached_DeterminismCheck_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "seq", algebraicType: AlgebraicType.U16 },
          { name: "hashString", algebraicType: AlgebraicType.String }
        );
        return _cached_DeterminismCheck_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, DeterminismCheck.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, DeterminismCheck.getTypeScriptAlgebraicType());
      }
    };
    DeterminismCheckTableHandle = class {
      static {
        __name(this, "DeterminismCheckTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `DeterminismCheck`,
       * which allows point queries on the field of the same name
       * via the [`DeterminismCheckIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.determinismCheck.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `DeterminismCheck`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_GameCoreSnap_type_value = null;
    GameCoreSnap = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_GameCoreSnap_type_value) return _cached_GameCoreSnap_type_value;
        _cached_GameCoreSnap_type_value = AlgebraicType.Product({ elements: [] });
        _cached_GameCoreSnap_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "seq", algebraicType: AlgebraicType.U16 },
          { name: "binaryData", algebraicType: AlgebraicType.Array(AlgebraicType.U8) }
        );
        return _cached_GameCoreSnap_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, GameCoreSnap.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, GameCoreSnap.getTypeScriptAlgebraicType());
      }
    };
    GameCoreSnapTableHandle = class {
      static {
        __name(this, "GameCoreSnapTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `GameCoreSnap`,
       * which allows point queries on the field of the same name
       * via the [`GameCoreSnapIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.gameCoreSnap.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `GameCoreSnap`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    InputCollectorTableHandle = class {
      static {
        __name(this, "InputCollectorTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
    };
    InputFrameTableHandle = class {
      static {
        __name(this, "InputFrameTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `seq` unique index on the table `InputFrame`,
       * which allows point queries on the field of the same name
       * via the [`InputFrameSeqUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.inputFrame.seq().find(...)`.
       *
       * Get a handle on the `seq` unique index on the table `InputFrame`.
       */
      seq = {
        // Find the subscribed row whose `seq` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.seq, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_LastAuthFrameTimestamp_type_value = null;
    LastAuthFrameTimestamp = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_LastAuthFrameTimestamp_type_value) return _cached_LastAuthFrameTimestamp_type_value;
        _cached_LastAuthFrameTimestamp_type_value = AlgebraicType.Product({ elements: [] });
        _cached_LastAuthFrameTimestamp_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "lastAuthFrameTime", algebraicType: AlgebraicType.createTimestampType() }
        );
        return _cached_LastAuthFrameTimestamp_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, LastAuthFrameTimestamp.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, LastAuthFrameTimestamp.getTypeScriptAlgebraicType());
      }
    };
    LastAuthFrameTimestampTableHandle = class {
      static {
        __name(this, "LastAuthFrameTimestampTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `LastAuthFrameTimestamp`,
       * which allows point queries on the field of the same name
       * via the [`LastAuthFrameTimestampIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.lastAuthFrameTimestamp.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `LastAuthFrameTimestamp`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    LevelFileDataTableHandle = class {
      static {
        __name(this, "LevelFileDataTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `unityPrefabGuid` unique index on the table `LevelFileData`,
       * which allows point queries on the field of the same name
       * via the [`LevelFileDataUnityPrefabGuidUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.levelFileData.unityPrefabGuid().find(...)`.
       *
       * Get a handle on the `unityPrefabGuid` unique index on the table `LevelFileData`.
       */
      unityPrefabGuid = {
        // Find the subscribed row whose `unityPrefabGuid` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.unityPrefabGuid, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_Seq_type_value = null;
    Seq = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_Seq_type_value) return _cached_Seq_type_value;
        _cached_Seq_type_value = AlgebraicType.Product({ elements: [] });
        _cached_Seq_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "value", algebraicType: AlgebraicType.U16 }
        );
        return _cached_Seq_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, Seq.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, Seq.getTypeScriptAlgebraicType());
      }
    };
    SeqTableHandle = class {
      static {
        __name(this, "SeqTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `Seq`,
       * which allows point queries on the field of the same name
       * via the [`SeqIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.seq.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `Seq`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_StepsSinceLastAuthFrame_type_value = null;
    StepsSinceLastAuthFrame = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_StepsSinceLastAuthFrame_type_value) return _cached_StepsSinceLastAuthFrame_type_value;
        _cached_StepsSinceLastAuthFrame_type_value = AlgebraicType.Product({ elements: [] });
        _cached_StepsSinceLastAuthFrame_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "value", algebraicType: AlgebraicType.U16 }
        );
        return _cached_StepsSinceLastAuthFrame_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, StepsSinceLastAuthFrame.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, StepsSinceLastAuthFrame.getTypeScriptAlgebraicType());
      }
    };
    StepsSinceLastAuthFrameTableHandle = class {
      static {
        __name(this, "StepsSinceLastAuthFrameTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `StepsSinceLastAuthFrame`,
       * which allows point queries on the field of the same name
       * via the [`StepsSinceLastAuthFrameIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.stepsSinceLastAuthFrame.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `StepsSinceLastAuthFrame`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    _cached_StepsSinceLastBatch_type_value = null;
    StepsSinceLastBatch = {
      /**
      * A function which returns this type represented as an AlgebraicType.
      * This function is derived from the AlgebraicType used to generate this type.
      */
      getTypeScriptAlgebraicType() {
        if (_cached_StepsSinceLastBatch_type_value) return _cached_StepsSinceLastBatch_type_value;
        _cached_StepsSinceLastBatch_type_value = AlgebraicType.Product({ elements: [] });
        _cached_StepsSinceLastBatch_type_value.value.elements.push(
          { name: "id", algebraicType: AlgebraicType.U8 },
          { name: "value", algebraicType: AlgebraicType.U16 }
        );
        return _cached_StepsSinceLastBatch_type_value;
      },
      serialize(writer, value) {
        AlgebraicType.serializeValue(writer, StepsSinceLastBatch.getTypeScriptAlgebraicType(), value);
      },
      deserialize(reader) {
        return AlgebraicType.deserializeValue(reader, StepsSinceLastBatch.getTypeScriptAlgebraicType());
      }
    };
    StepsSinceLastBatchTableHandle = class {
      static {
        __name(this, "StepsSinceLastBatchTableHandle");
      }
      // phantom type to track the table name
      tableName;
      tableCache;
      constructor(tableCache) {
        this.tableCache = tableCache;
      }
      count() {
        return this.tableCache.count();
      }
      iter() {
        return this.tableCache.iter();
      }
      /**
       * Access to the `id` unique index on the table `StepsSinceLastBatch`,
       * which allows point queries on the field of the same name
       * via the [`StepsSinceLastBatchIdUnique.find`] method.
       *
       * Users are encouraged not to explicitly reference this type,
       * but to directly chain method calls,
       * like `ctx.db.stepsSinceLastBatch.id().find(...)`.
       *
       * Get a handle on the `id` unique index on the table `StepsSinceLastBatch`.
       */
      id = {
        // Find the subscribed row whose `id` column value is equal to `col_val`,
        // if such a row is present in the client cache.
        find: /* @__PURE__ */ __name((col_val) => {
          for (let row of this.tableCache.iter()) {
            if (deepEqual(row.id, col_val)) {
              return row;
            }
          }
        }, "find")
      };
      onInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onInsert(cb);
      }, "onInsert");
      removeOnInsert = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnInsert(cb);
      }, "removeOnInsert");
      onDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onDelete(cb);
      }, "onDelete");
      removeOnDelete = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnDelete(cb);
      }, "removeOnDelete");
      // Updates are only defined for tables with primary keys.
      onUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.onUpdate(cb);
      }, "onUpdate");
      removeOnUpdate = /* @__PURE__ */ __name((cb) => {
        return this.tableCache.removeOnUpdate(cb);
      }, "removeOnUpdate");
    };
    REMOTE_MODULE = {
      tables: {
        Account: {
          tableName: "Account",
          rowType: Account.getTypeScriptAlgebraicType(),
          primaryKey: "identity",
          primaryKeyInfo: {
            colName: "identity",
            colType: Account.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        AccountCustomization: {
          tableName: "AccountCustomization",
          rowType: AccountCustomization.getTypeScriptAlgebraicType(),
          primaryKey: "accountId",
          primaryKeyInfo: {
            colName: "accountId",
            colType: AccountCustomization.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        AccountSeq: {
          tableName: "AccountSeq",
          rowType: AccountSeq.getTypeScriptAlgebraicType(),
          primaryKey: "idS",
          primaryKeyInfo: {
            colName: "idS",
            colType: AccountSeq.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        Admin: {
          tableName: "Admin",
          rowType: Admin.getTypeScriptAlgebraicType(),
          primaryKey: "adminIdentity",
          primaryKeyInfo: {
            colName: "adminIdentity",
            colType: Admin.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        AuthFrame: {
          tableName: "AuthFrame",
          rowType: AuthFrame.getTypeScriptAlgebraicType(),
          primaryKey: "seq",
          primaryKeyInfo: {
            colName: "seq",
            colType: AuthFrame.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        BaseCfg: {
          tableName: "BaseCfg",
          rowType: BaseCfg.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: BaseCfg.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        Clock: {
          tableName: "Clock",
          rowType: Clock.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: Clock.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        ClockSchedule: {
          tableName: "ClockSchedule",
          rowType: ClockSchedule.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: ClockSchedule.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        DeterminismCheck: {
          tableName: "DeterminismCheck",
          rowType: DeterminismCheck.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: DeterminismCheck.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        GameCoreSnap: {
          tableName: "GameCoreSnap",
          rowType: GameCoreSnap.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: GameCoreSnap.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        InputCollector: {
          tableName: "InputCollector",
          rowType: InputCollector.getTypeScriptAlgebraicType()
        },
        InputFrame: {
          tableName: "InputFrame",
          rowType: InputFrame.getTypeScriptAlgebraicType(),
          primaryKey: "seq",
          primaryKeyInfo: {
            colName: "seq",
            colType: InputFrame.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        LastAuthFrameTimestamp: {
          tableName: "LastAuthFrameTimestamp",
          rowType: LastAuthFrameTimestamp.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: LastAuthFrameTimestamp.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        LevelFileData: {
          tableName: "LevelFileData",
          rowType: LevelFileData.getTypeScriptAlgebraicType(),
          primaryKey: "unityPrefabGuid",
          primaryKeyInfo: {
            colName: "unityPrefabGuid",
            colType: LevelFileData.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        Seq: {
          tableName: "Seq",
          rowType: Seq.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: Seq.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        StepsSinceLastAuthFrame: {
          tableName: "StepsSinceLastAuthFrame",
          rowType: StepsSinceLastAuthFrame.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: StepsSinceLastAuthFrame.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        },
        StepsSinceLastBatch: {
          tableName: "StepsSinceLastBatch",
          rowType: StepsSinceLastBatch.getTypeScriptAlgebraicType(),
          primaryKey: "id",
          primaryKeyInfo: {
            colName: "id",
            colType: StepsSinceLastBatch.getTypeScriptAlgebraicType().value.elements[0].algebraicType
          }
        }
      },
      reducers: {
        ClockUpdate: {
          reducerName: "ClockUpdate",
          argsType: ClockUpdate.getTypeScriptAlgebraicType()
        },
        CloseAndCycleGameTile: {
          reducerName: "CloseAndCycleGameTile",
          argsType: CloseAndCycleGameTile.getTypeScriptAlgebraicType()
        },
        Connect: {
          reducerName: "Connect",
          argsType: Connect.getTypeScriptAlgebraicType()
        },
        Disconnect: {
          reducerName: "Disconnect",
          argsType: Disconnect.getTypeScriptAlgebraicType()
        },
        IncrementPfpVersion: {
          reducerName: "IncrementPfpVersion",
          argsType: IncrementPfpVersion.getTypeScriptAlgebraicType()
        },
        SetUsername: {
          reducerName: "SetUsername",
          argsType: SetUsername.getTypeScriptAlgebraicType()
        },
        UpsertAccount: {
          reducerName: "UpsertAccount",
          argsType: UpsertAccount.getTypeScriptAlgebraicType()
        },
        UpsertAccountSeq: {
          reducerName: "UpsertAccountSeq",
          argsType: UpsertAccountSeq.getTypeScriptAlgebraicType()
        },
        UpsertAuthFrame: {
          reducerName: "UpsertAuthFrame",
          argsType: UpsertAuthFrame.getTypeScriptAlgebraicType()
        },
        UpsertBaseCfg: {
          reducerName: "UpsertBaseCfg",
          argsType: UpsertBaseCfg.getTypeScriptAlgebraicType()
        },
        UpsertInputCollector: {
          reducerName: "UpsertInputCollector",
          argsType: UpsertInputCollector.getTypeScriptAlgebraicType()
        },
        UpsertInputFrame: {
          reducerName: "UpsertInputFrame",
          argsType: UpsertInputFrame.getTypeScriptAlgebraicType()
        },
        UpsertLevelFileData: {
          reducerName: "UpsertLevelFileData",
          argsType: UpsertLevelFileData.getTypeScriptAlgebraicType()
        }
      },
      versionInfo: {
        cliVersion: "1.8.0"
      },
      // Constructors which are used by the DbConnectionImpl to
      // extract type information from the generated RemoteModule.
      //
      // NOTE: This is not strictly necessary for `eventContextConstructor` because
      // all we do is build a TypeScript object which we could have done inside the
      // SDK, but if in the future we wanted to create a class this would be
      // necessary because classes have methods, so we'll keep it.
      eventContextConstructor: /* @__PURE__ */ __name((imp, event) => {
        return {
          ...imp,
          event
        };
      }, "eventContextConstructor"),
      dbViewConstructor: /* @__PURE__ */ __name((imp) => {
        return new RemoteTables(imp);
      }, "dbViewConstructor"),
      reducersConstructor: /* @__PURE__ */ __name((imp, setReducerFlags) => {
        return new RemoteReducers(imp, setReducerFlags);
      }, "reducersConstructor"),
      setReducerFlagsConstructor: /* @__PURE__ */ __name(() => {
        return new SetReducerFlags();
      }, "setReducerFlagsConstructor")
    };
    RemoteReducers = class {
      static {
        __name(this, "RemoteReducers");
      }
      constructor(connection, setCallReducerFlags) {
        this.connection = connection;
        this.setCallReducerFlags = setCallReducerFlags;
      }
      clockUpdate(schedule) {
        const __args = { schedule };
        let __writer = new BinaryWriter(1024);
        ClockUpdate.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("ClockUpdate", __argsBuffer, this.setCallReducerFlags.clockUpdateFlags);
      }
      onClockUpdate(callback) {
        this.connection.onReducer("ClockUpdate", callback);
      }
      removeOnClockUpdate(callback) {
        this.connection.offReducer("ClockUpdate", callback);
      }
      closeAndCycleGameTile(worldId) {
        const __args = { worldId };
        let __writer = new BinaryWriter(1024);
        CloseAndCycleGameTile.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("CloseAndCycleGameTile", __argsBuffer, this.setCallReducerFlags.closeAndCycleGameTileFlags);
      }
      onCloseAndCycleGameTile(callback) {
        this.connection.onReducer("CloseAndCycleGameTile", callback);
      }
      removeOnCloseAndCycleGameTile(callback) {
        this.connection.offReducer("CloseAndCycleGameTile", callback);
      }
      onConnect(callback) {
        this.connection.onReducer("Connect", callback);
      }
      removeOnConnect(callback) {
        this.connection.offReducer("Connect", callback);
      }
      onDisconnect(callback) {
        this.connection.onReducer("Disconnect", callback);
      }
      removeOnDisconnect(callback) {
        this.connection.offReducer("Disconnect", callback);
      }
      incrementPfpVersion() {
        this.connection.callReducer("IncrementPfpVersion", new Uint8Array(0), this.setCallReducerFlags.incrementPfpVersionFlags);
      }
      onIncrementPfpVersion(callback) {
        this.connection.onReducer("IncrementPfpVersion", callback);
      }
      removeOnIncrementPfpVersion(callback) {
        this.connection.offReducer("IncrementPfpVersion", callback);
      }
      setUsername(username, overwriteExisting) {
        const __args = { username, overwriteExisting };
        let __writer = new BinaryWriter(1024);
        SetUsername.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("SetUsername", __argsBuffer, this.setCallReducerFlags.setUsernameFlags);
      }
      onSetUsername(callback) {
        this.connection.onReducer("SetUsername", callback);
      }
      removeOnSetUsername(callback) {
        this.connection.offReducer("SetUsername", callback);
      }
      upsertAccount(row) {
        const __args = { row };
        let __writer = new BinaryWriter(1024);
        UpsertAccount.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertAccount", __argsBuffer, this.setCallReducerFlags.upsertAccountFlags);
      }
      onUpsertAccount(callback) {
        this.connection.onReducer("UpsertAccount", callback);
      }
      removeOnUpsertAccount(callback) {
        this.connection.offReducer("UpsertAccount", callback);
      }
      upsertAccountSeq(row) {
        const __args = { row };
        let __writer = new BinaryWriter(1024);
        UpsertAccountSeq.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertAccountSeq", __argsBuffer, this.setCallReducerFlags.upsertAccountSeqFlags);
      }
      onUpsertAccountSeq(callback) {
        this.connection.onReducer("UpsertAccountSeq", callback);
      }
      removeOnUpsertAccountSeq(callback) {
        this.connection.offReducer("UpsertAccountSeq", callback);
      }
      upsertAuthFrame(row) {
        const __args = { row };
        let __writer = new BinaryWriter(1024);
        UpsertAuthFrame.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertAuthFrame", __argsBuffer, this.setCallReducerFlags.upsertAuthFrameFlags);
      }
      onUpsertAuthFrame(callback) {
        this.connection.onReducer("UpsertAuthFrame", callback);
      }
      removeOnUpsertAuthFrame(callback) {
        this.connection.offReducer("UpsertAuthFrame", callback);
      }
      upsertBaseCfg(row) {
        const __args = { row };
        let __writer = new BinaryWriter(1024);
        UpsertBaseCfg.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertBaseCfg", __argsBuffer, this.setCallReducerFlags.upsertBaseCfgFlags);
      }
      onUpsertBaseCfg(callback) {
        this.connection.onReducer("UpsertBaseCfg", callback);
      }
      removeOnUpsertBaseCfg(callback) {
        this.connection.offReducer("UpsertBaseCfg", callback);
      }
      upsertInputCollector(row) {
        const __args = { row };
        let __writer = new BinaryWriter(1024);
        UpsertInputCollector.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertInputCollector", __argsBuffer, this.setCallReducerFlags.upsertInputCollectorFlags);
      }
      onUpsertInputCollector(callback) {
        this.connection.onReducer("UpsertInputCollector", callback);
      }
      removeOnUpsertInputCollector(callback) {
        this.connection.offReducer("UpsertInputCollector", callback);
      }
      upsertInputFrame(row) {
        const __args = { row };
        let __writer = new BinaryWriter(1024);
        UpsertInputFrame.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertInputFrame", __argsBuffer, this.setCallReducerFlags.upsertInputFrameFlags);
      }
      onUpsertInputFrame(callback) {
        this.connection.onReducer("UpsertInputFrame", callback);
      }
      removeOnUpsertInputFrame(callback) {
        this.connection.offReducer("UpsertInputFrame", callback);
      }
      upsertLevelFileData(levelFileData) {
        const __args = { levelFileData };
        let __writer = new BinaryWriter(1024);
        UpsertLevelFileData.serialize(__writer, __args);
        let __argsBuffer = __writer.getBuffer();
        this.connection.callReducer("UpsertLevelFileData", __argsBuffer, this.setCallReducerFlags.upsertLevelFileDataFlags);
      }
      onUpsertLevelFileData(callback) {
        this.connection.onReducer("UpsertLevelFileData", callback);
      }
      removeOnUpsertLevelFileData(callback) {
        this.connection.offReducer("UpsertLevelFileData", callback);
      }
    };
    SetReducerFlags = class {
      static {
        __name(this, "SetReducerFlags");
      }
      clockUpdateFlags = "FullUpdate";
      clockUpdate(flags2) {
        this.clockUpdateFlags = flags2;
      }
      closeAndCycleGameTileFlags = "FullUpdate";
      closeAndCycleGameTile(flags2) {
        this.closeAndCycleGameTileFlags = flags2;
      }
      incrementPfpVersionFlags = "FullUpdate";
      incrementPfpVersion(flags2) {
        this.incrementPfpVersionFlags = flags2;
      }
      setUsernameFlags = "FullUpdate";
      setUsername(flags2) {
        this.setUsernameFlags = flags2;
      }
      upsertAccountFlags = "FullUpdate";
      upsertAccount(flags2) {
        this.upsertAccountFlags = flags2;
      }
      upsertAccountSeqFlags = "FullUpdate";
      upsertAccountSeq(flags2) {
        this.upsertAccountSeqFlags = flags2;
      }
      upsertAuthFrameFlags = "FullUpdate";
      upsertAuthFrame(flags2) {
        this.upsertAuthFrameFlags = flags2;
      }
      upsertBaseCfgFlags = "FullUpdate";
      upsertBaseCfg(flags2) {
        this.upsertBaseCfgFlags = flags2;
      }
      upsertInputCollectorFlags = "FullUpdate";
      upsertInputCollector(flags2) {
        this.upsertInputCollectorFlags = flags2;
      }
      upsertInputFrameFlags = "FullUpdate";
      upsertInputFrame(flags2) {
        this.upsertInputFrameFlags = flags2;
      }
      upsertLevelFileDataFlags = "FullUpdate";
      upsertLevelFileData(flags2) {
        this.upsertLevelFileDataFlags = flags2;
      }
    };
    RemoteTables = class {
      static {
        __name(this, "RemoteTables");
      }
      constructor(connection) {
        this.connection = connection;
      }
      get account() {
        return new AccountTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.Account));
      }
      get accountCustomization() {
        return new AccountCustomizationTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.AccountCustomization));
      }
      get accountSeq() {
        return new AccountSeqTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.AccountSeq));
      }
      get admin() {
        return new AdminTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.Admin));
      }
      get authFrame() {
        return new AuthFrameTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.AuthFrame));
      }
      get baseCfg() {
        return new BaseCfgTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.BaseCfg));
      }
      get clock() {
        return new ClockTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.Clock));
      }
      get clockSchedule() {
        return new ClockScheduleTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.ClockSchedule));
      }
      get determinismCheck() {
        return new DeterminismCheckTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.DeterminismCheck));
      }
      get gameCoreSnap() {
        return new GameCoreSnapTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.GameCoreSnap));
      }
      get inputCollector() {
        return new InputCollectorTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.InputCollector));
      }
      get inputFrame() {
        return new InputFrameTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.InputFrame));
      }
      get lastAuthFrameTimestamp() {
        return new LastAuthFrameTimestampTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.LastAuthFrameTimestamp));
      }
      get levelFileData() {
        return new LevelFileDataTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.LevelFileData));
      }
      get seq() {
        return new SeqTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.Seq));
      }
      get stepsSinceLastAuthFrame() {
        return new StepsSinceLastAuthFrameTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.StepsSinceLastAuthFrame));
      }
      get stepsSinceLastBatch() {
        return new StepsSinceLastBatchTableHandle(this.connection.clientCache.getOrCreateTable(REMOTE_MODULE.tables.StepsSinceLastBatch));
      }
    };
    SubscriptionBuilder = class extends SubscriptionBuilderImpl {
      static {
        __name(this, "SubscriptionBuilder");
      }
    };
    DbConnection = class extends DbConnectionImpl {
      static {
        __name(this, "DbConnection");
      }
      static builder = /* @__PURE__ */ __name(() => {
        return new DbConnectionBuilder(REMOTE_MODULE, (imp) => imp);
      }, "builder");
      subscriptionBuilder = /* @__PURE__ */ __name(() => {
        return new SubscriptionBuilder(this);
      }, "subscriptionBuilder");
    };
    PROFILE_STORAGE_PREFIX = "pfp/";
    MAX_PROFILE_VERSION = 255;
    PFP_MAX_BYTES = 2 * 1024 * 1024;
    ACCEPTED_IMAGE_TYPES = [
      "image/png",
      "image/jpeg",
      "image/jpg",
      "image/webp",
      "image/gif",
      "image/bmp",
      "image/tiff"
    ];
    __name(subscribeAndWait, "subscribeAndWait");
    __name(connectToSpacetimeDb, "connectToSpacetimeDb");
    __name(resolveAccountData, "resolveAccountData");
    __name(uploadProfilePictureToR2, "uploadProfilePictureToR2");
    __name(buildProfilePictureUrl, "buildProfilePictureUrl");
    __name(downloadImageFromUrl, "downloadImageFromUrl");
    __name(detectImageType, "detectImageType");
    __name(convertToPng, "convertToPng");
    POST = /* @__PURE__ */ __name(async ({ request, platform: platform2 }) => {
      console.log("[Profile] Starting POST request");
      const env3 = platform2?.env;
      if (!env3) {
        console.error("[Profile] Platform environment is not available");
        throw error3(500, "Platform environment is not available");
      }
      const authHeader = request.headers.get("authorization") ?? request.headers.get("Authorization");
      console.log(
        `[Profile] Auth header present: ${!!authHeader}, starts with Bearer: ${authHeader?.startsWith("Bearer ")}`
      );
      if (!authHeader?.startsWith("Bearer ")) {
        console.error("[Profile] Missing or invalid auth header");
        throw error3(401, "An ID token is required to upload profile pictures");
      }
      const token = authHeader.slice(7).trim();
      if (!token) {
        console.error("[Profile] Token is empty after extracting from header");
        throw error3(401, "An ID token is required to upload profile pictures");
      }
      console.log(`[Profile] Received token (first 20 chars): ${token.substring(0, 20)}...`);
      const contentType = request.headers.get("content-type") ?? "";
      let imageBytes;
      let imageMimeType;
      let userIdentity = null;
      if (contentType.includes("multipart/form-data")) {
        const formData = await request.formData();
        const image = formData.get("image");
        const identityField = formData.get("identity");
        if (!(image instanceof File)) {
          throw error3(400, "The request must include an image file");
        }
        if (!identityField || typeof identityField !== "string") {
          throw error3(400, "The request must include an identity");
        }
        try {
          userIdentity = Identity.fromString(identityField);
        } catch {
          throw error3(400, "Invalid identity format");
        }
        if (!ACCEPTED_IMAGE_TYPES.includes(image.type)) {
          throw error3(400, `Profile pictures must be one of: ${ACCEPTED_IMAGE_TYPES.join(", ")}`);
        }
        if (image.size > PFP_MAX_BYTES) {
          throw error3(
            400,
            `Profile pictures must be smaller than ${PFP_MAX_BYTES / 1024 / 1024}MB`
          );
        }
        imageBytes = new Uint8Array(await image.arrayBuffer());
        imageMimeType = image.type;
        console.log(`[Profile] Received ${imageBytes.length} bytes ${imageMimeType} upload`);
      } else if (contentType.includes("application/json")) {
        const body2 = await request.json();
        if (!body2.imageUrl || typeof body2.imageUrl !== "string") {
          throw error3(400, "Request must include an imageUrl");
        }
        if (!body2.identity || typeof body2.identity !== "string") {
          throw error3(400, "Request must include an identity");
        }
        try {
          new URL(body2.imageUrl);
        } catch {
          throw error3(400, "Invalid imageUrl provided");
        }
        try {
          userIdentity = Identity.fromString(body2.identity);
        } catch {
          throw error3(400, "Invalid identity format");
        }
        console.log("[Profile] Downloading image from URL:", body2.imageUrl);
        try {
          const downloaded = await downloadImageFromUrl(body2.imageUrl);
          imageBytes = downloaded.bytes;
          imageMimeType = downloaded.contentType;
        } catch (err) {
          console.error("[Profile] Failed to download image:", err);
          throw error3(400, "Failed to download image from URL");
        }
      } else {
        throw error3(400, "Request must be multipart/form-data or application/json");
      }
      if (!userIdentity) {
        throw error3(400, "Identity is required");
      }
      console.log(`[Profile] User identity: ${userIdentity.toHexString()}`);
      const detectedType = detectImageType(imageBytes);
      console.log(`[Profile] Detected original image type: ${detectedType}`);
      let pngBytes;
      try {
        pngBytes = await convertToPng(imageBytes);
      } catch (err) {
        console.error("[Profile] Failed to convert image to PNG:", err);
        throw error3(400, "Failed to process image. Please ensure it's a valid image file.");
      }
      let connection = null;
      let accountId = 0n;
      let currentVersion = 0;
      try {
        console.log("[Profile] Attempting to connect to SpacetimeDB with admin token...");
        const connectionResult = await connectToSpacetimeDb(env3);
        console.log(
          "[Profile] Connected to SpacetimeDB as admin, identity:",
          connectionResult.identity.toHexString()
        );
        connection = connectionResult.connection;
        const accountData = await resolveAccountData(connection, userIdentity);
        accountId = accountData.accountId;
        currentVersion = accountData.currentVersion;
        console.log(`[Profile] Resolved account ${accountId} with pfp version ${currentVersion}`);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : String(err);
        const errorStack = err instanceof Error ? err.stack : void 0;
        console.error("[Profile] Failed to resolve account data:", errorMessage);
        console.error("[Profile] Error stack:", errorStack);
        connection?.disconnect();
        if (err && typeof err === "object" && "status" in err) {
          throw err;
        }
        throw error3(401, `Unable to verify your SpacetimeDB account: ${errorMessage}`);
      }
      if (!connection) {
        throw error3(500, "SpacetimeDB connection is not available");
      }
      const activeConnection = connection;
      const bucket = env3.MARBLES_BUCKET_BINDING;
      if (!bucket) {
        console.error("[Profile] R2 bucket binding not available");
        throw error3(500, "Profile picture storage is not configured");
      }
      const objectKey = `${PROFILE_STORAGE_PREFIX}${accountId.toString()}.png`;
      const nextVersion = Math.min(currentVersion + 1, MAX_PROFILE_VERSION);
      try {
        console.log(`[Profile] Uploading ${pngBytes.length} bytes PNG to R2 as ${objectKey}`);
        await uploadProfilePictureToR2(bucket, objectKey, pngBytes, "image/png");
        console.log("[Profile] Upload successful");
        console.log("[Profile] Calling IncrementPfpVersion reducer");
        await activeConnection.reducers.incrementPfpVersion();
        console.log("[Profile] Reducer called successfully");
      } catch (err) {
        console.error("[Profile] Failed to upload profile picture:", err);
        throw error3(500, "Failed to upload profile picture");
      } finally {
        activeConnection.disconnect();
      }
      const url = buildProfilePictureUrl(env3.VITE_PFP_CDN_BASE_URL, accountId, nextVersion, "png");
      console.log("[Profile] Returning profile picture URL:", url);
      return json({
        accountId: accountId.toString(),
        version: nextVersion,
        url
      });
    }, "POST");
  }
});

// .wrangler/tmp/bundle-Uhq1Nq/middleware-loader.entry.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-Uhq1Nq/middleware-insertion-facade.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .svelte-kit/cloudflare/_worker.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .svelte-kit/output/server/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .svelte-kit/output/server/chunks/environment.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BROWSER = false;
var base = "";
var assets = base;
var app_dir = "_app";
var relative = true;
var initial = { base, assets };
function override(paths) {
  base = paths.base;
  assets = paths.assets;
}
__name(override, "override");
function reset() {
  base = initial.base;
  assets = initial.assets;
}
__name(reset, "reset");

// .svelte-kit/output/server/index.js
init_exports();
init_internal();
init_server();

// node_modules/devalue/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/devalue/src/uneval.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/devalue/src/utils.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var escaped = {
  "<": "\\u003C",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var DevalueError = class extends Error {
  static {
    __name(this, "DevalueError");
  }
  /**
   * @param {string} message
   * @param {string[]} keys
   */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
__name(is_primitive, "is_primitive");
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
__name(is_plain_object, "is_plain_object");
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
__name(get_type, "get_type");
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
__name(get_escaped_char, "get_escaped_char");
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i2 = 0; i2 < len; i2 += 1) {
    const char = str[i2];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i2) + replacement;
      last_pos = i2 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
__name(stringify_string, "stringify_string");
function enumerable_symbols(object) {
  return Object.getOwnPropertySymbols(object).filter(
    (symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable
  );
}
__name(enumerable_symbols, "enumerable_symbols");
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key2) {
  return is_identifier.test(key2) ? "." + key2 : "[" + JSON.stringify(key2) + "]";
}
__name(stringify_key, "stringify_key");

// node_modules/devalue/src/uneval.js
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing, (value2) => uneval(value2, replacer));
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
        case "URL":
        case "URLSearchParams":
          return;
        case "Array":
          thing.forEach((value2, i2) => {
            keys.push(`[${i2}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array":
          walk(thing.buffer);
          return;
        case "ArrayBuffer":
          return;
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          return;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(stringify_key(key2));
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  __name(walk, "walk");
  walk(value);
  const names2 = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a2, b2) => b2[1] - a2[1]).forEach((entry, i2) => {
    names2.set(entry[0], get_name(i2));
  });
  function stringify3(thing) {
    if (names2.has(thing)) {
      return names2.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify3(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "URL":
        return `new URL(${stringify_string(thing.toString())})`;
      case "URLSearchParams":
        return `new URLSearchParams(${stringify_string(thing.toString())})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v2, i2) => i2 in thing ? stringify3(v2) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify3).join(",")}])`;
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array": {
        let str2 = `new ${type}`;
        if (counts.get(thing.buffer) === 1) {
          const array2 = new thing.constructor(thing.buffer);
          str2 += `([${array2}])`;
        } else {
          str2 += `([${stringify3(thing.buffer)}])`;
        }
        const a2 = thing.byteOffset;
        const b2 = a2 + thing.byteLength;
        if (a2 > 0 || b2 !== thing.buffer.byteLength) {
          const m = +/(\d+)/.exec(type)[1] / 8;
          str2 += `.subarray(${a2 / m},${b2 / m})`;
        }
        return str2;
      }
      case "ArrayBuffer": {
        const ui8 = new Uint8Array(thing);
        return `new Uint8Array([${ui8.toString()}]).buffer`;
      }
      case "Temporal.Duration":
      case "Temporal.Instant":
      case "Temporal.PlainDate":
      case "Temporal.PlainTime":
      case "Temporal.PlainDateTime":
      case "Temporal.PlainMonthDay":
      case "Temporal.PlainYearMonth":
      case "Temporal.ZonedDateTime":
        return `${type}.from(${stringify_string(thing.toString())})`;
      default:
        const keys2 = Object.keys(thing);
        const obj = keys2.map((key2) => `${safe_key(key2)}:${stringify3(thing[key2])}`).join(",");
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return keys2.length > 0 ? `{${obj},__proto__:null}` : `{__proto__:null}`;
        }
        return `{${obj}}`;
    }
  }
  __name(stringify3, "stringify");
  const str = stringify3(value);
  if (names2.size) {
    const params = [];
    const statements = [];
    const values = [];
    names2.forEach((name, thing) => {
      params.push(name);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify3(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v2, i2) => {
            statements.push(`${name}[${i2}]=${stringify3(v2)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v2) => `add(${stringify3(v2)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k2, v2]) => `set(${stringify3(k2)}, ${stringify3(v2)})`).join(".")}`
          );
          break;
        case "ArrayBuffer":
          values.push(
            `new Uint8Array([${new Uint8Array(thing).join(",")}]).buffer`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify3(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
__name(uneval, "uneval");
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
__name(get_name, "get_name");
function escape_unsafe_char(c3) {
  return escaped[c3] || c3;
}
__name(escape_unsafe_char, "escape_unsafe_char");
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
__name(escape_unsafe_chars, "escape_unsafe_chars");
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
__name(safe_key, "safe_key");
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
__name(safe_prop, "safe_prop");
function stringify_primitive(thing) {
  if (typeof thing === "string") return stringify_string(thing);
  if (thing === void 0) return "void 0";
  if (thing === 0 && 1 / thing < 0) return "-0";
  const str = String(thing);
  if (typeof thing === "number") return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint") return thing + "n";
  return str;
}
__name(stringify_primitive, "stringify_primitive");

// node_modules/devalue/src/parse.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/devalue/src/base64.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    binaryString += String.fromCharCode(dv.getUint8(i2));
  }
  return binaryToAscii(binaryString);
}
__name(encode64, "encode64");
function decode64(string) {
  const binaryString = asciiToBinary(string);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    dv.setUint8(i2, binaryString.charCodeAt(i2));
  }
  return arraybuffer;
}
__name(decode64, "decode64");
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i2 = 0; i2 < data.length; i2++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i2]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
__name(asciiToBinary, "asciiToBinary");
function binaryToAscii(str) {
  let out = "";
  for (let i2 = 0; i2 < str.length; i2 += 3) {
    const groupsOfSix = [void 0, void 0, void 0, void 0];
    groupsOfSix[0] = str.charCodeAt(i2) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i2) & 3) << 4;
    if (str.length > i2 + 1) {
      groupsOfSix[1] |= str.charCodeAt(i2 + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i2 + 1) & 15) << 2;
    }
    if (str.length > i2 + 2) {
      groupsOfSix[2] |= str.charCodeAt(i2 + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i2 + 2) & 63;
    }
    for (let j = 0; j < groupsOfSix.length; j++) {
      if (typeof groupsOfSix[j] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j]];
      }
    }
  }
  return out;
}
__name(binaryToAscii, "binaryToAscii");

// node_modules/devalue/src/constants.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
__name(parse, "parse");
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate2(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate2(index5, standalone = false) {
    if (index5 === UNDEFINED) return void 0;
    if (index5 === NAN) return NaN;
    if (index5 === POSITIVE_INFINITY) return Infinity;
    if (index5 === NEGATIVE_INFINITY) return -Infinity;
    if (index5 === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index5 !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index5 in hydrated) return hydrated[index5];
    const value = values[index5];
    if (!value || typeof value !== "object") {
      hydrated[index5] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i2 = value[1];
          if (typeof i2 !== "number") {
            i2 = values.push(value[1]) - 1;
          }
          return hydrated[index5] = reviver(hydrate2(i2));
        }
        switch (type) {
          case "Date":
            hydrated[index5] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated[index5] = set2;
            for (let i2 = 1; i2 < value.length; i2 += 1) {
              set2.add(hydrate2(value[i2]));
            }
            break;
          case "Map":
            const map = /* @__PURE__ */ new Map();
            hydrated[index5] = map;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              map.set(hydrate2(value[i2]), hydrate2(value[i2 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index5] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index5] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index5] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index5] = obj;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              obj[value[i2]] = hydrate2(value[i2 + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate2(value[1]));
            hydrated[index5] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base64 = value[1];
            const arraybuffer = decode64(base64);
            hydrated[index5] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index5] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url = new URL(value[1]);
            hydrated[index5] = url;
            break;
          }
          case "URLSearchParams": {
            const url = new URLSearchParams(value[1]);
            hydrated[index5] = url;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated[index5] = array2;
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          const n3 = value[i2];
          if (n3 === HOLE) continue;
          array2[i2] = hydrate2(n3);
        }
      }
    } else {
      const object = {};
      hydrated[index5] = object;
      for (const key2 in value) {
        if (key2 === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n3 = value[key2];
        object[key2] = hydrate2(n3);
      }
    }
    return hydrated[index5];
  }
  __name(hydrate2, "hydrate");
  return hydrate2(0);
}
__name(unflatten, "unflatten");

// node_modules/devalue/src/stringify.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key2 of Object.getOwnPropertyNames(reducers)) {
      custom2.push({ key: key2, fn: reducers[key2] });
    }
  }
  const keys = [];
  let p2 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index6 = p2++;
    indexes.set(thing, index6);
    for (const { key: key2, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index6] = `["${key2}",${flatten(value2)}]`;
        return index6;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source: source2, flags: flags2 } = thing;
          str = flags2 ? `["RegExp",${stringify_string(source2)},"${flags2}"]` : `["RegExp",${stringify_string(source2)}]`;
          break;
        case "Array":
          str = "[";
          for (let i2 = 0; i2 < thing.length; i2 += 1) {
            if (i2 > 0) str += ",";
            if (i2 in thing) {
              keys.push(`[${i2}]`);
              str += flatten(thing[i2]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a2 = thing.byteOffset;
          const b2 = a2 + thing.byteLength;
          if (a2 > 0 || b2 !== typedArray.buffer.byteLength) {
            const m = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a2 / m},${b2 / m}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base64 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base64}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(stringify_key(key2));
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key2));
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index6] = str;
    return index6;
  }
  __name(flatten, "flatten");
  const index5 = flatten(value);
  if (index5 < 0) return `${index5}`;
  return `[${stringified.join(",")}]`;
}
__name(stringify, "stringify");
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}
__name(stringify_primitive2, "stringify_primitive");

// .svelte-kit/output/server/index.js
init_exports2();
init_utils3();

// .svelte-kit/output/server/chunks/internal.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_chunks();
init_equality();
init_clsx();
init_context();
var public_env = {};
function set_private_env(environment) {
}
__name(set_private_env, "set_private_env");
function set_public_env(environment) {
  public_env = environment;
}
__name(set_public_env, "set_public_env");
function effect_update_depth_exceeded() {
  {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
__name(effect_update_depth_exceeded, "effect_update_depth_exceeded");
function hydration_failed() {
  {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
__name(hydration_failed, "hydration_failed");
function state_descriptors_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
  }
}
__name(state_descriptors_fixed, "state_descriptors_fixed");
function state_prototype_fixed() {
  {
    throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
  }
}
__name(state_prototype_fixed, "state_prototype_fixed");
function state_unsafe_mutation() {
  {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}
__name(state_unsafe_mutation, "state_unsafe_mutation");
function svelte_boundary_reset_onerror() {
  {
    throw new Error(`https://svelte.dev/e/svelte_boundary_reset_onerror`);
  }
}
__name(svelte_boundary_reset_onerror, "svelte_boundary_reset_onerror");
function hydration_mismatch(location) {
  {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
__name(hydration_mismatch, "hydration_mismatch");
function svelte_boundary_reset_noop() {
  {
    console.warn(`https://svelte.dev/e/svelte_boundary_reset_noop`);
  }
}
__name(svelte_boundary_reset_noop, "svelte_boundary_reset_noop");
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
__name(set_hydrating, "set_hydrating");
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
__name(set_hydrate_node, "set_hydrate_node");
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    /* @__PURE__ */ get_next_sibling(hydrate_node)
  );
}
__name(hydrate_next, "hydrate_next");
function next(count3 = 1) {
  if (hydrating) {
    var i2 = count3;
    var node = hydrate_node;
    while (i2--) {
      node = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node);
    }
    hydrate_node = node;
  }
}
__name(next, "next");
function skip_nodes(remove = true) {
  var depth = 0;
  var node = hydrate_node;
  while (true) {
    if (node.nodeType === COMMENT_NODE) {
      var data = (
        /** @type {Comment} */
        node.data
      );
      if (data === HYDRATION_END) {
        if (depth === 0) return node;
        depth -= 1;
      } else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {
        depth += 1;
      }
    }
    var next2 = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    if (remove) node.remove();
    node = next2;
  }
}
__name(skip_nodes, "skip_nodes");
var tracing_mode_flag = false;
var component_context = null;
function set_component_context(context3) {
  component_context = context3;
}
__name(set_component_context, "set_component_context");
function push2(props, runes = false, fn) {
  component_context = {
    p: component_context,
    i: false,
    c: null,
    e: null,
    s: props,
    x: null,
    l: null
  };
}
__name(push2, "push");
function pop2(component5) {
  var context3 = (
    /** @type {ComponentContext} */
    component_context
  );
  var effects = context3.e;
  if (effects !== null) {
    context3.e = null;
    for (var fn of effects) {
      create_user_effect(fn);
    }
  }
  context3.i = true;
  component_context = context3.p;
  return (
    /** @type {T} */
    {}
  );
}
__name(pop2, "pop");
function is_runes() {
  return true;
}
__name(is_runes, "is_runes");
var micro_tasks = [];
function run_micro_tasks() {
  var tasks = micro_tasks;
  micro_tasks = [];
  run_all(tasks);
}
__name(run_micro_tasks, "run_micro_tasks");
function queue_micro_task(fn) {
  if (micro_tasks.length === 0 && !is_flushing_sync) {
    var tasks = micro_tasks;
    queueMicrotask(() => {
      if (tasks === micro_tasks) run_micro_tasks();
    });
  }
  micro_tasks.push(fn);
}
__name(queue_micro_task, "queue_micro_task");
function flush_tasks() {
  while (micro_tasks.length > 0) {
    run_micro_tasks();
  }
}
__name(flush_tasks, "flush_tasks");
function handle_error(error4) {
  var effect = active_effect;
  if (effect === null) {
    active_reaction.f |= ERROR_VALUE;
    return error4;
  }
  if ((effect.f & EFFECT_RAN) === 0) {
    if ((effect.f & BOUNDARY_EFFECT) === 0) {
      throw error4;
    }
    effect.b.error(error4);
  } else {
    invoke_error_boundary(error4, effect);
  }
}
__name(handle_error, "handle_error");
function invoke_error_boundary(error4, effect) {
  while (effect !== null) {
    if ((effect.f & BOUNDARY_EFFECT) !== 0) {
      try {
        effect.b.error(error4);
        return;
      } catch (e5) {
        error4 = e5;
      }
    }
    effect = effect.parent;
  }
  throw error4;
}
__name(invoke_error_boundary, "invoke_error_boundary");
var batches = /* @__PURE__ */ new Set();
var current_batch = null;
var batch_values = null;
var queued_root_effects = [];
var last_scheduled_effect = null;
var is_flushing = false;
var is_flushing_sync = false;
var Batch = class _Batch {
  static {
    __name(this, "Batch");
  }
  committed = false;
  /**
   * The current values of any sources that are updated in this batch
   * They keys of this map are identical to `this.#previous`
   * @type {Map<Source, any>}
   */
  current = /* @__PURE__ */ new Map();
  /**
   * The values of any sources that are updated in this batch _before_ those updates took place.
   * They keys of this map are identical to `this.#current`
   * @type {Map<Source, any>}
   */
  previous = /* @__PURE__ */ new Map();
  /**
   * When the batch is committed (and the DOM is updated), we need to remove old branches
   * and append new ones by calling the functions added inside (if/each/key/etc) blocks
   * @type {Set<() => void>}
   */
  #commit_callbacks = /* @__PURE__ */ new Set();
  /**
   * If a fork is discarded, we need to destroy any effects that are no longer needed
   * @type {Set<(batch: Batch) => void>}
   */
  #discard_callbacks = /* @__PURE__ */ new Set();
  /**
   * The number of async effects that are currently in flight
   */
  #pending = 0;
  /**
   * The number of async effects that are currently in flight, _not_ inside a pending boundary
   */
  #blocking_pending = 0;
  /**
   * A deferred that resolves when the batch is committed, used with `settled()`
   * TODO replace with Promise.withResolvers once supported widely enough
   * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
   */
  #deferred = null;
  /**
   * Deferred effects (which run after async work has completed) that are DIRTY
   * @type {Effect[]}
   */
  #dirty_effects = [];
  /**
   * Deferred effects that are MAYBE_DIRTY
   * @type {Effect[]}
   */
  #maybe_dirty_effects = [];
  /**
   * A set of branches that still exist, but will be destroyed when this batch
   * is committed  we skip over these during `process`
   * @type {Set<Effect>}
   */
  skipped_effects = /* @__PURE__ */ new Set();
  is_fork = false;
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(root_effects) {
    queued_root_effects = [];
    this.apply();
    var target = {
      parent: null,
      effect: null,
      effects: [],
      render_effects: [],
      block_effects: []
    };
    for (const root2 of root_effects) {
      this.#traverse_effect_tree(root2, target);
    }
    if (!this.is_fork) {
      this.#resolve();
    }
    if (this.#blocking_pending > 0 || this.is_fork) {
      this.#defer_effects(target.effects);
      this.#defer_effects(target.render_effects);
      this.#defer_effects(target.block_effects);
    } else {
      current_batch = null;
      flush_queued_effects(target.render_effects);
      flush_queued_effects(target.effects);
      this.#deferred?.resolve();
    }
    batch_values = null;
  }
  /**
   * Traverse the effect tree, executing effects or stashing
   * them for later execution as appropriate
   * @param {Effect} root
   * @param {EffectTarget} target
   */
  #traverse_effect_tree(root2, target) {
    root2.f ^= CLEAN;
    var effect = root2.first;
    while (effect !== null) {
      var flags2 = effect.f;
      var is_branch = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
      var is_skippable_branch = is_branch && (flags2 & CLEAN) !== 0;
      var skip = is_skippable_branch || (flags2 & INERT) !== 0 || this.skipped_effects.has(effect);
      if ((effect.f & BOUNDARY_EFFECT) !== 0 && effect.b?.is_pending()) {
        target = {
          parent: target,
          effect,
          effects: [],
          render_effects: [],
          block_effects: []
        };
      }
      if (!skip && effect.fn !== null) {
        if (is_branch) {
          effect.f ^= CLEAN;
        } else if ((flags2 & EFFECT) !== 0) {
          target.effects.push(effect);
        } else if (is_dirty(effect)) {
          if ((effect.f & BLOCK_EFFECT) !== 0) target.block_effects.push(effect);
          update_effect(effect);
        }
        var child = effect.first;
        if (child !== null) {
          effect = child;
          continue;
        }
      }
      var parent = effect.parent;
      effect = effect.next;
      while (effect === null && parent !== null) {
        if (parent === target.effect) {
          this.#defer_effects(target.effects);
          this.#defer_effects(target.render_effects);
          this.#defer_effects(target.block_effects);
          target = /** @type {EffectTarget} */
          target.parent;
        }
        effect = parent.next;
        parent = parent.parent;
      }
    }
  }
  /**
   * @param {Effect[]} effects
   */
  #defer_effects(effects) {
    for (const e5 of effects) {
      const target = (e5.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
      target.push(e5);
      set_signal_status(e5, CLEAN);
    }
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(source2, value) {
    if (!this.previous.has(source2)) {
      this.previous.set(source2, value);
    }
    if ((source2.f & ERROR_VALUE) === 0) {
      this.current.set(source2, source2.v);
      batch_values?.set(source2, source2.v);
    }
  }
  activate() {
    current_batch = this;
    this.apply();
  }
  deactivate() {
    current_batch = null;
    batch_values = null;
  }
  flush() {
    this.activate();
    if (queued_root_effects.length > 0) {
      flush_effects();
      if (current_batch !== null && current_batch !== this) {
        return;
      }
    } else if (this.#pending === 0) {
      this.process([]);
    }
    this.deactivate();
  }
  discard() {
    for (const fn of this.#discard_callbacks) fn(this);
    this.#discard_callbacks.clear();
  }
  #resolve() {
    if (this.#blocking_pending === 0) {
      for (const fn of this.#commit_callbacks) fn();
      this.#commit_callbacks.clear();
    }
    if (this.#pending === 0) {
      this.#commit();
    }
  }
  #commit() {
    if (batches.size > 1) {
      this.previous.clear();
      var previous_batch_values = batch_values;
      var is_earlier = true;
      var dummy_target = {
        parent: null,
        effect: null,
        effects: [],
        render_effects: [],
        block_effects: []
      };
      for (const batch of batches) {
        if (batch === this) {
          is_earlier = false;
          continue;
        }
        const sources = [];
        for (const [source2, value] of this.current) {
          if (batch.current.has(source2)) {
            if (is_earlier && value !== batch.current.get(source2)) {
              batch.current.set(source2, value);
            } else {
              continue;
            }
          }
          sources.push(source2);
        }
        if (sources.length === 0) {
          continue;
        }
        const others = [...batch.current.keys()].filter((s4) => !this.current.has(s4));
        if (others.length > 0) {
          const marked = /* @__PURE__ */ new Set();
          const checked2 = /* @__PURE__ */ new Map();
          for (const source2 of sources) {
            mark_effects(source2, others, marked, checked2);
          }
          if (queued_root_effects.length > 0) {
            current_batch = batch;
            batch.apply();
            for (const root2 of queued_root_effects) {
              batch.#traverse_effect_tree(root2, dummy_target);
            }
            queued_root_effects = [];
            batch.deactivate();
          }
        }
      }
      current_batch = null;
      batch_values = previous_batch_values;
    }
    this.committed = true;
    batches.delete(this);
  }
  /**
   *
   * @param {boolean} blocking
   */
  increment(blocking) {
    this.#pending += 1;
    if (blocking) this.#blocking_pending += 1;
  }
  /**
   *
   * @param {boolean} blocking
   */
  decrement(blocking) {
    this.#pending -= 1;
    if (blocking) this.#blocking_pending -= 1;
    this.revive();
  }
  revive() {
    for (const e5 of this.#dirty_effects) {
      set_signal_status(e5, DIRTY);
      schedule_effect(e5);
    }
    for (const e5 of this.#maybe_dirty_effects) {
      set_signal_status(e5, MAYBE_DIRTY);
      schedule_effect(e5);
    }
    this.#dirty_effects = [];
    this.#maybe_dirty_effects = [];
    this.flush();
  }
  /** @param {() => void} fn */
  oncommit(fn) {
    this.#commit_callbacks.add(fn);
  }
  /** @param {(batch: Batch) => void} fn */
  ondiscard(fn) {
    this.#discard_callbacks.add(fn);
  }
  settled() {
    return (this.#deferred ??= deferred()).promise;
  }
  static ensure() {
    if (current_batch === null) {
      const batch = current_batch = new _Batch();
      batches.add(current_batch);
      if (!is_flushing_sync) {
        _Batch.enqueue(() => {
          if (current_batch !== batch) {
            return;
          }
          batch.flush();
        });
      }
    }
    return current_batch;
  }
  /** @param {() => void} task */
  static enqueue(task) {
    queue_micro_task(task);
  }
  apply() {
    return;
  }
};
function flushSync(fn) {
  var was_flushing_sync = is_flushing_sync;
  is_flushing_sync = true;
  try {
    var result;
    if (fn) ;
    while (true) {
      flush_tasks();
      if (queued_root_effects.length === 0) {
        current_batch?.flush();
        if (queued_root_effects.length === 0) {
          last_scheduled_effect = null;
          return (
            /** @type {T} */
            result
          );
        }
      }
      flush_effects();
    }
  } finally {
    is_flushing_sync = was_flushing_sync;
  }
}
__name(flushSync, "flushSync");
function flush_effects() {
  var was_updating_effect = is_updating_effect;
  is_flushing = true;
  try {
    var flush_count = 0;
    set_is_updating_effect(true);
    while (queued_root_effects.length > 0) {
      var batch = Batch.ensure();
      if (flush_count++ > 1e3) {
        var updates, entry;
        if (BROWSER) ;
        infinite_loop_guard();
      }
      batch.process(queued_root_effects);
      old_values.clear();
    }
  } finally {
    is_flushing = false;
    set_is_updating_effect(was_updating_effect);
    last_scheduled_effect = null;
  }
}
__name(flush_effects, "flush_effects");
function infinite_loop_guard() {
  try {
    effect_update_depth_exceeded();
  } catch (error4) {
    invoke_error_boundary(error4, last_scheduled_effect);
  }
}
__name(infinite_loop_guard, "infinite_loop_guard");
var eager_block_effects = null;
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  var i2 = 0;
  while (i2 < length) {
    var effect = effects[i2++];
    if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
      eager_block_effects = /* @__PURE__ */ new Set();
      update_effect(effect);
      if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
        if (effect.teardown === null && effect.ac === null) {
          unlink_effect(effect);
        } else {
          effect.fn = null;
        }
      }
      if (eager_block_effects?.size > 0) {
        old_values.clear();
        for (const e5 of eager_block_effects) {
          if ((e5.f & (DESTROYED | INERT)) !== 0) continue;
          const ordered_effects = [e5];
          let ancestor = e5.parent;
          while (ancestor !== null) {
            if (eager_block_effects.has(ancestor)) {
              eager_block_effects.delete(ancestor);
              ordered_effects.push(ancestor);
            }
            ancestor = ancestor.parent;
          }
          for (let j = ordered_effects.length - 1; j >= 0; j--) {
            const e23 = ordered_effects[j];
            if ((e23.f & (DESTROYED | INERT)) !== 0) continue;
            update_effect(e23);
          }
        }
        eager_block_effects.clear();
      }
    }
  }
  eager_block_effects = null;
}
__name(flush_queued_effects, "flush_queued_effects");
function mark_effects(value, sources, marked, checked2) {
  if (marked.has(value)) return;
  marked.add(value);
  if (value.reactions !== null) {
    for (const reaction of value.reactions) {
      const flags2 = reaction.f;
      if ((flags2 & DERIVED) !== 0) {
        mark_effects(
          /** @type {Derived} */
          reaction,
          sources,
          marked,
          checked2
        );
      } else if ((flags2 & (ASYNC | BLOCK_EFFECT)) !== 0 && (flags2 & DIRTY) === 0 && // we may have scheduled this one already
      depends_on(reaction, sources, checked2)) {
        set_signal_status(reaction, DIRTY);
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}
__name(mark_effects, "mark_effects");
function depends_on(reaction, sources, checked2) {
  const depends = checked2.get(reaction);
  if (depends !== void 0) return depends;
  if (reaction.deps !== null) {
    for (const dep of reaction.deps) {
      if (sources.includes(dep)) {
        return true;
      }
      if ((dep.f & DERIVED) !== 0 && depends_on(
        /** @type {Derived} */
        dep,
        sources,
        checked2
      )) {
        checked2.set(
          /** @type {Derived} */
          dep,
          true
        );
        return true;
      }
    }
  }
  checked2.set(reaction, false);
  return false;
}
__name(depends_on, "depends_on");
function schedule_effect(signal) {
  var effect = last_scheduled_effect = signal;
  while (effect.parent !== null) {
    effect = effect.parent;
    var flags2 = effect.f;
    if (is_flushing && effect === active_effect && (flags2 & BLOCK_EFFECT) !== 0 && (flags2 & HEAD_EFFECT) === 0) {
      return;
    }
    if ((flags2 & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags2 & CLEAN) === 0) return;
      effect.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect);
}
__name(schedule_effect, "schedule_effect");
function createSubscriber(start) {
  let subscribers = 0;
  let version2 = source(0);
  let stop;
  return () => {
    if (effect_tracking()) {
      get(version2);
      render_effect(() => {
        if (subscribers === 0) {
          stop = untrack(() => start(() => increment(version2)));
        }
        subscribers += 1;
        return () => {
          queue_micro_task(() => {
            subscribers -= 1;
            if (subscribers === 0) {
              stop?.();
              stop = void 0;
              increment(version2);
            }
          });
        };
      });
    }
  };
}
__name(createSubscriber, "createSubscriber");
var flags = EFFECT_TRANSPARENT | EFFECT_PRESERVED | BOUNDARY_EFFECT;
function boundary(node, props, children) {
  new Boundary(node, props, children);
}
__name(boundary, "boundary");
var Boundary = class {
  static {
    __name(this, "Boundary");
  }
  /** @type {Boundary | null} */
  parent;
  #pending = false;
  /** @type {TemplateNode} */
  #anchor;
  /** @type {TemplateNode | null} */
  #hydrate_open = hydrating ? hydrate_node : null;
  /** @type {BoundaryProps} */
  #props;
  /** @type {((anchor: Node) => void)} */
  #children;
  /** @type {Effect} */
  #effect;
  /** @type {Effect | null} */
  #main_effect = null;
  /** @type {Effect | null} */
  #pending_effect = null;
  /** @type {Effect | null} */
  #failed_effect = null;
  /** @type {DocumentFragment | null} */
  #offscreen_fragment = null;
  /** @type {TemplateNode | null} */
  #pending_anchor = null;
  #local_pending_count = 0;
  #pending_count = 0;
  #is_creating_fallback = false;
  /**
   * A source containing the number of pending async deriveds/expressions.
   * Only created if `$effect.pending()` is used inside the boundary,
   * otherwise updating the source results in needless `Batch.ensure()`
   * calls followed by no-op flushes
   * @type {Source<number> | null}
   */
  #effect_pending = null;
  #effect_pending_subscriber = createSubscriber(() => {
    this.#effect_pending = source(this.#local_pending_count);
    return () => {
      this.#effect_pending = null;
    };
  });
  /**
   * @param {TemplateNode} node
   * @param {BoundaryProps} props
   * @param {((anchor: Node) => void)} children
   */
  constructor(node, props, children) {
    this.#anchor = node;
    this.#props = props;
    this.#children = children;
    this.parent = /** @type {Effect} */
    active_effect.b;
    this.#pending = !!this.#props.pending;
    this.#effect = block(() => {
      active_effect.b = this;
      if (hydrating) {
        const comment = this.#hydrate_open;
        hydrate_next();
        const server_rendered_pending = (
          /** @type {Comment} */
          comment.nodeType === COMMENT_NODE && /** @type {Comment} */
          comment.data === HYDRATION_START_ELSE
        );
        if (server_rendered_pending) {
          this.#hydrate_pending_content();
        } else {
          this.#hydrate_resolved_content();
        }
      } else {
        var anchor = this.#get_anchor();
        try {
          this.#main_effect = branch(() => children(anchor));
        } catch (error4) {
          this.error(error4);
        }
        if (this.#pending_count > 0) {
          this.#show_pending_snippet();
        } else {
          this.#pending = false;
        }
      }
      return () => {
        this.#pending_anchor?.remove();
      };
    }, flags);
    if (hydrating) {
      this.#anchor = hydrate_node;
    }
  }
  #hydrate_resolved_content() {
    try {
      this.#main_effect = branch(() => this.#children(this.#anchor));
    } catch (error4) {
      this.error(error4);
    }
    this.#pending = false;
  }
  #hydrate_pending_content() {
    const pending = this.#props.pending;
    if (!pending) {
      return;
    }
    this.#pending_effect = branch(() => pending(this.#anchor));
    Batch.enqueue(() => {
      var anchor = this.#get_anchor();
      this.#main_effect = this.#run(() => {
        Batch.ensure();
        return branch(() => this.#children(anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        pause_effect(
          /** @type {Effect} */
          this.#pending_effect,
          () => {
            this.#pending_effect = null;
          }
        );
        this.#pending = false;
      }
    });
  }
  #get_anchor() {
    var anchor = this.#anchor;
    if (this.#pending) {
      this.#pending_anchor = create_text();
      this.#anchor.before(this.#pending_anchor);
      anchor = this.#pending_anchor;
    }
    return anchor;
  }
  /**
   * Returns `true` if the effect exists inside a boundary whose pending snippet is shown
   * @returns {boolean}
   */
  is_pending() {
    return this.#pending || !!this.parent && this.parent.is_pending();
  }
  has_pending_snippet() {
    return !!this.#props.pending;
  }
  /**
   * @param {() => Effect | null} fn
   */
  #run(fn) {
    var previous_effect = active_effect;
    var previous_reaction = active_reaction;
    var previous_ctx = component_context;
    set_active_effect(this.#effect);
    set_active_reaction(this.#effect);
    set_component_context(this.#effect.ctx);
    try {
      return fn();
    } catch (e5) {
      handle_error(e5);
      return null;
    } finally {
      set_active_effect(previous_effect);
      set_active_reaction(previous_reaction);
      set_component_context(previous_ctx);
    }
  }
  #show_pending_snippet() {
    const pending = (
      /** @type {(anchor: Node) => void} */
      this.#props.pending
    );
    if (this.#main_effect !== null) {
      this.#offscreen_fragment = document.createDocumentFragment();
      this.#offscreen_fragment.append(
        /** @type {TemplateNode} */
        this.#pending_anchor
      );
      move_effect(this.#main_effect, this.#offscreen_fragment);
    }
    if (this.#pending_effect === null) {
      this.#pending_effect = branch(() => pending(this.#anchor));
    }
  }
  /**
   * Updates the pending count associated with the currently visible pending snippet,
   * if any, such that we can replace the snippet with content once work is done
   * @param {1 | -1} d
   */
  #update_pending_count(d) {
    if (!this.has_pending_snippet()) {
      if (this.parent) {
        this.parent.#update_pending_count(d);
      }
      return;
    }
    this.#pending_count += d;
    if (this.#pending_count === 0) {
      this.#pending = false;
      if (this.#pending_effect) {
        pause_effect(this.#pending_effect, () => {
          this.#pending_effect = null;
        });
      }
      if (this.#offscreen_fragment) {
        this.#anchor.before(this.#offscreen_fragment);
        this.#offscreen_fragment = null;
      }
    }
  }
  /**
   * Update the source that powers `$effect.pending()` inside this boundary,
   * and controls when the current `pending` snippet (if any) is removed.
   * Do not call from inside the class
   * @param {1 | -1} d
   */
  update_pending_count(d) {
    this.#update_pending_count(d);
    this.#local_pending_count += d;
    if (this.#effect_pending) {
      internal_set(this.#effect_pending, this.#local_pending_count);
    }
  }
  get_effect_pending() {
    this.#effect_pending_subscriber();
    return get(
      /** @type {Source<number>} */
      this.#effect_pending
    );
  }
  /** @param {unknown} error */
  error(error4) {
    var onerror = this.#props.onerror;
    let failed = this.#props.failed;
    if (this.#is_creating_fallback || !onerror && !failed) {
      throw error4;
    }
    if (this.#main_effect) {
      destroy_effect(this.#main_effect);
      this.#main_effect = null;
    }
    if (this.#pending_effect) {
      destroy_effect(this.#pending_effect);
      this.#pending_effect = null;
    }
    if (this.#failed_effect) {
      destroy_effect(this.#failed_effect);
      this.#failed_effect = null;
    }
    if (hydrating) {
      set_hydrate_node(
        /** @type {TemplateNode} */
        this.#hydrate_open
      );
      next();
      set_hydrate_node(skip_nodes());
    }
    var did_reset = false;
    var calling_on_error = false;
    const reset2 = /* @__PURE__ */ __name(() => {
      if (did_reset) {
        svelte_boundary_reset_noop();
        return;
      }
      did_reset = true;
      if (calling_on_error) {
        svelte_boundary_reset_onerror();
      }
      Batch.ensure();
      this.#local_pending_count = 0;
      if (this.#failed_effect !== null) {
        pause_effect(this.#failed_effect, () => {
          this.#failed_effect = null;
        });
      }
      this.#pending = this.has_pending_snippet();
      this.#main_effect = this.#run(() => {
        this.#is_creating_fallback = false;
        return branch(() => this.#children(this.#anchor));
      });
      if (this.#pending_count > 0) {
        this.#show_pending_snippet();
      } else {
        this.#pending = false;
      }
    }, "reset");
    var previous_reaction = active_reaction;
    try {
      set_active_reaction(null);
      calling_on_error = true;
      onerror?.(error4, reset2);
      calling_on_error = false;
    } catch (error22) {
      invoke_error_boundary(error22, this.#effect && this.#effect.parent);
    } finally {
      set_active_reaction(previous_reaction);
    }
    if (failed) {
      queue_micro_task(() => {
        this.#failed_effect = this.#run(() => {
          Batch.ensure();
          this.#is_creating_fallback = true;
          try {
            return branch(() => {
              failed(
                this.#anchor,
                () => error4,
                () => reset2
              );
            });
          } catch (error22) {
            invoke_error_boundary(
              error22,
              /** @type {Effect} */
              this.#effect.parent
            );
            return null;
          } finally {
            this.#is_creating_fallback = false;
          }
        });
      });
    }
  }
};
function destroy_derived_effects(derived) {
  var effects = derived.effects;
  if (effects !== null) {
    derived.effects = null;
    for (var i2 = 0; i2 < effects.length; i2 += 1) {
      destroy_effect(
        /** @type {Effect} */
        effects[i2]
      );
    }
  }
}
__name(destroy_derived_effects, "destroy_derived_effects");
function get_derived_parent_effect(derived) {
  var parent = derived.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
__name(get_derived_parent_effect, "get_derived_parent_effect");
function execute_derived(derived) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived));
  {
    try {
      derived.f &= ~WAS_MARKED;
      destroy_derived_effects(derived);
      value = update_reaction(derived);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
__name(execute_derived, "execute_derived");
function update_derived(derived) {
  var value = execute_derived(derived);
  if (!derived.equals(value)) {
    derived.v = value;
    derived.wv = increment_write_version();
  }
  if (is_destroying_effect) {
    return;
  }
  if (batch_values !== null) {
    if (effect_tracking()) {
      batch_values.set(derived, derived.v);
    }
  } else {
    var status = (derived.f & CONNECTED) === 0 ? MAYBE_DIRTY : CLEAN;
    set_signal_status(derived, status);
  }
}
__name(update_derived, "update_derived");
var eager_effects = /* @__PURE__ */ new Set();
var old_values = /* @__PURE__ */ new Map();
var eager_effects_deferred = false;
function source(v2, stack) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: v2,
    reactions: null,
    equals,
    rv: 0,
    wv: 0
  };
  return signal;
}
__name(source, "source");
// @__NO_SIDE_EFFECTS__
function state(v2, stack) {
  const s4 = source(v2);
  push_reaction_value(s4);
  return s4;
}
__name(state, "state");
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable2 = false, trackable = true) {
  const s4 = source(initial_value);
  if (!immutable2) {
    s4.equals = safe_equals;
  }
  return s4;
}
__name(mutable_source, "mutable_source");
function set(source2, value, should_proxy = false) {
  if (active_reaction !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!untracking || (active_reaction.f & EAGER_EFFECT) !== 0) && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | EAGER_EFFECT)) !== 0 && !current_sources?.includes(source2)) {
    state_unsafe_mutation();
  }
  let new_value = should_proxy ? proxy(value) : value;
  return internal_set(source2, new_value);
}
__name(set, "set");
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    var old_value = source2.v;
    if (is_destroying_effect) {
      old_values.set(source2, value);
    } else {
      old_values.set(source2, old_value);
    }
    source2.v = value;
    var batch = Batch.ensure();
    batch.capture(source2, old_value);
    if ((source2.f & DERIVED) !== 0) {
      if ((source2.f & DIRTY) !== 0) {
        execute_derived(
          /** @type {Derived} */
          source2
        );
      }
      set_signal_status(source2, (source2.f & CONNECTED) !== 0 ? CLEAN : MAYBE_DIRTY);
    }
    source2.wv = increment_write_version();
    mark_reactions(source2, DIRTY);
    if (active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0) {
      if (untracked_writes === null) {
        set_untracked_writes([source2]);
      } else {
        untracked_writes.push(source2);
      }
    }
    if (!batch.is_fork && eager_effects.size > 0 && !eager_effects_deferred) {
      flush_eager_effects();
    }
  }
  return value;
}
__name(internal_set, "internal_set");
function flush_eager_effects() {
  eager_effects_deferred = false;
  const inspects = Array.from(eager_effects);
  for (const effect of inspects) {
    if ((effect.f & CLEAN) !== 0) {
      set_signal_status(effect, MAYBE_DIRTY);
    }
    if (is_dirty(effect)) {
      update_effect(effect);
    }
  }
  eager_effects.clear();
}
__name(flush_eager_effects, "flush_eager_effects");
function increment(source2) {
  set(source2, source2.v + 1);
}
__name(increment, "increment");
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var length = reactions.length;
  for (var i2 = 0; i2 < length; i2++) {
    var reaction = reactions[i2];
    var flags2 = reaction.f;
    var not_dirty = (flags2 & DIRTY) === 0;
    if (not_dirty) {
      set_signal_status(reaction, status);
    }
    if ((flags2 & DERIVED) !== 0) {
      var derived = (
        /** @type {Derived} */
        reaction
      );
      batch_values?.delete(derived);
      if ((flags2 & WAS_MARKED) === 0) {
        if (flags2 & CONNECTED) {
          reaction.f |= WAS_MARKED;
        }
        mark_reactions(derived, MAYBE_DIRTY);
      }
    } else if (not_dirty) {
      if ((flags2 & BLOCK_EFFECT) !== 0) {
        if (eager_block_effects !== null) {
          eager_block_effects.add(
            /** @type {Effect} */
            reaction
          );
        }
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(mark_reactions, "mark_reactions");
function proxy(value) {
  if (typeof value !== "object" || value === null || STATE_SYMBOL in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var sources = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var version2 = /* @__PURE__ */ state(0);
  var parent_version = update_version;
  var with_parent = /* @__PURE__ */ __name((fn) => {
    if (update_version === parent_version) {
      return fn();
    }
    var reaction = active_reaction;
    var version22 = update_version;
    set_active_reaction(null);
    set_update_version(parent_version);
    var result = fn();
    set_active_reaction(reaction);
    set_update_version(version22);
    return result;
  }, "with_parent");
  if (is_proxied_array) {
    sources.set("length", /* @__PURE__ */ state(
      /** @type {any[]} */
      value.length
    ));
  }
  return new Proxy(
    /** @type {any} */
    value,
    {
      defineProperty(_2, prop, descriptor) {
        if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
          state_descriptors_fixed();
        }
        var s4 = sources.get(prop);
        if (s4 === void 0) {
          s4 = with_parent(() => {
            var s22 = /* @__PURE__ */ state(descriptor.value);
            sources.set(prop, s22);
            return s22;
          });
        } else {
          set(s4, descriptor.value, true);
        }
        return true;
      },
      deleteProperty(target, prop) {
        var s4 = sources.get(prop);
        if (s4 === void 0) {
          if (prop in target) {
            const s22 = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
            sources.set(prop, s22);
            increment(version2);
          }
        } else {
          set(s4, UNINITIALIZED);
          increment(version2);
        }
        return true;
      },
      get(target, prop, receiver) {
        if (prop === STATE_SYMBOL) {
          return value;
        }
        var s4 = sources.get(prop);
        var exists = prop in target;
        if (s4 === void 0 && (!exists || get_descriptor(target, prop)?.writable)) {
          s4 = with_parent(() => {
            var p2 = proxy(exists ? target[prop] : UNINITIALIZED);
            var s22 = /* @__PURE__ */ state(p2);
            return s22;
          });
          sources.set(prop, s4);
        }
        if (s4 !== void 0) {
          var v2 = get(s4);
          return v2 === UNINITIALIZED ? void 0 : v2;
        }
        return Reflect.get(target, prop, receiver);
      },
      getOwnPropertyDescriptor(target, prop) {
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor && "value" in descriptor) {
          var s4 = sources.get(prop);
          if (s4) descriptor.value = get(s4);
        } else if (descriptor === void 0) {
          var source2 = sources.get(prop);
          var value2 = source2?.v;
          if (source2 !== void 0 && value2 !== UNINITIALIZED) {
            return {
              enumerable: true,
              configurable: true,
              value: value2,
              writable: true
            };
          }
        }
        return descriptor;
      },
      has(target, prop) {
        if (prop === STATE_SYMBOL) {
          return true;
        }
        var s4 = sources.get(prop);
        var has = s4 !== void 0 && s4.v !== UNINITIALIZED || Reflect.has(target, prop);
        if (s4 !== void 0 || active_effect !== null && (!has || get_descriptor(target, prop)?.writable)) {
          if (s4 === void 0) {
            s4 = with_parent(() => {
              var p2 = has ? proxy(target[prop]) : UNINITIALIZED;
              var s22 = /* @__PURE__ */ state(p2);
              return s22;
            });
            sources.set(prop, s4);
          }
          var value2 = get(s4);
          if (value2 === UNINITIALIZED) {
            return false;
          }
        }
        return has;
      },
      set(target, prop, value2, receiver) {
        var s4 = sources.get(prop);
        var has = prop in target;
        if (is_proxied_array && prop === "length") {
          for (var i2 = value2; i2 < /** @type {Source<number>} */
          s4.v; i2 += 1) {
            var other_s = sources.get(i2 + "");
            if (other_s !== void 0) {
              set(other_s, UNINITIALIZED);
            } else if (i2 in target) {
              other_s = with_parent(() => /* @__PURE__ */ state(UNINITIALIZED));
              sources.set(i2 + "", other_s);
            }
          }
        }
        if (s4 === void 0) {
          if (!has || get_descriptor(target, prop)?.writable) {
            s4 = with_parent(() => /* @__PURE__ */ state(void 0));
            set(s4, proxy(value2));
            sources.set(prop, s4);
          }
        } else {
          has = s4.v !== UNINITIALIZED;
          var p2 = with_parent(() => proxy(value2));
          set(s4, p2);
        }
        var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
        if (descriptor?.set) {
          descriptor.set.call(receiver, value2);
        }
        if (!has) {
          if (is_proxied_array && typeof prop === "string") {
            var ls = (
              /** @type {Source<number>} */
              sources.get("length")
            );
            var n3 = Number(prop);
            if (Number.isInteger(n3) && n3 >= ls.v) {
              set(ls, n3 + 1);
            }
          }
          increment(version2);
        }
        return true;
      },
      ownKeys(target) {
        get(version2);
        var own_keys = Reflect.ownKeys(target).filter((key22) => {
          var source3 = sources.get(key22);
          return source3 === void 0 || source3.v !== UNINITIALIZED;
        });
        for (var [key2, source2] of sources) {
          if (source2.v !== UNINITIALIZED && !(key2 in target)) {
            own_keys.push(key2);
          }
        }
        return own_keys;
      },
      setPrototypeOf() {
        state_prototype_fixed();
      }
    }
  );
}
__name(proxy, "proxy");
var $window;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  var text_prototype = Text.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  if (is_extensible(element_prototype)) {
    element_prototype.__click = void 0;
    element_prototype.__className = void 0;
    element_prototype.__attributes = null;
    element_prototype.__style = void 0;
    element_prototype.__e = void 0;
  }
  if (is_extensible(text_prototype)) {
    text_prototype.__t = void 0;
  }
}
__name(init_operations, "init_operations");
function create_text(value = "") {
  return document.createTextNode(value);
}
__name(create_text, "create_text");
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
__name(get_first_child, "get_first_child");
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
__name(get_next_sibling, "get_next_sibling");
function clear_text_content(node) {
  node.textContent = "";
}
__name(clear_text_content, "clear_text_content");
function without_reactive_context(fn) {
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    return fn();
  } finally {
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(without_reactive_context, "without_reactive_context");
function push_effect(effect, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect;
  } else {
    parent_last.next = effect;
    effect.prev = parent_last;
    parent_effect.last = effect;
  }
}
__name(push_effect, "push_effect");
function create_effect(type, fn, sync, push22 = true) {
  var parent = active_effect;
  if (parent !== null && (parent.f & INERT) !== 0) {
    type |= INERT;
  }
  var effect = {
    ctx: component_context,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: type | DIRTY | CONNECTED,
    first: null,
    fn,
    last: null,
    next: null,
    parent,
    b: parent && parent.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (sync) {
    try {
      update_effect(effect);
      effect.f |= EFFECT_RAN;
    } catch (e23) {
      destroy_effect(effect);
      throw e23;
    }
  } else if (fn !== null) {
    schedule_effect(effect);
  }
  if (push22) {
    var e5 = effect;
    if (sync && e5.deps === null && e5.teardown === null && e5.nodes_start === null && e5.first === e5.last && // either `null`, or a singular child
    (e5.f & EFFECT_PRESERVED) === 0) {
      e5 = e5.first;
      if ((type & BLOCK_EFFECT) !== 0 && (type & EFFECT_TRANSPARENT) !== 0 && e5 !== null) {
        e5.f |= EFFECT_TRANSPARENT;
      }
    }
    if (e5 !== null) {
      e5.parent = parent;
      if (parent !== null) {
        push_effect(e5, parent);
      }
      if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0 && (type & ROOT_EFFECT) === 0) {
        var derived = (
          /** @type {Derived} */
          active_reaction
        );
        (derived.effects ??= []).push(e5);
      }
    }
  }
  return effect;
}
__name(create_effect, "create_effect");
function effect_tracking() {
  return active_reaction !== null && !untracking;
}
__name(effect_tracking, "effect_tracking");
function create_user_effect(fn) {
  return create_effect(EFFECT | USER_EFFECT, fn, false);
}
__name(create_user_effect, "create_user_effect");
function component_root(fn) {
  Batch.ensure();
  const effect = create_effect(ROOT_EFFECT | EFFECT_PRESERVED, fn, true);
  return (options2 = {}) => {
    return new Promise((fulfil) => {
      if (options2.outro) {
        pause_effect(effect, () => {
          destroy_effect(effect);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect);
        fulfil(void 0);
      }
    });
  };
}
__name(component_root, "component_root");
function render_effect(fn, flags2 = 0) {
  return create_effect(RENDER_EFFECT | flags2, fn, true);
}
__name(render_effect, "render_effect");
function block(fn, flags2 = 0) {
  var effect = create_effect(BLOCK_EFFECT | flags2, fn, true);
  return effect;
}
__name(block, "block");
function branch(fn, push22 = true) {
  return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push22);
}
__name(branch, "branch");
function execute_effect_teardown(effect) {
  var teardown = effect.teardown;
  if (teardown !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
__name(execute_effect_teardown, "execute_effect_teardown");
function destroy_effect_children(signal, remove_dom = false) {
  var effect = signal.first;
  signal.first = signal.last = null;
  while (effect !== null) {
    const controller2 = effect.ac;
    if (controller2 !== null) {
      without_reactive_context(() => {
        controller2.abort(STALE_REACTION);
      });
    }
    var next2 = effect.next;
    if ((effect.f & ROOT_EFFECT) !== 0) {
      effect.parent = null;
    } else {
      destroy_effect(effect, remove_dom);
    }
    effect = next2;
  }
}
__name(destroy_effect_children, "destroy_effect_children");
function destroy_block_effect_children(signal) {
  var effect = signal.first;
  while (effect !== null) {
    var next2 = effect.next;
    if ((effect.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect);
    }
    effect = next2;
  }
}
__name(destroy_block_effect_children, "destroy_block_effect_children");
function destroy_effect(effect, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null && effect.nodes_end !== null) {
    remove_effect_dom(
      effect.nodes_start,
      /** @type {TemplateNode} */
      effect.nodes_end
    );
    removed = true;
  }
  destroy_effect_children(effect, remove_dom && !removed);
  remove_reactions(effect, 0);
  set_signal_status(effect, DESTROYED);
  var transitions = effect.transitions;
  if (transitions !== null) {
    for (const transition of transitions) {
      transition.stop();
    }
  }
  execute_effect_teardown(effect);
  var parent = effect.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect);
  }
  effect.next = effect.prev = effect.teardown = effect.ctx = effect.deps = effect.fn = effect.nodes_start = effect.nodes_end = effect.ac = null;
}
__name(destroy_effect, "destroy_effect");
function remove_effect_dom(node, end) {
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    node.remove();
    node = next2;
  }
}
__name(remove_effect_dom, "remove_effect_dom");
function unlink_effect(effect) {
  var parent = effect.parent;
  var prev = effect.prev;
  var next2 = effect.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect) parent.first = next2;
    if (parent.last === effect) parent.last = prev;
  }
}
__name(unlink_effect, "unlink_effect");
function pause_effect(effect, callback, destroy = true) {
  var transitions = [];
  pause_children(effect, transitions, true);
  run_out_transitions(transitions, () => {
    if (destroy) destroy_effect(effect);
    if (callback) callback();
  });
}
__name(pause_effect, "pause_effect");
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = /* @__PURE__ */ __name(() => --remaining || fn(), "check");
    for (var transition of transitions) {
      transition.out(check);
    }
  } else {
    fn();
  }
}
__name(run_out_transitions, "run_out_transitions");
function pause_children(effect, transitions, local) {
  if ((effect.f & INERT) !== 0) return;
  effect.f ^= INERT;
  if (effect.transitions !== null) {
    for (const transition of effect.transitions) {
      if (transition.is_global || local) {
        transitions.push(transition);
      }
    }
  }
  var child = effect.first;
  while (child !== null) {
    var sibling = child.next;
    var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || // If this is a branch effect without a block effect parent,
    // it means the parent block effect was pruned. In that case,
    // transparency information was transferred to the branch effect.
    (child.f & BRANCH_EFFECT) !== 0 && (effect.f & BLOCK_EFFECT) !== 0;
    pause_children(child, transitions, transparent ? local : false);
    child = sibling;
  }
}
__name(pause_children, "pause_children");
function move_effect(effect, fragment) {
  var node = effect.nodes_start;
  var end = effect.nodes_end;
  while (node !== null) {
    var next2 = node === end ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(node)
    );
    fragment.append(node);
    node = next2;
  }
}
__name(move_effect, "move_effect");
var is_updating_effect = false;
function set_is_updating_effect(value) {
  is_updating_effect = value;
}
__name(set_is_updating_effect, "set_is_updating_effect");
var is_destroying_effect = false;
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
__name(set_is_destroying_effect, "set_is_destroying_effect");
var active_reaction = null;
var untracking = false;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
__name(set_active_reaction, "set_active_reaction");
var active_effect = null;
function set_active_effect(effect) {
  active_effect = effect;
}
__name(set_active_effect, "set_active_effect");
var current_sources = null;
function push_reaction_value(value) {
  if (active_reaction !== null && true) {
    if (current_sources === null) {
      current_sources = [value];
    } else {
      current_sources.push(value);
    }
  }
}
__name(push_reaction_value, "push_reaction_value");
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
__name(set_untracked_writes, "set_untracked_writes");
var write_version = 1;
var read_version = 0;
var update_version = read_version;
function set_update_version(value) {
  update_version = value;
}
__name(set_update_version, "set_update_version");
function increment_write_version() {
  return ++write_version;
}
__name(increment_write_version, "increment_write_version");
function is_dirty(reaction) {
  var flags2 = reaction.f;
  if ((flags2 & DIRTY) !== 0) {
    return true;
  }
  if (flags2 & DERIVED) {
    reaction.f &= ~WAS_MARKED;
  }
  if ((flags2 & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length = dependencies.length;
      for (var i2 = 0; i2 < length; i2++) {
        var dependency = dependencies[i2];
        if (is_dirty(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (dependency.wv > reaction.wv) {
          return true;
        }
      }
    }
    if ((flags2 & CONNECTED) !== 0 && // During time traveling we don't want to reset the status so that
    // traversal of the graph in the other batches still happens
    batch_values === null) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
__name(is_dirty, "is_dirty");
function schedule_possible_effect_self_invalidation(signal, effect, root2 = true) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  if (current_sources?.includes(signal)) {
    return;
  }
  for (var i2 = 0; i2 < reactions.length; i2++) {
    var reaction = reactions[i2];
    if ((reaction.f & DERIVED) !== 0) {
      schedule_possible_effect_self_invalidation(
        /** @type {Derived} */
        reaction,
        effect,
        false
      );
    } else if (effect === reaction) {
      if (root2) {
        set_signal_status(reaction, DIRTY);
      } else if ((reaction.f & CLEAN) !== 0) {
        set_signal_status(reaction, MAYBE_DIRTY);
      }
      schedule_effect(
        /** @type {Effect} */
        reaction
      );
    }
  }
}
__name(schedule_possible_effect_self_invalidation, "schedule_possible_effect_self_invalidation");
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_sources = current_sources;
  var previous_component_context = component_context;
  var previous_untracking = untracking;
  var previous_update_version = update_version;
  var flags2 = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags2 & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  current_sources = null;
  set_component_context(reaction.ctx);
  untracking = false;
  update_version = ++read_version;
  if (reaction.ac !== null) {
    without_reactive_context(() => {
      reaction.ac.abort(STALE_REACTION);
    });
    reaction.ac = null;
  }
  try {
    reaction.f |= REACTION_IS_UPDATING;
    var fn = (
      /** @type {Function} */
      reaction.fn
    );
    var result = fn();
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i2;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i2 = 0; i2 < new_deps.length; i2++) {
          deps[skipped_deps + i2] = new_deps[i2];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (is_updating_effect && effect_tracking() && (reaction.f & CONNECTED) !== 0) {
        for (i2 = skipped_deps; i2 < deps.length; i2++) {
          (deps[i2].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    if (is_runes() && untracked_writes !== null && !untracking && deps !== null && (reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0) {
      for (i2 = 0; i2 < /** @type {Source[]} */
      untracked_writes.length; i2++) {
        schedule_possible_effect_self_invalidation(
          untracked_writes[i2],
          /** @type {Effect} */
          reaction
        );
      }
    }
    if (previous_reaction !== null && previous_reaction !== reaction) {
      read_version++;
      if (untracked_writes !== null) {
        if (previous_untracked_writes === null) {
          previous_untracked_writes = untracked_writes;
        } else {
          previous_untracked_writes.push(.../** @type {Source[]} */
          untracked_writes);
        }
      }
    }
    if ((reaction.f & ERROR_VALUE) !== 0) {
      reaction.f ^= ERROR_VALUE;
    }
    return result;
  } catch (error4) {
    return handle_error(error4);
  } finally {
    reaction.f ^= REACTION_IS_UPDATING;
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    current_sources = previous_sources;
    set_component_context(previous_component_context);
    untracking = previous_untracking;
    update_version = previous_update_version;
  }
}
__name(update_reaction, "update_reaction");
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index5 = index_of.call(reactions, signal);
    if (index5 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index5] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & CONNECTED) !== 0) {
      dependency.f ^= CONNECTED;
      dependency.f &= ~WAS_MARKED;
    }
    destroy_derived_effects(
      /** @type {Derived} **/
      dependency
    );
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
__name(remove_reaction, "remove_reaction");
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i2 = start_index; i2 < dependencies.length; i2++) {
    remove_reaction(signal, dependencies[i2]);
  }
}
__name(remove_reactions, "remove_reactions");
function update_effect(effect) {
  var flags2 = effect.f;
  if ((flags2 & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect, CLEAN);
  var previous_effect = active_effect;
  var was_updating_effect = is_updating_effect;
  active_effect = effect;
  is_updating_effect = true;
  try {
    if ((flags2 & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect);
    } else {
      destroy_effect_children(effect);
    }
    execute_effect_teardown(effect);
    var teardown = update_reaction(effect);
    effect.teardown = typeof teardown === "function" ? teardown : null;
    effect.wv = write_version;
    var dep;
    if (BROWSER && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) ;
  } finally {
    is_updating_effect = was_updating_effect;
    active_effect = previous_effect;
  }
}
__name(update_effect, "update_effect");
function get(signal) {
  var flags2 = signal.f;
  var is_derived = (flags2 & DERIVED) !== 0;
  if (active_reaction !== null && !untracking) {
    var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;
    if (!destroyed && !current_sources?.includes(signal)) {
      var deps = active_reaction.deps;
      if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
        if (signal.rv < read_version) {
          signal.rv = read_version;
          if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
            skipped_deps++;
          } else if (new_deps === null) {
            new_deps = [signal];
          } else if (!new_deps.includes(signal)) {
            new_deps.push(signal);
          }
        }
      } else {
        (active_reaction.deps ??= []).push(signal);
        var reactions = signal.reactions;
        if (reactions === null) {
          signal.reactions = [active_reaction];
        } else if (!reactions.includes(active_reaction)) {
          reactions.push(active_reaction);
        }
      }
    }
  }
  if (is_destroying_effect) {
    if (old_values.has(signal)) {
      return old_values.get(signal);
    }
    if (is_derived) {
      var derived = (
        /** @type {Derived} */
        signal
      );
      var value = derived.v;
      if ((derived.f & CLEAN) === 0 && derived.reactions !== null || depends_on_old_values(derived)) {
        value = execute_derived(derived);
      }
      old_values.set(derived, value);
      return value;
    }
  } else if (is_derived) {
    derived = /** @type {Derived} */
    signal;
    if (batch_values?.has(derived)) {
      return batch_values.get(derived);
    }
    if (is_dirty(derived)) {
      update_derived(derived);
    }
    if (is_updating_effect && effect_tracking() && (derived.f & CONNECTED) === 0) {
      reconnect(derived);
    }
  } else if (batch_values?.has(signal)) {
    return batch_values.get(signal);
  }
  if ((signal.f & ERROR_VALUE) !== 0) {
    throw signal.v;
  }
  return signal.v;
}
__name(get, "get");
function reconnect(derived) {
  if (derived.deps === null) return;
  derived.f ^= CONNECTED;
  for (const dep of derived.deps) {
    (dep.reactions ??= []).push(derived);
    if ((dep.f & DERIVED) !== 0 && (dep.f & CONNECTED) === 0) {
      reconnect(
        /** @type {Derived} */
        dep
      );
    }
  }
}
__name(reconnect, "reconnect");
function depends_on_old_values(derived) {
  if (derived.v === UNINITIALIZED) return true;
  if (derived.deps === null) return false;
  for (const dep of derived.deps) {
    if (old_values.has(dep)) {
      return true;
    }
    if ((dep.f & DERIVED) !== 0 && depends_on_old_values(
      /** @type {Derived} */
      dep
    )) {
      return true;
    }
  }
  return false;
}
__name(depends_on_old_values, "depends_on_old_values");
function untrack(fn) {
  var previous_untracking = untracking;
  try {
    untracking = true;
    return fn();
  } finally {
    untracking = previous_untracking;
  }
}
__name(untrack, "untrack");
var STATUS_MASK = -7169;
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
__name(set_signal_status, "set_signal_status");
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var last_propagated_event = null;
function handle_event_propagation(event) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event.type;
  var path2 = event.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path2[0] || event.target
  );
  last_propagated_event = event;
  var path_idx = 0;
  var handled_at = last_propagated_event === event && event.__root;
  if (handled_at) {
    var at_idx = path2.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event.__root = handler_element;
      return;
    }
    var handler_idx = path2.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path2[path_idx] || event.target;
  if (current_target === handler_element) return;
  define_property(event, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated != null && (!/** @type {any} */
        current_target.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
        // -> the target could not have been disabled because it emits the event in the first place
        event.target === current_target)) {
          delegated.call(current_target, event);
        }
      } catch (error4) {
        if (throw_error) {
          other_errors.push(error4);
        } else {
          throw_error = error4;
        }
      }
      if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error4 of other_errors) {
        queueMicrotask(() => {
          throw error4;
        });
      }
      throw throw_error;
    }
  } finally {
    event.__root = handler_element;
    delete event.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}
__name(handle_event_propagation, "handle_event_propagation");
function assign_nodes(start, end) {
  var effect = (
    /** @type {Effect} */
    active_effect
  );
  if (effect.nodes_start === null) {
    effect.nodes_start = start;
    effect.nodes_end = end;
  }
}
__name(assign_nodes, "assign_nodes");
function mount(component5, options2) {
  return _mount(component5, options2);
}
__name(mount, "mount");
function hydrate(component5, options2) {
  init_operations();
  options2.intro = options2.intro ?? false;
  const target = options2.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== COMMENT_NODE || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      /* @__PURE__ */ get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    const instance = _mount(component5, { ...options2, anchor });
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error4) {
    if (error4 instanceof Error && error4.message.split("\n").some((line) => line.startsWith("https://svelte.dev/e/"))) {
      throw error4;
    }
    if (error4 !== HYDRATION_ERROR) {
      console.warn("Failed to hydrate: ", error4);
    }
    if (options2.recover === false) {
      hydration_failed();
    }
    init_operations();
    clear_text_content(target);
    set_hydrating(false);
    return mount(component5, options2);
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
  }
}
__name(hydrate, "hydrate");
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context: context3, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = /* @__PURE__ */ __name((events2) => {
    for (var i2 = 0; i2 < events2.length; i2++) {
      var event_name = events2[i2];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive });
      var n3 = document_listeners.get(event_name);
      if (n3 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n3 + 1);
      }
    }
  }, "event_handle");
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component5 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    boundary(
      /** @type {TemplateNode} */
      anchor_node,
      {
        pending: /* @__PURE__ */ __name(() => {
        }, "pending")
      },
      (anchor_node2) => {
        if (context3) {
          push2({});
          var ctx = (
            /** @type {ComponentContext} */
            component_context
          );
          ctx.c = context3;
        }
        if (events) {
          props.$$events = events;
        }
        if (hydrating) {
          assign_nodes(
            /** @type {TemplateNode} */
            anchor_node2,
            null
          );
        }
        component5 = Component(anchor_node2, props) || {};
        if (hydrating) {
          active_effect.nodes_end = hydrate_node;
          if (hydrate_node === null || hydrate_node.nodeType !== COMMENT_NODE || /** @type {Comment} */
          hydrate_node.data !== HYDRATION_END) {
            hydration_mismatch();
            throw HYDRATION_ERROR;
          }
        }
        if (context3) {
          pop2();
        }
      }
    );
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n3 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n3 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n3);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component5, unmount2);
  return component5;
}
__name(_mount, "_mount");
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component5, options2) {
  const fn = mounted_components.get(component5);
  if (fn) {
    mounted_components.delete(component5);
    return fn(options2);
  }
  return Promise.resolve();
}
__name(unmount, "unmount");
function asClassComponent$1(component5) {
  return class extends Svelte4Component {
    /** @param {any} options */
    constructor(options2) {
      super({
        component: component5,
        ...options2
      });
    }
  };
}
__name(asClassComponent$1, "asClassComponent$1");
var Svelte4Component = class {
  static {
    __name(this, "Svelte4Component");
  }
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options2) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = /* @__PURE__ */ __name((key2, value) => {
      var s4 = /* @__PURE__ */ mutable_source(value, false, false);
      sources.set(key2, s4);
      return s4;
    }, "add_source");
    const props = new Proxy(
      { ...options2.props || {}, $$events: {} },
      {
        get(target, prop) {
          return get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
        },
        has(target, prop) {
          if (prop === LEGACY_PROPS) return true;
          get(sources.get(prop) ?? add_source(prop, Reflect.get(target, prop)));
          return Reflect.has(target, prop);
        },
        set(target, prop, value) {
          set(sources.get(prop) ?? add_source(prop, value), value);
          return Reflect.set(target, prop, value);
        }
      }
    );
    this.#instance = (options2.hydrate ? hydrate : mount)(options2.component, {
      target: options2.target,
      anchor: options2.anchor,
      props,
      context: options2.context,
      intro: options2.intro ?? false,
      recover: options2.recover
    });
    if (!options2?.props?.$$host || options2.sync === false) {
      flushSync();
    }
    this.#events = props.$$events;
    for (const key2 of Object.keys(this.#instance)) {
      if (key2 === "$set" || key2 === "$destroy" || key2 === "$on") continue;
      define_property(this, key2, {
        get() {
          return this.#instance[key2];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key2] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event, callback) {
    this.#events[event] = this.#events[event] || [];
    const cb = /* @__PURE__ */ __name((...args) => callback.call(this, ...args), "cb");
    this.#events[event].push(cb);
    return () => {
      this.#events[event] = this.#events[event].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};
var read_implementation = null;
function set_read_implementation(fn) {
  read_implementation = fn;
}
__name(set_read_implementation, "set_read_implementation");
function asClassComponent(component5) {
  const component_constructor = asClassComponent$1(component5);
  const _render = /* @__PURE__ */ __name((props, { context: context3 } = {}) => {
    const result = render(component5, { props, context: context3 });
    const munged = Object.defineProperties(
      /** @type {LegacyRenderResult & PromiseLike<LegacyRenderResult>} */
      {},
      {
        css: {
          value: { code: "", map: null }
        },
        head: {
          get: /* @__PURE__ */ __name(() => result.head, "get")
        },
        html: {
          get: /* @__PURE__ */ __name(() => result.body, "get")
        },
        then: {
          /**
           * this is not type-safe, but honestly it's the best I can do right now, and it's a straightforward function.
           *
           * @template TResult1
           * @template [TResult2=never]
           * @param { (value: LegacyRenderResult) => TResult1 } onfulfilled
           * @param { (reason: unknown) => TResult2 } onrejected
           */
          value: /* @__PURE__ */ __name((onfulfilled, onrejected) => {
            {
              const user_result = onfulfilled({
                css: munged.css,
                head: munged.head,
                html: munged.html
              });
              return Promise.resolve(user_result);
            }
          }, "value")
        }
      }
    );
    return munged;
  }, "_render");
  component_constructor.render = _render;
  return component_constructor;
}
__name(asClassComponent, "asClassComponent");
function Root($$renderer, $$props) {
  $$renderer.component(($$renderer2) => {
    let {
      stores: stores2,
      page: page2,
      constructors,
      components = [],
      form,
      data_0 = null,
      data_1 = null
    } = $$props;
    {
      setContext("__svelte__", stores2);
    }
    {
      stores2.page.set(page2);
    }
    const Pyramid_1 = constructors[1];
    if (constructors[1]) {
      $$renderer2.push("<!--[-->");
      const Pyramid_0 = constructors[0];
      $$renderer2.push(`<!---->`);
      Pyramid_0($$renderer2, {
        data: data_0,
        form,
        params: page2.params,
        children: /* @__PURE__ */ __name(($$renderer3) => {
          $$renderer3.push(`<!---->`);
          Pyramid_1($$renderer3, { data: data_1, form, params: page2.params });
          $$renderer3.push(`<!---->`);
        }, "children"),
        $$slots: { default: true }
      });
      $$renderer2.push(`<!---->`);
    } else {
      $$renderer2.push("<!--[!-->");
      const Pyramid_0 = constructors[0];
      $$renderer2.push(`<!---->`);
      Pyramid_0($$renderer2, { data: data_0, form, params: page2.params });
      $$renderer2.push(`<!---->`);
    }
    $$renderer2.push(`<!--]--> `);
    {
      $$renderer2.push("<!--[!-->");
    }
    $$renderer2.push(`<!--]-->`);
  });
}
__name(Root, "Root");
var root = asClassComponent(Root);
var options = {
  app_template_contains_nonce: false,
  async: false,
  csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
  csrf_check_origin: true,
  csrf_trusted_origins: [],
  embedded: false,
  env_public_prefix: "PUBLIC_",
  env_private_prefix: "",
  hash_routing: false,
  hooks: null,
  // added lazily, via `get_hooks`
  preload_strategy: "modulepreload",
  root,
  service_worker: false,
  service_worker_options: void 0,
  templates: {
    app: /* @__PURE__ */ __name(({ head: head2, body: body2, assets: assets2, nonce, env: env3 }) => '<!doctype html>\r\n<html lang="en">\r\n	<head>\r\n		<meta charset="utf-8" />\r\n		<meta name="viewport" content="width=device-width, initial-scale=1.0" />\r\n		' + head2 + '\r\n	</head>\r\n	<body data-sveltekit-preload-data="hover">\r\n		<div style="display: contents">' + body2 + "</div>\r\n	</body>\r\n</html>\r\n\r\n", "app"),
    error: /* @__PURE__ */ __name(({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n", "error")
  },
  version_hash: "1r8jy0i"
};
async function get_hooks() {
  let handle;
  let handleFetch;
  let handleError;
  let handleValidationError;
  let init3;
  let reroute;
  let transport;
  return {
    handle,
    handleFetch,
    handleError,
    handleValidationError,
    init: init3,
    reroute,
    transport
  };
}
__name(get_hooks, "get_hooks");

// .svelte-kit/output/server/chunks/shared.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
init_utils3();
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
function stringify2(data, transport) {
  const encoders = Object.fromEntries(Object.entries(transport).map(([k2, v2]) => [k2, v2.encode]));
  return stringify(data, encoders);
}
__name(stringify2, "stringify");
function parse_remote_arg(string, transport) {
  if (!string) return void 0;
  const json_string = text_decoder2.decode(
    // no need to add back `=` characters, atob can handle it
    base64_decode(string.replaceAll("-", "+").replaceAll("_", "/"))
  );
  const decoders = Object.fromEntries(Object.entries(transport).map(([k2, v2]) => [k2, v2.decode]));
  return parse(json_string, decoders);
}
__name(parse_remote_arg, "parse_remote_arg");
function create_remote_cache_key(id, payload) {
  return id + "/" + payload;
}
__name(create_remote_cache_key, "create_remote_cache_key");

// .svelte-kit/output/server/index.js
var import_cookie = __toESM(require_cookie(), 1);
var set_cookie_parser = __toESM(require_set_cookie(), 1);
function with_resolvers() {
  let resolve22;
  let reject2;
  const promise = new Promise((res, rej) => {
    resolve22 = res;
    reject2 = rej;
  });
  return { promise, resolve: resolve22, reject: reject2 };
}
__name(with_resolvers, "with_resolvers");
var NULL_BODY_STATUS = [101, 103, 204, 205, 304];
var IN_WEBCONTAINER2 = !!globalThis.process?.versions?.webcontainer;
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i2) => {
    const match = /([^/ \t]+)\/([^; \t]+)[ \t]*(?:;[ \t]*q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      parts.push({ type, subtype, q: +q, i: i2 });
    }
  });
  parts.sort((a2, b2) => {
    if (a2.q !== b2.q) {
      return b2.q - a2.q;
    }
    if (a2.subtype === "*" !== (b2.subtype === "*")) {
      return a2.subtype === "*" ? 1 : -1;
    }
    if (a2.type === "*" !== (b2.type === "*")) {
      return a2.type === "*" ? 1 : -1;
    }
    return a2.i - b2.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
__name(negotiate, "negotiate");
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
__name(is_content_type, "is_content_type");
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
__name(is_form_content_type, "is_form_content_type");
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
__name(coalesce_to_error, "coalesce_to_error");
function normalize_error(error22) {
  return (
    /** @type {import('../exports/internal/index.js').Redirect | HttpError | SvelteKitError | Error} */
    error22
  );
}
__name(normalize_error, "normalize_error");
function get_status(error22) {
  return error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : 500;
}
__name(get_status, "get_status");
function get_message(error22) {
  return error22 instanceof SvelteKitError ? error22.text : "Internal Error";
}
__name(get_message, "get_message");
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
  // Svelte also escapes < because the escape function could be called inside a `noscript` there
  // https://github.com/sveltejs/svelte/security/advisories/GHSA-8266-84wp-wv5c
  // However, that doesn't apply in SvelteKit
};
var escape_html_dict = {
  "&": "&amp;",
  "<": "&lt;"
};
var surrogates = (
  // high surrogate without paired low surrogate
  "[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]"
);
var escape_html_attr_regex = new RegExp(
  `[${Object.keys(escape_html_attr_dict).join("")}]|` + surrogates,
  "g"
);
var escape_html_regex = new RegExp(
  `[${Object.keys(escape_html_dict).join("")}]|` + surrogates,
  "g"
);
function escape_html2(str, is_attr) {
  const dict = is_attr ? escape_html_attr_dict : escape_html_dict;
  const escaped_str = str.replace(is_attr ? escape_html_attr_regex : escape_html_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return escaped_str;
}
__name(escape_html2, "escape_html");
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
__name(method_not_allowed, "method_not_allowed");
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod && !("HEAD" in mod)) {
    allowed.push("HEAD");
  }
  return allowed;
}
__name(allowed_methods, "allowed_methods");
function get_global_name(options2) {
  return `__sveltekit_${options2.version_hash}`;
}
__name(get_global_name, "get_global_name");
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message: escape_html2(message) });
  return text(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
__name(static_error_page, "static_error_page");
async function handle_fatal_error(event, state2, options2, error22) {
  error22 = error22 instanceof HttpError ? error22 : coalesce_to_error(error22);
  const status = get_status(error22);
  const body2 = await handle_error_and_jsonify(event, state2, options2, error22);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body2, {
      status
    });
  }
  return static_error_page(options2, status, body2.message);
}
__name(handle_fatal_error, "handle_fatal_error");
async function handle_error_and_jsonify(event, state2, options2, error22) {
  if (error22 instanceof HttpError) {
    return { message: "Unknown Error", ...error22.body };
  }
  const status = get_status(error22);
  const message = get_message(error22);
  return await with_request_store(
    { event, state: state2 },
    () => options2.hooks.handleError({ error: error22, event, status, message })
  ) ?? { message };
}
__name(handle_error_and_jsonify, "handle_error_and_jsonify");
function redirect_response(status, location) {
  const response = new Response(void 0, {
    status,
    headers: { location }
  });
  return response;
}
__name(redirect_response, "redirect_response");
function clarify_devalue_error(event, error22) {
  if (error22.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error22.message} (${error22.path}). If you need to serialize/deserialize custom types, use transport hooks: https://svelte.dev/docs/kit/hooks#Universal-hooks-transport.`;
  }
  if (error22.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error22.message;
}
__name(clarify_devalue_error, "clarify_devalue_error");
function serialize_uses(node) {
  const uses = {};
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.dependencies = Array.from(node.uses.dependencies);
  }
  if (node.uses && node.uses.search_params.size > 0) {
    uses.search_params = Array.from(node.uses.search_params);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.params = Array.from(node.uses.params);
  }
  if (node.uses?.parent) uses.parent = 1;
  if (node.uses?.route) uses.route = 1;
  if (node.uses?.url) uses.url = 1;
  return uses;
}
__name(serialize_uses, "serialize_uses");
function has_prerendered_path(manifest2, pathname) {
  return manifest2._.prerendered_routes.has(pathname) || pathname.at(-1) === "/" && manifest2._.prerendered_routes.has(pathname.slice(0, -1));
}
__name(has_prerendered_path, "has_prerendered_path");
function format_server_error(status, error22, event) {
  const formatted_text = `
\x1B[1;31m[${status}] ${event.request.method} ${event.url.pathname}\x1B[0m`;
  if (status === 404) {
    return formatted_text;
  }
  return `${formatted_text}
${error22.stack}`;
}
__name(format_server_error, "format_server_error");
function get_node_type(node_id) {
  const parts = node_id?.split("/");
  const filename = parts?.at(-1);
  if (!filename) return "unknown";
  const dot_parts = filename.split(".");
  return dot_parts.slice(0, -1).join(".");
}
__name(get_node_type, "get_node_type");
async function render_endpoint(event, event_state, mod, state2) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && !mod.HEAD && mod.GET) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state2.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state2.prerendering && !state2.prerendering.inside_reroute && !prerender) {
    if (state2.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  event_state.is_endpoint_request = true;
  try {
    const response = await with_request_store(
      { event, state: event_state },
      () => handler(
        /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
        event
      )
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state2.prerendering && (!state2.prerendering.inside_reroute || prerender)) {
      const cloned = new Response(response.clone().body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      cloned.headers.set("x-sveltekit-prerender", String(prerender));
      if (state2.prerendering.inside_reroute && prerender) {
        cloned.headers.set(
          "x-sveltekit-routeid",
          encodeURI(
            /** @type {string} */
            event.route.id
          )
        );
        state2.prerendering.dependencies.set(event.url.pathname, { response: cloned, body: null });
      } else {
        return cloned;
      }
    }
    return response;
  } catch (e5) {
    if (e5 instanceof Redirect) {
      return new Response(void 0, {
        status: e5.status,
        headers: { location: e5.location }
      });
    }
    throw e5;
  }
}
__name(render_endpoint, "render_endpoint");
function is_endpoint_request(event) {
  const { method, headers: headers2 } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers2.get("x-sveltekit-action") === "true") return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
__name(is_endpoint_request, "is_endpoint_request");
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
__name(compact, "compact");
var DATA_SUFFIX = "/__data.json";
var HTML_DATA_SUFFIX = ".html__data.json";
function has_data_suffix2(pathname) {
  return pathname.endsWith(DATA_SUFFIX) || pathname.endsWith(HTML_DATA_SUFFIX);
}
__name(has_data_suffix2, "has_data_suffix");
function add_data_suffix2(pathname) {
  if (pathname.endsWith(".html")) return pathname.replace(/\.html$/, HTML_DATA_SUFFIX);
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
__name(add_data_suffix2, "add_data_suffix");
function strip_data_suffix2(pathname) {
  if (pathname.endsWith(HTML_DATA_SUFFIX)) {
    return pathname.slice(0, -HTML_DATA_SUFFIX.length) + ".html";
  }
  return pathname.slice(0, -DATA_SUFFIX.length);
}
__name(strip_data_suffix2, "strip_data_suffix");
var ROUTE_SUFFIX = "/__route.js";
function has_resolution_suffix2(pathname) {
  return pathname.endsWith(ROUTE_SUFFIX);
}
__name(has_resolution_suffix2, "has_resolution_suffix");
function add_resolution_suffix2(pathname) {
  return pathname.replace(/\/$/, "") + ROUTE_SUFFIX;
}
__name(add_resolution_suffix2, "add_resolution_suffix");
function strip_resolution_suffix2(pathname) {
  return pathname.slice(0, -ROUTE_SUFFIX.length);
}
__name(strip_resolution_suffix2, "strip_resolution_suffix");
var noop_span = {
  spanContext() {
    return noop_span_context;
  },
  setAttribute() {
    return this;
  },
  setAttributes() {
    return this;
  },
  addEvent() {
    return this;
  },
  setStatus() {
    return this;
  },
  updateName() {
    return this;
  },
  end() {
    return this;
  },
  isRecording() {
    return false;
  },
  recordException() {
    return this;
  },
  addLink() {
    return this;
  },
  addLinks() {
    return this;
  }
};
var noop_span_context = {
  traceId: "",
  spanId: "",
  traceFlags: 0
};
async function record_span({ name, attributes: attributes2, fn }) {
  {
    return fn(noop_span);
  }
}
__name(record_span, "record_span");
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
__name(is_action_json_request, "is_action_json_request");
async function handle_action_json_request(event, event_state, options2, server2) {
  const actions = server2?.actions;
  if (!actions) {
    const no_actions_error = new SvelteKitError(
      405,
      "Method Not Allowed",
      `POST method not allowed. No form actions exist for ${"this page"}`
    );
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, event_state, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, event_state, actions);
    if (BROWSER) ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        )
      });
    }
  } catch (e5) {
    const err = normalize_error(e5);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(
          event,
          event_state,
          options2,
          check_incorrect_fail_use(err)
        )
      },
      {
        status: get_status(err)
      }
    );
  }
}
__name(handle_action_json_request, "handle_action_json_request");
function check_incorrect_fail_use(error22) {
  return error22 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error22;
}
__name(check_incorrect_fail_use, "check_incorrect_fail_use");
function action_json_redirect(redirect) {
  return action_json({
    type: "redirect",
    status: redirect.status,
    location: redirect.location
  });
}
__name(action_json_redirect, "action_json_redirect");
function action_json(data, init22) {
  return json(data, init22);
}
__name(action_json, "action_json");
function is_action_request(event) {
  return event.request.method === "POST";
}
__name(is_action_request, "is_action_request");
async function handle_action_request(event, event_state, server2) {
  const actions = server2?.actions;
  if (!actions) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  check_named_default_separate(actions);
  try {
    const data = await call_action(event, event_state, actions);
    if (BROWSER) ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e5) {
    const err = normalize_error(e5);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
__name(handle_action_request, "handle_action_request");
function check_named_default_separate(actions) {
  if (actions.default && Object.keys(actions).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://svelte.dev/docs/kit/form-actions#named-actions"
    );
  }
}
__name(check_named_default_separate, "check_named_default_separate");
async function call_action(event, event_state, actions) {
  const url = new URL(event.request.url);
  let name = "default";
  for (const param of url.searchParams) {
    if (param[0].startsWith("/")) {
      name = param[0].slice(1);
      if (name === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions[name];
  if (!action) {
    throw new SvelteKitError(404, "Not Found", `No action with name '${name}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new SvelteKitError(
      415,
      "Unsupported Media Type",
      `Form actions expect form-encoded data \u2014 received ${event.request.headers.get(
        "content-type"
      )}`
    );
  }
  return record_span({
    name: "sveltekit.form_action",
    attributes: {
      "http.route": event.route.id || "unknown"
    },
    fn: /* @__PURE__ */ __name(async (current2) => {
      const traced_event = merge_tracing(event, current2);
      const result = await with_request_store(
        { event: traced_event, state: event_state },
        () => action(traced_event)
      );
      if (result instanceof ActionFailure) {
        current2.setAttributes({
          "sveltekit.form_action.result.type": "failure",
          "sveltekit.form_action.result.status": result.status
        });
      }
      return result;
    }, "fn")
  });
}
__name(call_action, "call_action");
function uneval_action_response(data, route_id, transport) {
  const replacer = /* @__PURE__ */ __name((thing) => {
    for (const key2 in transport) {
      const encoded = transport[key2].encode(thing);
      if (encoded) {
        return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
      }
    }
  }, "replacer");
  return try_serialize(data, (value) => uneval(value, replacer), route_id);
}
__name(uneval_action_response, "uneval_action_response");
function stringify_action_response(data, route_id, transport) {
  const encoders = Object.fromEntries(
    Object.entries(transport).map(([key2, value]) => [key2, value.encode])
  );
  return try_serialize(data, (value) => stringify(value, encoders), route_id);
}
__name(stringify_action_response, "stringify_action_response");
function try_serialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e5) {
    const error22 = (
      /** @type {any} */
      e5
    );
    if (data instanceof Response) {
      throw new Error(
        `Data returned from action inside ${route_id} is not serializable. Form actions need to return plain objects or fail(). E.g. return { success: true } or return fail(400, { message: "invalid" });`
      );
    }
    if ("path" in error22) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error22.message}`;
      if (error22.path !== "") message += ` (data.${error22.path})`;
      throw new Error(message);
    }
    throw error22;
  }
}
__name(try_serialize, "try_serialize");
function create_async_iterator() {
  let resolved = -1;
  let returned = -1;
  const deferred2 = [];
  return {
    iterate: /* @__PURE__ */ __name((transform = (x2) => x2) => {
      return {
        [Symbol.asyncIterator]() {
          return {
            next: /* @__PURE__ */ __name(async () => {
              const next2 = deferred2[++returned];
              if (!next2) return { value: null, done: true };
              const value = await next2.promise;
              return { value: transform(value), done: false };
            }, "next")
          };
        }
      };
    }, "iterate"),
    add: /* @__PURE__ */ __name((promise) => {
      deferred2.push(with_resolvers());
      void promise.then((value) => {
        deferred2[++resolved].resolve(value);
      });
    }, "add")
  };
}
__name(create_async_iterator, "create_async_iterator");
function server_data_serializer(event, event_state, options2) {
  let promise_id = 1;
  let max_nodes = -1;
  const iterator = create_async_iterator();
  const global2 = get_global_name(options2);
  function get_replacer(index5) {
    return /* @__PURE__ */ __name(function replacer(thing) {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        const promise = thing.then(
          /** @param {any} data */
          (data) => ({ data })
        ).catch(
          /** @param {any} error */
          async (error22) => ({
            error: await handle_error_and_jsonify(event, event_state, options2, error22)
          })
        ).then(
          /**
           * @param {{data: any; error: any}} result
           */
          async ({ data, error: error22 }) => {
            let str;
            try {
              str = uneval(error22 ? [, error22] : [data], replacer);
            } catch {
              error22 = await handle_error_and_jsonify(
                event,
                event_state,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              data = void 0;
              str = uneval([, error22], replacer);
            }
            return {
              index: index5,
              str: `${global2}.resolve(${id}, ${str.includes("app.decode") ? `(app) => ${str}` : `() => ${str}`})`
            };
          }
        );
        iterator.add(promise);
        return `${global2}.defer(${id})`;
      } else {
        for (const key2 in options2.hooks.transport) {
          const encoded = options2.hooks.transport[key2].encode(thing);
          if (encoded) {
            return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
          }
        }
      }
    }, "replacer");
  }
  __name(get_replacer, "get_replacer");
  const strings2 = (
    /** @type {string[]} */
    []
  );
  return {
    set_max_nodes(i2) {
      max_nodes = i2;
    },
    add_node(i2, node) {
      try {
        if (!node) {
          strings2[i2] = "null";
          return;
        }
        const payload = { type: "data", data: node.data, uses: serialize_uses(node) };
        if (node.slash) payload.slash = node.slash;
        strings2[i2] = uneval(payload, get_replacer(i2));
      } catch (e5) {
        e5.path = e5.path.slice(1);
        throw new Error(clarify_devalue_error(
          event,
          /** @type {any} */
          e5
        ));
      }
    },
    get_data(csp) {
      const open = `<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>`;
      const close = `<\/script>
`;
      return {
        data: `[${compact(max_nodes > -1 ? strings2.slice(0, max_nodes) : strings2).join(",")}]`,
        chunks: promise_id > 1 ? iterator.iterate(({ index: index5, str }) => {
          if (max_nodes > -1 && index5 >= max_nodes) {
            return "";
          }
          return open + str + close;
        }) : null
      };
    }
  };
}
__name(server_data_serializer, "server_data_serializer");
function server_data_serializer_json(event, event_state, options2) {
  let promise_id = 1;
  const iterator = create_async_iterator();
  const reducers = {
    ...Object.fromEntries(
      Object.entries(options2.hooks.transport).map(([key2, value]) => [key2, value.encode])
    ),
    /** @param {any} thing */
    Promise: /* @__PURE__ */ __name((thing) => {
      if (typeof thing?.then !== "function") {
        return;
      }
      const id = promise_id++;
      let key2 = "data";
      const promise = thing.catch(
        /** @param {any} e */
        async (e5) => {
          key2 = "error";
          return handle_error_and_jsonify(
            event,
            event_state,
            options2,
            /** @type {any} */
            e5
          );
        }
      ).then(
        /** @param {any} value */
        async (value) => {
          let str;
          try {
            str = stringify(value, reducers);
          } catch {
            const error22 = await handle_error_and_jsonify(
              event,
              event_state,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            key2 = "error";
            str = stringify(error22, reducers);
          }
          return `{"type":"chunk","id":${id},"${key2}":${str}}
`;
        }
      );
      iterator.add(promise);
      return id;
    }, "Promise")
  };
  const strings2 = (
    /** @type {string[]} */
    []
  );
  return {
    add_node(i2, node) {
      try {
        if (!node) {
          strings2[i2] = "null";
          return;
        }
        if (node.type === "error" || node.type === "skip") {
          strings2[i2] = JSON.stringify(node);
          return;
        }
        strings2[i2] = `{"type":"data","data":${stringify(node.data, reducers)},"uses":${JSON.stringify(
          serialize_uses(node)
        )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
      } catch (e5) {
        e5.path = "data" + e5.path;
        throw new Error(clarify_devalue_error(
          event,
          /** @type {any} */
          e5
        ));
      }
    },
    get_data() {
      return {
        data: `{"type":"data","nodes":[${strings2.join(",")}]}
`,
        chunks: promise_id > 1 ? iterator.iterate() : null
      };
    }
  };
}
__name(server_data_serializer_json, "server_data_serializer_json");
async function load_server_data({ event, event_state, state: state2, node, parent }) {
  if (!node?.server) return null;
  let is_tracking = true;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false,
    search_params: /* @__PURE__ */ new Set()
  };
  const load2 = node.server.load;
  const slash = node.server.trailingSlash;
  if (!load2) {
    return { type: "data", data: null, uses, slash };
  }
  const url = make_trackable(
    event.url,
    () => {
      if (is_tracking) {
        uses.url = true;
      }
    },
    (param) => {
      if (is_tracking) {
        uses.search_params.add(param);
      }
    }
  );
  if (state2.prerendering) {
    disable_search(url);
  }
  const result = await record_span({
    name: "sveltekit.load",
    attributes: {
      "sveltekit.load.node_id": node.server_id || "unknown",
      "sveltekit.load.node_type": get_node_type(node.server_id),
      "http.route": event.route.id || "unknown"
    },
    fn: /* @__PURE__ */ __name(async (current2) => {
      const traced_event = merge_tracing(event, current2);
      const result2 = await with_request_store(
        { event: traced_event, state: event_state },
        () => load2.call(null, {
          ...traced_event,
          fetch: /* @__PURE__ */ __name((info3, init22) => {
            new URL(info3 instanceof Request ? info3.url : info3, event.url);
            return event.fetch(info3, init22);
          }, "fetch"),
          /** @param {string[]} deps */
          depends: /* @__PURE__ */ __name((...deps) => {
            for (const dep of deps) {
              const { href } = new URL(dep, event.url);
              uses.dependencies.add(href);
            }
          }, "depends"),
          params: new Proxy(event.params, {
            get: /* @__PURE__ */ __name((target, key2) => {
              if (is_tracking) {
                uses.params.add(key2);
              }
              return target[
                /** @type {string} */
                key2
              ];
            }, "get")
          }),
          parent: /* @__PURE__ */ __name(async () => {
            if (is_tracking) {
              uses.parent = true;
            }
            return parent();
          }, "parent"),
          route: new Proxy(event.route, {
            get: /* @__PURE__ */ __name((target, key2) => {
              if (is_tracking) {
                uses.route = true;
              }
              return target[
                /** @type {'id'} */
                key2
              ];
            }, "get")
          }),
          url,
          untrack(fn) {
            is_tracking = false;
            try {
              return fn();
            } finally {
              is_tracking = true;
            }
          }
        })
      );
      return result2;
    }, "fn")
  });
  return {
    type: "data",
    data: result ?? null,
    uses,
    slash
  };
}
__name(load_server_data, "load_server_data");
async function load_data({
  event,
  event_state,
  fetched,
  node,
  parent,
  server_data_promise,
  state: state2,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  const load2 = node?.universal?.load;
  if (!load2) {
    return server_data_node?.data ?? null;
  }
  const result = await record_span({
    name: "sveltekit.load",
    attributes: {
      "sveltekit.load.node_id": node.universal_id || "unknown",
      "sveltekit.load.node_type": get_node_type(node.universal_id),
      "http.route": event.route.id || "unknown"
    },
    fn: /* @__PURE__ */ __name(async (current2) => {
      const traced_event = merge_tracing(event, current2);
      return await with_request_store(
        { event: traced_event, state: event_state },
        () => load2.call(null, {
          url: event.url,
          params: event.params,
          data: server_data_node?.data ?? null,
          route: event.route,
          fetch: create_universal_fetch(event, state2, fetched, csr, resolve_opts),
          setHeaders: event.setHeaders,
          depends: /* @__PURE__ */ __name(() => {
          }, "depends"),
          parent,
          untrack: /* @__PURE__ */ __name((fn) => fn(), "untrack"),
          tracing: traced_event.tracing
        })
      );
    }, "fn")
  });
  return result ?? null;
}
__name(load_data, "load_data");
function create_universal_fetch(event, state2, fetched, csr, resolve_opts) {
  const universal_fetch = /* @__PURE__ */ __name(async (input, init22) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init22?.headers;
    let response = await event.fetch(input, init22);
    const url = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state2.prerendering) {
        dependency = { response, body: null };
        state2.prerendering.dependencies.set(url.pathname, dependency);
      }
    } else if (url.protocol === "https:" || url.protocol === "http:") {
      const mode = input instanceof Request ? input.mode : init22?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    let teed_body;
    const proxy2 = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body2, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url.href.slice(event.url.origin.length) : url.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init22?.body
            ),
            request_headers: cloned_headers,
            response_body: body2,
            response: response2,
            is_b64
          });
        }
        __name(push_fetched, "push_fetched");
        if (key2 === "body") {
          if (response2.body === null) {
            return null;
          }
          if (teed_body) {
            return teed_body;
          }
          const [a2, b2] = response2.body.tee();
          void (async () => {
            let result = new Uint8Array();
            for await (const chunk of a2) {
              const combined = new Uint8Array(result.length + chunk.length);
              combined.set(result, 0);
              combined.set(chunk, result.length);
              result = combined;
            }
            if (dependency) {
              dependency.body = new Uint8Array(result);
            }
            void push_fetched(base64_encode(result), true);
          })();
          return teed_body = b2;
        }
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            if (dependency) {
              dependency.body = bytes;
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(base64_encode(bytes), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body2 = await response2.text();
          if (body2 === "" && NULL_BODY_STATUS.includes(response2.status)) {
            await push_fetched(void 0, false);
            return void 0;
          }
          if (!body2 || typeof body2 === "string") {
            await push_fetched(body2, false);
          }
          if (dependency) {
            dependency.body = body2;
          }
          return body2;
        }
        __name(text2, "text2");
        if (key2 === "text") {
          return text2;
        }
        if (key2 === "json") {
          return async () => {
            const body2 = await text2();
            return body2 ? JSON.parse(body2) : void 0;
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get2 = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get2.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://svelte.dev/docs/kit/hooks#Server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy2;
  }, "universal_fetch");
  return (input, init22) => {
    const response = universal_fetch(input, init22);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_universal_fetch, "create_universal_fetch");
async function stream_to_string(stream3) {
  let result = "";
  const reader = stream3.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += text_decoder2.decode(value);
  }
  return result;
}
__name(stream_to_string, "stream_to_string");
function hash(...values) {
  let hash2 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i2 = value.length;
      while (i2) hash2 = hash2 * 33 ^ value.charCodeAt(--i2);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i2 = buffer.length;
      while (i2) hash2 = hash2 * 33 ^ buffer[--i2];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash2 >>> 0).toString(36);
}
__name(hash, "hash");
var replacements2 = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements2).join("")}]`, "g");
function serialize_data(fetched, filter2, prerendering = false) {
  const headers2 = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter2(key2, value)) {
      headers2[key2] = value;
    }
    if (key2 === "cache-control") cache_control = value;
    else if (key2 === "age") age = value;
    else if (key2 === "vary" && value.trim() === "*") varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers: headers2,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements2[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url="${escape_html2(fetched.url, true)}"`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash(...values)}"`);
  }
  if (!prerendering && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
__name(serialize_data, "serialize_data");
var s = JSON.stringify;
function sha256(data) {
  if (!key[0]) precompute();
  const out = init.slice(0);
  const array2 = encode(data);
  for (let i2 = 0; i2 < array2.length; i2 += 16) {
    const w = array2.subarray(i2, i2 + 16);
    let tmp;
    let a2;
    let b2;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a2 = w[i22 + 1 & 15];
        b2 = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a2 >>> 7 ^ a2 >>> 18 ^ a2 >>> 3 ^ a2 << 25 ^ a2 << 14) + (b2 >>> 17 ^ b2 >>> 19 ^ b2 >>> 10 ^ b2 << 15 ^ b2 << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return btoa(String.fromCharCode(...bytes));
}
__name(sha256, "sha256");
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x2) {
    return (x2 - Math.floor(x2)) * 4294967296;
  }
  __name(frac, "frac");
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
__name(precompute, "precompute");
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a2 = bytes[i2 + 0];
    const b2 = bytes[i2 + 1];
    const c3 = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c3;
    bytes[i2 + 2] = b2;
    bytes[i2 + 3] = a2;
  }
}
__name(reverse_endianness, "reverse_endianness");
function encode(str) {
  const encoded = text_encoder2.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
__name(encode, "encode");
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return btoa(String.fromCharCode(...array));
}
__name(generate_nonce, "generate_nonce");
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  static {
    __name(this, "BaseProvider");
  }
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #script_src_needs_csp;
  /** @type {boolean} */
  #script_src_elem_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {boolean} */
  #style_src_needs_csp;
  /** @type {boolean} */
  #style_src_attr_needs_csp;
  /** @type {boolean} */
  #style_src_elem_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #script_src_elem;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src_attr;
  /** @type {import('types').Csp.Source[]} */
  #style_src_elem;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#script_src_elem = [];
    this.#style_src = [];
    this.#style_src_attr = [];
    this.#style_src_elem = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const script_src_elem = d["script-src-elem"];
    const effective_style_src = d["style-src"] || d["default-src"];
    const style_src_attr = d["style-src-attr"];
    const style_src_elem = d["style-src-elem"];
    const needs_csp = /* @__PURE__ */ __name((directive) => !!directive && !directive.some((value) => value === "unsafe-inline"), "needs_csp");
    this.#script_src_needs_csp = needs_csp(effective_script_src);
    this.#script_src_elem_needs_csp = needs_csp(script_src_elem);
    this.#style_src_needs_csp = needs_csp(effective_style_src);
    this.#style_src_attr_needs_csp = needs_csp(style_src_attr);
    this.#style_src_elem_needs_csp = needs_csp(style_src_elem);
    this.#script_needs_csp = this.#script_src_needs_csp || this.#script_src_elem_needs_csp;
    this.#style_needs_csp = this.#style_src_needs_csp || this.#style_src_attr_needs_csp || this.#style_src_elem_needs_csp;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (!this.#script_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha256(content)}` : `nonce-${this.#nonce}`;
    if (this.#script_src_needs_csp) {
      this.#script_src.push(source2);
    }
    if (this.#script_src_elem_needs_csp) {
      this.#script_src_elem.push(source2);
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (!this.#style_needs_csp) return;
    const source2 = this.#use_hashes ? `sha256-${sha256(content)}` : `nonce-${this.#nonce}`;
    if (this.#style_src_needs_csp) {
      this.#style_src.push(source2);
    }
    if (this.#style_src_attr_needs_csp) {
      this.#style_src_attr.push(source2);
    }
    if (this.#style_src_elem_needs_csp) {
      const sha256_empty_comment_hash = "sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=";
      const d = this.#directives;
      if (d["style-src-elem"] && !d["style-src-elem"].includes(sha256_empty_comment_hash) && !this.#style_src_elem.includes(sha256_empty_comment_hash)) {
        this.#style_src_elem.push(sha256_empty_comment_hash);
      }
      if (source2 !== sha256_empty_comment_hash) {
        this.#style_src_elem.push(source2);
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#style_src_attr.length > 0) {
      directives["style-src-attr"] = [
        ...directives["style-src-attr"] || [],
        ...this.#style_src_attr
      ];
    }
    if (this.#style_src_elem.length > 0) {
      directives["style-src-elem"] = [
        ...directives["style-src-elem"] || [],
        ...this.#style_src_elem
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    if (this.#script_src_elem.length > 0) {
      directives["script-src-elem"] = [
        ...directives["script-src-elem"] || [],
        ...this.#script_src_elem
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value) continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  static {
    __name(this, "CspProvider");
  }
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content="${escape_html2(content, true)}">`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  static {
    __name(this, "CspReportOnlyProvider");
  }
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v2) => !!v2).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  static {
    __name(this, "Csp");
  }
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function exec(match, params, matchers2) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i2 = 0; i2 < params.length; i2 += 1) {
    const param = params[i2];
    let value = values[i2 - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i2 - buffered, i2 + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest) result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers2[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i2 + 1];
      const next_value = values[i2 + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered) return;
  return result;
}
__name(exec, "exec");
function generate_route_object(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  const nodes = [...errors, ...layouts.map((l2) => l2?.[1]), leaf[1]].filter((n3) => typeof n3 === "number").map((n3) => `'${n3}': () => ${create_client_import(manifest2._.client.nodes?.[n3], url)}`).join(",\n		");
  return [
    `{
	id: ${s(route.id)}`,
    `errors: ${s(route.errors)}`,
    `layouts: ${s(route.layouts)}`,
    `leaf: ${s(route.leaf)}`,
    `nodes: {
		${nodes}
	}
}`
  ].join(",\n	");
}
__name(generate_route_object, "generate_route_object");
function create_client_import(import_path, url) {
  if (!import_path) return "Promise.resolve({})";
  if (import_path[0] === "/") {
    return `import('${import_path}')`;
  }
  if (assets !== "") {
    return `import('${assets}/${import_path}')`;
  }
  let path2 = get_relative_path(url.pathname, `${base}/${import_path}`);
  if (path2[0] !== ".") path2 = `./${path2}`;
  return `import('${path2}')`;
}
__name(create_client_import, "create_client_import");
async function resolve_route(resolved_path, url, manifest2) {
  if (!manifest2._.client.routes) {
    return text("Server-side route resolution disabled", { status: 400 });
  }
  let route = null;
  let params = {};
  const matchers2 = await manifest2._.matchers();
  for (const candidate of manifest2._.client.routes) {
    const match = candidate.pattern.exec(resolved_path);
    if (!match) continue;
    const matched = exec(match, candidate.params, matchers2);
    if (matched) {
      route = candidate;
      params = decode_params(matched);
      break;
    }
  }
  return create_server_routing_response(route, params, url, manifest2).response;
}
__name(resolve_route, "resolve_route");
function create_server_routing_response(route, params, url, manifest2) {
  const headers2 = new Headers({
    "content-type": "application/javascript; charset=utf-8"
  });
  if (route) {
    const csr_route = generate_route_object(route, url, manifest2);
    const body2 = `${create_css_import(route, url, manifest2)}
export const route = ${csr_route}; export const params = ${JSON.stringify(params)};`;
    return { response: text(body2, { headers: headers2 }), body: body2 };
  } else {
    return { response: text("", { headers: headers2 }), body: "" };
  }
}
__name(create_server_routing_response, "create_server_routing_response");
function create_css_import(route, url, manifest2) {
  const { errors, layouts, leaf } = route;
  let css = "";
  for (const node of [...errors, ...layouts.map((l2) => l2?.[1]), leaf[1]]) {
    if (typeof node !== "number") continue;
    const node_css = manifest2._.client.css?.[node];
    for (const css_path of node_css ?? []) {
      css += `'${assets || base}/${css_path}',`;
    }
  }
  if (!css) return "";
  return `${create_client_import(
    /** @type {string} */
    manifest2._.client.start,
    url
  )}.then(x => x.load_css([${css}]));`;
}
__name(create_css_import, "create_css_import");
var updated = {
  ...readable(false),
  check: /* @__PURE__ */ __name(() => false, "check")
};
async function render_response({
  branch: branch2,
  fetched,
  options: options2,
  manifest: manifest2,
  state: state2,
  page_config,
  status,
  error: error22 = null,
  event,
  event_state,
  resolve_opts,
  action_result,
  data_serializer
}) {
  if (state2.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets5 = new Set(client.stylesheets);
  const fonts5 = new Set(client.fonts);
  const link_headers = /* @__PURE__ */ new Set();
  const link_tags = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  {
    if (!state2.prerendering?.fallback) {
      const segments = event.url.pathname.slice(base.length).split("/").slice(2);
      base$1 = segments.map(() => "..").join("/") || ".";
      base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
      if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
        assets$1 = base$1;
      }
    } else if (options2.hash_routing) {
      base_expression = "new URL('.', location).pathname.slice(0, -1)";
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(
        branch2.map(({ node }) => {
          if (!node.component) {
            throw new Error(`Missing +page.svelte component for route ${event.route.id}`);
          }
          return node.component();
        })
      ),
      form: form_value
    };
    let data2 = {};
    for (let i2 = 0; i2 < branch2.length; i2 += 1) {
      data2 = { ...data2, ...branch2[i2].data };
      props[`data_${i2}`] = data2;
    }
    props.page = {
      error: error22,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value,
      state: {}
    };
    const render_opts = {
      context: /* @__PURE__ */ new Map([
        [
          "__request__",
          {
            page: props.page
          }
        ]
      ])
    };
    const fetch2 = globalThis.fetch;
    try {
      if (BROWSER) ;
      rendered = await with_request_store({ event, state: event_state }, async () => {
        if (relative) override({ base: base$1, assets: assets$1 });
        const maybe_promise = options2.root.render(props, render_opts);
        const rendered2 = options2.async && "then" in maybe_promise ? (
          /** @type {ReturnType<typeof options.root.render> & Promise<any>} */
          maybe_promise.then((r4) => r4)
        ) : maybe_promise;
        if (options2.async) {
          reset();
        }
        const { head: head22, html: html2, css } = options2.async ? await rendered2 : rendered2;
        return { head: head22, html: html2, css };
      });
    } finally {
      reset();
    }
    for (const { node } of branch2) {
      for (const url of node.imports) modulepreloads.add(url);
      for (const url of node.stylesheets) stylesheets5.add(url);
      for (const url of node.fonts) fonts5.add(url);
      if (node.inline_styles && !client.inline) {
        Object.entries(await node.inline_styles()).forEach(([k2, v2]) => inline_styles.set(k2, v2));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head2 = "";
  let body2 = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state2.prerendering
  });
  const prefixed = /* @__PURE__ */ __name((path2) => {
    if (path2.startsWith("/")) {
      return base + path2;
    }
    return `${assets$1}/${path2}`;
  }, "prefixed");
  const style = client.inline ? client.inline?.style : Array.from(inline_styles.values()).join("\n");
  if (style) {
    const attributes2 = [];
    if (csp.style_needs_nonce) attributes2.push(` nonce="${csp.nonce}"`);
    csp.add_style(style);
    head2 += `
	<style${attributes2.join("")}>${style}</style>`;
  }
  for (const dep of stylesheets5) {
    const path2 = prefixed(dep);
    const attributes2 = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes2.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path: path2 })) {
        link_headers.add(`<${encodeURI(path2)}>; rel="preload"; as="style"; nopush`);
      }
    }
    head2 += `
		<link href="${path2}" ${attributes2.join(" ")}>`;
  }
  for (const dep of fonts5) {
    const path2 = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path: path2 })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      link_tags.add(`<link rel="preload" as="font" type="font/${ext}" href="${path2}" crossorigin>`);
      link_headers.add(
        `<${encodeURI(path2)}>; rel="preload"; as="font"; type="font/${ext}"; crossorigin; nopush`
      );
    }
  }
  const global2 = get_global_name(options2);
  const { data, chunks } = data_serializer.get_data(csp);
  if (page_config.ssr && page_config.csr) {
    body2 += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state2.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    const route = manifest2._.client.routes?.find((r4) => r4.id === event.route.id) ?? null;
    if (client.uses_env_dynamic_public && state2.prerendering) {
      modulepreloads.add(`${app_dir}/env.js`);
    }
    if (!client.inline) {
      const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
        (path2) => resolve_opts.preload({ type: "js", path: path2 })
      );
      for (const path2 of included_modulepreloads) {
        link_headers.add(`<${encodeURI(path2)}>; rel="modulepreload"; nopush`);
        if (options2.preload_strategy !== "modulepreload") {
          head2 += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path2}">`;
        } else {
          link_tags.add(`<link rel="modulepreload" href="${path2}">`);
        }
      }
    }
    if (state2.prerendering && link_tags.size > 0) {
      head2 += Array.from(link_tags).map((tag) => `
		${tag}`).join("");
    }
    if (manifest2._.client.routes && state2.prerendering && !state2.prerendering.fallback) {
      const pathname = add_resolution_suffix2(event.url.pathname);
      state2.prerendering.dependencies.set(
        pathname,
        create_server_routing_response(route, event.params, new URL(pathname, event.url), manifest2)
      );
    }
    const blocks = [];
    const load_env_eagerly = client.uses_env_dynamic_public && state2.prerendering;
    const properties = [`base: ${base_expression}`];
    if (assets) {
      properties.push(`assets: ${s(assets)}`);
    }
    if (client.uses_env_dynamic_public) {
      properties.push(`env: ${load_env_eagerly ? "null" : s(public_env)}`);
    }
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      let app_declaration = "";
      if (Object.keys(options2.hooks.transport).length > 0) {
        if (client.inline) {
          app_declaration = `const app = __sveltekit_${options2.version_hash}.app.app;`;
        } else if (client.app) {
          app_declaration = `const app = await import(${s(prefixed(client.app))});`;
        } else {
          app_declaration = `const { app } = await import(${s(prefixed(client.start))});`;
        }
      }
      const prelude = app_declaration ? `${app_declaration}
							const [data, error] = fn(app);` : `const [data, error] = fn();`;
      properties.push(`resolve: async (id, fn) => {
							${prelude}

							const try_to_resolve = () => {
								if (!deferred.has(id)) {
									setTimeout(try_to_resolve, 0);
									return;
								}
								const { fulfil, reject } = deferred.get(id);
								deferred.delete(id);
								if (error) reject(error);
								else fulfil(data);
							}
							try_to_resolve();
						}`);
    }
    blocks.push(`${global2} = {
						${properties.join(",\n						")}
					};`);
    const args = ["element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id,
          options2.hooks.transport
        );
      }
      if (error22) {
        serialized.error = uneval(error22);
      }
      const hydrate2 = [
        `node_ids: [${branch2.map(({ node }) => node.index).join(", ")}]`,
        `data: ${data}`,
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate2.push(`status: ${status}`);
      }
      if (manifest2._.client.routes) {
        if (route) {
          const stringified = generate_route_object(route, event.url, manifest2).replaceAll(
            "\n",
            "\n							"
          );
          hydrate2.push(`params: ${uneval(event.params)}`, `server_route: ${stringified}`);
        }
      } else if (options2.embedded) {
        hydrate2.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      const indent = "	".repeat(load_env_eagerly ? 7 : 6);
      args.push(`{
${indent}	${hydrate2.join(`,
${indent}	`)}
${indent}}`);
    }
    const { remote_data: remote_cache } = event_state;
    let serialized_remote_data = "";
    if (remote_cache) {
      const remote = {};
      for (const [info3, cache] of remote_cache) {
        if (!info3.id) continue;
        for (const key2 in cache) {
          remote[create_remote_cache_key(info3.id, key2)] = await cache[key2];
        }
      }
      const replacer = /* @__PURE__ */ __name((thing) => {
        for (const key2 in options2.hooks.transport) {
          const encoded = options2.hooks.transport[key2].encode(thing);
          if (encoded) {
            return `app.decode('${key2}', ${uneval(encoded, replacer)})`;
          }
        }
      }, "replacer");
      serialized_remote_data = `${global2}.data = ${uneval(remote, replacer)};

						`;
    }
    const boot = client.inline ? `${client.inline.script}

					${serialized_remote_data}${global2}.app.start(${args.join(", ")});` : client.app ? `Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						${serialized_remote_data}kit.start(app, ${args.join(", ")});
					});` : `import(${s(prefixed(client.start))}).then((app) => {
						${serialized_remote_data}app.start(${args.join(", ")})
					});`;
    if (load_env_eagerly) {
      blocks.push(`import(${s(`${base$1}/${app_dir}/env.js`)}).then(({ env }) => {
						${global2}.env = env;

						${boot.replace(/\n/g, "\n	")}
					});`);
    } else {
      blocks.push(boot);
    }
    if (options2.service_worker) {
      let opts = "";
      if (options2.service_worker_options != null) {
        const service_worker_options = { ...options2.service_worker_options };
        opts = `, ${s(service_worker_options)}`;
      }
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers2 = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state2.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state2.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state2.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head2 = http_equiv.join("\n") + head2;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers2.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers2.set("content-security-policy-report-only", report_only_header);
    }
    if (link_headers.size) {
      headers2.set("link", Array.from(link_headers).join(", "));
    }
  }
  head2 += rendered.head;
  const html = options2.templates.app({
    head: head2,
    body: body2,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers2.set("etag", `"${hash(transformed)}"`);
  }
  return !chunks ? text(transformed, {
    status,
    headers: headers2
  }) : new Response(
    new ReadableStream({
      async start(controller2) {
        controller2.enqueue(text_encoder2.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          if (chunk.length) controller2.enqueue(text_encoder2.encode(chunk));
        }
        controller2.close();
      },
      type: "bytes"
    }),
    {
      headers: headers2
    }
  );
}
__name(render_response, "render_response");
var PageNodes = class {
  static {
    __name(this, "PageNodes");
  }
  data;
  /**
   * @param {Array<import('types').SSRNode | undefined>} nodes
   */
  constructor(nodes) {
    this.data = nodes;
  }
  layouts() {
    return this.data.slice(0, -1);
  }
  page() {
    return this.data.at(-1);
  }
  validate() {
    for (const layout of this.layouts()) {
      if (layout) {
        validate_layout_server_exports(
          layout.server,
          /** @type {string} */
          layout.server_id
        );
        validate_layout_exports(
          layout.universal,
          /** @type {string} */
          layout.universal_id
        );
      }
    }
    const page2 = this.page();
    if (page2) {
      validate_page_server_exports(
        page2.server,
        /** @type {string} */
        page2.server_id
      );
      validate_page_exports(
        page2.universal,
        /** @type {string} */
        page2.universal_id
      );
    }
  }
  /**
   * @template {'prerender' | 'ssr' | 'csr' | 'trailingSlash'} Option
   * @param {Option} option
   * @returns {Value | undefined}
   */
  #get_option(option) {
    return this.data.reduce(
      (value, node) => {
        return node?.universal?.[option] ?? node?.server?.[option] ?? value;
      },
      /** @type {Value | undefined} */
      void 0
    );
  }
  csr() {
    return this.#get_option("csr") ?? true;
  }
  ssr() {
    return this.#get_option("ssr") ?? true;
  }
  prerender() {
    return this.#get_option("prerender") ?? false;
  }
  trailing_slash() {
    return this.#get_option("trailingSlash") ?? "never";
  }
  get_config() {
    let current2 = {};
    for (const node of this.data) {
      if (!node?.universal?.config && !node?.server?.config) continue;
      current2 = {
        ...current2,
        // TODO: should we override the server config value with the universal value similar to other page options?
        ...node?.universal?.config,
        ...node?.server?.config
      };
    }
    return Object.keys(current2).length ? current2 : void 0;
  }
  should_prerender_data() {
    return this.data.some(
      // prerender in case of trailingSlash because the client retrieves that value from the server
      (node) => node?.server?.load || node?.server?.trailingSlash !== void 0
    );
  }
};
async function respond_with_error({
  event,
  event_state,
  options: options2,
  manifest: manifest2,
  state: state2,
  status,
  error: error22,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error22.message
    );
  }
  const fetched = [];
  try {
    const branch2 = [];
    const default_layout = await manifest2._.nodes[0]();
    const nodes = new PageNodes([default_layout]);
    const ssr = nodes.ssr();
    const csr = nodes.csr();
    const data_serializer = server_data_serializer(event, event_state, options2);
    if (ssr) {
      state2.error = true;
      const server_data_promise = load_server_data({
        event,
        event_state,
        state: state2,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: /* @__PURE__ */ __name(async () => ({}), "parent")
      });
      const server_data = await server_data_promise;
      data_serializer.add_node(0, server_data);
      const data = await load_data({
        event,
        event_state,
        fetched,
        node: default_layout,
        // eslint-disable-next-line @typescript-eslint/require-await
        parent: /* @__PURE__ */ __name(async () => ({}), "parent"),
        resolve_opts,
        server_data_promise,
        state: state2,
        csr
      });
      branch2.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state: state2,
      page_config: {
        ssr,
        csr
      },
      status,
      error: await handle_error_and_jsonify(event, event_state, options2, error22),
      branch: branch2,
      fetched,
      event,
      event_state,
      resolve_opts,
      data_serializer
    });
  } catch (e5) {
    if (e5 instanceof Redirect) {
      return redirect_response(e5.status, e5.location);
    }
    return static_error_page(
      options2,
      get_status(e5),
      (await handle_error_and_jsonify(event, event_state, options2, e5)).message
    );
  }
}
__name(respond_with_error, "respond_with_error");
async function handle_remote_call(event, state2, options2, manifest2, id) {
  return record_span({
    name: "sveltekit.remote.call",
    attributes: {},
    fn: /* @__PURE__ */ __name((current2) => {
      const traced_event = merge_tracing(event, current2);
      return with_request_store(
        { event: traced_event, state: state2 },
        () => handle_remote_call_internal(traced_event, state2, options2, manifest2, id)
      );
    }, "fn")
  });
}
__name(handle_remote_call, "handle_remote_call");
async function handle_remote_call_internal(event, state2, options2, manifest2, id) {
  const [hash2, name, additional_args] = id.split("/");
  const remotes = manifest2._.remotes;
  if (!remotes[hash2]) error3(404);
  const module2 = await remotes[hash2]();
  const fn = module2.default[name];
  if (!fn) error3(404);
  const info3 = fn.__;
  const transport = options2.hooks.transport;
  event.tracing.current.setAttributes({
    "sveltekit.remote.call.type": info3.type,
    "sveltekit.remote.call.name": info3.name
  });
  let form_client_refreshes;
  try {
    if (info3.type === "query_batch") {
      if (event.request.method !== "POST") {
        throw new SvelteKitError(
          405,
          "Method Not Allowed",
          `\`query.batch\` functions must be invoked via POST request, not ${event.request.method}`
        );
      }
      const { payloads } = await event.request.json();
      const args = payloads.map((payload2) => parse_remote_arg(payload2, transport));
      const get_result = await with_request_store({ event, state: state2 }, () => info3.run(args));
      const results = await Promise.all(
        args.map(async (arg, i2) => {
          try {
            return { type: "result", data: get_result(arg, i2) };
          } catch (error22) {
            return {
              type: "error",
              error: await handle_error_and_jsonify(event, state2, options2, error22),
              status: error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : 500
            };
          }
        })
      );
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify2(results, transport)
        }
      );
    }
    if (info3.type === "form") {
      if (event.request.method !== "POST") {
        throw new SvelteKitError(
          405,
          "Method Not Allowed",
          `\`form\` functions must be invoked via POST request, not ${event.request.method}`
        );
      }
      if (!is_form_content_type(event.request)) {
        throw new SvelteKitError(
          415,
          "Unsupported Media Type",
          `\`form\` functions expect form-encoded data \u2014 received ${event.request.headers.get(
            "content-type"
          )}`
        );
      }
      const form_data = await event.request.formData();
      form_client_refreshes = /** @type {string[]} */
      JSON.parse(
        /** @type {string} */
        form_data.get("sveltekit:remote_refreshes") ?? "[]"
      );
      form_data.delete("sveltekit:remote_refreshes");
      if (additional_args) {
        form_data.set("sveltekit:id", decodeURIComponent(additional_args));
      }
      const fn2 = info3.fn;
      const data2 = await with_request_store({ event, state: state2 }, () => fn2(form_data));
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify2(data2, transport),
          refreshes: data2.issues ? {} : await serialize_refreshes(form_client_refreshes)
        }
      );
    }
    if (info3.type === "command") {
      const { payload: payload2, refreshes } = await event.request.json();
      const arg = parse_remote_arg(payload2, transport);
      const data2 = await with_request_store({ event, state: state2 }, () => fn(arg));
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "result",
          result: stringify2(data2, transport),
          refreshes: await serialize_refreshes(refreshes)
        }
      );
    }
    const payload = info3.type === "prerender" ? additional_args : (
      /** @type {string} */
      // new URL(...) necessary because we're hiding the URL from the user in the event object
      new URL(event.request.url).searchParams.get("payload")
    );
    const data = await with_request_store(
      { event, state: state2 },
      () => fn(parse_remote_arg(payload, transport))
    );
    return json(
      /** @type {RemoteFunctionResponse} */
      {
        type: "result",
        result: stringify2(data, transport)
      }
    );
  } catch (error22) {
    if (error22 instanceof Redirect) {
      return json(
        /** @type {RemoteFunctionResponse} */
        {
          type: "redirect",
          location: error22.location,
          refreshes: await serialize_refreshes(form_client_refreshes ?? [])
        }
      );
    }
    const status = error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : 500;
    return json(
      /** @type {RemoteFunctionResponse} */
      {
        type: "error",
        error: await handle_error_and_jsonify(event, state2, options2, error22),
        status
      },
      {
        // By setting a non-200 during prerendering we fail the prerender process (unless handleHttpError handles it).
        // Errors at runtime will be passed to the client and are handled there
        status: state2.prerendering ? status : void 0,
        headers: {
          "cache-control": "private, no-store"
        }
      }
    );
  }
  async function serialize_refreshes(client_refreshes) {
    const refreshes = state2.refreshes ?? {};
    for (const key2 of client_refreshes) {
      if (refreshes[key2] !== void 0) continue;
      const [hash3, name2, payload] = key2.split("/");
      const loader = manifest2._.remotes[hash3];
      const fn2 = (await loader?.())?.default?.[name2];
      if (!fn2) error3(400, "Bad Request");
      refreshes[key2] = with_request_store(
        { event, state: state2 },
        () => fn2(parse_remote_arg(payload, transport))
      );
    }
    if (Object.keys(refreshes).length === 0) {
      return void 0;
    }
    return stringify2(
      Object.fromEntries(
        await Promise.all(
          Object.entries(refreshes).map(async ([key2, promise]) => [key2, await promise])
        )
      ),
      transport
    );
  }
  __name(serialize_refreshes, "serialize_refreshes");
}
__name(handle_remote_call_internal, "handle_remote_call_internal");
async function handle_remote_form_post(event, state2, manifest2, id) {
  return record_span({
    name: "sveltekit.remote.form.post",
    attributes: {},
    fn: /* @__PURE__ */ __name((current2) => {
      const traced_event = merge_tracing(event, current2);
      return with_request_store(
        { event: traced_event, state: state2 },
        () => handle_remote_form_post_internal(traced_event, state2, manifest2, id)
      );
    }, "fn")
  });
}
__name(handle_remote_form_post, "handle_remote_form_post");
async function handle_remote_form_post_internal(event, state2, manifest2, id) {
  const [hash2, name, action_id] = id.split("/");
  const remotes = manifest2._.remotes;
  const module2 = await remotes[hash2]?.();
  let form = (
    /** @type {RemoteForm<any, any>} */
    module2?.default[name]
  );
  if (!form) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: new SvelteKitError(
        405,
        "Method Not Allowed",
        `POST method not allowed. No form actions exist for ${"this page"}`
      )
    };
  }
  if (action_id) {
    form = with_request_store({ event, state: state2 }, () => form.for(JSON.parse(action_id)));
  }
  try {
    const form_data = await event.request.formData();
    const fn = (
      /** @type {RemoteInfo & { type: 'form' }} */
      /** @type {any} */
      form.__.fn
    );
    if (action_id && !form_data.has("id")) {
      form_data.set("sveltekit:id", decodeURIComponent(action_id));
    }
    await with_request_store({ event, state: state2 }, () => fn(form_data));
    return {
      type: "success",
      status: 200
    };
  } catch (e5) {
    const err = normalize_error(e5);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
__name(handle_remote_form_post_internal, "handle_remote_form_post_internal");
function get_remote_id(url) {
  return url.pathname.startsWith(`${base}/${app_dir}/remote/`) && url.pathname.replace(`${base}/${app_dir}/remote/`, "");
}
__name(get_remote_id, "get_remote_id");
function get_remote_action(url) {
  return url.searchParams.get("/remote");
}
__name(get_remote_action, "get_remote_action");
var MAX_DEPTH = 10;
async function render_page(event, event_state, page2, options2, manifest2, state2, nodes, resolve_opts) {
  if (state2.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, event_state, options2, node?.server);
  }
  try {
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.page()
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      const remote_id = get_remote_action(event.url);
      if (remote_id) {
        action_result = await handle_remote_form_post(event, event_state, manifest2, remote_id);
      } else {
        action_result = await handle_action_request(event, event_state, leaf_node.server);
      }
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        status = get_status(action_result.error);
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender = nodes.prerender();
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state2.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state2.prerender_default = should_prerender;
    const should_prerender_data = nodes.should_prerender_data();
    const data_pathname = add_data_suffix2(event.url.pathname);
    const fetched = [];
    const ssr = nodes.ssr();
    const csr = nodes.csr();
    if (ssr === false && !(state2.prerendering && should_prerender_data)) {
      if (BROWSER && action_result && !event.request.headers.has("x-sveltekit-action")) ;
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr
        },
        status,
        error: null,
        event,
        event_state,
        options: options2,
        manifest: manifest2,
        state: state2,
        resolve_opts,
        data_serializer: server_data_serializer(event, event_state, options2)
      });
    }
    const branch2 = [];
    let load_error = null;
    const data_serializer = server_data_serializer(event, event_state, options2);
    const data_serializer_json = state2.prerendering && should_prerender_data ? server_data_serializer_json(event, event_state, options2) : null;
    const server_promises = nodes.data.map((node, i2) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          const server_data = await load_server_data({
            event,
            event_state,
            state: state2,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data = {};
              for (let j = 0; j < i2; j += 1) {
                const parent = await server_promises[j];
                if (parent) Object.assign(data, parent.data);
              }
              return data;
            }, "parent")
          });
          if (node) {
            data_serializer.add_node(i2, server_data);
          }
          data_serializer_json?.add_node(i2, server_data);
          return server_data;
        } catch (e5) {
          load_error = /** @type {Error} */
          e5;
          throw load_error;
        }
      });
    });
    const load_promises = nodes.data.map((node, i2) => {
      if (load_error) throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            event_state,
            fetched,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data = {};
              for (let j = 0; j < i2; j += 1) {
                Object.assign(data, await load_promises[j]);
              }
              return data;
            }, "parent"),
            resolve_opts,
            server_data_promise: server_promises[i2],
            state: state2,
            csr
          });
        } catch (e5) {
          load_error = /** @type {Error} */
          e5;
          throw load_error;
        }
      });
    });
    for (const p2 of server_promises) p2.catch(() => {
    });
    for (const p2 of load_promises) p2.catch(() => {
    });
    for (let i2 = 0; i2 < nodes.data.length; i2 += 1) {
      const node = nodes.data[i2];
      if (node) {
        try {
          const server_data = await server_promises[i2];
          const data = await load_promises[i2];
          branch2.push({ node, server_data, data });
        } catch (e5) {
          const err = normalize_error(e5);
          if (err instanceof Redirect) {
            if (state2.prerendering && should_prerender_data) {
              const body2 = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state2.prerendering.dependencies.set(data_pathname, {
                response: text(body2),
                body: body2
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = get_status(err);
          const error22 = await handle_error_and_jsonify(event, event_state, options2, err);
          while (i2--) {
            if (page2.errors[i2]) {
              const index5 = (
                /** @type {number} */
                page2.errors[i2]
              );
              const node2 = await manifest2._.nodes[index5]();
              let j = i2;
              while (!branch2[j]) j -= 1;
              data_serializer.set_max_nodes(j + 1);
              const layouts = compact(branch2.slice(0, j + 1));
              const nodes2 = new PageNodes(layouts.map((layout) => layout.node));
              return await render_response({
                event,
                event_state,
                options: options2,
                manifest: manifest2,
                state: state2,
                resolve_opts,
                page_config: {
                  ssr: nodes2.ssr(),
                  csr: nodes2.csr()
                },
                status: status2,
                error: error22,
                branch: layouts.concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched,
                data_serializer
              });
            }
          }
          return static_error_page(options2, status2, error22.message);
        }
      } else {
        branch2.push(null);
      }
    }
    if (state2.prerendering && data_serializer_json) {
      let { data, chunks } = data_serializer_json.get_data();
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state2.prerendering.dependencies.set(data_pathname, {
        response: text(data),
        body: data
      });
    }
    return await render_response({
      event,
      event_state,
      options: options2,
      manifest: manifest2,
      state: state2,
      resolve_opts,
      page_config: {
        csr,
        ssr
      },
      status,
      error: null,
      branch: ssr === false ? [] : compact(branch2),
      action_result,
      fetched,
      data_serializer: ssr === false ? server_data_serializer(event, event_state, options2) : data_serializer
    });
  } catch (e5) {
    return await respond_with_error({
      event,
      event_state,
      options: options2,
      manifest: manifest2,
      state: state2,
      status: 500,
      error: e5,
      resolve_opts
    });
  }
}
__name(render_page, "render_page");
function once2(fn) {
  let done = false;
  let result;
  return () => {
    if (done) return result;
    done = true;
    return result = fn();
  };
}
__name(once2, "once");
async function render_data(event, event_state, route, options2, manifest2, state2, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted = false;
    const url = new URL(event.url);
    url.pathname = normalize_path(url.pathname, trailing_slash);
    const new_event = { ...event, url };
    const functions = node_ids.map((n3, i2) => {
      return once2(async () => {
        try {
          if (aborted) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n3 == void 0 ? n3 : await manifest2._.nodes[n3]();
          return load_server_data({
            event: new_event,
            event_state,
            state: state2,
            node,
            parent: /* @__PURE__ */ __name(async () => {
              const data2 = {};
              for (let j = 0; j < i2; j += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            }, "parent")
          });
        } catch (e5) {
          aborted = true;
          throw e5;
        }
      });
    });
    const promises = functions.map(async (fn, i2) => {
      if (!invalidated[i2]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p2, i2) => p2.catch(async (error22) => {
          if (error22 instanceof Redirect) {
            throw error22;
          }
          length = Math.min(length, i2 + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, event_state, options2, error22),
              status: error22 instanceof HttpError || error22 instanceof SvelteKitError ? error22.status : void 0
            }
          );
        })
      )
    );
    const data_serializer = server_data_serializer_json(event, event_state, options2);
    for (let i2 = 0; i2 < nodes.length; i2++) data_serializer.add_node(i2, nodes[i2]);
    const { data, chunks } = data_serializer.get_data();
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller2) {
          controller2.enqueue(text_encoder2.encode(data));
          for await (const chunk of chunks) {
            controller2.enqueue(text_encoder2.encode(chunk));
          }
          controller2.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e5) {
    const error22 = normalize_error(e5);
    if (error22 instanceof Redirect) {
      return redirect_json_response(error22);
    } else {
      return json_response(await handle_error_and_jsonify(event, event_state, options2, error22), 500);
    }
  }
}
__name(render_data, "render_data");
function json_response(json2, status = 200) {
  return text(typeof json2 === "string" ? json2 : JSON.stringify(json2), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
__name(json_response, "json_response");
function redirect_json_response(redirect) {
  return json_response(
    /** @type {import('types').ServerRedirectNode} */
    {
      type: "redirect",
      location: redirect.location
    }
  );
}
__name(redirect_json_response, "redirect_json_response");
var INVALID_COOKIE_CHARACTER_REGEX = /[\x00-\x1F\x7F()<>@,;:"/[\]?={} \t]/;
function validate_options(options2) {
  if (options2?.path === void 0) {
    throw new Error("You must specify a `path` when setting, deleting or serializing cookies");
  }
}
__name(validate_options, "validate_options");
function generate_cookie_key(domain2, path2, name) {
  return `${domain2 || ""}${path2}?${encodeURIComponent(name)}`;
}
__name(generate_cookie_key, "generate_cookie_key");
function get_cookies(request, url) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = (0, import_cookie.parse)(header, { decode: /* @__PURE__ */ __name((value) => value, "decode") });
  let normalized_url;
  const new_cookies = /* @__PURE__ */ new Map();
  const defaults = {
    httpOnly: true,
    sameSite: "lax",
    secure: url.hostname === "localhost" && url.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    get(name, opts) {
      const best_match = Array.from(new_cookies.values()).filter((c3) => {
        return c3.name === name && domain_matches(url.hostname, c3.options.domain) && path_matches(url.pathname, c3.options.path);
      }).sort((a2, b2) => b2.options.path.length - a2.options.path.length)[0];
      if (best_match) {
        return best_match.options.maxAge === 0 ? void 0 : best_match.value;
      }
      const req_cookies = (0, import_cookie.parse)(header, { decode: opts?.decode });
      const cookie = req_cookies[name];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} [opts]
     */
    getAll(opts) {
      const cookies2 = (0, import_cookie.parse)(header, { decode: opts?.decode });
      const lookup2 = /* @__PURE__ */ new Map();
      for (const c3 of new_cookies.values()) {
        if (domain_matches(url.hostname, c3.options.domain) && path_matches(url.pathname, c3.options.path)) {
          const existing = lookup2.get(c3.name);
          if (!existing || c3.options.path.length > existing.options.path.length) {
            lookup2.set(c3.name, c3);
          }
        }
      }
      for (const c3 of lookup2.values()) {
        cookies2[c3.name] = c3.value;
      }
      return Object.entries(cookies2).map(([name, value]) => ({ name, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('./page/types.js').Cookie['options']} options
     */
    set(name, value, options2) {
      const illegal_characters = name.match(INVALID_COOKIE_CHARACTER_REGEX);
      if (illegal_characters) {
        console.warn(
          `The cookie name "${name}" will be invalid in SvelteKit 3.0 as it contains ${illegal_characters.join(
            " and "
          )}. See RFC 2616 for more details https://datatracker.ietf.org/doc/html/rfc2616#section-2.2`
        );
      }
      validate_options(options2);
      set_internal(name, value, { ...defaults, ...options2 });
    },
    /**
     * @param {string} name
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    delete(name, options2) {
      validate_options(options2);
      cookies.set(name, "", { ...options2, maxAge: 0 });
    },
    /**
     * @param {string} name
     * @param {string} value
     *  @param {import('./page/types.js').Cookie['options']} options
     */
    serialize(name, value, options2) {
      validate_options(options2);
      let path2 = options2.path;
      if (!options2.domain || options2.domain === url.hostname) {
        if (!normalized_url) {
          throw new Error("Cannot serialize cookies until after the route is determined");
        }
        path2 = resolve2(normalized_url, path2);
      }
      return (0, import_cookie.serialize)(name, value, { ...defaults, ...options2, path: path2 });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const cookie of new_cookies.values()) {
      if (!domain_matches(destination.hostname, cookie.options.domain)) continue;
      if (!path_matches(destination.pathname, cookie.options.path)) continue;
      const encoder2 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder2(cookie.value);
    }
    if (header2) {
      const parsed = (0, import_cookie.parse)(header2, { decode: /* @__PURE__ */ __name((value) => value, "decode") });
      for (const name in parsed) {
        combined_cookies[name] = parsed[name];
      }
    }
    return Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
  }
  __name(get_cookie_header, "get_cookie_header");
  const internal_queue = [];
  function set_internal(name, value, options2) {
    if (!normalized_url) {
      internal_queue.push(() => set_internal(name, value, options2));
      return;
    }
    let path2 = options2.path;
    if (!options2.domain || options2.domain === url.hostname) {
      path2 = resolve2(normalized_url, path2);
    }
    const cookie_key = generate_cookie_key(options2.domain, path2, name);
    const cookie = { name, value, options: { ...options2, path: path2 } };
    new_cookies.set(cookie_key, cookie);
  }
  __name(set_internal, "set_internal");
  function set_trailing_slash(trailing_slash) {
    normalized_url = normalize_path(url.pathname, trailing_slash);
    internal_queue.forEach((fn) => fn());
  }
  __name(set_trailing_slash, "set_trailing_slash");
  return { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash };
}
__name(get_cookies, "get_cookies");
function domain_matches(hostname, constraint) {
  if (!constraint) return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname === normalized) return true;
  return hostname.endsWith("." + normalized);
}
__name(domain_matches, "domain_matches");
function path_matches(path2, constraint) {
  if (!constraint) return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path2 === normalized) return true;
  return path2.startsWith(normalized + "/");
}
__name(path_matches, "path_matches");
function add_cookies_to_headers(headers2, cookies) {
  for (const new_cookie of cookies) {
    const { name, value, options: options2 } = new_cookie;
    headers2.append("set-cookie", (0, import_cookie.serialize)(name, value, options2));
    if (options2.path.endsWith(".html")) {
      const path2 = add_data_suffix2(options2.path);
      headers2.append("set-cookie", (0, import_cookie.serialize)(name, value, { ...options2, path: path2 }));
    }
  }
}
__name(add_cookies_to_headers, "add_cookies_to_headers");
function create_fetch({ event, options: options2, manifest: manifest2, state: state2, get_cookie_header, set_internal }) {
  const server_fetch = /* @__PURE__ */ __name(async (info3, init22) => {
    const original_request = normalize_fetch_input(info3, init22, event.url);
    let mode = (info3 instanceof Request ? info3.mode : init22?.mode) ?? "cors";
    let credentials = (info3 instanceof Request ? info3.credentials : init22?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: /* @__PURE__ */ __name(async (info22, init3) => {
        const request = normalize_fetch_input(info22, init3, event.url);
        const url = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info22 !== original_request) {
          mode = (info22 instanceof Request ? info22.mode : init3?.mode) ?? "cors";
          credentials = (info22 instanceof Request ? info22.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url.origin !== event.url.origin || url.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url.origin !== event.url.origin) {
          if (`.${url.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url, request.headers.get("cookie"));
            if (cookie) request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename) || filename in manifest2._.server_assets;
        const is_asset_html = manifest2.assets.has(filename_html) || filename_html in manifest2._.server_assets;
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (state2.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state2.read(file), {
              headers: type ? { "content-type": type } : {}
            });
          } else if (read_implementation && file in manifest2._.server_assets) {
            const length = manifest2._.server_assets[file];
            const type = manifest2.mimeTypes[file.slice(file.lastIndexOf("."))];
            return new Response(read_implementation(file), {
              headers: {
                "Content-Length": "" + length,
                "Content-Type": type
              }
            });
          }
          return await fetch(request);
        }
        if (has_prerendered_path(manifest2, base + decoded)) {
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await internal_fetch(request, options2, manifest2, state2);
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of set_cookie_parser.splitCookiesString(set_cookie)) {
            const { name, value, ...options3 } = set_cookie_parser.parseString(str, {
              decodeValues: false
            });
            const path2 = options3.path ?? (url.pathname.split("/").slice(0, -1).join("/") || "/");
            set_internal(name, value, {
              path: path2,
              encode: /* @__PURE__ */ __name((value2) => value2, "encode"),
              .../** @type {import('cookie').CookieSerializeOptions} */
              options3
            });
          }
        }
        return response;
      }, "fetch")
    });
  }, "server_fetch");
  return (input, init22) => {
    const response = server_fetch(input, init22);
    response.catch(() => {
    });
    return response;
  };
}
__name(create_fetch, "create_fetch");
function normalize_fetch_input(info3, init22, url) {
  if (info3 instanceof Request) {
    return info3;
  }
  return new Request(typeof info3 === "string" ? new URL(info3, url) : info3, init22);
}
__name(normalize_fetch_input, "normalize_fetch_input");
async function internal_fetch(request, options2, manifest2, state2) {
  if (request.signal) {
    if (request.signal.aborted) {
      throw new DOMException("The operation was aborted.", "AbortError");
    }
    let remove_abort_listener = /* @__PURE__ */ __name(() => {
    }, "remove_abort_listener");
    const abort_promise = new Promise((_2, reject2) => {
      const on_abort = /* @__PURE__ */ __name(() => {
        reject2(new DOMException("The operation was aborted.", "AbortError"));
      }, "on_abort");
      request.signal.addEventListener("abort", on_abort, { once: true });
      remove_abort_listener = /* @__PURE__ */ __name(() => request.signal.removeEventListener("abort", on_abort), "remove_abort_listener");
    });
    const result = await Promise.race([
      respond(request, options2, manifest2, {
        ...state2,
        depth: state2.depth + 1
      }),
      abort_promise
    ]);
    remove_abort_listener();
    return result;
  } else {
    return await respond(request, options2, manifest2, {
      ...state2,
      depth: state2.depth + 1
    });
  }
}
__name(internal_fetch, "internal_fetch");
var body;
var etag;
var headers;
function get_public_env(request) {
  body ??= `export const env=${JSON.stringify(public_env)}`;
  etag ??= `W/${Date.now()}`;
  headers ??= new Headers({
    "content-type": "application/javascript; charset=utf-8",
    etag
  });
  if (request.headers.get("if-none-match") === etag) {
    return new Response(void 0, { status: 304, headers });
  }
  return new Response(body, { headers });
}
__name(get_public_env, "get_public_env");
var default_transform = /* @__PURE__ */ __name(({ html }) => html, "default_transform");
var default_filter = /* @__PURE__ */ __name(() => false, "default_filter");
var default_preload = /* @__PURE__ */ __name(({ type }) => type === "js" || type === "css", "default_preload");
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
var respond = propagate_context(internal_respond);
async function internal_respond(request, options2, manifest2, state2) {
  const url = new URL(request.url);
  const is_route_resolution_request = has_resolution_suffix2(url.pathname);
  const is_data_request = has_data_suffix2(url.pathname);
  const remote_id = get_remote_id(url);
  {
    const request_origin = request.headers.get("origin");
    if (remote_id) {
      if (request.method !== "GET" && request_origin !== url.origin) {
        const message = "Cross-site remote requests are forbidden";
        return json({ message }, { status: 403 });
      }
    } else if (options2.csrf_check_origin) {
      const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request_origin !== url.origin && (!request_origin || !options2.csrf_trusted_origins.includes(request_origin));
      if (forbidden) {
        const message = `Cross-site ${request.method} form submissions are forbidden`;
        const opts = { status: 403 };
        if (request.headers.get("accept") === "application/json") {
          return json({ message }, opts);
        }
        return text(message, opts);
      }
    }
  }
  if (options2.hash_routing && url.pathname !== base + "/" && url.pathname !== "/[fallback]") {
    return text("Not found", { status: 404 });
  }
  let invalidated_data_nodes;
  if (is_route_resolution_request) {
    url.pathname = strip_resolution_suffix2(url.pathname);
  } else if (is_data_request) {
    url.pathname = strip_data_suffix2(url.pathname) + (url.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url.searchParams.delete(INVALIDATED_PARAM);
  } else if (remote_id) {
    url.pathname = request.headers.get("x-sveltekit-pathname") ?? base;
    url.search = request.headers.get("x-sveltekit-search") ?? "";
  }
  const headers2 = {};
  const { cookies, new_cookies, get_cookie_header, set_internal, set_trailing_slash } = get_cookies(
    request,
    url
  );
  const event_state = {
    prerendering: state2.prerendering,
    transport: options2.hooks.transport,
    handleValidationError: options2.hooks.handleValidationError,
    tracing: {
      record_span
    },
    is_in_remote_function: false
  };
  const event = {
    cookies,
    // @ts-expect-error `fetch` needs to be created after the `event` itself
    fetch: null,
    getClientAddress: state2.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params: {},
    platform: state2.platform,
    request,
    route: { id: null },
    setHeaders: /* @__PURE__ */ __name((new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers2) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers2[lower] = value;
          if (state2.prerendering && lower === "cache-control") {
            state2.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    }, "setHeaders"),
    url,
    isDataRequest: is_data_request,
    isSubRequest: state2.depth > 0,
    isRemoteRequest: !!remote_id
  };
  event.fetch = create_fetch({
    event,
    options: options2,
    manifest: manifest2,
    state: state2,
    get_cookie_header,
    set_internal
  });
  if (state2.emulator?.platform) {
    event.platform = await state2.emulator.platform({
      config: {},
      prerender: !!state2.prerendering?.fallback
    });
  }
  let resolved_path = url.pathname;
  if (!remote_id) {
    const prerendering_reroute_state = state2.prerendering?.inside_reroute;
    try {
      if (state2.prerendering) state2.prerendering.inside_reroute = true;
      resolved_path = await options2.hooks.reroute({ url: new URL(url), fetch: event.fetch }) ?? url.pathname;
    } catch {
      return text("Internal Server Error", {
        status: 500
      });
    } finally {
      if (state2.prerendering) state2.prerendering.inside_reroute = prerendering_reroute_state;
    }
  }
  try {
    resolved_path = decode_pathname(resolved_path);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  if (resolved_path !== url.pathname && !state2.prerendering?.fallback && has_prerendered_path(manifest2, resolved_path)) {
    const url2 = new URL(request.url);
    url2.pathname = is_data_request ? add_data_suffix2(resolved_path) : is_route_resolution_request ? add_resolution_suffix2(resolved_path) : resolved_path;
    const response = await fetch(url2, request);
    const headers22 = new Headers(response.headers);
    if (headers22.has("content-encoding")) {
      headers22.delete("content-encoding");
      headers22.delete("content-length");
    }
    return new Response(response.body, {
      headers: headers22,
      status: response.status,
      statusText: response.statusText
    });
  }
  let route = null;
  if (base && !state2.prerendering?.fallback) {
    if (!resolved_path.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    resolved_path = resolved_path.slice(base.length) || "/";
  }
  if (is_route_resolution_request) {
    return resolve_route(resolved_path, new URL(request.url), manifest2);
  }
  if (resolved_path === `/${app_dir}/env.js`) {
    return get_public_env(request);
  }
  if (!remote_id && resolved_path.startsWith(`/${app_dir}`)) {
    const headers22 = new Headers();
    headers22.set("cache-control", "public, max-age=0, must-revalidate");
    return text("Not found", { status: 404, headers: headers22 });
  }
  if (!state2.prerendering?.fallback) {
    const matchers2 = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(resolved_path);
      if (!match) continue;
      const matched = exec(match, candidate.params, matchers2);
      if (matched) {
        route = candidate;
        event.route = { id: route.id };
        event.params = decode_params(matched);
        break;
      }
    }
  }
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  let trailing_slash = "never";
  try {
    const page_nodes = route?.page ? new PageNodes(await load_page_nodes(route.page, manifest2)) : void 0;
    if (route && !remote_id) {
      if (url.pathname === base || url.pathname === base + "/") {
        trailing_slash = "always";
      } else if (page_nodes) {
        if (BROWSER) ;
        trailing_slash = page_nodes.trailing_slash();
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash ?? "never";
        if (BROWSER) ;
      }
      if (!is_data_request) {
        const normalized = normalize_path(url.pathname, trailing_slash);
        if (normalized !== url.pathname && !state2.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
              )
            }
          });
        }
      }
      if (state2.before_handle || state2.emulator?.platform) {
        let config2 = {};
        let prerender = false;
        if (route.endpoint) {
          const node = await route.endpoint();
          config2 = node.config ?? config2;
          prerender = node.prerender ?? prerender;
        } else if (page_nodes) {
          config2 = page_nodes.get_config() ?? config2;
          prerender = page_nodes.prerender();
        }
        if (state2.before_handle) {
          state2.before_handle(event, config2, prerender);
        }
        if (state2.emulator?.platform) {
          event.platform = await state2.emulator.platform({ config: config2, prerender });
        }
      }
    }
    set_trailing_slash(trailing_slash);
    if (state2.prerendering && !state2.prerendering.fallback && !state2.prerendering.inside_reroute) {
      disable_search(url);
    }
    const response = await record_span({
      name: "sveltekit.handle.root",
      attributes: {
        "http.route": event.route.id || "unknown",
        "http.method": event.request.method,
        "http.url": event.url.href,
        "sveltekit.is_data_request": is_data_request,
        "sveltekit.is_sub_request": event.isSubRequest
      },
      fn: /* @__PURE__ */ __name(async (root_span) => {
        const traced_event = {
          ...event,
          tracing: {
            enabled: false,
            root: root_span,
            current: root_span
          }
        };
        return await with_request_store(
          { event: traced_event, state: event_state },
          () => options2.hooks.handle({
            event: traced_event,
            resolve: /* @__PURE__ */ __name((event2, opts) => {
              return record_span({
                name: "sveltekit.resolve",
                attributes: {
                  "http.route": event2.route.id || "unknown"
                },
                fn: /* @__PURE__ */ __name((resolve_span) => {
                  return with_request_store(
                    null,
                    () => resolve22(merge_tracing(event2, resolve_span), page_nodes, opts).then(
                      (response2) => {
                        for (const key2 in headers2) {
                          const value = headers2[key2];
                          response2.headers.set(
                            key2,
                            /** @type {string} */
                            value
                          );
                        }
                        add_cookies_to_headers(response2.headers, new_cookies.values());
                        if (state2.prerendering && event2.route.id !== null) {
                          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
                        }
                        resolve_span.setAttributes({
                          "http.response.status_code": response2.status,
                          "http.response.body.size": response2.headers.get("content-length") || "unknown"
                        });
                        return response2;
                      }
                    )
                  );
                }, "fn")
              });
            }, "resolve")
          })
        );
      }, "fn")
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag2 = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag2) {
        const headers22 = new Headers({ etag: etag2 });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value) headers22.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers22
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location = response.headers.get("location");
      if (location) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location
        ));
      }
    }
    return response;
  } catch (e5) {
    if (e5 instanceof Redirect) {
      const response = is_data_request || remote_id ? redirect_json_response(e5) : route?.page && is_action_json_request(event) ? action_json_redirect(e5) : redirect_response(e5.status, e5.location);
      add_cookies_to_headers(response.headers, new_cookies.values());
      return response;
    }
    return await handle_fatal_error(event, event_state, options2, e5);
  }
  async function resolve22(event2, page_nodes, opts) {
    try {
      if (opts) {
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (options2.hash_routing || state2.prerendering?.fallback) {
        return await render_response({
          event: event2,
          event_state,
          options: options2,
          manifest: manifest2,
          state: state2,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts,
          data_serializer: server_data_serializer(event2, event_state, options2)
        });
      }
      if (remote_id) {
        return await handle_remote_call(event2, event_state, options2, manifest2, remote_id);
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response2;
        if (is_data_request) {
          response2 = await render_data(
            event2,
            event_state,
            route,
            options2,
            manifest2,
            state2,
            invalidated_data_nodes,
            trailing_slash
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response2 = await render_endpoint(event2, event_state, await route.endpoint(), state2);
        } else if (route.page) {
          if (!page_nodes) {
            throw new Error("page_nodes not found. This should never happen");
          } else if (page_methods.has(method)) {
            response2 = await render_page(
              event2,
              event_state,
              route.page,
              options2,
              manifest2,
              state2,
              page_nodes,
              resolve_opts
            );
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response2 = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response2 = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("Route is neither page nor endpoint. This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response2.headers.get("vary")?.split(",")?.map((v2) => v2.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response2 = new Response(response2.body, {
              status: response2.status,
              statusText: response2.statusText,
              headers: new Headers(response2.headers)
            });
            response2.headers.append("Vary", "Accept");
          }
        }
        return response2;
      }
      if (state2.error && event2.isSubRequest) {
        const headers22 = new Headers(request.headers);
        headers22.set("x-sveltekit-error", "true");
        return await fetch(request, { headers: headers22 });
      }
      if (state2.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state2.depth === 0) {
        if (BROWSER && event2.url.pathname === "/.well-known/appspecific/com.chrome.devtools.json") ;
        return await respond_with_error({
          event: event2,
          event_state,
          options: options2,
          manifest: manifest2,
          state: state2,
          status: 404,
          error: new SvelteKitError(404, "Not Found", `Not found: ${event2.url.pathname}`),
          resolve_opts
        });
      }
      if (state2.prerendering) {
        return text("not found", { status: 404 });
      }
      const response = await fetch(request);
      return new Response(response.body, response);
    } catch (e5) {
      return await handle_fatal_error(event2, event_state, options2, e5);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
  __name(resolve22, "resolve2");
}
__name(internal_respond, "internal_respond");
function load_page_nodes(page2, manifest2) {
  return Promise.all([
    // we use == here rather than === because [undefined] serializes as "[null]"
    ...page2.layouts.map((n3) => n3 == void 0 ? n3 : manifest2._.nodes[n3]()),
    manifest2._.nodes[page2.leaf]()
  ]);
}
__name(load_page_nodes, "load_page_nodes");
function propagate_context(fn) {
  return async (req, ...rest) => {
    {
      return fn(req, ...rest);
    }
  };
}
__name(propagate_context, "propagate_context");
function filter_env(env3, allowed, disallowed) {
  return Object.fromEntries(
    Object.entries(env3).filter(
      ([k2]) => k2.startsWith(allowed) && (disallowed === "" || !k2.startsWith(disallowed))
    )
  );
}
__name(filter_env, "filter_env");
function set_app(value) {
}
__name(set_app, "set_app");
var init_promise;
var current = null;
var Server = class {
  static {
    __name(this, "Server");
  }
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
    if (IN_WEBCONTAINER2) {
      const respond2 = this.respond.bind(this);
      this.respond = async (...args) => {
        const { promise, resolve: resolve22 } = (
          /** @type {PromiseWithResolvers<void>} */
          with_resolvers()
        );
        const previous = current;
        current = promise;
        await previous;
        return respond2(...args).finally(resolve22);
      };
    }
  }
  /**
   * @param {import('@sveltejs/kit').ServerInitOptions} opts
   */
  async init({ env: env3, read: read2 }) {
    const { env_public_prefix, env_private_prefix } = this.#options;
    set_private_env(filter_env(env3, env_private_prefix, env_public_prefix));
    set_public_env(filter_env(env3, env_public_prefix, env_private_prefix));
    if (read2) {
      const wrapped_read = /* @__PURE__ */ __name((file) => {
        const result = read2(file);
        if (result instanceof ReadableStream) {
          return result;
        } else {
          return new ReadableStream({
            async start(controller2) {
              try {
                const stream3 = await Promise.resolve(result);
                if (!stream3) {
                  controller2.close();
                  return;
                }
                const reader = stream3.getReader();
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) break;
                  controller2.enqueue(value);
                }
                controller2.close();
              } catch (error22) {
                controller2.error(error22);
              }
            }
          });
        }
      }, "wrapped_read");
      set_read_implementation(wrapped_read);
    }
    await (init_promise ??= (async () => {
      try {
        const module2 = await get_hooks();
        this.#options.hooks = {
          handle: module2.handle || (({ event, resolve: resolve22 }) => resolve22(event)),
          handleError: module2.handleError || (({ status, error: error22, event }) => {
            const error_message = format_server_error(
              status,
              /** @type {Error} */
              error22,
              event
            );
            console.error(error_message);
          }),
          handleFetch: module2.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request)),
          handleValidationError: module2.handleValidationError || (({ issues }) => {
            console.error("Remote function schema validation failed:", issues);
            return { message: "Bad Request" };
          }),
          reroute: module2.reroute || (() => {
          }),
          transport: module2.transport || {}
        };
        set_app({
          decoders: module2.transport ? Object.fromEntries(Object.entries(module2.transport).map(([k2, v2]) => [k2, v2.decode])) : {}
        });
        if (module2.init) {
          await module2.init();
        }
      } catch (e5) {
        {
          throw e5;
        }
      }
    })());
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  __name(__memo, "__memo");
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["unity-webgl/Build/unity-webgl.data.unityweb", "unity-webgl/Build/unity-webgl.framework.js.unityweb", "unity-webgl/Build/unity-webgl.loader.js", "unity-webgl/Build/unity-webgl.wasm.unityweb", "unity-webgl/TemplateData/webmemd-icon.png"]),
    mimeTypes: { ".js": "text/javascript", ".png": "image/png" },
    _: {
      client: { start: "_app/immutable/entry/start.BI57CQaw.js", app: "_app/immutable/entry/app.DxpxkyH2.js", imports: ["_app/immutable/entry/start.BI57CQaw.js", "_app/immutable/chunks/CGKANyzZ.js", "_app/immutable/chunks/H8HRPmpP.js", "_app/immutable/chunks/C_Sh5Hij.js", "_app/immutable/entry/app.DxpxkyH2.js", "_app/immutable/chunks/H8HRPmpP.js", "_app/immutable/chunks/DWDlLD0t.js", "_app/immutable/chunks/DFqY95ai.js", "_app/immutable/chunks/C_Sh5Hij.js", "_app/immutable/chunks/yg97jW04.js"], stylesheets: [], fonts: [], uses_env_dynamic_public: false },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4)))
      ],
      remotes: {},
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 2 },
          endpoint: null
        },
        {
          id: "/api/profile-picture",
          pattern: /^\/api\/profile-picture\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts(), server_ts_exports)))
        },
        {
          id: "/game",
          pattern: /^\/game\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 3 },
          endpoint: null
        }
      ],
      prerendered_routes: /* @__PURE__ */ new Set([]),
      matchers: /* @__PURE__ */ __name(async () => {
        return {};
      }, "matchers"),
      server_assets: {}
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);
var base_path = "";

// .svelte-kit/cloudflare/_worker.js
import { env as env2 } from "cloudflare:workers";
async function e4(e32, t22) {
  let n22 = "string" != typeof t22 && "HEAD" === t22.method;
  n22 && (t22 = new Request(t22, { method: "GET" }));
  let r32 = await e32.match(t22);
  return n22 && r32 && (r32 = new Response(null, r32)), r32;
}
__name(e4, "e");
function t2(e32, t22, n22, o22) {
  return ("string" == typeof t22 || "GET" === t22.method) && r3(n22) && (n22.headers.has("Set-Cookie") && (n22 = new Response(n22.body, n22)).headers.append("Cache-Control", "private=Set-Cookie"), o22.waitUntil(e32.put(t22, n22.clone()))), n22;
}
__name(t2, "t");
var n2 = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r3(e32) {
  if (!n2.has(e32.status)) return false;
  if (~(e32.headers.get("Vary") || "").indexOf("*")) return false;
  let t22 = e32.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t22);
}
__name(r3, "r");
function o2(n22) {
  return async function(r32, o22) {
    let a2 = await e4(n22, r32);
    if (a2) return a2;
    o22.defer((e32) => {
      t2(n22, r32, e32, o22);
    });
  };
}
__name(o2, "o");
var s3 = caches.default;
var c2 = t2.bind(0, s3);
var r22 = e4.bind(0, s3);
var e22 = o2.bind(0, s3);
var server = new Server(manifest);
var app_path = `/${manifest.appPath}`;
var immutable = `${app_path}/immutable/`;
var version_file = `${app_path}/version.json`;
var origin;
var initialized = server.init({
  // @ts-expect-error env contains environment variables and bindings
  env: env2,
  read: /* @__PURE__ */ __name(async (file) => {
    const url = `${origin}/${file}`;
    const response = await /** @type {{ ASSETS: { fetch: typeof fetch } }} */
    env2.ASSETS.fetch(
      url
    );
    if (!response.ok) {
      throw new Error(
        `read(...) failed: could not fetch ${url} (${response.status} ${response.statusText})`
      );
    }
    return response.body;
  }, "read")
});
var worker_default = {
  /**
   * @param {Request} req
   * @param {{ ASSETS: { fetch: typeof fetch } }} env
   * @param {ExecutionContext} ctx
   * @returns {Promise<Response>}
   */
  async fetch(req, env22, ctx) {
    if (!origin) {
      origin = new URL(req.url).origin;
      await initialized;
    }
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r22(req);
    if (res) return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.slice(base_path.length + 1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html") || filename in manifest._.server_assets || filename + "/index.html" in manifest._.server_assets;
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname) || pathname === version_file || pathname.startsWith(immutable)) {
      res = await env22.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search) location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        platform: {
          env: env22,
          ctx,
          context: ctx,
          // deprecated in favor of ctx
          // @ts-expect-error webworker types from worktop are not compatible with Cloudflare Workers types
          caches,
          // @ts-expect-error the type is correct but ts is confused because platform.cf uses the type from index.ts while req.cf uses the type from index.d.ts
          cf: req.cf
        },
        getClientAddress() {
          return (
            /** @type {string} */
            req.headers.get("cf-connecting-ip")
          );
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c2(req, res, ctx) : res;
  }
};

// node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request, env3);
  } finally {
    try {
      if (request.body !== null && !request.bodyUsed) {
        const reader = request.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e5) {
      console.error("Failed to drain the unused request body.", e5);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// .wrangler/tmp/bundle-Uhq1Nq/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default
];
var middleware_insertion_facade_default = worker_default;

// node_modules/wrangler/templates/middleware/common.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request, env3, ctx, dispatch, middlewareChain) {
  const [head2, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head2(request, env3, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request, env3, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request, env3, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-Uhq1Nq/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request, env3, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request, env3, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request, env3, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type, init3) {
        if (type === "scheduled" && worker.scheduled !== void 0) {
          const controller2 = new __Facade_ScheduledController__(
            Date.now(),
            init3.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller2, env3, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request, env3, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request, env3, ctx) => {
      this.env = env3;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type, init3) => {
      if (type === "scheduled" && super.scheduled !== void 0) {
        const controller2 = new __Facade_ScheduledController__(
          Date.now(),
          init3.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller2);
      }
    }, "#dispatcher");
    fetch(request) {
      return __facade_invoke__(
        request,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

jimp/dist/browser/index.js:
  (*!
  	 * The buffer module from node.js, for the browser.
  	 *
  	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
  	 * @license  MIT
  	 *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cie94.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ciede2000.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cmetric.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * common.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * constants.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ditherErrorDiffusionArray.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * euclidean.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * helper.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * hueStatistics.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * iq.ts - Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * manhattanNeuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * nearestColor.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * palette.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pngQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * point.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pointContainer.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2hsl.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ssim.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * wuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * MIT License
   *
   * Copyright 2015-2018 Igor Bezkrovnyi
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to
   * deal in the Software without restriction, including without limitation the
   * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
   * sell copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   *
   * riemersma.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * colorHistogram.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * neuquant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2018 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgbquant.ts - part of Image Quantization Library
   *)
*/
//# sourceMappingURL=_worker.js.map
